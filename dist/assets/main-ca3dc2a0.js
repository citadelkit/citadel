var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jquery = { exports: {} };
/*!
 * jQuery JavaScript Library v3.7.1
 * https://jquery.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2023-08-28T13:37Z
 */
var hasRequiredJquery;
function requireJquery() {
  if (hasRequiredJquery)
    return jquery.exports;
  hasRequiredJquery = 1;
  (function(module) {
    (function(global2, factory) {
      {
        module.exports = global2.document ? factory(global2, true) : function(w2) {
          if (!w2.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w2);
        };
      }
    })(typeof window !== "undefined" ? window : commonjsGlobal, function(window2, noGlobal) {
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString3 = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction2 = function isFunction3(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code, node, doc) {
        doc = doc || document2;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node) {
          for (i in preservedScriptAttributes) {
            val = node[i] || node.getAttribute && node.getAttribute(i);
            if (val) {
              script.setAttribute(i, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType2(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
      }
      var version = "3.7.1", rhtmlSuffix = /HTML$/i, jQuery2 = function(selector, context) {
        return new jQuery2.fn.init(selector, context);
      };
      jQuery2.fn = jQuery2.prototype = {
        // The current version of jQuery being used
        jquery: version,
        constructor: jQuery2,
        // The default length of a jQuery object is 0
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
          if (num == null) {
            return slice.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {
          var ret = jQuery2.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        // Execute a callback for every element in the matched set.
        each: function(callback) {
          return jQuery2.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery2.map(this, function(elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i) {
            return (i + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery2.grep(this, function(_elem, i) {
            return i % 2;
          }));
        },
        eq: function(i) {
          var len = this.length, j2 = +i + (i < 0 ? len : 0);
          return this.pushStack(j2 >= 0 && j2 < len ? [this[j2]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery2.extend = jQuery2.fn.extend = function() {
        var options, name2, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i] || {};
          i++;
        }
        if (typeof target !== "object" && !isFunction2(target)) {
          target = {};
        }
        if (i === length) {
          target = this;
          i--;
        }
        for (; i < length; i++) {
          if ((options = arguments[i]) != null) {
            for (name2 in options) {
              copy = options[name2];
              if (name2 === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery2.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name2];
                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery2.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }
                copyIsArray = false;
                target[name2] = jQuery2.extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name2] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery2.extend({
        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        // Assume jQuery is ready without the ready module
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString3.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name2;
          for (name2 in obj) {
            return false;
          }
          return true;
        },
        // Evaluates a script in a provided context; falls back to the global one
        // if not specified.
        globalEval: function(code, options, doc) {
          DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i < length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        // Retrieve the text value of an array of DOM nodes
        text: function(elem) {
          var node, ret = "", i = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i++]) {
              ret += jQuery2.text(node);
            }
          }
          if (nodeType === 1 || nodeType === 11) {
            return elem.textContent;
          }
          if (nodeType === 9) {
            return elem.documentElement.textContent;
          }
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        },
        // results is for internal usage only
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery2.merge(
                ret,
                typeof arr2 === "string" ? [arr2] : arr2
              );
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
        },
        isXMLDoc: function(elem) {
          var namespace = elem && elem.namespaceURI, docElem = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtmlSuffix.test(namespace || docElem && docElem.nodeName || "HTML");
        },
        // Support: Android <=4.0 only, PhantomJS 1 only
        // push.apply(_, arraylike) throws on ancient WebKit
        merge: function(first, second) {
          var len = +second.length, j2 = 0, i = first.length;
          for (; j2 < len; j2++) {
            first[i++] = second[j2];
          }
          first.length = i;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }
          return matches;
        },
        // arg is for internal usage only
        map: function(elems, callback, arg) {
          var length, value, i = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i < length; i++) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        // A global GUID counter for objects
        guid: 1,
        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support
      });
      if (typeof Symbol === "function") {
        jQuery2.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery2.each(
        "Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
        function(_i2, name2) {
          class2type["[object " + name2 + "]"] = name2.toLowerCase();
        }
      );
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType2(obj);
        if (isFunction2(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      function nodeName(elem, name2) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name2.toLowerCase();
      }
      var pop = arr.pop;
      var sort = arr.sort;
      var splice = arr.splice;
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp(
        "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$",
        "g"
      );
      jQuery2.contains = function(a2, b2) {
        var bup = b2 && b2.parentNode;
        return a2 === bup || !!(bup && bup.nodeType === 1 && // Support: IE 9 - 11+
        // IE doesn't have `contains` on SVG.
        (a2.contains ? a2.contains(bup) : a2.compareDocumentPosition && a2.compareDocumentPosition(bup) & 16));
      };
      var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
      function fcssescape(ch, asCodePoint) {
        if (asCodePoint) {
          if (ch === "\0") {
            return "�";
          }
          return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
        }
        return "\\" + ch;
      }
      jQuery2.escapeSelector = function(sel) {
        return (sel + "").replace(rcssescape, fcssescape);
      };
      var preferredDoc = document2, pushNative = push;
      (function() {
        var i, Expr, outermostContext, sortInput, hasDuplicate, push2 = pushNative, document3, documentElement2, documentIsHTML, rbuggyQSA, matches, expando = jQuery2.expando, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a2, b2) {
          if (a2 === b2) {
            hasDuplicate = true;
          }
          return 0;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rleadingCombinator = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rdescend = new RegExp(whitespace + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          ID: new RegExp("^#(" + identifier + ")"),
          CLASS: new RegExp("^\\.(" + identifier + ")"),
          TAG: new RegExp("^(" + identifier + "|[*])"),
          ATTR: new RegExp("^" + attributes),
          PSEUDO: new RegExp("^" + pseudos),
          CHILD: new RegExp(
            "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)",
            "i"
          ),
          bool: new RegExp("^(?:" + booleans + ")$", "i"),
          // For use in libraries implementing .is()
          // We use this for POS matching in `select`
          needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 65536;
          if (nonHex) {
            return nonHex;
          }
          return high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(
          function(elem) {
            return elem.disabled === true && nodeName(elem, "fieldset");
          },
          { dir: "parentNode", next: "legend" }
        );
        function safeActiveElement() {
          try {
            return document3.activeElement;
          } catch (err) {
          }
        }
        try {
          push2.apply(
            arr = slice.call(preferredDoc.childNodes),
            preferredDoc.childNodes
          );
          arr[preferredDoc.childNodes.length].nodeType;
        } catch (e2) {
          push2 = {
            apply: function(target, els) {
              pushNative.apply(target, slice.call(els));
            },
            call: function(target) {
              pushNative.apply(target, slice.call(arguments, 1));
            }
          };
        }
        function find2(selector, context, results, seed) {
          var m2, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m2 = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m2)) {
                      if (elem.id === m2) {
                        push2.call(results, elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m2)) && find2.contains(context, elem) && elem.id === m2) {
                      push2.call(results, elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m2 = match[3]) && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m2));
                  return results;
                }
              }
              if (!nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rleadingCombinator.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext != context || !support.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = jQuery2.escapeSelector(nid);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  push2.apply(
                    results,
                    newContext.querySelectorAll(newSelector)
                  );
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrimCSS, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn3) {
          fn3[expando] = true;
          return fn3;
        }
        function assert(fn3) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn3(el);
          } catch (e2) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function createInputPseudo(type) {
          return function(elem) {
            return nodeName(elem, "input") && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            return (nodeName(elem, "input") || nodeName(elem, "button")) && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || // Where there is no isDisabled, check manually
                elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn3) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j2, matchIndexes = fn3([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j2 = matchIndexes[i2]]) {
                  seed[j2] = !(matches2[j2] = seed[j2]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        function setDocument(node) {
          var subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          documentElement2 = document3.documentElement;
          documentIsHTML = !jQuery2.isXMLDoc(document3);
          matches = documentElement2.matches || documentElement2.webkitMatchesSelector || documentElement2.msMatchesSelector;
          if (documentElement2.msMatchesSelector && // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            subWindow.addEventListener("unload", unloadHandler);
          }
          support.getById = assert(function(el) {
            documentElement2.appendChild(el).id = jQuery2.expando;
            return !document3.getElementsByName || !document3.getElementsByName(jQuery2.expando).length;
          });
          support.disconnectedMatch = assert(function(el) {
            return matches.call(el, "*");
          });
          support.scope = assert(function() {
            return document3.querySelectorAll(":scope");
          });
          support.cssHas = assert(function() {
            try {
              document3.querySelector(":has(*,:jqfake)");
              return false;
            } catch (e2) {
              return true;
            }
          });
          if (support.getById) {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter.ID = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find.ID = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i2, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find.TAG = function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else {
              return context.querySelectorAll(tag);
            }
          };
          Expr.find.CLASS = function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyQSA = [];
          assert(function(el) {
            var input;
            documentElement2.appendChild(el).innerHTML = "<a id='" + expando + "' href='' disabled='disabled'></a><select id='" + expando + "-\r\\' disabled='disabled'><option selected=''></option></select>";
            if (!el.querySelectorAll("[selected]").length) {
              rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
            }
            if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
              rbuggyQSA.push("~=");
            }
            if (!el.querySelectorAll("a#" + expando + "+*").length) {
              rbuggyQSA.push(".#.+[+~]");
            }
            if (!el.querySelectorAll(":checked").length) {
              rbuggyQSA.push(":checked");
            }
            input = document3.createElement("input");
            input.setAttribute("type", "hidden");
            el.appendChild(input).setAttribute("name", "D");
            documentElement2.appendChild(el).disabled = true;
            if (el.querySelectorAll(":disabled").length !== 2) {
              rbuggyQSA.push(":enabled", ":disabled");
            }
            input = document3.createElement("input");
            input.setAttribute("name", "");
            el.appendChild(input);
            if (!el.querySelectorAll("[name='']").length) {
              rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + `*(?:''|"")`);
            }
          });
          if (!support.cssHas) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          sortOrder = function(a2, b2) {
            if (a2 === b2) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a2.compareDocumentPosition - !b2.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a2.ownerDocument || a2) == (b2.ownerDocument || b2) ? a2.compareDocumentPosition(b2) : (
              // Otherwise we know they are disconnected
              1
            );
            if (compare & 1 || !support.sortDetached && b2.compareDocumentPosition(a2) === compare) {
              if (a2 === document3 || a2.ownerDocument == preferredDoc && find2.contains(preferredDoc, a2)) {
                return -1;
              }
              if (b2 === document3 || b2.ownerDocument == preferredDoc && find2.contains(preferredDoc, b2)) {
                return 1;
              }
              return sortInput ? indexOf.call(sortInput, a2) - indexOf.call(sortInput, b2) : 0;
            }
            return compare & 4 ? -1 : 1;
          };
          return document3;
        }
        find2.matches = function(expr, elements) {
          return find2(expr, null, null, elements);
        };
        find2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
              // fragment in IE 9
              elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e2) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return find2(expr, document3, null, [elem]).length > 0;
        };
        find2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return jQuery2.contains(context, elem);
        };
        find2.attr = function(elem, name2) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn3 = Expr.attrHandle[name2.toLowerCase()], val = fn3 && hasOwn.call(Expr.attrHandle, name2.toLowerCase()) ? fn3(elem, name2, !documentIsHTML) : void 0;
          if (val !== void 0) {
            return val;
          }
          return elem.getAttribute(name2);
        };
        find2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        jQuery2.uniqueSort = function(results) {
          var elem, duplicates = [], j2 = 0, i2 = 0;
          hasDuplicate = !support.sortStable;
          sortInput = !support.sortStable && slice.call(results, 0);
          sort.call(results, sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j2 = duplicates.push(i2);
              }
            }
            while (j2--) {
              splice.call(results, duplicates[j2], 1);
            }
          }
          sortInput = null;
          return results;
        };
        jQuery2.fn.uniqueSort = function() {
          return this.pushStack(jQuery2.uniqueSort(slice.apply(this)));
        };
        Expr = jQuery2.expr = {
          // Can be adjusted by the user
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            ATTR: function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            CHILD: function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  find2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                find2.error(match[0]);
              }
              return match;
            },
            PSEUDO: function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr.CHILD.test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
              (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
              (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            TAG: function(nodeNameSelector) {
              var expectedNodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return nodeName(elem, expectedNodeName);
              };
            },
            CLASS: function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                return pattern.test(
                  typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || ""
                );
              });
            },
            ATTR: function(name2, operator, check) {
              return function(elem) {
                var result = find2.attr(elem, name2);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                if (operator === "=") {
                  return result === check;
                }
                if (operator === "!=") {
                  return result !== check;
                }
                if (operator === "^=") {
                  return check && result.indexOf(check) === 0;
                }
                if (operator === "*=") {
                  return check && result.indexOf(check) > -1;
                }
                if (operator === "$=") {
                  return check && result.slice(-check.length) === check;
                }
                if (operator === "~=") {
                  return (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1;
                }
                if (operator === "|=") {
                  return result === check || result.slice(0, check.length + 1) === check + "-";
                }
                return false;
              };
            },
            CHILD: function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? (
                // Shortcut for :nth-*(n)
                function(elem) {
                  return !!elem.parentNode;
                }
              ) : function(elem, _context, xml) {
                var cache, outerCache, node, nodeIndex2, start2, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name2 = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? nodeName(node, name2) : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start2 = dir2 = type === "only" && !start2 && "nextSibling";
                    }
                    return true;
                  }
                  start2 = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    outerCache = parent[expando] || (parent[expando] = {});
                    cache = outerCache[type] || [];
                    nodeIndex2 = cache[0] === dirruns && cache[1];
                    diff = nodeIndex2 && cache[2];
                    node = nodeIndex2 && parent.childNodes[nodeIndex2];
                    while (node = ++nodeIndex2 && node && node[dir2] || // Fallback to seeking `elem` from the start
                    (diff = nodeIndex2 = 0) || start2.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        outerCache[type] = [dirruns, nodeIndex2, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      outerCache = elem[expando] || (elem[expando] = {});
                      cache = outerCache[type] || [];
                      nodeIndex2 = cache[0] === dirruns && cache[1];
                      diff = nodeIndex2;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex2 && node && node[dir2] || (diff = nodeIndex2 = 0) || start2.pop()) {
                        if ((ofType ? nodeName(node, name2) : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            outerCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            PSEUDO: function(pseudo, argument) {
              var args, fn3 = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || find2.error("unsupported pseudo: " + pseudo);
              if (fn3[expando]) {
                return fn3(argument);
              }
              if (fn3.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn3(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf.call(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn3(elem, 0, args);
                };
              }
              return fn3;
            }
          },
          pseudos: {
            // Potentially complex pseudos
            not: markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrimCSS, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            has: markFunction(function(selector) {
              return function(elem) {
                return find2(selector, elem).length > 0;
              };
            }),
            contains: markFunction(function(text2) {
              text2 = text2.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || jQuery2.text(elem)).indexOf(text2) > -1;
              };
            }),
            // "Whether an element is represented by a :lang() selector
            // is based solely on the element's language value
            // being equal to the identifier C,
            // or beginning with the identifier C immediately followed by "-".
            // The matching of C against the element's language value is performed case-insensitively.
            // The identifier C does not have to be a valid language name."
            // https://www.w3.org/TR/selectors/#lang-pseudo
            lang: markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                find2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            // Miscellaneous
            target: function(elem) {
              var hash2 = window2.location && window2.location.hash;
              return hash2 && hash2.slice(1) === elem.id;
            },
            root: function(elem) {
              return elem === documentElement2;
            },
            focus: function(elem) {
              return elem === safeActiveElement() && document3.hasFocus() && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            // Boolean properties
            enabled: createDisabledPseudo(false),
            disabled: createDisabledPseudo(true),
            checked: function(elem) {
              return nodeName(elem, "input") && !!elem.checked || nodeName(elem, "option") && !!elem.selected;
            },
            selected: function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            // Contents
            empty: function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            parent: function(elem) {
              return !Expr.pseudos.empty(elem);
            },
            // Element/input types
            header: function(elem) {
              return rheader.test(elem.nodeName);
            },
            input: function(elem) {
              return rinputs.test(elem.nodeName);
            },
            button: function(elem) {
              return nodeName(elem, "input") && elem.type === "button" || nodeName(elem, "button");
            },
            text: function(elem) {
              var attr2;
              return nodeName(elem, "input") && elem.type === "text" && // Support: IE <10 only
              // New HTML5 attribute values (e.g., "search") appear
              // with elem.type === "text"
              ((attr2 = elem.getAttribute("type")) == null || attr2.toLowerCase() === "text");
            },
            // Position-in-collection
            first: createPositionalPseudo(function() {
              return [0];
            }),
            last: createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            eq: createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            even: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            odd: createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            lt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2;
              if (argument < 0) {
                i2 = argument + length;
              } else if (argument > length) {
                i2 = length;
              } else {
                i2 = argument;
              }
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            gt: createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        function tokenize(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rleadingCombinator.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                // Cast descendant combinators to space
                type: match[0].replace(rtrimCSS, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          if (parseOnly) {
            return soFar.length;
          }
          return soFar ? find2.error(selector) : (
            // Cache the tokens
            tokenCache(selector, groups).slice(0)
          );
        }
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? (
            // Check against closest ancestor/preceding element
            function(elem, context, xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  return matcher(elem, context, xml);
                }
              }
              return false;
            }
          ) : (
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
              var oldCache, outerCache, newCache = [dirruns, doneName];
              if (xml) {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    if (matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              } else {
                while (elem = elem[dir2]) {
                  if (elem.nodeType === 1 || checkNonElements) {
                    outerCache = elem[expando] || (elem[expando] = {});
                    if (skip && nodeName(elem, skip)) {
                      elem = elem[dir2] || elem;
                    } else if ((oldCache = outerCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                      return newCache[2] = oldCache[2];
                    } else {
                      outerCache[key] = newCache;
                      if (newCache[2] = matcher(elem, context, xml)) {
                        return true;
                      }
                    }
                  }
                }
              }
              return false;
            }
          );
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            find2(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map2, filter2, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map2 != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter2 || filter2(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map2.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, matcherOut, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(
              selector || "*",
              context.nodeType ? [context] : context,
              []
            ), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems;
            if (matcher) {
              matcherOut = postFinder || (seed ? preFilter : preexisting || postFilter) ? (
                // ...intermediate processing is necessary
                []
              ) : (
                // ...otherwise use results directly
                results
              );
              matcher(matcherIn, matcherOut, context, xml);
            } else {
              matcherOut = matcherIn;
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(
                matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut
              );
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j2, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf.call(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context != outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j2 = ++i2;
                for (; j2 < len; j2++) {
                  if (Expr.relative[tokens[j2].type]) {
                    break;
                  }
                }
                return setMatcher(
                  i2 > 1 && elementMatcher(matchers),
                  i2 > 1 && toSelector(
                    // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                    tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })
                  ).replace(rtrimCSS, "$1"),
                  matcher,
                  i2 < j2 && matcherFromTokens(tokens.slice(i2, j2)),
                  j2 < len && matcherFromTokens(tokens = tokens.slice(j2)),
                  j2 < len && toSelector(tokens)
                );
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j2, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j2 = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j2++]) {
                  if (matcher(elem, context || document3, xml)) {
                    push2.call(results, elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j2 = 0;
              while (matcher = setMatchers[j2++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                jQuery2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        function compile(selector, match) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i2 = match.length;
            while (i2--) {
              cached = matcherFromTokens(match[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(
              selector,
              matcherFromGroupMatchers(elementMatchers, setMatchers)
            );
            cached.selector = selector;
          }
          return cached;
        }
        function select(selector, context, results, seed) {
          var i2, tokens, token, type, find3, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find.ID(
                token.matches[0].replace(runescape, funescape),
                context
              ) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr.needsContext.test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find3 = Expr.find[type]) {
                if (seed = find3(
                  token.matches[0].replace(runescape, funescape),
                  rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                )) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(
            seed,
            context,
            !documentIsHTML,
            results,
            !context || rsibling.test(selector) && testContext(context.parentNode) || context
          );
          return results;
        }
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        setDocument();
        support.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        jQuery2.find = find2;
        jQuery2.expr[":"] = jQuery2.expr.pseudos;
        jQuery2.unique = jQuery2.uniqueSort;
        find2.compile = compile;
        find2.select = select;
        find2.setDocument = setDocument;
        find2.tokenize = tokenize;
        find2.escape = jQuery2.escapeSelector;
        find2.getText = jQuery2.text;
        find2.isXML = jQuery2.isXMLDoc;
        find2.selectors = jQuery2.expr;
        find2.support = jQuery2.support;
        find2.uniqueSort = jQuery2.uniqueSort;
      })();
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery2(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n2, elem) {
        var matched = [];
        for (; n2; n2 = n2.nextSibling) {
          if (n2.nodeType === 1 && n2 !== elem) {
            matched.push(n2);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery2.expr.match.needsContext;
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction2(qualifier)) {
          return jQuery2.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery2.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery2.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery2.filter(qualifier, elements, not);
      }
      jQuery2.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery2.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery2.find.matches(expr, jQuery2.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery2.fn.extend({
        find: function(selector) {
          var i, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery2(selector).filter(function() {
              for (i = 0; i < len; i++) {
                if (jQuery2.contains(self2[i], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i = 0; i < len; i++) {
            jQuery2.find(selector, self2[i], ret);
          }
          return len > 1 ? jQuery2.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(
            this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery2(selector) : selector || [],
            false
          ).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init2 = jQuery2.fn.init = function(selector, context, root2) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root2 = root2 || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery2 ? context[0] : context;
              jQuery2.merge(this, jQuery2.parseHTML(
                match[1],
                context && context.nodeType ? context.ownerDocument || context : document2,
                true
              ));
              if (rsingleTag.test(match[1]) && jQuery2.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction2(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root2).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction2(selector)) {
          return root2.ready !== void 0 ? root2.ready(selector) : (
            // Execute immediately if ready is not present
            selector(jQuery2)
          );
        }
        return jQuery2.makeArray(selector, this);
      };
      init2.prototype = jQuery2.fn;
      rootjQuery = jQuery2(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery2.fn.extend({
        has: function(target) {
          var targets = jQuery2(target, this), l2 = targets.length;
          return this.filter(function() {
            var i = 0;
            for (; i < l2; i++) {
              if (jQuery2.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i = 0, l2 = this.length, matched = [], targets = typeof selectors !== "string" && jQuery2(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i < l2; i++) {
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : (
                  // Don't pass non-elements to jQuery#find
                  cur.nodeType === 1 && jQuery2.find.matchesSelector(cur, selectors)
                ))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery2.uniqueSort(matched) : matched);
        },
        // Determine the position of an element within the set
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery2(elem), this[0]);
          }
          return indexOf.call(
            this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem
          );
        },
        add: function(selector, context) {
          return this.pushStack(
            jQuery2.uniqueSort(
              jQuery2.merge(this.get(), jQuery2(selector, context))
            )
          );
        },
        addBack: function(selector) {
          return this.add(
            selector == null ? this.prevObject : this.prevObject.filter(selector)
          );
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery2.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i2, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i2, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i2, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && // Support: IE 11+
          // <object> elements with no `data` attribute has an object
          // `contentDocument` with a `null` prototype.
          getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery2.merge([], elem.childNodes);
        }
      }, function(name2, fn3) {
        jQuery2.fn[name2] = function(until, selector) {
          var matched = jQuery2.map(this, fn3, until);
          if (name2.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery2.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name2]) {
              jQuery2.uniqueSort(matched);
            }
            if (rparentsprev.test(name2)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions2(options) {
        var object = {};
        jQuery2.each(options.match(rnothtmlwhite) || [], function(_2, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery2.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions2(options) : jQuery2.extend({}, options);
        var firing, memory, fired, locked, list2 = [], queue = [], firingIndex = -1, fire2 = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list2.length) {
              if (list2[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list2.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list2 = [];
            } else {
              list2 = "";
            }
          }
        }, self2 = {
          // Add a callback or a collection of callbacks to the list
          add: function() {
            if (list2) {
              if (memory && !firing) {
                firingIndex = list2.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery2.each(args, function(_2, arg) {
                  if (isFunction2(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list2.push(arg);
                    }
                  } else if (arg && arg.length && toType2(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire2();
              }
            }
            return this;
          },
          // Remove a callback from the list
          remove: function() {
            jQuery2.each(arguments, function(_2, arg) {
              var index;
              while ((index = jQuery2.inArray(arg, list2, index)) > -1) {
                list2.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          // Check if a given callback is in the list.
          // If no argument is given, return whether or not list has callbacks attached.
          has: function(fn3) {
            return fn3 ? jQuery2.inArray(fn3, list2) > -1 : list2.length > 0;
          },
          // Remove all callbacks from the list
          empty: function() {
            if (list2) {
              list2 = [];
            }
            return this;
          },
          // Disable .fire and .add
          // Abort any current/pending executions
          // Clear all callbacks and values
          disable: function() {
            locked = queue = [];
            list2 = memory = "";
            return this;
          },
          disabled: function() {
            return !list2;
          },
          // Disable .fire
          // Also disable .add unless we have memory (since it would have no effect)
          // Abort any pending executions
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list2 = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          // Call all callbacks with the given context and arguments
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire2();
              }
            }
            return this;
          },
          // Call all the callbacks with the given arguments
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          // To know if the callbacks have already been called at least once
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v2) {
        return v2;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
          if (value && isFunction2(method = value.promise)) {
            method.call(value).done(resolve).fail(reject);
          } else if (value && isFunction2(method = value.then)) {
            method.call(value, resolve, reject);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject.apply(void 0, [value2]);
        }
      }
      jQuery2.extend({
        Deferred: function(func) {
          var tuples = [
            // action, add listener, callbacks,
            // ... .then handlers, argument index, [final state]
            [
              "notify",
              "progress",
              jQuery2.Callbacks("memory"),
              jQuery2.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery2.Callbacks("once memory"),
              jQuery2.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state2 = "pending", promise = {
            state: function() {
              return state2;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn3) {
              return promise.then(null, fn3);
            },
            // Keep pipe for back-compat
            pipe: function() {
              var fns = arguments;
              return jQuery2.Deferred(function(newDefer) {
                jQuery2.each(tuples, function(_i2, tuple) {
                  var fn3 = isFunction2(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn3 && fn3.apply(this, arguments);
                    if (returned && isFunction2(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](
                        this,
                        fn3 ? [returned] : arguments
                      );
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && // Support: Promises/A+ section 2.3.4
                    // https://promisesaplus.com/#point-64
                    // Only check objects and functions for thenability
                    (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction2(then)) {
                      if (special) {
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special)
                        );
                      } else {
                        maxDepth++;
                        then.call(
                          returned,
                          resolve(maxDepth, deferred2, Identity, special),
                          resolve(maxDepth, deferred2, Thrower, special),
                          resolve(
                            maxDepth,
                            deferred2,
                            Identity,
                            deferred2.notifyWith
                          )
                        );
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e2) {
                      if (jQuery2.Deferred.exceptionHook) {
                        jQuery2.Deferred.exceptionHook(
                          e2,
                          process2.error
                        );
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e2];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery2.Deferred.getErrorHook) {
                      process2.error = jQuery2.Deferred.getErrorHook();
                    } else if (jQuery2.Deferred.getStackHook) {
                      process2.error = jQuery2.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery2.Deferred(function(newDefer) {
                tuples[0][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onProgress) ? onProgress : Identity,
                    newDefer.notifyWith
                  )
                );
                tuples[1][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onFulfilled) ? onFulfilled : Identity
                  )
                );
                tuples[2][3].add(
                  resolve(
                    0,
                    newDefer,
                    isFunction2(onRejected) ? onRejected : Thrower
                  )
                );
              }).promise();
            },
            // Get a promise for this deferred
            // If obj is provided, the promise aspect is added to the object
            promise: function(obj) {
              return obj != null ? jQuery2.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery2.each(tuples, function(i, tuple) {
            var list2 = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list2.add;
            if (stateString) {
              list2.add(
                function() {
                  state2 = stateString;
                },
                // rejected_callbacks.disable
                // fulfilled_callbacks.disable
                tuples[3 - i][2].disable,
                // rejected_handlers.disable
                // fulfilled_handlers.disable
                tuples[3 - i][3].disable,
                // progress_callbacks.lock
                tuples[0][2].lock,
                // progress_handlers.lock
                tuples[0][3].lock
              );
            }
            list2.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list2.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        // Deferred helper
        when: function(singleValue) {
          var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery2.Deferred(), updateFunc = function(i2) {
            return function(value) {
              resolveContexts[i2] = this;
              resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(
              singleValue,
              primary.done(updateFunc(i)).resolve,
              primary.reject,
              !remaining
            );
            if (primary.state() === "pending" || isFunction2(resolveValues[i] && resolveValues[i].then)) {
              return primary.then();
            }
          }
          while (i--) {
            adoptValue(resolveValues[i], updateFunc(i), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery2.Deferred.exceptionHook = function(error2, asyncError) {
        if (window2.console && window2.console.warn && error2 && rerrorNames.test(error2.name)) {
          window2.console.warn(
            "jQuery.Deferred exception: " + error2.message,
            error2.stack,
            asyncError
          );
        }
      };
      jQuery2.readyException = function(error2) {
        window2.setTimeout(function() {
          throw error2;
        });
      };
      var readyList = jQuery2.Deferred();
      jQuery2.fn.ready = function(fn3) {
        readyList.then(fn3).catch(function(error2) {
          jQuery2.readyException(error2);
        });
        return this;
      };
      jQuery2.extend({
        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,
        // A counter to track how many items to wait for before
        // the ready event fires. See trac-6781
        readyWait: 1,
        // Handle when the DOM is ready
        ready: function(wait) {
          if (wait === true ? --jQuery2.readyWait : jQuery2.isReady) {
            return;
          }
          jQuery2.isReady = true;
          if (wait !== true && --jQuery2.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery2]);
        }
      });
      jQuery2.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery2.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery2.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn3, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (toType2(key) === "object") {
          chainable = true;
          for (i in key) {
            access(elems, fn3, i, key[i], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction2(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn3.call(elems, value);
              fn3 = null;
            } else {
              bulk = fn3;
              fn3 = function(elem, _key, value2) {
                return bulk.call(jQuery2(elem), value2);
              };
            }
          }
          if (fn3) {
            for (; i < len; i++) {
              fn3(
                elems[i],
                key,
                raw ? value : value.call(elems[i], i, fn3(elems[i], key))
              );
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn3.call(elems);
        }
        return len ? fn3(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data2() {
        this.expando = jQuery2.expando + Data2.uid++;
      }
      Data2.uid = 1;
      Data2.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data2, value) {
          var prop, cache = this.cache(owner);
          if (typeof data2 === "string") {
            cache[camelCase(data2)] = value;
          } else {
            for (prop in data2) {
              cache[camelCase(prop)] = data2[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : (
            // Always use camelCase key (gh-2257)
            owner[this.expando] && owner[this.expando][camelCase(key)]
          );
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i, cache = owner[this.expando];
          if (cache === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }
            i = key.length;
            while (i--) {
              delete cache[key[i]];
            }
          }
          if (key === void 0 || jQuery2.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== void 0 && !jQuery2.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data2();
      var dataUser = new Data2();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data2) {
        if (data2 === "true") {
          return true;
        }
        if (data2 === "false") {
          return false;
        }
        if (data2 === "null") {
          return null;
        }
        if (data2 === +data2 + "") {
          return +data2;
        }
        if (rbrace.test(data2)) {
          return JSON.parse(data2);
        }
        return data2;
      }
      function dataAttr(elem, key, data2) {
        var name2;
        if (data2 === void 0 && elem.nodeType === 1) {
          name2 = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data2 = elem.getAttribute(name2);
          if (typeof data2 === "string") {
            try {
              data2 = getData(data2);
            } catch (e2) {
            }
            dataUser.set(elem, key, data2);
          } else {
            data2 = void 0;
          }
        }
        return data2;
      }
      jQuery2.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name2, data2) {
          return dataUser.access(elem, name2, data2);
        },
        removeData: function(elem, name2) {
          dataUser.remove(elem, name2);
        },
        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name2, data2) {
          return dataPriv.access(elem, name2, data2);
        },
        _removeData: function(elem, name2) {
          dataPriv.remove(elem, name2);
        }
      });
      jQuery2.fn.extend({
        data: function(key, value) {
          var i, name2, data2, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data2 = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;
                while (i--) {
                  if (attrs[i]) {
                    name2 = attrs[i].name;
                    if (name2.indexOf("data-") === 0) {
                      name2 = camelCase(name2.slice(5));
                      dataAttr(elem, name2, data2[name2]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data2;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data3;
            if (elem && value2 === void 0) {
              data3 = dataUser.get(elem, key);
              if (data3 !== void 0) {
                return data3;
              }
              data3 = dataAttr(elem, key);
              if (data3 !== void 0) {
                return data3;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery2.extend({
        queue: function(elem, type, data2) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data2) {
              if (!queue || Array.isArray(data2)) {
                queue = dataPriv.access(elem, type, jQuery2.makeArray(data2));
              } else {
                queue.push(data2);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery2.queue(elem, type), startLength = queue.length, fn3 = queue.shift(), hooks = jQuery2._queueHooks(elem, type), next = function() {
            jQuery2.dequeue(elem, type);
          };
          if (fn3 === "inprogress") {
            fn3 = queue.shift();
            startLength--;
          }
          if (fn3) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn3.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery2.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery2.fn.extend({
        queue: function(type, data2) {
          var setter = 2;
          if (typeof type !== "string") {
            data2 = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery2.queue(this[0], type);
          }
          return data2 === void 0 ? this : this.each(function() {
            var queue = jQuery2.queue(this, type, data2);
            jQuery2._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery2.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery2.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
          var tmp, count = 1, defer = jQuery2.Deferred(), elements = this, i = this.length, resolve = function() {
            if (!--count) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery2.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery2.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
        // Support: Firefox <=43 - 45
        // Disconnected elements can have computed display: none, so first confirm that elem is
        // in the document.
        isAttached(elem) && jQuery2.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween2) {
        var adjusted, scale, maxIterations = 20, currentValue = tween2 ? function() {
          return tween2.cur();
        } : function() {
          return jQuery2.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery2.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery2.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery2.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial = initial / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery2.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery2.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween2) {
            tween2.unit = unit;
            tween2.start = initialInUnit;
            tween2.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery2.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show2) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show2) {
            if (display === "none") {
              values[index] = dataPriv.get(elem, "display") || null;
              if (!values[index]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index = 0; index < length; index++) {
          if (values[index] != null) {
            elements[index].style.display = values[index];
          }
        }
        return elements;
      }
      jQuery2.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state2) {
          if (typeof state2 === "boolean") {
            return state2 ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery2(this).show();
            } else {
              jQuery2(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery2.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i = 0, l2 = elems.length;
        for (; i < l2; i++) {
          dataPriv.set(
            elems[i],
            "globalEval",
            !refElements || dataPriv.get(refElements[i], "globalEval")
          );
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j2, fragment = context.createDocumentFragment(), nodes = [], i = 0, l2 = elems.length;
        for (; i < l2; i++) {
          elem = elems[i];
          if (elem || elem === 0) {
            if (toType2(elem) === "object") {
              jQuery2.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery2.htmlPrefilter(elem) + wrap[2];
              j2 = wrap[0];
              while (j2--) {
                tmp = tmp.lastChild;
              }
              jQuery2.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i = 0;
        while (elem = nodes[i++]) {
          if (selection && jQuery2.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j2 = 0;
            while (elem = tmp[j2++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function on2(elem, types, selector, data2, fn3, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data2 = data2 || selector;
            selector = void 0;
          }
          for (type in types) {
            on2(elem, type, selector, data2, types[type], one);
          }
          return elem;
        }
        if (data2 == null && fn3 == null) {
          fn3 = selector;
          data2 = selector = void 0;
        } else if (fn3 == null) {
          if (typeof selector === "string") {
            fn3 = data2;
            data2 = void 0;
          } else {
            fn3 = data2;
            data2 = selector;
            selector = void 0;
          }
        }
        if (fn3 === false) {
          fn3 = returnFalse;
        } else if (!fn3) {
          return elem;
        }
        if (one === 1) {
          origFn = fn3;
          fn3 = function(event) {
            jQuery2().off(event);
            return origFn.apply(this, arguments);
          };
          fn3.guid = origFn.guid || (origFn.guid = jQuery2.guid++);
        }
        return elem.each(function() {
          jQuery2.event.add(this, types, fn3, data2, selector);
        });
      }
      jQuery2.event = {
        global: {},
        add: function(elem, types, handler, data2, selector) {
          var handleObjIn, eventHandle, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery2.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery2.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e2) {
              return typeof jQuery2 !== "undefined" && jQuery2.event.triggered !== e2.type ? jQuery2.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t2 = types.length;
          while (t2--) {
            tmp = rtypenamespace.exec(types[t2]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery2.event.special[type] || {};
            handleObj = jQuery2.extend({
              type,
              origType,
              data: data2,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery2.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data2, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery2.event.global[type] = true;
          }
        },
        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j2, origCount, tmp, events, t2, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t2 = types.length;
          while (t2--) {
            tmp = rtypenamespace.exec(types[t2]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery2.event.remove(elem, type + types[t2], handler, selector, true);
              }
              continue;
            }
            special = jQuery2.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j2 = handlers.length;
            while (j2--) {
              handleObj = handlers[j2];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j2, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery2.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery2.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i, j2, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery2.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery2.event.special[event.type] || {};
          args[0] = event;
          for (i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery2.event.handlers.call(this, event, handlers);
          i = 0;
          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j2 = 0;
            while ((handleObj = matched.handlers[j2++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery2.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && // Support: IE <=9
          // Black-hole SVG <use> instance trees (trac-13180)
          cur.nodeType && // Support: Firefox <=42
          // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
          // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
          // Support: IE 11 only
          // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
          !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i = 0; i < delegateCount; i++) {
                  handleObj = handlers[i];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery2(sel, this).index(cur) > -1 : jQuery2.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name2, hook) {
          Object.defineProperty(jQuery2.Event.prototype, name2, {
            enumerable: true,
            configurable: true,
            get: isFunction2(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name2];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name2, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery2.expando] ? originalEvent : new jQuery2.Event(originalEvent);
        },
        special: {
          load: {
            // Prevent triggered image.load events from bubbling to window.load
            noBubble: true
          },
          click: {
            // Utilize native event to ensure correct state for checkable inputs
            setup: function(data2) {
              var el = this || data2;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", true);
              }
              return false;
            },
            trigger: function(data2) {
              var el = this || data2;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            // For cross-browser consistency, suppress native .click() on links
            // Also prevent it if we're currently inside a leveraged native-event stack
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, isSetup) {
        if (!isSetup) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery2.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery2.event.add(el, type, {
          namespace: false,
          handler: function(event) {
            var result, saved = dataPriv.get(this, type);
            if (event.isTrigger & 1 && this[type]) {
              if (!saved) {
                saved = slice.call(arguments);
                dataPriv.set(this, type, saved);
                this[type]();
                result = dataPriv.get(this, type);
                dataPriv.set(this, type, false);
                if (saved !== result) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result;
                }
              } else if ((jQuery2.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved) {
              dataPriv.set(this, type, jQuery2.event.trigger(
                saved[0],
                saved.slice(1),
                this
              ));
              event.stopPropagation();
              event.isImmediatePropagationStopped = returnTrue;
            }
          }
        });
      }
      jQuery2.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery2.Event = function(src, props) {
        if (!(this instanceof jQuery2.Event)) {
          return new jQuery2.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && // Support: Android <=2.3 only
          src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery2.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery2.expando] = true;
      };
      jQuery2.Event.prototype = {
        constructor: jQuery2.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e2 = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e2 && !this.isSimulated) {
            e2.preventDefault();
          }
        },
        stopPropagation: function() {
          var e2 = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e2 && !this.isSimulated) {
            e2.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e2 = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e2 && !this.isSimulated) {
            e2.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery2.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery2.event.addProp);
      jQuery2.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        function focusMappedHandler(nativeEvent) {
          if (document2.documentMode) {
            var handle = dataPriv.get(this, "handle"), event = jQuery2.event.fix(nativeEvent);
            event.type = nativeEvent.type === "focusin" ? "focus" : "blur";
            event.isSimulated = true;
            handle(nativeEvent);
            if (event.target === event.currentTarget) {
              handle(event);
            }
          } else {
            jQuery2.event.simulate(
              delegateType,
              nativeEvent.target,
              jQuery2.event.fix(nativeEvent)
            );
          }
        }
        jQuery2.event.special[type] = {
          // Utilize native event if possible so blur/focus sequence is correct
          setup: function() {
            var attaches;
            leverageNative(this, type, true);
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType);
              if (!attaches) {
                this.addEventListener(delegateType, focusMappedHandler);
              }
              dataPriv.set(this, delegateType, (attaches || 0) + 1);
            } else {
              return false;
            }
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          teardown: function() {
            var attaches;
            if (document2.documentMode) {
              attaches = dataPriv.get(this, delegateType) - 1;
              if (!attaches) {
                this.removeEventListener(delegateType, focusMappedHandler);
                dataPriv.remove(this, delegateType);
              } else {
                dataPriv.set(this, delegateType, attaches);
              }
            } else {
              return false;
            }
          },
          // Suppress native focus or blur if we're currently inside
          // a leveraged native-event stack
          _default: function(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType
        };
        jQuery2.event.special[delegateType] = {
          setup: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType);
            if (!attaches) {
              if (document2.documentMode) {
                this.addEventListener(delegateType, focusMappedHandler);
              } else {
                doc.addEventListener(type, focusMappedHandler, true);
              }
            }
            dataPriv.set(dataHolder, delegateType, (attaches || 0) + 1);
          },
          teardown: function() {
            var doc = this.ownerDocument || this.document || this, dataHolder = document2.documentMode ? this : doc, attaches = dataPriv.get(dataHolder, delegateType) - 1;
            if (!attaches) {
              if (document2.documentMode) {
                this.removeEventListener(delegateType, focusMappedHandler);
              } else {
                doc.removeEventListener(type, focusMappedHandler, true);
              }
              dataPriv.remove(dataHolder, delegateType);
            } else {
              dataPriv.set(dataHolder, delegateType, attaches);
            }
          }
        };
      });
      jQuery2.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery2.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery2.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery2.fn.extend({
        on: function(types, selector, data2, fn3) {
          return on2(this, types, selector, data2, fn3);
        },
        one: function(types, selector, data2, fn3) {
          return on2(this, types, selector, data2, fn3, 1);
        },
        off: function(types, selector, fn3) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery2(types.delegateTarget).off(
              handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
              handleObj.selector,
              handleObj.handler
            );
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn3 = selector;
            selector = void 0;
          }
          if (fn3 === false) {
            fn3 = returnFalse;
          }
          return this.each(function() {
            jQuery2.event.remove(this, types, fn3, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery2(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i, l2, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i = 0, l2 = events[type].length; i < l2; i++) {
                jQuery2.event.add(dest, type, events[type][i]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery2.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l2 = collection.length, iNoClone = l2 - 1, value = args[0], valueIsFunction = isFunction2(value);
        if (valueIsFunction || l2 > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index) {
            var self2 = collection.eq(index);
            if (valueIsFunction) {
              args[0] = value.call(this, index, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l2) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery2.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i < l2; i++) {
              node = fragment;
              if (i !== iNoClone) {
                node = jQuery2.clone(node, true, true);
                if (hasScripts) {
                  jQuery2.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i], node, i);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery2.map(scripts, restoreScript);
              for (i = 0; i < hasScripts; i++) {
                node = scripts[i];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery2.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery2._evalUrl && !node.noModule) {
                      jQuery2._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery2.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
          if (!keepData && node.nodeType === 1) {
            jQuery2.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery2.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i, l2, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery2.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i = 0, l2 = srcElements.length; i < l2; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i = 0, l2 = srcElements.length; i < l2; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        cleanData: function(elems) {
          var data2, elem, type, special = jQuery2.event.special, i = 0;
          for (; (elem = elems[i]) !== void 0; i++) {
            if (acceptData(elem)) {
              if (data2 = elem[dataPriv.expando]) {
                if (data2.events) {
                  for (type in data2.events) {
                    if (special[type]) {
                      jQuery2.event.remove(elem, type);
                    } else {
                      jQuery2.removeEvent(elem, type, data2.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery2.fn.extend({
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery2.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i = 0;
          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              jQuery2.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery2.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i = 0, l2 = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery2.htmlPrefilter(value2);
              try {
                for (; i < l2; i++) {
                  elem = this[i] || {};
                  if (elem.nodeType === 1) {
                    jQuery2.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e2) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery2.inArray(this, ignored) < 0) {
              jQuery2.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery2.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name2, original) {
        jQuery2.fn[name2] = function(selector) {
          var elems, ret = [], insert = jQuery2(selector), last = insert.length - 1, i = 0;
          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery2(insert[i])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name2, old2 = {};
        for (name2 in options) {
          old2[name2] = elem.style[name2];
          elem.style[name2] = options[name2];
        }
        ret = callback.call(elem);
        for (name2 in options) {
          elem.style[name2] = old2[name2];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery2.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          // Support: IE 9 - 11+, Edge 15 - 18+
          // IE/Edge misreport `getComputedStyle` of table rows with width/height
          // set in CSS while `offset*` properties report correct values.
          // Behavior in IE 9 is more subtle than in newer versions & it passes
          // some versions of this test; make sure not to make it pass there!
          //
          // Support: Firefox 70+
          // Only Firefox includes border widths
          // in computed dimensions. (gh-4529)
          reliableTrDimensions: function() {
            var table, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "box-sizing:content-box;border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name2, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name2), style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name2) || computed[name2];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery2.style(elem, name2);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name2)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? (
          // Support: IE <=9 - 11 only
          // IE returns zIndex value as an integer.
          ret + ""
        ) : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name2) {
        var capName = name2[0].toUpperCase() + name2.slice(1), i = cssPrefixes.length;
        while (i--) {
          name2 = cssPrefixes[i] + capName;
          if (name2 in emptyStyle) {
            return name2;
          }
        }
      }
      function finalPropName(name2) {
        var final = jQuery2.cssProps[name2] || vendorProps[name2];
        if (final) {
          return final;
        }
        if (name2 in emptyStyle) {
          return name2;
        }
        return vendorProps[name2] = vendorPropName(name2) || name2;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? (
          // Guard against undefined "subtract", e.g., when used as in cssHooks
          Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px")
        ) : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles2, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0, marginDelta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i < 4; i += 2) {
          if (box === "margin") {
            marginDelta += jQuery2.css(elem, box + cssExpand[i], true, styles2);
          }
          if (!isBorderBox) {
            delta += jQuery2.css(elem, "padding" + cssExpand[i], true, styles2);
            if (box !== "padding") {
              delta += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            } else {
              extra += jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            }
          } else {
            if (box === "content") {
              delta -= jQuery2.css(elem, "padding" + cssExpand[i], true, styles2);
            }
            if (box !== "margin") {
              delta -= jQuery2.css(elem, "border" + cssExpand[i] + "Width", true, styles2);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(
            elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5
            // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
            // Use an explicit zero to avoid NaN (gh-3964)
          )) || 0;
        }
        return delta + marginDelta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles2 = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles2) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles2), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
        // IE/Edge misreport `getComputedStyle` of table rows with width/height
        // set in CSS while `offset*` properties report correct values.
        // Interestingly, in some cases IE 9 doesn't suffer from this issue.
        !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
        // This happens for inline elements with no explicit setting (gh-3571)
        val === "auto" || // Support: Android <=4.1 - 4.3 only
        // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
        !parseFloat(val) && jQuery2.css(elem, "display", false, styles2) === "inline") && // Make sure the element is visible & connected
        elem.getClientRects().length) {
          isBorderBox = jQuery2.css(elem, "boxSizing", false, styles2) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(
          elem,
          dimension,
          extra || (isBorderBox ? "border" : "content"),
          valueIsBorderBox,
          styles2,
          // Provide the current computed size to request scroll gutter calculation (gh-3589)
          val
        ) + "px";
      }
      jQuery2.extend({
        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
          animationIterationCount: true,
          aspectRatio: true,
          borderImageSlice: true,
          columnCount: true,
          flexGrow: true,
          flexShrink: true,
          fontWeight: true,
          gridArea: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnStart: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowStart: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          scale: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeMiterlimit: true,
          strokeOpacity: true
        },
        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {},
        // Get and set the style property on a DOM Node
        style: function(elem, name2, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2), style = elem.style;
          if (!isCustomProp) {
            name2 = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name2, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery2.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name2.indexOf("background") === 0) {
              style[name2] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name2, value);
              } else {
                style[name2] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name2];
          }
        },
        css: function(elem, name2, extra, styles2) {
          var val, num, hooks, origName = camelCase(name2), isCustomProp = rcustomProp.test(name2);
          if (!isCustomProp) {
            name2 = finalPropName(origName);
          }
          hooks = jQuery2.cssHooks[name2] || jQuery2.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name2, styles2);
          }
          if (val === "normal" && name2 in cssNormalTransform) {
            val = cssNormalTransform[name2];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery2.each(["height", "width"], function(_i2, dimension) {
        jQuery2.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery2.css(elem, "display")) && // Support: Safari 8+
              // Table columns in Safari have non-zero offsetWidth & zero
              // getBoundingClientRect().width unless display is changed.
              // Support: IE <=11 only
              // Running getBoundingClientRect on a disconnected node
              // in IE throws an error.
              (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles2 = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles2.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery2.css(elem, "boxSizing", false, styles2) === "border-box", subtract = extra ? boxModelAdjustment(
              elem,
              dimension,
              extra,
              isBorderBox,
              styles2
            ) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(
                elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles2[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles2) - 0.5
              );
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery2.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery2.cssHooks.marginLeft = addGetHookIf(
        support.reliableMarginLeft,
        function(elem, computed) {
          if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
              return elem.getBoundingClientRect().left;
            })) + "px";
          }
        }
      );
      jQuery2.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery2.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery2.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery2.fn.extend({
        css: function(name2, value) {
          return access(this, function(elem, name3, value2) {
            var styles2, len, map2 = {}, i = 0;
            if (Array.isArray(name3)) {
              styles2 = getStyles(elem);
              len = name3.length;
              for (; i < len; i++) {
                map2[name3[i]] = jQuery2.css(elem, name3[i], false, styles2);
              }
              return map2;
            }
            return value2 !== void 0 ? jQuery2.style(elem, name3, value2) : jQuery2.css(elem, name3);
          }, name2, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end2, easing) {
        return new Tween.prototype.init(elem, options, prop, end2, easing);
      }
      jQuery2.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end2, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery2.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end2;
          this.unit = unit || (jQuery2.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery2.easing[this.easing](
              percent,
              this.options.duration * percent,
              0,
              1,
              this.options.duration
            );
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween2) {
            var result;
            if (tween2.elem.nodeType !== 1 || tween2.elem[tween2.prop] != null && tween2.elem.style[tween2.prop] == null) {
              return tween2.elem[tween2.prop];
            }
            result = jQuery2.css(tween2.elem, tween2.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween2) {
            if (jQuery2.fx.step[tween2.prop]) {
              jQuery2.fx.step[tween2.prop](tween2);
            } else if (tween2.elem.nodeType === 1 && (jQuery2.cssHooks[tween2.prop] || tween2.elem.style[finalPropName(tween2.prop)] != null)) {
              jQuery2.style(tween2.elem, tween2.prop, tween2.now + tween2.unit);
            } else {
              tween2.elem[tween2.prop] = tween2.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween2) {
          if (tween2.elem.nodeType && tween2.elem.parentNode) {
            tween2.elem[tween2.prop] = tween2.now;
          }
        }
      };
      jQuery2.easing = {
        linear: function(p2) {
          return p2;
        },
        swing: function(p2) {
          return 0.5 - Math.cos(p2 * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery2.fx = Tween.prototype.init;
      jQuery2.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery2.fx.interval);
          }
          jQuery2.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween2, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (; index < length; index++) {
          if (tween2 = collection[index].call(animation, prop, value)) {
            return tween2;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle2, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery2._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery2.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle2 = toggle2 || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery2.style(elem, prop);
          }
        }
        propTween = !jQuery2.isEmptyObject(props);
        if (!propTween && jQuery2.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery2.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery2.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery2.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle2) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery2.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index, name2, easing, value, hooks;
        for (index in props) {
          name2 = camelCase(index);
          easing = specialEasing[name2];
          value = props[index];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }
          if (index !== name2) {
            props[name2] = value;
            delete props[index];
          }
          hooks = jQuery2.cssHooks[name2];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name2];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name2] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery2.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery2.extend({}, properties),
          opts: jQuery2.extend(true, {
            specialEasing: {},
            easing: jQuery2.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end2) {
            var tween2 = jQuery2.Tween(
              elem,
              animation.opts,
              prop,
              end2,
              animation.opts.specialEasing[prop] || animation.opts.easing
            );
            animation.tweens.push(tween2);
            return tween2;
          },
          stop: function(gotoEnd) {
            var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction2(result.stop)) {
              jQuery2._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery2.map(props, createTween, animation);
        if (isFunction2(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery2.fx.timer(
          jQuery2.extend(tick, {
            elem,
            anim: animation,
            queue: animation.opts.queue
          })
        );
        return animation;
      }
      jQuery2.Animation = jQuery2.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween2 = this.createTween(prop, value);
            adjustCSS(tween2.elem, prop, rcssNum.exec(value), tween2);
            return tween2;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction2(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index = 0, length = props.length;
          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery2.speed = function(speed, easing, fn3) {
        var opt = speed && typeof speed === "object" ? jQuery2.extend({}, speed) : {
          complete: fn3 || !fn3 && easing || isFunction2(speed) && speed,
          duration: speed,
          easing: fn3 && easing || easing && !isFunction2(easing) && easing
        };
        if (jQuery2.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery2.fx.speeds) {
              opt.duration = jQuery2.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery2.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction2(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery2.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery2.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery2.isEmptyObject(prop), optall = jQuery2.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery2.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery2.timers, data2 = dataPriv.get(this);
            if (index) {
              if (data2[index] && data2[index].stop) {
                stopQueue(data2[index]);
              }
            } else {
              for (index in data2) {
                if (data2[index] && data2[index].stop && rrun.test(index)) {
                  stopQueue(data2[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery2.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index, data2 = dataPriv.get(this), queue = data2[type + "queue"], hooks = data2[type + "queueHooks"], timers = jQuery2.timers, length = queue ? queue.length : 0;
            data2.finish = true;
            jQuery2.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            }
            delete data2.finish;
          });
        }
      });
      jQuery2.each(["toggle", "show", "hide"], function(_i2, name2) {
        var cssFn = jQuery2.fn[name2];
        jQuery2.fn[name2] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name2, true), speed, easing, callback);
        };
      });
      jQuery2.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name2, props) {
        jQuery2.fn[name2] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery2.timers = [];
      jQuery2.fx.tick = function() {
        var timer, i = 0, timers = jQuery2.timers;
        fxNow = Date.now();
        for (; i < timers.length; i++) {
          timer = timers[i];
          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }
        if (!timers.length) {
          jQuery2.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery2.fx.timer = function(timer) {
        jQuery2.timers.push(timer);
        jQuery2.fx.start();
      };
      jQuery2.fx.interval = 13;
      jQuery2.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery2.fx.stop = function() {
        inProgress = null;
      };
      jQuery2.fx.speeds = {
        slow: 600,
        fast: 200,
        // Default speed
        _default: 400
      };
      jQuery2.fn.delay = function(time, type) {
        time = jQuery2.fx ? jQuery2.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout2 = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout2);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery2.expr.attrHandle;
      jQuery2.fn.extend({
        attr: function(name2, value) {
          return access(this, jQuery2.attr, name2, value, arguments.length > 1);
        },
        removeAttr: function(name2) {
          return this.each(function() {
            jQuery2.removeAttr(this, name2);
          });
        }
      });
      jQuery2.extend({
        attr: function(elem, name2, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery2.prop(elem, name2, value);
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            hooks = jQuery2.attrHooks[name2.toLowerCase()] || (jQuery2.expr.match.bool.test(name2) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery2.removeAttr(elem, name2);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name2, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
            return ret;
          }
          ret = jQuery2.find.attr(elem, name2);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name2, i = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name2 = attrNames[i++]) {
              elem.removeAttribute(name2);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name2) {
          if (value === false) {
            jQuery2.removeAttr(elem, name2);
          } else {
            elem.setAttribute(name2, name2);
          }
          return name2;
        }
      };
      jQuery2.each(jQuery2.expr.match.bool.source.match(/\w+/g), function(_i2, name2) {
        var getter = attrHandle[name2] || jQuery2.find.attr;
        attrHandle[name2] = function(elem, name3, isXML) {
          var ret, handle, lowercaseName = name3.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name3, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery2.fn.extend({
        prop: function(name2, value) {
          return access(this, jQuery2.prop, name2, value, arguments.length > 1);
        },
        removeProp: function(name2) {
          return this.each(function() {
            delete this[jQuery2.propFix[name2] || name2];
          });
        }
      });
      jQuery2.extend({
        prop: function(elem, name2, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery2.isXMLDoc(elem)) {
            name2 = jQuery2.propFix[name2] || name2;
            hooks = jQuery2.propHooks[name2];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name2)) !== void 0) {
              return ret;
            }
            return elem[name2] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name2)) !== null) {
            return ret;
          }
          return elem[name2];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery2.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery2.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery2.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery2.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery2.fn.extend({
        addClass: function(value) {
          var classNames2, cur, curValue, className, i, finalValue;
          if (isFunction2(value)) {
            return this.each(function(j2) {
              jQuery2(this).addClass(value.call(this, j2, getClass(this)));
            });
          }
          classNames2 = classesToArray(value);
          if (classNames2.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames2.length; i++) {
                  className = classNames2[i];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames2, cur, curValue, className, i, finalValue;
          if (isFunction2(value)) {
            return this.each(function(j2) {
              jQuery2(this).removeClass(value.call(this, j2, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames2 = classesToArray(value);
          if (classNames2.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames2.length; i++) {
                  className = classNames2[i];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames2, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction2(value)) {
            return this.each(function(i2) {
              jQuery2(this).toggleClass(
                value.call(this, i2, getClass(this), stateVal),
                stateVal
              );
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames2 = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery2(this);
              for (i = 0; i < classNames2.length; i++) {
                className = classNames2[i];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute(
                  "class",
                  className || value === false ? "" : dataPriv.get(this, "__className__") || ""
                );
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i = 0;
          className = " " + selector + " ";
          while (elem = this[i++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery2.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery2.valHooks[elem.type] || jQuery2.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction2(value);
          return this.each(function(i) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i, jQuery2(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery2.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery2.valHooks[this.type] || jQuery2.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery2.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery2.find.attr(elem, "value");
              return val != null ? val : (
                // Support: IE <=10 - 11 only
                // option.text throws exceptions (trac-14686, trac-14858)
                // Strip and collapse whitespace
                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                stripAndCollapse(jQuery2.text(elem))
              );
            }
          },
          select: {
            get: function(elem) {
              var value, option2, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max2 = one ? index + 1 : options.length;
              if (index < 0) {
                i = max2;
              } else {
                i = one ? index : 0;
              }
              for (; i < max2; i++) {
                option2 = options[i];
                if ((option2.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
                !option2.disabled && (!option2.parentNode.disabled || !nodeName(option2.parentNode, "optgroup"))) {
                  value = jQuery2(option2).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet, option2, options = elem.options, values = jQuery2.makeArray(value), i = options.length;
              while (i--) {
                option2 = options[i];
                if (option2.selected = jQuery2.inArray(jQuery2.valHooks.option.get(option2), values) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }
      });
      jQuery2.each(["radio", "checkbox"], function() {
        jQuery2.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery2.inArray(jQuery2(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery2.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      var location2 = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery2.parseXML = function(data2) {
        var xml, parserErrorElem;
        if (!data2 || typeof data2 !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data2, "text/xml");
        } catch (e2) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery2.error("Invalid XML: " + (parserErrorElem ? jQuery2.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
          }).join("\n") : data2));
        }
        return xml;
      };
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e2) {
        e2.stopPropagation();
      };
      jQuery2.extend(jQuery2.event, {
        trigger: function(event, data2, elem, onlyHandlers) {
          var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery2.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery2.expando] ? event : new jQuery2.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data2 = data2 == null ? [event] : jQuery2.makeArray(data2, [event]);
          special = jQuery2.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data2) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i = 0;
          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data2);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data2);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data2) === false) && acceptData(elem)) {
              if (ontype && isFunction2(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery2.event.triggered = type;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery2.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
          var e2 = jQuery2.extend(
            new jQuery2.Event(),
            event,
            {
              type,
              isSimulated: true
            }
          );
          jQuery2.event.trigger(e2, null, elem);
        }
      });
      jQuery2.fn.extend({
        trigger: function(type, data2) {
          return this.each(function() {
            jQuery2.event.trigger(type, data2, this);
          });
        },
        triggerHandler: function(type, data2) {
          var elem = this[0];
          if (elem) {
            return jQuery2.event.trigger(type, data2, elem, true);
          }
        }
      });
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name2;
        if (Array.isArray(obj)) {
          jQuery2.each(obj, function(i, v2) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v2);
            } else {
              buildParams(
                prefix + "[" + (typeof v2 === "object" && v2 != null ? i : "") + "]",
                v2,
                traditional,
                add
              );
            }
          });
        } else if (!traditional && toType2(obj) === "object") {
          for (name2 in obj) {
            buildParams(prefix + "[" + name2 + "]", obj[name2], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery2.param = function(a2, traditional) {
        var prefix, s2 = [], add = function(key, valueOrFunction) {
          var value = isFunction2(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s2[s2.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a2 == null) {
          return "";
        }
        if (Array.isArray(a2) || a2.jquery && !jQuery2.isPlainObject(a2)) {
          jQuery2.each(a2, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a2) {
            buildParams(prefix, a2[prefix], traditional, add);
          }
        }
        return s2.join("&");
      };
      jQuery2.fn.extend({
        serialize: function() {
          return jQuery2.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery2.prop(this, "elements");
            return elements ? jQuery2.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery2(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i2, elem) {
            var val = jQuery2(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery2.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location2.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction2(func)) {
            while (dataType = dataTypes[i++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery2.each(structure[dataType] || [], function(_2, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery2.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery2.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s2, jqXHR, responses) {
        var ct2, type, finalDataType, firstDataType, contents = s2.contents, dataTypes = s2.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct2 === void 0) {
            ct2 = s2.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct2) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct2)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s2.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s2, response2, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s2.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s2.converters) {
            converters[conv.toLowerCase()] = s2.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s2.responseFields[current]) {
            jqXHR[s2.responseFields[current]] = response2;
          }
          if (!prev && isSuccess && s2.dataFilter) {
            response2 = s2.dataFilter(response2, s2.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s2.throws) {
                  response2 = conv(response2);
                } else {
                  try {
                    response2 = conv(response2);
                  } catch (e2) {
                    return {
                      state: "parsererror",
                      error: conv ? e2 : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response2 };
      }
      jQuery2.extend({
        // Counter for holding the number of active queries
        active: 0,
        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location2.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location2.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          /*
          timeout: 0,
          data: null,
          dataType: null,
          username: null,
          password: null,
          cache: null,
          throws: false,
          traditional: false,
          headers: {},
          */
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          // Data converters
          // Keys separate source (or catchall "*") and destination types with a single space
          converters: {
            // Convert anything to text
            "* text": String,
            // Text to html (true = no transformation)
            "text html": true,
            // Evaluate text as a json expression
            "text json": JSON.parse,
            // Parse text as xml
            "text xml": jQuery2.parseXML
          },
          // For options that shouldn't be deep extended:
          // you can add your own custom options here if
          // and when you create one that shouldn't be
          // deep extended (see ajaxExtend)
          flatOptions: {
            url: true,
            context: true
          }
        },
        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
          return settings ? (
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery2.ajaxSettings), settings)
          ) : (
            // Extending ajaxSettings
            ajaxExtend(jQuery2.ajaxSettings, target)
          );
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        // Main method
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s2 = jQuery2.ajaxSetup({}, options), callbackContext = s2.context || s2, globalEventContext = s2.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery2(callbackContext) : jQuery2.event, deferred = jQuery2.Deferred(), completeDeferred = jQuery2.Callbacks("once memory"), statusCode = s2.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            // Builds headers hashtable if needed
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            // Raw string
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            // Caches the header
            setRequestHeader: function(name2, value) {
              if (completed2 == null) {
                name2 = requestHeadersNames[name2.toLowerCase()] = requestHeadersNames[name2.toLowerCase()] || name2;
                requestHeaders[name2] = value;
              }
              return this;
            },
            // Overrides response content-type header
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s2.mimeType = type;
              }
              return this;
            },
            // Status-dependent callbacks
            statusCode: function(map2) {
              var code;
              if (map2) {
                if (completed2) {
                  jqXHR.always(map2[jqXHR.status]);
                } else {
                  for (code in map2) {
                    statusCode[code] = [statusCode[code], map2[code]];
                  }
                }
              }
              return this;
            },
            // Cancel the request
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s2.url = ((url || s2.url || location2.href) + "").replace(rprotocol, location2.protocol + "//");
          s2.type = options.method || options.type || s2.method || s2.type;
          s2.dataTypes = (s2.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s2.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s2.url;
              urlAnchor.href = urlAnchor.href;
              s2.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e2) {
              s2.crossDomain = true;
            }
          }
          if (s2.data && s2.processData && typeof s2.data !== "string") {
            s2.data = jQuery2.param(s2.data, s2.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s2, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery2.event && s2.global;
          if (fireGlobals && jQuery2.active++ === 0) {
            jQuery2.event.trigger("ajaxStart");
          }
          s2.type = s2.type.toUpperCase();
          s2.hasContent = !rnoContent.test(s2.type);
          cacheURL = s2.url.replace(rhash, "");
          if (!s2.hasContent) {
            uncached = s2.url.slice(cacheURL.length);
            if (s2.data && (s2.processData || typeof s2.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s2.data;
              delete s2.data;
            }
            if (s2.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s2.url = cacheURL + uncached;
          } else if (s2.data && s2.processData && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s2.data = s2.data.replace(r20, "+");
          }
          if (s2.ifModified) {
            if (jQuery2.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery2.lastModified[cacheURL]);
            }
            if (jQuery2.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery2.etag[cacheURL]);
            }
          }
          if (s2.data && s2.hasContent && s2.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s2.contentType);
          }
          jqXHR.setRequestHeader(
            "Accept",
            s2.dataTypes[0] && s2.accepts[s2.dataTypes[0]] ? s2.accepts[s2.dataTypes[0]] + (s2.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s2.accepts["*"]
          );
          for (i in s2.headers) {
            jqXHR.setRequestHeader(i, s2.headers[i]);
          }
          if (s2.beforeSend && (s2.beforeSend.call(callbackContext, jqXHR, s2) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s2.complete);
          jqXHR.done(s2.success);
          jqXHR.fail(s2.error);
          transport = inspectPrefiltersOrTransports(transports, s2, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s2]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s2.async && s2.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s2.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e2) {
              if (completed2) {
                throw e2;
              }
              done(-1, e2);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error2, response2, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response2 = ajaxHandleResponses(s2, jqXHR, responses);
            }
            if (!isSuccess && jQuery2.inArray("script", s2.dataTypes) > -1 && jQuery2.inArray("json", s2.dataTypes) < 0) {
              s2.converters["text script"] = function() {
              };
            }
            response2 = ajaxConvert(s2, response2, jqXHR, isSuccess);
            if (isSuccess) {
              if (s2.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery2.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery2.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s2.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response2.state;
                success = response2.data;
                error2 = response2.error;
                isSuccess = !error2;
              }
            } else {
              error2 = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error2]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(
                isSuccess ? "ajaxSuccess" : "ajaxError",
                [jqXHR, s2, isSuccess ? success : error2]
              );
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s2]);
              if (!--jQuery2.active) {
                jQuery2.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data2, callback) {
          return jQuery2.get(url, data2, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery2.get(url, void 0, callback, "script");
        }
      });
      jQuery2.each(["get", "post"], function(_i2, method) {
        jQuery2[method] = function(url, data2, callback, type) {
          if (isFunction2(data2)) {
            type = type || callback;
            callback = data2;
            data2 = void 0;
          }
          return jQuery2.ajax(jQuery2.extend({
            url,
            type: method,
            dataType: type,
            data: data2,
            success: callback
          }, jQuery2.isPlainObject(url) && url));
        };
      });
      jQuery2.ajaxPrefilter(function(s2) {
        var i;
        for (i in s2.headers) {
          if (i.toLowerCase() === "content-type") {
            s2.contentType = s2.headers[i] || "";
          }
        }
      });
      jQuery2._evalUrl = function(url, options, doc) {
        return jQuery2.ajax({
          url,
          // Make this explicit, since user can override this through ajaxSetup (trac-11264)
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          // Only evaluate the response if it is successful (gh-4126)
          // dataFilter is not invoked for failure responses, so using it instead
          // of the default converter is kludgy but it works.
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response2) {
            jQuery2.globalEval(response2, options, doc);
          }
        });
      };
      jQuery2.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (this[0]) {
            if (isFunction2(html)) {
              html = html.call(this[0]);
            }
            wrap = jQuery2(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction2(html)) {
            return this.each(function(i) {
              jQuery2(this).wrapInner(html.call(this, i));
            });
          }
          return this.each(function() {
            var self2 = jQuery2(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction2(html);
          return this.each(function(i) {
            jQuery2(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery2(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery2.expr.pseudos.hidden = function(elem) {
        return !jQuery2.expr.pseudos.visible(elem);
      };
      jQuery2.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery2.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e2) {
        }
      };
      var xhrSuccessStatus = {
        // File protocol always yields status code 0, assume 200
        0: 200,
        // Support: IE <=9 only
        // trac-1450: sometimes IE returns 1223 when it should be 204
        1223: 204
      }, xhrSupported = jQuery2.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery2.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i, xhr = options.xhr();
              xhr.open(
                options.type,
                options.url,
                options.async,
                options.username,
                options.password
              );
              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(
                          // File: protocol always yields status 0; see trac-8605, trac-14207
                          xhr.status,
                          xhr.statusText
                        );
                      }
                    } else {
                      complete(
                        xhrSuccessStatus[xhr.status] || xhr.status,
                        xhr.statusText,
                        // Support: IE <=9 only
                        // IE9 has no XHR2 but throws on binary (trac-11426)
                        // For XHR2 non-text, let the caller handle it (gh-2498)
                        (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText },
                        xhr.getAllResponseHeaders()
                      );
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e2) {
                if (callback) {
                  throw e2;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery2.ajaxPrefilter(function(s2) {
        if (s2.crossDomain) {
          s2.contents.script = false;
        }
      });
      jQuery2.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text2) {
            jQuery2.globalEval(text2);
            return text2;
          }
        }
      });
      jQuery2.ajaxPrefilter("script", function(s2) {
        if (s2.cache === void 0) {
          s2.cache = false;
        }
        if (s2.crossDomain) {
          s2.type = "GET";
        }
      });
      jQuery2.ajaxTransport("script", function(s2) {
        if (s2.crossDomain || s2.scriptAttrs) {
          var script, callback;
          return {
            send: function(_2, complete) {
              script = jQuery2("<script>").attr(s2.scriptAttrs || {}).prop({ charset: s2.scriptCharset, src: s2.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery2.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery2.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery2.ajaxPrefilter("json jsonp", function(s2, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s2.jsonp !== false && (rjsonp.test(s2.url) ? "url" : typeof s2.data === "string" && (s2.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s2.data) && "data");
        if (jsonProp || s2.dataTypes[0] === "jsonp") {
          callbackName = s2.jsonpCallback = isFunction2(s2.jsonpCallback) ? s2.jsonpCallback() : s2.jsonpCallback;
          if (jsonProp) {
            s2[jsonProp] = s2[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s2.jsonp !== false) {
            s2.url += (rquery.test(s2.url) ? "&" : "?") + s2.jsonp + "=" + callbackName;
          }
          s2.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery2.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s2.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery2(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s2[callbackName]) {
              s2.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction2(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery2.parseHTML = function(data2, context, keepScripts) {
        if (typeof data2 !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data2);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data2], context, scripts);
        if (scripts && scripts.length) {
          jQuery2(scripts).remove();
        }
        return jQuery2.merge([], parsed.childNodes);
      };
      jQuery2.fn.load = function(url, params, callback) {
        var selector, type, response2, self2 = this, off2 = url.indexOf(" ");
        if (off2 > -1) {
          selector = stripAndCollapse(url.slice(off2));
          url = url.slice(0, off2);
        }
        if (isFunction2(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery2.ajax({
            url,
            // If "type" variable is undefined, then "GET" method will be used.
            // Make value of this field explicit since
            // user can override it through ajaxSetup method
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response2 = arguments;
            self2.html(selector ? (
              // If a selector was specified, locate the right elements in a dummy div
              // Exclude scripts to avoid IE 'Permission Denied' errors
              jQuery2("<div>").append(jQuery2.parseHTML(responseText)).find(selector)
            ) : (
              // Otherwise use the full result
              responseText
            ));
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response2 || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery2.expr.pseudos.animated = function(elem) {
        return jQuery2.grep(jQuery2.timers, function(fn3) {
          return elem === fn3.elem;
        }).length;
      };
      jQuery2.offset = {
        setOffset: function(elem, options, i) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery2.css(elem, "position"), curElem = jQuery2(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery2.css(elem, "top");
          curCSSLeft = jQuery2.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction2(options)) {
            options = options.call(elem, i, jQuery2.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery2.fn.extend({
        // offset() relates an element's border box to the document origin
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i) {
              jQuery2.offset.setOffset(this, options, i);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        // position() relates an element's margin box to its offset parent's padding box
        // This corresponds to the behavior of CSS absolute positioning
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset2, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery2.css(elem, "position") === "fixed") {
            offset2 = elem.getBoundingClientRect();
          } else {
            offset2 = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery2(offsetParent).offset();
              parentOffset.top += jQuery2.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery2.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset2.top - parentOffset.top - jQuery2.css(elem, "marginTop", true),
            left: offset2.left - parentOffset.left - jQuery2.css(elem, "marginLeft", true)
          };
        },
        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery2.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery2.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top2 = "pageYOffset" === prop;
        jQuery2.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(
                !top2 ? val2 : win.pageXOffset,
                top2 ? val2 : win.pageYOffset
              );
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery2.each(["top", "left"], function(_i2, prop) {
        jQuery2.cssHooks[prop] = addGetHookIf(
          support.pixelPosition,
          function(elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              return rnumnonpx.test(computed) ? jQuery2(elem).position()[prop] + "px" : computed;
            }
          }
        );
      });
      jQuery2.each({ Height: "height", Width: "width" }, function(name2, type) {
        jQuery2.each({
          padding: "inner" + name2,
          content: type,
          "": "outer" + name2
        }, function(defaultExtra, funcName) {
          jQuery2.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name2] : elem.document.documentElement["client" + name2];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(
                  elem.body["scroll" + name2],
                  doc["scroll" + name2],
                  elem.body["offset" + name2],
                  doc["offset" + name2],
                  doc["client" + name2]
                );
              }
              return value2 === void 0 ? (
                // Get width or height on the element, requesting but not forcing parseFloat
                jQuery2.css(elem, type2, extra)
              ) : (
                // Set width or height on the element
                jQuery2.style(elem, type2, value2, extra)
              );
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery2.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i2, type) {
        jQuery2.fn[type] = function(fn3) {
          return this.on(type, fn3);
        };
      });
      jQuery2.fn.extend({
        bind: function(types, data2, fn3) {
          return this.on(types, null, data2, fn3);
        },
        unbind: function(types, fn3) {
          return this.off(types, null, fn3);
        },
        delegate: function(selector, types, data2, fn3) {
          return this.on(types, selector, data2, fn3);
        },
        undelegate: function(selector, types, fn3) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn3);
        },
        hover: function(fnOver, fnOut) {
          return this.on("mouseenter", fnOver).on("mouseleave", fnOut || fnOver);
        }
      });
      jQuery2.each(
        "blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),
        function(_i2, name2) {
          jQuery2.fn[name2] = function(data2, fn3) {
            return arguments.length > 0 ? this.on(name2, null, data2, fn3) : this.trigger(name2);
          };
        }
      );
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery2.proxy = function(fn3, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn3[context];
          context = fn3;
          fn3 = tmp;
        }
        if (!isFunction2(fn3)) {
          return void 0;
        }
        args = slice.call(arguments, 2);
        proxy = function() {
          return fn3.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn3.guid = fn3.guid || jQuery2.guid++;
        return proxy;
      };
      jQuery2.holdReady = function(hold) {
        if (hold) {
          jQuery2.readyWait++;
        } else {
          jQuery2.ready(true);
        }
      };
      jQuery2.isArray = Array.isArray;
      jQuery2.parseJSON = JSON.parse;
      jQuery2.nodeName = nodeName;
      jQuery2.isFunction = isFunction2;
      jQuery2.isWindow = isWindow;
      jQuery2.camelCase = camelCase;
      jQuery2.type = toType2;
      jQuery2.now = Date.now;
      jQuery2.isNumeric = function(obj) {
        var type = jQuery2.type(obj);
        return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
        // subtraction forces infinities to NaN
        !isNaN(obj - parseFloat(obj));
      };
      jQuery2.trim = function(text2) {
        return text2 == null ? "" : (text2 + "").replace(rtrim, "$1");
      };
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery2.noConflict = function(deep) {
        if (window2.$ === jQuery2) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery2) {
          window2.jQuery = _jQuery;
        }
        return jQuery2;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery2;
      }
      return jQuery2;
    });
  })(jquery);
  return jquery.exports;
}
var jqueryExports = requireJquery();
const jQuery$1 = /* @__PURE__ */ getDefaultExportFromCjs(jqueryExports);
var select2$1 = { exports: {} };
/*!
 * Select2 4.0.13
 * https://select2.github.io
 *
 * Released under the MIT license
 * https://github.com/select2/select2/blob/master/LICENSE.md
 */
(function(module) {
  (function(factory) {
    if (module.exports) {
      module.exports = function(root2, jQuery2) {
        if (jQuery2 === void 0) {
          if (typeof window !== "undefined") {
            jQuery2 = requireJquery();
          } else {
            jQuery2 = requireJquery()(root2);
          }
        }
        factory(jQuery2);
        return jQuery2;
      };
    } else {
      factory(jQuery);
    }
  })(function(jQuery2) {
    var S2 = function() {
      if (jQuery2 && jQuery2.fn && jQuery2.fn.select2 && jQuery2.fn.select2.amd) {
        var S22 = jQuery2.fn.select2.amd;
      }
      var S22;
      (function() {
        if (!S22 || !S22.requirejs) {
          if (!S22) {
            S22 = {};
          } else {
            require2 = S22;
          }
          /**
           * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
           * Released under MIT license, http://github.com/requirejs/almond/LICENSE
           */
          var requirejs, require2, define;
          (function(undef) {
            var main2, req, makeMap, handlers, defined = {}, waiting = {}, config2 = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
            function hasProp(obj, prop) {
              return hasOwn.call(obj, prop);
            }
            function normalize2(name2, baseName) {
              var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j2, part, normalizedBaseParts, baseParts = baseName && baseName.split("/"), map2 = config2.map, starMap = map2 && map2["*"] || {};
              if (name2) {
                name2 = name2.split("/");
                lastIndex = name2.length - 1;
                if (config2.nodeIdCompat && jsSuffixRegExp.test(name2[lastIndex])) {
                  name2[lastIndex] = name2[lastIndex].replace(jsSuffixRegExp, "");
                }
                if (name2[0].charAt(0) === "." && baseParts) {
                  normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                  name2 = normalizedBaseParts.concat(name2);
                }
                for (i = 0; i < name2.length; i++) {
                  part = name2[i];
                  if (part === ".") {
                    name2.splice(i, 1);
                    i -= 1;
                  } else if (part === "..") {
                    if (i === 0 || i === 1 && name2[2] === ".." || name2[i - 1] === "..") {
                      continue;
                    } else if (i > 0) {
                      name2.splice(i - 1, 2);
                      i -= 2;
                    }
                  }
                }
                name2 = name2.join("/");
              }
              if ((baseParts || starMap) && map2) {
                nameParts = name2.split("/");
                for (i = nameParts.length; i > 0; i -= 1) {
                  nameSegment = nameParts.slice(0, i).join("/");
                  if (baseParts) {
                    for (j2 = baseParts.length; j2 > 0; j2 -= 1) {
                      mapValue = map2[baseParts.slice(0, j2).join("/")];
                      if (mapValue) {
                        mapValue = mapValue[nameSegment];
                        if (mapValue) {
                          foundMap = mapValue;
                          foundI = i;
                          break;
                        }
                      }
                    }
                  }
                  if (foundMap) {
                    break;
                  }
                  if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                  }
                }
                if (!foundMap && foundStarMap) {
                  foundMap = foundStarMap;
                  foundI = starI;
                }
                if (foundMap) {
                  nameParts.splice(0, foundI, foundMap);
                  name2 = nameParts.join("/");
                }
              }
              return name2;
            }
            function makeRequire(relName, forceSync) {
              return function() {
                var args = aps.call(arguments, 0);
                if (typeof args[0] !== "string" && args.length === 1) {
                  args.push(null);
                }
                return req.apply(undef, args.concat([relName, forceSync]));
              };
            }
            function makeNormalize(relName) {
              return function(name2) {
                return normalize2(name2, relName);
              };
            }
            function makeLoad(depName) {
              return function(value) {
                defined[depName] = value;
              };
            }
            function callDep(name2) {
              if (hasProp(waiting, name2)) {
                var args = waiting[name2];
                delete waiting[name2];
                defining[name2] = true;
                main2.apply(undef, args);
              }
              if (!hasProp(defined, name2) && !hasProp(defining, name2)) {
                throw new Error("No " + name2);
              }
              return defined[name2];
            }
            function splitPrefix(name2) {
              var prefix, index = name2 ? name2.indexOf("!") : -1;
              if (index > -1) {
                prefix = name2.substring(0, index);
                name2 = name2.substring(index + 1, name2.length);
              }
              return [prefix, name2];
            }
            function makeRelParts(relName) {
              return relName ? splitPrefix(relName) : [];
            }
            makeMap = function(name2, relParts) {
              var plugin2, parts = splitPrefix(name2), prefix = parts[0], relResourceName = relParts[1];
              name2 = parts[1];
              if (prefix) {
                prefix = normalize2(prefix, relResourceName);
                plugin2 = callDep(prefix);
              }
              if (prefix) {
                if (plugin2 && plugin2.normalize) {
                  name2 = plugin2.normalize(name2, makeNormalize(relResourceName));
                } else {
                  name2 = normalize2(name2, relResourceName);
                }
              } else {
                name2 = normalize2(name2, relResourceName);
                parts = splitPrefix(name2);
                prefix = parts[0];
                name2 = parts[1];
                if (prefix) {
                  plugin2 = callDep(prefix);
                }
              }
              return {
                f: prefix ? prefix + "!" + name2 : name2,
                //fullName
                n: name2,
                pr: prefix,
                p: plugin2
              };
            };
            function makeConfig(name2) {
              return function() {
                return config2 && config2.config && config2.config[name2] || {};
              };
            }
            handlers = {
              require: function(name2) {
                return makeRequire(name2);
              },
              exports: function(name2) {
                var e2 = defined[name2];
                if (typeof e2 !== "undefined") {
                  return e2;
                } else {
                  return defined[name2] = {};
                }
              },
              module: function(name2) {
                return {
                  id: name2,
                  uri: "",
                  exports: defined[name2],
                  config: makeConfig(name2)
                };
              }
            };
            main2 = function(name2, deps, callback, relName) {
              var cjsModule, depName, ret, map2, i, relParts, args = [], callbackType = typeof callback, usingExports;
              relName = relName || name2;
              relParts = makeRelParts(relName);
              if (callbackType === "undefined" || callbackType === "function") {
                deps = !deps.length && callback.length ? ["require", "exports", "module"] : deps;
                for (i = 0; i < deps.length; i += 1) {
                  map2 = makeMap(deps[i], relParts);
                  depName = map2.f;
                  if (depName === "require") {
                    args[i] = handlers.require(name2);
                  } else if (depName === "exports") {
                    args[i] = handlers.exports(name2);
                    usingExports = true;
                  } else if (depName === "module") {
                    cjsModule = args[i] = handlers.module(name2);
                  } else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                  } else if (map2.p) {
                    map2.p.load(map2.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                  } else {
                    throw new Error(name2 + " missing " + depName);
                  }
                }
                ret = callback ? callback.apply(defined[name2], args) : void 0;
                if (name2) {
                  if (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name2]) {
                    defined[name2] = cjsModule.exports;
                  } else if (ret !== undef || !usingExports) {
                    defined[name2] = ret;
                  }
                }
              } else if (name2) {
                defined[name2] = callback;
              }
            };
            requirejs = require2 = req = function(deps, callback, relName, forceSync, alt) {
              if (typeof deps === "string") {
                if (handlers[deps]) {
                  return handlers[deps](callback);
                }
                return callDep(makeMap(deps, makeRelParts(callback)).f);
              } else if (!deps.splice) {
                config2 = deps;
                if (config2.deps) {
                  req(config2.deps, config2.callback);
                }
                if (!callback) {
                  return;
                }
                if (callback.splice) {
                  deps = callback;
                  callback = relName;
                  relName = null;
                } else {
                  deps = undef;
                }
              }
              callback = callback || function() {
              };
              if (typeof relName === "function") {
                relName = forceSync;
                forceSync = alt;
              }
              if (forceSync) {
                main2(undef, deps, callback, relName);
              } else {
                setTimeout(function() {
                  main2(undef, deps, callback, relName);
                }, 4);
              }
              return req;
            };
            req.config = function(cfg) {
              return req(cfg);
            };
            requirejs._defined = defined;
            define = function(name2, deps, callback) {
              if (typeof name2 !== "string") {
                throw new Error("See almond README: incorrect module build, no module name");
              }
              if (!deps.splice) {
                callback = deps;
                deps = [];
              }
              if (!hasProp(defined, name2) && !hasProp(waiting, name2)) {
                waiting[name2] = [name2, deps, callback];
              }
            };
            define.amd = {
              jQuery: true
            };
          })();
          S22.requirejs = requirejs;
          S22.require = require2;
          S22.define = define;
        }
      })();
      S22.define("almond", function() {
      });
      S22.define("jquery", [], function() {
        var _$ = jQuery2 || $;
        if (_$ == null && console && console.error) {
          console.error(
            "Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."
          );
        }
        return _$;
      });
      S22.define("select2/utils", [
        "jquery"
      ], function($2) {
        var Utils = {};
        Utils.Extend = function(ChildClass, SuperClass) {
          var __hasProp = {}.hasOwnProperty;
          function BaseConstructor() {
            this.constructor = ChildClass;
          }
          for (var key in SuperClass) {
            if (__hasProp.call(SuperClass, key)) {
              ChildClass[key] = SuperClass[key];
            }
          }
          BaseConstructor.prototype = SuperClass.prototype;
          ChildClass.prototype = new BaseConstructor();
          ChildClass.__super__ = SuperClass.prototype;
          return ChildClass;
        };
        function getMethods(theClass) {
          var proto = theClass.prototype;
          var methods2 = [];
          for (var methodName in proto) {
            var m2 = proto[methodName];
            if (typeof m2 !== "function") {
              continue;
            }
            if (methodName === "constructor") {
              continue;
            }
            methods2.push(methodName);
          }
          return methods2;
        }
        Utils.Decorate = function(SuperClass, DecoratorClass) {
          var decoratedMethods = getMethods(DecoratorClass);
          var superMethods = getMethods(SuperClass);
          function DecoratedClass() {
            var unshift = Array.prototype.unshift;
            var argCount = DecoratorClass.prototype.constructor.length;
            var calledConstructor = SuperClass.prototype.constructor;
            if (argCount > 0) {
              unshift.call(arguments, SuperClass.prototype.constructor);
              calledConstructor = DecoratorClass.prototype.constructor;
            }
            calledConstructor.apply(this, arguments);
          }
          DecoratorClass.displayName = SuperClass.displayName;
          function ctr() {
            this.constructor = DecoratedClass;
          }
          DecoratedClass.prototype = new ctr();
          for (var m2 = 0; m2 < superMethods.length; m2++) {
            var superMethod = superMethods[m2];
            DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
          }
          var calledMethod = function(methodName) {
            var originalMethod = function() {
            };
            if (methodName in DecoratedClass.prototype) {
              originalMethod = DecoratedClass.prototype[methodName];
            }
            var decoratedMethod2 = DecoratorClass.prototype[methodName];
            return function() {
              var unshift = Array.prototype.unshift;
              unshift.call(arguments, originalMethod);
              return decoratedMethod2.apply(this, arguments);
            };
          };
          for (var d2 = 0; d2 < decoratedMethods.length; d2++) {
            var decoratedMethod = decoratedMethods[d2];
            DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
          }
          return DecoratedClass;
        };
        var Observable = function() {
          this.listeners = {};
        };
        Observable.prototype.on = function(event, callback) {
          this.listeners = this.listeners || {};
          if (event in this.listeners) {
            this.listeners[event].push(callback);
          } else {
            this.listeners[event] = [callback];
          }
        };
        Observable.prototype.trigger = function(event) {
          var slice = Array.prototype.slice;
          var params = slice.call(arguments, 1);
          this.listeners = this.listeners || {};
          if (params == null) {
            params = [];
          }
          if (params.length === 0) {
            params.push({});
          }
          params[0]._type = event;
          if (event in this.listeners) {
            this.invoke(this.listeners[event], slice.call(arguments, 1));
          }
          if ("*" in this.listeners) {
            this.invoke(this.listeners["*"], arguments);
          }
        };
        Observable.prototype.invoke = function(listeners2, params) {
          for (var i = 0, len = listeners2.length; i < len; i++) {
            listeners2[i].apply(this, params);
          }
        };
        Utils.Observable = Observable;
        Utils.generateChars = function(length) {
          var chars = "";
          for (var i = 0; i < length; i++) {
            var randomChar = Math.floor(Math.random() * 36);
            chars += randomChar.toString(36);
          }
          return chars;
        };
        Utils.bind = function(func, context) {
          return function() {
            func.apply(context, arguments);
          };
        };
        Utils._convertData = function(data2) {
          for (var originalKey in data2) {
            var keys = originalKey.split("-");
            var dataLevel = data2;
            if (keys.length === 1) {
              continue;
            }
            for (var k2 = 0; k2 < keys.length; k2++) {
              var key = keys[k2];
              key = key.substring(0, 1).toLowerCase() + key.substring(1);
              if (!(key in dataLevel)) {
                dataLevel[key] = {};
              }
              if (k2 == keys.length - 1) {
                dataLevel[key] = data2[originalKey];
              }
              dataLevel = dataLevel[key];
            }
            delete data2[originalKey];
          }
          return data2;
        };
        Utils.hasScroll = function(index, el) {
          var $el = $2(el);
          var overflowX = el.style.overflowX;
          var overflowY = el.style.overflowY;
          if (overflowX === overflowY && (overflowY === "hidden" || overflowY === "visible")) {
            return false;
          }
          if (overflowX === "scroll" || overflowY === "scroll") {
            return true;
          }
          return $el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth;
        };
        Utils.escapeMarkup = function(markup) {
          var replaceMap = {
            "\\": "&#92;",
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;",
            "/": "&#47;"
          };
          if (typeof markup !== "string") {
            return markup;
          }
          return String(markup).replace(/[&<>"'\/\\]/g, function(match) {
            return replaceMap[match];
          });
        };
        Utils.appendMany = function($element, $nodes) {
          if ($2.fn.jquery.substr(0, 3) === "1.7") {
            var $jqNodes = $2();
            $2.map($nodes, function(node) {
              $jqNodes = $jqNodes.add(node);
            });
            $nodes = $jqNodes;
          }
          $element.append($nodes);
        };
        Utils.__cache = {};
        var id = 0;
        Utils.GetUniqueElementId = function(element) {
          var select2Id = element.getAttribute("data-select2-id");
          if (select2Id == null) {
            if (element.id) {
              select2Id = element.id;
              element.setAttribute("data-select2-id", select2Id);
            } else {
              element.setAttribute("data-select2-id", ++id);
              select2Id = id.toString();
            }
          }
          return select2Id;
        };
        Utils.StoreData = function(element, name2, value) {
          var id2 = Utils.GetUniqueElementId(element);
          if (!Utils.__cache[id2]) {
            Utils.__cache[id2] = {};
          }
          Utils.__cache[id2][name2] = value;
        };
        Utils.GetData = function(element, name2) {
          var id2 = Utils.GetUniqueElementId(element);
          if (name2) {
            if (Utils.__cache[id2]) {
              if (Utils.__cache[id2][name2] != null) {
                return Utils.__cache[id2][name2];
              }
              return $2(element).data(name2);
            }
            return $2(element).data(name2);
          } else {
            return Utils.__cache[id2];
          }
        };
        Utils.RemoveData = function(element) {
          var id2 = Utils.GetUniqueElementId(element);
          if (Utils.__cache[id2] != null) {
            delete Utils.__cache[id2];
          }
          element.removeAttribute("data-select2-id");
        };
        return Utils;
      });
      S22.define("select2/results", [
        "jquery",
        "./utils"
      ], function($2, Utils) {
        function Results($element, options, dataAdapter) {
          this.$element = $element;
          this.data = dataAdapter;
          this.options = options;
          Results.__super__.constructor.call(this);
        }
        Utils.Extend(Results, Utils.Observable);
        Results.prototype.render = function() {
          var $results = $2(
            '<ul class="select2-results__options" role="listbox"></ul>'
          );
          if (this.options.get("multiple")) {
            $results.attr("aria-multiselectable", "true");
          }
          this.$results = $results;
          return $results;
        };
        Results.prototype.clear = function() {
          this.$results.empty();
        };
        Results.prototype.displayMessage = function(params) {
          var escapeMarkup = this.options.get("escapeMarkup");
          this.clear();
          this.hideLoading();
          var $message = $2(
            '<li role="alert" aria-live="assertive" class="select2-results__option"></li>'
          );
          var message = this.options.get("translations").get(params.message);
          $message.append(
            escapeMarkup(
              message(params.args)
            )
          );
          $message[0].className += " select2-results__message";
          this.$results.append($message);
        };
        Results.prototype.hideMessages = function() {
          this.$results.find(".select2-results__message").remove();
        };
        Results.prototype.append = function(data2) {
          this.hideLoading();
          var $options = [];
          if (data2.results == null || data2.results.length === 0) {
            if (this.$results.children().length === 0) {
              this.trigger("results:message", {
                message: "noResults"
              });
            }
            return;
          }
          data2.results = this.sort(data2.results);
          for (var d2 = 0; d2 < data2.results.length; d2++) {
            var item2 = data2.results[d2];
            var $option = this.option(item2);
            $options.push($option);
          }
          this.$results.append($options);
        };
        Results.prototype.position = function($results, $dropdown) {
          var $resultsContainer = $dropdown.find(".select2-results");
          $resultsContainer.append($results);
        };
        Results.prototype.sort = function(data2) {
          var sorter = this.options.get("sorter");
          return sorter(data2);
        };
        Results.prototype.highlightFirstItem = function() {
          var $options = this.$results.find(".select2-results__option[aria-selected]");
          var $selected = $options.filter("[aria-selected=true]");
          if ($selected.length > 0) {
            $selected.first().trigger("mouseenter");
          } else {
            $options.first().trigger("mouseenter");
          }
          this.ensureHighlightVisible();
        };
        Results.prototype.setClasses = function() {
          var self2 = this;
          this.data.current(function(selected) {
            var selectedIds = $2.map(selected, function(s2) {
              return s2.id.toString();
            });
            var $options = self2.$results.find(".select2-results__option[aria-selected]");
            $options.each(function() {
              var $option = $2(this);
              var item2 = Utils.GetData(this, "data");
              var id = "" + item2.id;
              if (item2.element != null && item2.element.selected || item2.element == null && $2.inArray(id, selectedIds) > -1) {
                $option.attr("aria-selected", "true");
              } else {
                $option.attr("aria-selected", "false");
              }
            });
          });
        };
        Results.prototype.showLoading = function(params) {
          this.hideLoading();
          var loadingMore = this.options.get("translations").get("searching");
          var loading = {
            disabled: true,
            loading: true,
            text: loadingMore(params)
          };
          var $loading = this.option(loading);
          $loading.className += " loading-results";
          this.$results.prepend($loading);
        };
        Results.prototype.hideLoading = function() {
          this.$results.find(".loading-results").remove();
        };
        Results.prototype.option = function(data2) {
          var option2 = document.createElement("li");
          option2.className = "select2-results__option";
          var attrs = {
            "role": "option",
            "aria-selected": "false"
          };
          var matches = window.Element.prototype.matches || window.Element.prototype.msMatchesSelector || window.Element.prototype.webkitMatchesSelector;
          if (data2.element != null && matches.call(data2.element, ":disabled") || data2.element == null && data2.disabled) {
            delete attrs["aria-selected"];
            attrs["aria-disabled"] = "true";
          }
          if (data2.id == null) {
            delete attrs["aria-selected"];
          }
          if (data2._resultId != null) {
            option2.id = data2._resultId;
          }
          if (data2.title) {
            option2.title = data2.title;
          }
          if (data2.children) {
            attrs.role = "group";
            attrs["aria-label"] = data2.text;
            delete attrs["aria-selected"];
          }
          for (var attr2 in attrs) {
            var val = attrs[attr2];
            option2.setAttribute(attr2, val);
          }
          if (data2.children) {
            var $option = $2(option2);
            var label = document.createElement("strong");
            label.className = "select2-results__group";
            $2(label);
            this.template(data2, label);
            var $children = [];
            for (var c2 = 0; c2 < data2.children.length; c2++) {
              var child = data2.children[c2];
              var $child = this.option(child);
              $children.push($child);
            }
            var $childrenContainer = $2("<ul></ul>", {
              "class": "select2-results__options select2-results__options--nested"
            });
            $childrenContainer.append($children);
            $option.append(label);
            $option.append($childrenContainer);
          } else {
            this.template(data2, option2);
          }
          Utils.StoreData(option2, "data", data2);
          return option2;
        };
        Results.prototype.bind = function(container, $container) {
          var self2 = this;
          var id = container.id + "-results";
          this.$results.attr("id", id);
          container.on("results:all", function(params) {
            self2.clear();
            self2.append(params.data);
            if (container.isOpen()) {
              self2.setClasses();
              self2.highlightFirstItem();
            }
          });
          container.on("results:append", function(params) {
            self2.append(params.data);
            if (container.isOpen()) {
              self2.setClasses();
            }
          });
          container.on("query", function(params) {
            self2.hideMessages();
            self2.showLoading(params);
          });
          container.on("select", function() {
            if (!container.isOpen()) {
              return;
            }
            self2.setClasses();
            if (self2.options.get("scrollAfterSelect")) {
              self2.highlightFirstItem();
            }
          });
          container.on("unselect", function() {
            if (!container.isOpen()) {
              return;
            }
            self2.setClasses();
            if (self2.options.get("scrollAfterSelect")) {
              self2.highlightFirstItem();
            }
          });
          container.on("open", function() {
            self2.$results.attr("aria-expanded", "true");
            self2.$results.attr("aria-hidden", "false");
            self2.setClasses();
            self2.ensureHighlightVisible();
          });
          container.on("close", function() {
            self2.$results.attr("aria-expanded", "false");
            self2.$results.attr("aria-hidden", "true");
            self2.$results.removeAttr("aria-activedescendant");
          });
          container.on("results:toggle", function() {
            var $highlighted = self2.getHighlightedResults();
            if ($highlighted.length === 0) {
              return;
            }
            $highlighted.trigger("mouseup");
          });
          container.on("results:select", function() {
            var $highlighted = self2.getHighlightedResults();
            if ($highlighted.length === 0) {
              return;
            }
            var data2 = Utils.GetData($highlighted[0], "data");
            if ($highlighted.attr("aria-selected") == "true") {
              self2.trigger("close", {});
            } else {
              self2.trigger("select", {
                data: data2
              });
            }
          });
          container.on("results:previous", function() {
            var $highlighted = self2.getHighlightedResults();
            var $options = self2.$results.find("[aria-selected]");
            var currentIndex = $options.index($highlighted);
            if (currentIndex <= 0) {
              return;
            }
            var nextIndex = currentIndex - 1;
            if ($highlighted.length === 0) {
              nextIndex = 0;
            }
            var $next = $options.eq(nextIndex);
            $next.trigger("mouseenter");
            var currentOffset = self2.$results.offset().top;
            var nextTop = $next.offset().top;
            var nextOffset = self2.$results.scrollTop() + (nextTop - currentOffset);
            if (nextIndex === 0) {
              self2.$results.scrollTop(0);
            } else if (nextTop - currentOffset < 0) {
              self2.$results.scrollTop(nextOffset);
            }
          });
          container.on("results:next", function() {
            var $highlighted = self2.getHighlightedResults();
            var $options = self2.$results.find("[aria-selected]");
            var currentIndex = $options.index($highlighted);
            var nextIndex = currentIndex + 1;
            if (nextIndex >= $options.length) {
              return;
            }
            var $next = $options.eq(nextIndex);
            $next.trigger("mouseenter");
            var currentOffset = self2.$results.offset().top + self2.$results.outerHeight(false);
            var nextBottom = $next.offset().top + $next.outerHeight(false);
            var nextOffset = self2.$results.scrollTop() + nextBottom - currentOffset;
            if (nextIndex === 0) {
              self2.$results.scrollTop(0);
            } else if (nextBottom > currentOffset) {
              self2.$results.scrollTop(nextOffset);
            }
          });
          container.on("results:focus", function(params) {
            params.element.addClass("select2-results__option--highlighted");
          });
          container.on("results:message", function(params) {
            self2.displayMessage(params);
          });
          if ($2.fn.mousewheel) {
            this.$results.on("mousewheel", function(e2) {
              var top2 = self2.$results.scrollTop();
              var bottom2 = self2.$results.get(0).scrollHeight - top2 + e2.deltaY;
              var isAtTop = e2.deltaY > 0 && top2 - e2.deltaY <= 0;
              var isAtBottom = e2.deltaY < 0 && bottom2 <= self2.$results.height();
              if (isAtTop) {
                self2.$results.scrollTop(0);
                e2.preventDefault();
                e2.stopPropagation();
              } else if (isAtBottom) {
                self2.$results.scrollTop(
                  self2.$results.get(0).scrollHeight - self2.$results.height()
                );
                e2.preventDefault();
                e2.stopPropagation();
              }
            });
          }
          this.$results.on(
            "mouseup",
            ".select2-results__option[aria-selected]",
            function(evt) {
              var $this = $2(this);
              var data2 = Utils.GetData(this, "data");
              if ($this.attr("aria-selected") === "true") {
                if (self2.options.get("multiple")) {
                  self2.trigger("unselect", {
                    originalEvent: evt,
                    data: data2
                  });
                } else {
                  self2.trigger("close", {});
                }
                return;
              }
              self2.trigger("select", {
                originalEvent: evt,
                data: data2
              });
            }
          );
          this.$results.on(
            "mouseenter",
            ".select2-results__option[aria-selected]",
            function(evt) {
              var data2 = Utils.GetData(this, "data");
              self2.getHighlightedResults().removeClass("select2-results__option--highlighted");
              self2.trigger("results:focus", {
                data: data2,
                element: $2(this)
              });
            }
          );
        };
        Results.prototype.getHighlightedResults = function() {
          var $highlighted = this.$results.find(".select2-results__option--highlighted");
          return $highlighted;
        };
        Results.prototype.destroy = function() {
          this.$results.remove();
        };
        Results.prototype.ensureHighlightVisible = function() {
          var $highlighted = this.getHighlightedResults();
          if ($highlighted.length === 0) {
            return;
          }
          var $options = this.$results.find("[aria-selected]");
          var currentIndex = $options.index($highlighted);
          var currentOffset = this.$results.offset().top;
          var nextTop = $highlighted.offset().top;
          var nextOffset = this.$results.scrollTop() + (nextTop - currentOffset);
          var offsetDelta = nextTop - currentOffset;
          nextOffset -= $highlighted.outerHeight(false) * 2;
          if (currentIndex <= 2) {
            this.$results.scrollTop(0);
          } else if (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) {
            this.$results.scrollTop(nextOffset);
          }
        };
        Results.prototype.template = function(result, container) {
          var template = this.options.get("templateResult");
          var escapeMarkup = this.options.get("escapeMarkup");
          var content = template(result, container);
          if (content == null) {
            container.style.display = "none";
          } else if (typeof content === "string") {
            container.innerHTML = escapeMarkup(content);
          } else {
            $2(container).append(content);
          }
        };
        return Results;
      });
      S22.define("select2/keys", [], function() {
        var KEYS = {
          BACKSPACE: 8,
          TAB: 9,
          ENTER: 13,
          SHIFT: 16,
          CTRL: 17,
          ALT: 18,
          ESC: 27,
          SPACE: 32,
          PAGE_UP: 33,
          PAGE_DOWN: 34,
          END: 35,
          HOME: 36,
          LEFT: 37,
          UP: 38,
          RIGHT: 39,
          DOWN: 40,
          DELETE: 46
        };
        return KEYS;
      });
      S22.define("select2/selection/base", [
        "jquery",
        "../utils",
        "../keys"
      ], function($2, Utils, KEYS) {
        function BaseSelection($element, options) {
          this.$element = $element;
          this.options = options;
          BaseSelection.__super__.constructor.call(this);
        }
        Utils.Extend(BaseSelection, Utils.Observable);
        BaseSelection.prototype.render = function() {
          var $selection = $2(
            '<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>'
          );
          this._tabindex = 0;
          if (Utils.GetData(this.$element[0], "old-tabindex") != null) {
            this._tabindex = Utils.GetData(this.$element[0], "old-tabindex");
          } else if (this.$element.attr("tabindex") != null) {
            this._tabindex = this.$element.attr("tabindex");
          }
          $selection.attr("title", this.$element.attr("title"));
          $selection.attr("tabindex", this._tabindex);
          $selection.attr("aria-disabled", "false");
          this.$selection = $selection;
          return $selection;
        };
        BaseSelection.prototype.bind = function(container, $container) {
          var self2 = this;
          var resultsId = container.id + "-results";
          this.container = container;
          this.$selection.on("focus", function(evt) {
            self2.trigger("focus", evt);
          });
          this.$selection.on("blur", function(evt) {
            self2._handleBlur(evt);
          });
          this.$selection.on("keydown", function(evt) {
            self2.trigger("keypress", evt);
            if (evt.which === KEYS.SPACE) {
              evt.preventDefault();
            }
          });
          container.on("results:focus", function(params) {
            self2.$selection.attr("aria-activedescendant", params.data._resultId);
          });
          container.on("selection:update", function(params) {
            self2.update(params.data);
          });
          container.on("open", function() {
            self2.$selection.attr("aria-expanded", "true");
            self2.$selection.attr("aria-owns", resultsId);
            self2._attachCloseHandler(container);
          });
          container.on("close", function() {
            self2.$selection.attr("aria-expanded", "false");
            self2.$selection.removeAttr("aria-activedescendant");
            self2.$selection.removeAttr("aria-owns");
            self2.$selection.trigger("focus");
            self2._detachCloseHandler(container);
          });
          container.on("enable", function() {
            self2.$selection.attr("tabindex", self2._tabindex);
            self2.$selection.attr("aria-disabled", "false");
          });
          container.on("disable", function() {
            self2.$selection.attr("tabindex", "-1");
            self2.$selection.attr("aria-disabled", "true");
          });
        };
        BaseSelection.prototype._handleBlur = function(evt) {
          var self2 = this;
          window.setTimeout(function() {
            if (document.activeElement == self2.$selection[0] || $2.contains(self2.$selection[0], document.activeElement)) {
              return;
            }
            self2.trigger("blur", evt);
          }, 1);
        };
        BaseSelection.prototype._attachCloseHandler = function(container) {
          $2(document.body).on("mousedown.select2." + container.id, function(e2) {
            var $target = $2(e2.target);
            var $select = $target.closest(".select2");
            var $all = $2(".select2.select2-container--open");
            $all.each(function() {
              if (this == $select[0]) {
                return;
              }
              var $element = Utils.GetData(this, "element");
              $element.select2("close");
            });
          });
        };
        BaseSelection.prototype._detachCloseHandler = function(container) {
          $2(document.body).off("mousedown.select2." + container.id);
        };
        BaseSelection.prototype.position = function($selection, $container) {
          var $selectionContainer = $container.find(".selection");
          $selectionContainer.append($selection);
        };
        BaseSelection.prototype.destroy = function() {
          this._detachCloseHandler(this.container);
        };
        BaseSelection.prototype.update = function(data2) {
          throw new Error("The `update` method must be defined in child classes.");
        };
        BaseSelection.prototype.isEnabled = function() {
          return !this.isDisabled();
        };
        BaseSelection.prototype.isDisabled = function() {
          return this.options.get("disabled");
        };
        return BaseSelection;
      });
      S22.define("select2/selection/single", [
        "jquery",
        "./base",
        "../utils",
        "../keys"
      ], function($2, BaseSelection, Utils, KEYS) {
        function SingleSelection() {
          SingleSelection.__super__.constructor.apply(this, arguments);
        }
        Utils.Extend(SingleSelection, BaseSelection);
        SingleSelection.prototype.render = function() {
          var $selection = SingleSelection.__super__.render.call(this);
          $selection.addClass("select2-selection--single");
          $selection.html(
            '<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'
          );
          return $selection;
        };
        SingleSelection.prototype.bind = function(container, $container) {
          var self2 = this;
          SingleSelection.__super__.bind.apply(this, arguments);
          var id = container.id + "-container";
          this.$selection.find(".select2-selection__rendered").attr("id", id).attr("role", "textbox").attr("aria-readonly", "true");
          this.$selection.attr("aria-labelledby", id);
          this.$selection.on("mousedown", function(evt) {
            if (evt.which !== 1) {
              return;
            }
            self2.trigger("toggle", {
              originalEvent: evt
            });
          });
          this.$selection.on("focus", function(evt) {
          });
          this.$selection.on("blur", function(evt) {
          });
          container.on("focus", function(evt) {
            if (!container.isOpen()) {
              self2.$selection.trigger("focus");
            }
          });
        };
        SingleSelection.prototype.clear = function() {
          var $rendered = this.$selection.find(".select2-selection__rendered");
          $rendered.empty();
          $rendered.removeAttr("title");
        };
        SingleSelection.prototype.display = function(data2, container) {
          var template = this.options.get("templateSelection");
          var escapeMarkup = this.options.get("escapeMarkup");
          return escapeMarkup(template(data2, container));
        };
        SingleSelection.prototype.selectionContainer = function() {
          return $2("<span></span>");
        };
        SingleSelection.prototype.update = function(data2) {
          if (data2.length === 0) {
            this.clear();
            return;
          }
          var selection = data2[0];
          var $rendered = this.$selection.find(".select2-selection__rendered");
          var formatted = this.display(selection, $rendered);
          $rendered.empty().append(formatted);
          var title = selection.title || selection.text;
          if (title) {
            $rendered.attr("title", title);
          } else {
            $rendered.removeAttr("title");
          }
        };
        return SingleSelection;
      });
      S22.define("select2/selection/multiple", [
        "jquery",
        "./base",
        "../utils"
      ], function($2, BaseSelection, Utils) {
        function MultipleSelection($element, options) {
          MultipleSelection.__super__.constructor.apply(this, arguments);
        }
        Utils.Extend(MultipleSelection, BaseSelection);
        MultipleSelection.prototype.render = function() {
          var $selection = MultipleSelection.__super__.render.call(this);
          $selection.addClass("select2-selection--multiple");
          $selection.html(
            '<ul class="select2-selection__rendered"></ul>'
          );
          return $selection;
        };
        MultipleSelection.prototype.bind = function(container, $container) {
          var self2 = this;
          MultipleSelection.__super__.bind.apply(this, arguments);
          this.$selection.on("click", function(evt) {
            self2.trigger("toggle", {
              originalEvent: evt
            });
          });
          this.$selection.on(
            "click",
            ".select2-selection__choice__remove",
            function(evt) {
              if (self2.isDisabled()) {
                return;
              }
              var $remove = $2(this);
              var $selection = $remove.parent();
              var data2 = Utils.GetData($selection[0], "data");
              self2.trigger("unselect", {
                originalEvent: evt,
                data: data2
              });
            }
          );
        };
        MultipleSelection.prototype.clear = function() {
          var $rendered = this.$selection.find(".select2-selection__rendered");
          $rendered.empty();
          $rendered.removeAttr("title");
        };
        MultipleSelection.prototype.display = function(data2, container) {
          var template = this.options.get("templateSelection");
          var escapeMarkup = this.options.get("escapeMarkup");
          return escapeMarkup(template(data2, container));
        };
        MultipleSelection.prototype.selectionContainer = function() {
          var $container = $2(
            '<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>'
          );
          return $container;
        };
        MultipleSelection.prototype.update = function(data2) {
          this.clear();
          if (data2.length === 0) {
            return;
          }
          var $selections = [];
          for (var d2 = 0; d2 < data2.length; d2++) {
            var selection = data2[d2];
            var $selection = this.selectionContainer();
            var formatted = this.display(selection, $selection);
            $selection.append(formatted);
            var title = selection.title || selection.text;
            if (title) {
              $selection.attr("title", title);
            }
            Utils.StoreData($selection[0], "data", selection);
            $selections.push($selection);
          }
          var $rendered = this.$selection.find(".select2-selection__rendered");
          Utils.appendMany($rendered, $selections);
        };
        return MultipleSelection;
      });
      S22.define("select2/selection/placeholder", [
        "../utils"
      ], function(Utils) {
        function Placeholder(decorated, $element, options) {
          this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
          decorated.call(this, $element, options);
        }
        Placeholder.prototype.normalizePlaceholder = function(_2, placeholder) {
          if (typeof placeholder === "string") {
            placeholder = {
              id: "",
              text: placeholder
            };
          }
          return placeholder;
        };
        Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
          var $placeholder = this.selectionContainer();
          $placeholder.html(this.display(placeholder));
          $placeholder.addClass("select2-selection__placeholder").removeClass("select2-selection__choice");
          return $placeholder;
        };
        Placeholder.prototype.update = function(decorated, data2) {
          var singlePlaceholder = data2.length == 1 && data2[0].id != this.placeholder.id;
          var multipleSelections = data2.length > 1;
          if (multipleSelections || singlePlaceholder) {
            return decorated.call(this, data2);
          }
          this.clear();
          var $placeholder = this.createPlaceholder(this.placeholder);
          this.$selection.find(".select2-selection__rendered").append($placeholder);
        };
        return Placeholder;
      });
      S22.define("select2/selection/allowClear", [
        "jquery",
        "../keys",
        "../utils"
      ], function($2, KEYS, Utils) {
        function AllowClear() {
        }
        AllowClear.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          if (this.placeholder == null) {
            if (this.options.get("debug") && window.console && console.error) {
              console.error(
                "Select2: The `allowClear` option should be used in combination with the `placeholder` option."
              );
            }
          }
          this.$selection.on(
            "mousedown",
            ".select2-selection__clear",
            function(evt) {
              self2._handleClear(evt);
            }
          );
          container.on("keypress", function(evt) {
            self2._handleKeyboardClear(evt, container);
          });
        };
        AllowClear.prototype._handleClear = function(_2, evt) {
          if (this.isDisabled()) {
            return;
          }
          var $clear = this.$selection.find(".select2-selection__clear");
          if ($clear.length === 0) {
            return;
          }
          evt.stopPropagation();
          var data2 = Utils.GetData($clear[0], "data");
          var previousVal = this.$element.val();
          this.$element.val(this.placeholder.id);
          var unselectData = {
            data: data2
          };
          this.trigger("clear", unselectData);
          if (unselectData.prevented) {
            this.$element.val(previousVal);
            return;
          }
          for (var d2 = 0; d2 < data2.length; d2++) {
            unselectData = {
              data: data2[d2]
            };
            this.trigger("unselect", unselectData);
            if (unselectData.prevented) {
              this.$element.val(previousVal);
              return;
            }
          }
          this.$element.trigger("input").trigger("change");
          this.trigger("toggle", {});
        };
        AllowClear.prototype._handleKeyboardClear = function(_2, evt, container) {
          if (container.isOpen()) {
            return;
          }
          if (evt.which == KEYS.DELETE || evt.which == KEYS.BACKSPACE) {
            this._handleClear(evt);
          }
        };
        AllowClear.prototype.update = function(decorated, data2) {
          decorated.call(this, data2);
          if (this.$selection.find(".select2-selection__placeholder").length > 0 || data2.length === 0) {
            return;
          }
          var removeAll = this.options.get("translations").get("removeAllItems");
          var $remove = $2(
            '<span class="select2-selection__clear" title="' + removeAll() + '">&times;</span>'
          );
          Utils.StoreData($remove[0], "data", data2);
          this.$selection.find(".select2-selection__rendered").prepend($remove);
        };
        return AllowClear;
      });
      S22.define("select2/selection/search", [
        "jquery",
        "../utils",
        "../keys"
      ], function($2, Utils, KEYS) {
        function Search(decorated, $element, options) {
          decorated.call(this, $element, options);
        }
        Search.prototype.render = function(decorated) {
          var $search = $2(
            '<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></li>'
          );
          this.$searchContainer = $search;
          this.$search = $search.find("input");
          var $rendered = decorated.call(this);
          this._transferTabIndex();
          return $rendered;
        };
        Search.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          var resultsId = container.id + "-results";
          decorated.call(this, container, $container);
          container.on("open", function() {
            self2.$search.attr("aria-controls", resultsId);
            self2.$search.trigger("focus");
          });
          container.on("close", function() {
            self2.$search.val("");
            self2.$search.removeAttr("aria-controls");
            self2.$search.removeAttr("aria-activedescendant");
            self2.$search.trigger("focus");
          });
          container.on("enable", function() {
            self2.$search.prop("disabled", false);
            self2._transferTabIndex();
          });
          container.on("disable", function() {
            self2.$search.prop("disabled", true);
          });
          container.on("focus", function(evt) {
            self2.$search.trigger("focus");
          });
          container.on("results:focus", function(params) {
            if (params.data._resultId) {
              self2.$search.attr("aria-activedescendant", params.data._resultId);
            } else {
              self2.$search.removeAttr("aria-activedescendant");
            }
          });
          this.$selection.on("focusin", ".select2-search--inline", function(evt) {
            self2.trigger("focus", evt);
          });
          this.$selection.on("focusout", ".select2-search--inline", function(evt) {
            self2._handleBlur(evt);
          });
          this.$selection.on("keydown", ".select2-search--inline", function(evt) {
            evt.stopPropagation();
            self2.trigger("keypress", evt);
            self2._keyUpPrevented = evt.isDefaultPrevented();
            var key = evt.which;
            if (key === KEYS.BACKSPACE && self2.$search.val() === "") {
              var $previousChoice = self2.$searchContainer.prev(".select2-selection__choice");
              if ($previousChoice.length > 0) {
                var item2 = Utils.GetData($previousChoice[0], "data");
                self2.searchRemoveChoice(item2);
                evt.preventDefault();
              }
            }
          });
          this.$selection.on("click", ".select2-search--inline", function(evt) {
            if (self2.$search.val()) {
              evt.stopPropagation();
            }
          });
          var msie = document.documentMode;
          var disableInputEvents = msie && msie <= 11;
          this.$selection.on(
            "input.searchcheck",
            ".select2-search--inline",
            function(evt) {
              if (disableInputEvents) {
                self2.$selection.off("input.search input.searchcheck");
                return;
              }
              self2.$selection.off("keyup.search");
            }
          );
          this.$selection.on(
            "keyup.search input.search",
            ".select2-search--inline",
            function(evt) {
              if (disableInputEvents && evt.type === "input") {
                self2.$selection.off("input.search input.searchcheck");
                return;
              }
              var key = evt.which;
              if (key == KEYS.SHIFT || key == KEYS.CTRL || key == KEYS.ALT) {
                return;
              }
              if (key == KEYS.TAB) {
                return;
              }
              self2.handleSearch(evt);
            }
          );
        };
        Search.prototype._transferTabIndex = function(decorated) {
          this.$search.attr("tabindex", this.$selection.attr("tabindex"));
          this.$selection.attr("tabindex", "-1");
        };
        Search.prototype.createPlaceholder = function(decorated, placeholder) {
          this.$search.attr("placeholder", placeholder.text);
        };
        Search.prototype.update = function(decorated, data2) {
          var searchHadFocus = this.$search[0] == document.activeElement;
          this.$search.attr("placeholder", "");
          decorated.call(this, data2);
          this.$selection.find(".select2-selection__rendered").append(this.$searchContainer);
          this.resizeSearch();
          if (searchHadFocus) {
            this.$search.trigger("focus");
          }
        };
        Search.prototype.handleSearch = function() {
          this.resizeSearch();
          if (!this._keyUpPrevented) {
            var input = this.$search.val();
            this.trigger("query", {
              term: input
            });
          }
          this._keyUpPrevented = false;
        };
        Search.prototype.searchRemoveChoice = function(decorated, item2) {
          this.trigger("unselect", {
            data: item2
          });
          this.$search.val(item2.text);
          this.handleSearch();
        };
        Search.prototype.resizeSearch = function() {
          this.$search.css("width", "25px");
          var width = "";
          if (this.$search.attr("placeholder") !== "") {
            width = this.$selection.find(".select2-selection__rendered").width();
          } else {
            var minimumWidth = this.$search.val().length + 1;
            width = minimumWidth * 0.75 + "em";
          }
          this.$search.css("width", width);
        };
        return Search;
      });
      S22.define("select2/selection/eventRelay", [
        "jquery"
      ], function($2) {
        function EventRelay() {
        }
        EventRelay.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          var relayEvents = [
            "open",
            "opening",
            "close",
            "closing",
            "select",
            "selecting",
            "unselect",
            "unselecting",
            "clear",
            "clearing"
          ];
          var preventableEvents = [
            "opening",
            "closing",
            "selecting",
            "unselecting",
            "clearing"
          ];
          decorated.call(this, container, $container);
          container.on("*", function(name2, params) {
            if ($2.inArray(name2, relayEvents) === -1) {
              return;
            }
            params = params || {};
            var evt = $2.Event("select2:" + name2, {
              params
            });
            self2.$element.trigger(evt);
            if ($2.inArray(name2, preventableEvents) === -1) {
              return;
            }
            params.prevented = evt.isDefaultPrevented();
          });
        };
        return EventRelay;
      });
      S22.define("select2/translation", [
        "jquery",
        "require"
      ], function($2, require2) {
        function Translation(dict) {
          this.dict = dict || {};
        }
        Translation.prototype.all = function() {
          return this.dict;
        };
        Translation.prototype.get = function(key) {
          return this.dict[key];
        };
        Translation.prototype.extend = function(translation) {
          this.dict = $2.extend({}, translation.all(), this.dict);
        };
        Translation._cache = {};
        Translation.loadPath = function(path) {
          if (!(path in Translation._cache)) {
            var translations = require2(path);
            Translation._cache[path] = translations;
          }
          return new Translation(Translation._cache[path]);
        };
        return Translation;
      });
      S22.define("select2/diacritics", [], function() {
        var diacritics = {
          "Ⓐ": "A",
          "Ａ": "A",
          "À": "A",
          "Á": "A",
          "Â": "A",
          "Ầ": "A",
          "Ấ": "A",
          "Ẫ": "A",
          "Ẩ": "A",
          "Ã": "A",
          "Ā": "A",
          "Ă": "A",
          "Ằ": "A",
          "Ắ": "A",
          "Ẵ": "A",
          "Ẳ": "A",
          "Ȧ": "A",
          "Ǡ": "A",
          "Ä": "A",
          "Ǟ": "A",
          "Ả": "A",
          "Å": "A",
          "Ǻ": "A",
          "Ǎ": "A",
          "Ȁ": "A",
          "Ȃ": "A",
          "Ạ": "A",
          "Ậ": "A",
          "Ặ": "A",
          "Ḁ": "A",
          "Ą": "A",
          "Ⱥ": "A",
          "Ɐ": "A",
          "Ꜳ": "AA",
          "Æ": "AE",
          "Ǽ": "AE",
          "Ǣ": "AE",
          "Ꜵ": "AO",
          "Ꜷ": "AU",
          "Ꜹ": "AV",
          "Ꜻ": "AV",
          "Ꜽ": "AY",
          "Ⓑ": "B",
          "Ｂ": "B",
          "Ḃ": "B",
          "Ḅ": "B",
          "Ḇ": "B",
          "Ƀ": "B",
          "Ƃ": "B",
          "Ɓ": "B",
          "Ⓒ": "C",
          "Ｃ": "C",
          "Ć": "C",
          "Ĉ": "C",
          "Ċ": "C",
          "Č": "C",
          "Ç": "C",
          "Ḉ": "C",
          "Ƈ": "C",
          "Ȼ": "C",
          "Ꜿ": "C",
          "Ⓓ": "D",
          "Ｄ": "D",
          "Ḋ": "D",
          "Ď": "D",
          "Ḍ": "D",
          "Ḑ": "D",
          "Ḓ": "D",
          "Ḏ": "D",
          "Đ": "D",
          "Ƌ": "D",
          "Ɗ": "D",
          "Ɖ": "D",
          "Ꝺ": "D",
          "Ǳ": "DZ",
          "Ǆ": "DZ",
          "ǲ": "Dz",
          "ǅ": "Dz",
          "Ⓔ": "E",
          "Ｅ": "E",
          "È": "E",
          "É": "E",
          "Ê": "E",
          "Ề": "E",
          "Ế": "E",
          "Ễ": "E",
          "Ể": "E",
          "Ẽ": "E",
          "Ē": "E",
          "Ḕ": "E",
          "Ḗ": "E",
          "Ĕ": "E",
          "Ė": "E",
          "Ë": "E",
          "Ẻ": "E",
          "Ě": "E",
          "Ȅ": "E",
          "Ȇ": "E",
          "Ẹ": "E",
          "Ệ": "E",
          "Ȩ": "E",
          "Ḝ": "E",
          "Ę": "E",
          "Ḙ": "E",
          "Ḛ": "E",
          "Ɛ": "E",
          "Ǝ": "E",
          "Ⓕ": "F",
          "Ｆ": "F",
          "Ḟ": "F",
          "Ƒ": "F",
          "Ꝼ": "F",
          "Ⓖ": "G",
          "Ｇ": "G",
          "Ǵ": "G",
          "Ĝ": "G",
          "Ḡ": "G",
          "Ğ": "G",
          "Ġ": "G",
          "Ǧ": "G",
          "Ģ": "G",
          "Ǥ": "G",
          "Ɠ": "G",
          "Ꞡ": "G",
          "Ᵹ": "G",
          "Ꝿ": "G",
          "Ⓗ": "H",
          "Ｈ": "H",
          "Ĥ": "H",
          "Ḣ": "H",
          "Ḧ": "H",
          "Ȟ": "H",
          "Ḥ": "H",
          "Ḩ": "H",
          "Ḫ": "H",
          "Ħ": "H",
          "Ⱨ": "H",
          "Ⱶ": "H",
          "Ɥ": "H",
          "Ⓘ": "I",
          "Ｉ": "I",
          "Ì": "I",
          "Í": "I",
          "Î": "I",
          "Ĩ": "I",
          "Ī": "I",
          "Ĭ": "I",
          "İ": "I",
          "Ï": "I",
          "Ḯ": "I",
          "Ỉ": "I",
          "Ǐ": "I",
          "Ȉ": "I",
          "Ȋ": "I",
          "Ị": "I",
          "Į": "I",
          "Ḭ": "I",
          "Ɨ": "I",
          "Ⓙ": "J",
          "Ｊ": "J",
          "Ĵ": "J",
          "Ɉ": "J",
          "Ⓚ": "K",
          "Ｋ": "K",
          "Ḱ": "K",
          "Ǩ": "K",
          "Ḳ": "K",
          "Ķ": "K",
          "Ḵ": "K",
          "Ƙ": "K",
          "Ⱪ": "K",
          "Ꝁ": "K",
          "Ꝃ": "K",
          "Ꝅ": "K",
          "Ꞣ": "K",
          "Ⓛ": "L",
          "Ｌ": "L",
          "Ŀ": "L",
          "Ĺ": "L",
          "Ľ": "L",
          "Ḷ": "L",
          "Ḹ": "L",
          "Ļ": "L",
          "Ḽ": "L",
          "Ḻ": "L",
          "Ł": "L",
          "Ƚ": "L",
          "Ɫ": "L",
          "Ⱡ": "L",
          "Ꝉ": "L",
          "Ꝇ": "L",
          "Ꞁ": "L",
          "Ǉ": "LJ",
          "ǈ": "Lj",
          "Ⓜ": "M",
          "Ｍ": "M",
          "Ḿ": "M",
          "Ṁ": "M",
          "Ṃ": "M",
          "Ɱ": "M",
          "Ɯ": "M",
          "Ⓝ": "N",
          "Ｎ": "N",
          "Ǹ": "N",
          "Ń": "N",
          "Ñ": "N",
          "Ṅ": "N",
          "Ň": "N",
          "Ṇ": "N",
          "Ņ": "N",
          "Ṋ": "N",
          "Ṉ": "N",
          "Ƞ": "N",
          "Ɲ": "N",
          "Ꞑ": "N",
          "Ꞥ": "N",
          "Ǌ": "NJ",
          "ǋ": "Nj",
          "Ⓞ": "O",
          "Ｏ": "O",
          "Ò": "O",
          "Ó": "O",
          "Ô": "O",
          "Ồ": "O",
          "Ố": "O",
          "Ỗ": "O",
          "Ổ": "O",
          "Õ": "O",
          "Ṍ": "O",
          "Ȭ": "O",
          "Ṏ": "O",
          "Ō": "O",
          "Ṑ": "O",
          "Ṓ": "O",
          "Ŏ": "O",
          "Ȯ": "O",
          "Ȱ": "O",
          "Ö": "O",
          "Ȫ": "O",
          "Ỏ": "O",
          "Ő": "O",
          "Ǒ": "O",
          "Ȍ": "O",
          "Ȏ": "O",
          "Ơ": "O",
          "Ờ": "O",
          "Ớ": "O",
          "Ỡ": "O",
          "Ở": "O",
          "Ợ": "O",
          "Ọ": "O",
          "Ộ": "O",
          "Ǫ": "O",
          "Ǭ": "O",
          "Ø": "O",
          "Ǿ": "O",
          "Ɔ": "O",
          "Ɵ": "O",
          "Ꝋ": "O",
          "Ꝍ": "O",
          "Œ": "OE",
          "Ƣ": "OI",
          "Ꝏ": "OO",
          "Ȣ": "OU",
          "Ⓟ": "P",
          "Ｐ": "P",
          "Ṕ": "P",
          "Ṗ": "P",
          "Ƥ": "P",
          "Ᵽ": "P",
          "Ꝑ": "P",
          "Ꝓ": "P",
          "Ꝕ": "P",
          "Ⓠ": "Q",
          "Ｑ": "Q",
          "Ꝗ": "Q",
          "Ꝙ": "Q",
          "Ɋ": "Q",
          "Ⓡ": "R",
          "Ｒ": "R",
          "Ŕ": "R",
          "Ṙ": "R",
          "Ř": "R",
          "Ȑ": "R",
          "Ȓ": "R",
          "Ṛ": "R",
          "Ṝ": "R",
          "Ŗ": "R",
          "Ṟ": "R",
          "Ɍ": "R",
          "Ɽ": "R",
          "Ꝛ": "R",
          "Ꞧ": "R",
          "Ꞃ": "R",
          "Ⓢ": "S",
          "Ｓ": "S",
          "ẞ": "S",
          "Ś": "S",
          "Ṥ": "S",
          "Ŝ": "S",
          "Ṡ": "S",
          "Š": "S",
          "Ṧ": "S",
          "Ṣ": "S",
          "Ṩ": "S",
          "Ș": "S",
          "Ş": "S",
          "Ȿ": "S",
          "Ꞩ": "S",
          "Ꞅ": "S",
          "Ⓣ": "T",
          "Ｔ": "T",
          "Ṫ": "T",
          "Ť": "T",
          "Ṭ": "T",
          "Ț": "T",
          "Ţ": "T",
          "Ṱ": "T",
          "Ṯ": "T",
          "Ŧ": "T",
          "Ƭ": "T",
          "Ʈ": "T",
          "Ⱦ": "T",
          "Ꞇ": "T",
          "Ꜩ": "TZ",
          "Ⓤ": "U",
          "Ｕ": "U",
          "Ù": "U",
          "Ú": "U",
          "Û": "U",
          "Ũ": "U",
          "Ṹ": "U",
          "Ū": "U",
          "Ṻ": "U",
          "Ŭ": "U",
          "Ü": "U",
          "Ǜ": "U",
          "Ǘ": "U",
          "Ǖ": "U",
          "Ǚ": "U",
          "Ủ": "U",
          "Ů": "U",
          "Ű": "U",
          "Ǔ": "U",
          "Ȕ": "U",
          "Ȗ": "U",
          "Ư": "U",
          "Ừ": "U",
          "Ứ": "U",
          "Ữ": "U",
          "Ử": "U",
          "Ự": "U",
          "Ụ": "U",
          "Ṳ": "U",
          "Ų": "U",
          "Ṷ": "U",
          "Ṵ": "U",
          "Ʉ": "U",
          "Ⓥ": "V",
          "Ｖ": "V",
          "Ṽ": "V",
          "Ṿ": "V",
          "Ʋ": "V",
          "Ꝟ": "V",
          "Ʌ": "V",
          "Ꝡ": "VY",
          "Ⓦ": "W",
          "Ｗ": "W",
          "Ẁ": "W",
          "Ẃ": "W",
          "Ŵ": "W",
          "Ẇ": "W",
          "Ẅ": "W",
          "Ẉ": "W",
          "Ⱳ": "W",
          "Ⓧ": "X",
          "Ｘ": "X",
          "Ẋ": "X",
          "Ẍ": "X",
          "Ⓨ": "Y",
          "Ｙ": "Y",
          "Ỳ": "Y",
          "Ý": "Y",
          "Ŷ": "Y",
          "Ỹ": "Y",
          "Ȳ": "Y",
          "Ẏ": "Y",
          "Ÿ": "Y",
          "Ỷ": "Y",
          "Ỵ": "Y",
          "Ƴ": "Y",
          "Ɏ": "Y",
          "Ỿ": "Y",
          "Ⓩ": "Z",
          "Ｚ": "Z",
          "Ź": "Z",
          "Ẑ": "Z",
          "Ż": "Z",
          "Ž": "Z",
          "Ẓ": "Z",
          "Ẕ": "Z",
          "Ƶ": "Z",
          "Ȥ": "Z",
          "Ɀ": "Z",
          "Ⱬ": "Z",
          "Ꝣ": "Z",
          "ⓐ": "a",
          "ａ": "a",
          "ẚ": "a",
          "à": "a",
          "á": "a",
          "â": "a",
          "ầ": "a",
          "ấ": "a",
          "ẫ": "a",
          "ẩ": "a",
          "ã": "a",
          "ā": "a",
          "ă": "a",
          "ằ": "a",
          "ắ": "a",
          "ẵ": "a",
          "ẳ": "a",
          "ȧ": "a",
          "ǡ": "a",
          "ä": "a",
          "ǟ": "a",
          "ả": "a",
          "å": "a",
          "ǻ": "a",
          "ǎ": "a",
          "ȁ": "a",
          "ȃ": "a",
          "ạ": "a",
          "ậ": "a",
          "ặ": "a",
          "ḁ": "a",
          "ą": "a",
          "ⱥ": "a",
          "ɐ": "a",
          "ꜳ": "aa",
          "æ": "ae",
          "ǽ": "ae",
          "ǣ": "ae",
          "ꜵ": "ao",
          "ꜷ": "au",
          "ꜹ": "av",
          "ꜻ": "av",
          "ꜽ": "ay",
          "ⓑ": "b",
          "ｂ": "b",
          "ḃ": "b",
          "ḅ": "b",
          "ḇ": "b",
          "ƀ": "b",
          "ƃ": "b",
          "ɓ": "b",
          "ⓒ": "c",
          "ｃ": "c",
          "ć": "c",
          "ĉ": "c",
          "ċ": "c",
          "č": "c",
          "ç": "c",
          "ḉ": "c",
          "ƈ": "c",
          "ȼ": "c",
          "ꜿ": "c",
          "ↄ": "c",
          "ⓓ": "d",
          "ｄ": "d",
          "ḋ": "d",
          "ď": "d",
          "ḍ": "d",
          "ḑ": "d",
          "ḓ": "d",
          "ḏ": "d",
          "đ": "d",
          "ƌ": "d",
          "ɖ": "d",
          "ɗ": "d",
          "ꝺ": "d",
          "ǳ": "dz",
          "ǆ": "dz",
          "ⓔ": "e",
          "ｅ": "e",
          "è": "e",
          "é": "e",
          "ê": "e",
          "ề": "e",
          "ế": "e",
          "ễ": "e",
          "ể": "e",
          "ẽ": "e",
          "ē": "e",
          "ḕ": "e",
          "ḗ": "e",
          "ĕ": "e",
          "ė": "e",
          "ë": "e",
          "ẻ": "e",
          "ě": "e",
          "ȅ": "e",
          "ȇ": "e",
          "ẹ": "e",
          "ệ": "e",
          "ȩ": "e",
          "ḝ": "e",
          "ę": "e",
          "ḙ": "e",
          "ḛ": "e",
          "ɇ": "e",
          "ɛ": "e",
          "ǝ": "e",
          "ⓕ": "f",
          "ｆ": "f",
          "ḟ": "f",
          "ƒ": "f",
          "ꝼ": "f",
          "ⓖ": "g",
          "ｇ": "g",
          "ǵ": "g",
          "ĝ": "g",
          "ḡ": "g",
          "ğ": "g",
          "ġ": "g",
          "ǧ": "g",
          "ģ": "g",
          "ǥ": "g",
          "ɠ": "g",
          "ꞡ": "g",
          "ᵹ": "g",
          "ꝿ": "g",
          "ⓗ": "h",
          "ｈ": "h",
          "ĥ": "h",
          "ḣ": "h",
          "ḧ": "h",
          "ȟ": "h",
          "ḥ": "h",
          "ḩ": "h",
          "ḫ": "h",
          "ẖ": "h",
          "ħ": "h",
          "ⱨ": "h",
          "ⱶ": "h",
          "ɥ": "h",
          "ƕ": "hv",
          "ⓘ": "i",
          "ｉ": "i",
          "ì": "i",
          "í": "i",
          "î": "i",
          "ĩ": "i",
          "ī": "i",
          "ĭ": "i",
          "ï": "i",
          "ḯ": "i",
          "ỉ": "i",
          "ǐ": "i",
          "ȉ": "i",
          "ȋ": "i",
          "ị": "i",
          "į": "i",
          "ḭ": "i",
          "ɨ": "i",
          "ı": "i",
          "ⓙ": "j",
          "ｊ": "j",
          "ĵ": "j",
          "ǰ": "j",
          "ɉ": "j",
          "ⓚ": "k",
          "ｋ": "k",
          "ḱ": "k",
          "ǩ": "k",
          "ḳ": "k",
          "ķ": "k",
          "ḵ": "k",
          "ƙ": "k",
          "ⱪ": "k",
          "ꝁ": "k",
          "ꝃ": "k",
          "ꝅ": "k",
          "ꞣ": "k",
          "ⓛ": "l",
          "ｌ": "l",
          "ŀ": "l",
          "ĺ": "l",
          "ľ": "l",
          "ḷ": "l",
          "ḹ": "l",
          "ļ": "l",
          "ḽ": "l",
          "ḻ": "l",
          "ſ": "l",
          "ł": "l",
          "ƚ": "l",
          "ɫ": "l",
          "ⱡ": "l",
          "ꝉ": "l",
          "ꞁ": "l",
          "ꝇ": "l",
          "ǉ": "lj",
          "ⓜ": "m",
          "ｍ": "m",
          "ḿ": "m",
          "ṁ": "m",
          "ṃ": "m",
          "ɱ": "m",
          "ɯ": "m",
          "ⓝ": "n",
          "ｎ": "n",
          "ǹ": "n",
          "ń": "n",
          "ñ": "n",
          "ṅ": "n",
          "ň": "n",
          "ṇ": "n",
          "ņ": "n",
          "ṋ": "n",
          "ṉ": "n",
          "ƞ": "n",
          "ɲ": "n",
          "ŉ": "n",
          "ꞑ": "n",
          "ꞥ": "n",
          "ǌ": "nj",
          "ⓞ": "o",
          "ｏ": "o",
          "ò": "o",
          "ó": "o",
          "ô": "o",
          "ồ": "o",
          "ố": "o",
          "ỗ": "o",
          "ổ": "o",
          "õ": "o",
          "ṍ": "o",
          "ȭ": "o",
          "ṏ": "o",
          "ō": "o",
          "ṑ": "o",
          "ṓ": "o",
          "ŏ": "o",
          "ȯ": "o",
          "ȱ": "o",
          "ö": "o",
          "ȫ": "o",
          "ỏ": "o",
          "ő": "o",
          "ǒ": "o",
          "ȍ": "o",
          "ȏ": "o",
          "ơ": "o",
          "ờ": "o",
          "ớ": "o",
          "ỡ": "o",
          "ở": "o",
          "ợ": "o",
          "ọ": "o",
          "ộ": "o",
          "ǫ": "o",
          "ǭ": "o",
          "ø": "o",
          "ǿ": "o",
          "ɔ": "o",
          "ꝋ": "o",
          "ꝍ": "o",
          "ɵ": "o",
          "œ": "oe",
          "ƣ": "oi",
          "ȣ": "ou",
          "ꝏ": "oo",
          "ⓟ": "p",
          "ｐ": "p",
          "ṕ": "p",
          "ṗ": "p",
          "ƥ": "p",
          "ᵽ": "p",
          "ꝑ": "p",
          "ꝓ": "p",
          "ꝕ": "p",
          "ⓠ": "q",
          "ｑ": "q",
          "ɋ": "q",
          "ꝗ": "q",
          "ꝙ": "q",
          "ⓡ": "r",
          "ｒ": "r",
          "ŕ": "r",
          "ṙ": "r",
          "ř": "r",
          "ȑ": "r",
          "ȓ": "r",
          "ṛ": "r",
          "ṝ": "r",
          "ŗ": "r",
          "ṟ": "r",
          "ɍ": "r",
          "ɽ": "r",
          "ꝛ": "r",
          "ꞧ": "r",
          "ꞃ": "r",
          "ⓢ": "s",
          "ｓ": "s",
          "ß": "s",
          "ś": "s",
          "ṥ": "s",
          "ŝ": "s",
          "ṡ": "s",
          "š": "s",
          "ṧ": "s",
          "ṣ": "s",
          "ṩ": "s",
          "ș": "s",
          "ş": "s",
          "ȿ": "s",
          "ꞩ": "s",
          "ꞅ": "s",
          "ẛ": "s",
          "ⓣ": "t",
          "ｔ": "t",
          "ṫ": "t",
          "ẗ": "t",
          "ť": "t",
          "ṭ": "t",
          "ț": "t",
          "ţ": "t",
          "ṱ": "t",
          "ṯ": "t",
          "ŧ": "t",
          "ƭ": "t",
          "ʈ": "t",
          "ⱦ": "t",
          "ꞇ": "t",
          "ꜩ": "tz",
          "ⓤ": "u",
          "ｕ": "u",
          "ù": "u",
          "ú": "u",
          "û": "u",
          "ũ": "u",
          "ṹ": "u",
          "ū": "u",
          "ṻ": "u",
          "ŭ": "u",
          "ü": "u",
          "ǜ": "u",
          "ǘ": "u",
          "ǖ": "u",
          "ǚ": "u",
          "ủ": "u",
          "ů": "u",
          "ű": "u",
          "ǔ": "u",
          "ȕ": "u",
          "ȗ": "u",
          "ư": "u",
          "ừ": "u",
          "ứ": "u",
          "ữ": "u",
          "ử": "u",
          "ự": "u",
          "ụ": "u",
          "ṳ": "u",
          "ų": "u",
          "ṷ": "u",
          "ṵ": "u",
          "ʉ": "u",
          "ⓥ": "v",
          "ｖ": "v",
          "ṽ": "v",
          "ṿ": "v",
          "ʋ": "v",
          "ꝟ": "v",
          "ʌ": "v",
          "ꝡ": "vy",
          "ⓦ": "w",
          "ｗ": "w",
          "ẁ": "w",
          "ẃ": "w",
          "ŵ": "w",
          "ẇ": "w",
          "ẅ": "w",
          "ẘ": "w",
          "ẉ": "w",
          "ⱳ": "w",
          "ⓧ": "x",
          "ｘ": "x",
          "ẋ": "x",
          "ẍ": "x",
          "ⓨ": "y",
          "ｙ": "y",
          "ỳ": "y",
          "ý": "y",
          "ŷ": "y",
          "ỹ": "y",
          "ȳ": "y",
          "ẏ": "y",
          "ÿ": "y",
          "ỷ": "y",
          "ẙ": "y",
          "ỵ": "y",
          "ƴ": "y",
          "ɏ": "y",
          "ỿ": "y",
          "ⓩ": "z",
          "ｚ": "z",
          "ź": "z",
          "ẑ": "z",
          "ż": "z",
          "ž": "z",
          "ẓ": "z",
          "ẕ": "z",
          "ƶ": "z",
          "ȥ": "z",
          "ɀ": "z",
          "ⱬ": "z",
          "ꝣ": "z",
          "Ά": "Α",
          "Έ": "Ε",
          "Ή": "Η",
          "Ί": "Ι",
          "Ϊ": "Ι",
          "Ό": "Ο",
          "Ύ": "Υ",
          "Ϋ": "Υ",
          "Ώ": "Ω",
          "ά": "α",
          "έ": "ε",
          "ή": "η",
          "ί": "ι",
          "ϊ": "ι",
          "ΐ": "ι",
          "ό": "ο",
          "ύ": "υ",
          "ϋ": "υ",
          "ΰ": "υ",
          "ώ": "ω",
          "ς": "σ",
          "’": "'"
        };
        return diacritics;
      });
      S22.define("select2/data/base", [
        "../utils"
      ], function(Utils) {
        function BaseAdapter($element, options) {
          BaseAdapter.__super__.constructor.call(this);
        }
        Utils.Extend(BaseAdapter, Utils.Observable);
        BaseAdapter.prototype.current = function(callback) {
          throw new Error("The `current` method must be defined in child classes.");
        };
        BaseAdapter.prototype.query = function(params, callback) {
          throw new Error("The `query` method must be defined in child classes.");
        };
        BaseAdapter.prototype.bind = function(container, $container) {
        };
        BaseAdapter.prototype.destroy = function() {
        };
        BaseAdapter.prototype.generateResultId = function(container, data2) {
          var id = container.id + "-result-";
          id += Utils.generateChars(4);
          if (data2.id != null) {
            id += "-" + data2.id.toString();
          } else {
            id += "-" + Utils.generateChars(4);
          }
          return id;
        };
        return BaseAdapter;
      });
      S22.define("select2/data/select", [
        "./base",
        "../utils",
        "jquery"
      ], function(BaseAdapter, Utils, $2) {
        function SelectAdapter($element, options) {
          this.$element = $element;
          this.options = options;
          SelectAdapter.__super__.constructor.call(this);
        }
        Utils.Extend(SelectAdapter, BaseAdapter);
        SelectAdapter.prototype.current = function(callback) {
          var data2 = [];
          var self2 = this;
          this.$element.find(":selected").each(function() {
            var $option = $2(this);
            var option2 = self2.item($option);
            data2.push(option2);
          });
          callback(data2);
        };
        SelectAdapter.prototype.select = function(data2) {
          var self2 = this;
          data2.selected = true;
          if ($2(data2.element).is("option")) {
            data2.element.selected = true;
            this.$element.trigger("input").trigger("change");
            return;
          }
          if (this.$element.prop("multiple")) {
            this.current(function(currentData) {
              var val2 = [];
              data2 = [data2];
              data2.push.apply(data2, currentData);
              for (var d2 = 0; d2 < data2.length; d2++) {
                var id = data2[d2].id;
                if ($2.inArray(id, val2) === -1) {
                  val2.push(id);
                }
              }
              self2.$element.val(val2);
              self2.$element.trigger("input").trigger("change");
            });
          } else {
            var val = data2.id;
            this.$element.val(val);
            this.$element.trigger("input").trigger("change");
          }
        };
        SelectAdapter.prototype.unselect = function(data2) {
          var self2 = this;
          if (!this.$element.prop("multiple")) {
            return;
          }
          data2.selected = false;
          if ($2(data2.element).is("option")) {
            data2.element.selected = false;
            this.$element.trigger("input").trigger("change");
            return;
          }
          this.current(function(currentData) {
            var val = [];
            for (var d2 = 0; d2 < currentData.length; d2++) {
              var id = currentData[d2].id;
              if (id !== data2.id && $2.inArray(id, val) === -1) {
                val.push(id);
              }
            }
            self2.$element.val(val);
            self2.$element.trigger("input").trigger("change");
          });
        };
        SelectAdapter.prototype.bind = function(container, $container) {
          var self2 = this;
          this.container = container;
          container.on("select", function(params) {
            self2.select(params.data);
          });
          container.on("unselect", function(params) {
            self2.unselect(params.data);
          });
        };
        SelectAdapter.prototype.destroy = function() {
          this.$element.find("*").each(function() {
            Utils.RemoveData(this);
          });
        };
        SelectAdapter.prototype.query = function(params, callback) {
          var data2 = [];
          var self2 = this;
          var $options = this.$element.children();
          $options.each(function() {
            var $option = $2(this);
            if (!$option.is("option") && !$option.is("optgroup")) {
              return;
            }
            var option2 = self2.item($option);
            var matches = self2.matches(params, option2);
            if (matches !== null) {
              data2.push(matches);
            }
          });
          callback({
            results: data2
          });
        };
        SelectAdapter.prototype.addOptions = function($options) {
          Utils.appendMany(this.$element, $options);
        };
        SelectAdapter.prototype.option = function(data2) {
          var option2;
          if (data2.children) {
            option2 = document.createElement("optgroup");
            option2.label = data2.text;
          } else {
            option2 = document.createElement("option");
            if (option2.textContent !== void 0) {
              option2.textContent = data2.text;
            } else {
              option2.innerText = data2.text;
            }
          }
          if (data2.id !== void 0) {
            option2.value = data2.id;
          }
          if (data2.disabled) {
            option2.disabled = true;
          }
          if (data2.selected) {
            option2.selected = true;
          }
          if (data2.title) {
            option2.title = data2.title;
          }
          var $option = $2(option2);
          var normalizedData = this._normalizeItem(data2);
          normalizedData.element = option2;
          Utils.StoreData(option2, "data", normalizedData);
          return $option;
        };
        SelectAdapter.prototype.item = function($option) {
          var data2 = {};
          data2 = Utils.GetData($option[0], "data");
          if (data2 != null) {
            return data2;
          }
          if ($option.is("option")) {
            data2 = {
              id: $option.val(),
              text: $option.text(),
              disabled: $option.prop("disabled"),
              selected: $option.prop("selected"),
              title: $option.prop("title")
            };
          } else if ($option.is("optgroup")) {
            data2 = {
              text: $option.prop("label"),
              children: [],
              title: $option.prop("title")
            };
            var $children = $option.children("option");
            var children = [];
            for (var c2 = 0; c2 < $children.length; c2++) {
              var $child = $2($children[c2]);
              var child = this.item($child);
              children.push(child);
            }
            data2.children = children;
          }
          data2 = this._normalizeItem(data2);
          data2.element = $option[0];
          Utils.StoreData($option[0], "data", data2);
          return data2;
        };
        SelectAdapter.prototype._normalizeItem = function(item2) {
          if (item2 !== Object(item2)) {
            item2 = {
              id: item2,
              text: item2
            };
          }
          item2 = $2.extend({}, {
            text: ""
          }, item2);
          var defaults2 = {
            selected: false,
            disabled: false
          };
          if (item2.id != null) {
            item2.id = item2.id.toString();
          }
          if (item2.text != null) {
            item2.text = item2.text.toString();
          }
          if (item2._resultId == null && item2.id && this.container != null) {
            item2._resultId = this.generateResultId(this.container, item2);
          }
          return $2.extend({}, defaults2, item2);
        };
        SelectAdapter.prototype.matches = function(params, data2) {
          var matcher = this.options.get("matcher");
          return matcher(params, data2);
        };
        return SelectAdapter;
      });
      S22.define("select2/data/array", [
        "./select",
        "../utils",
        "jquery"
      ], function(SelectAdapter, Utils, $2) {
        function ArrayAdapter($element, options) {
          this._dataToConvert = options.get("data") || [];
          ArrayAdapter.__super__.constructor.call(this, $element, options);
        }
        Utils.Extend(ArrayAdapter, SelectAdapter);
        ArrayAdapter.prototype.bind = function(container, $container) {
          ArrayAdapter.__super__.bind.call(this, container, $container);
          this.addOptions(this.convertToOptions(this._dataToConvert));
        };
        ArrayAdapter.prototype.select = function(data2) {
          var $option = this.$element.find("option").filter(function(i, elm) {
            return elm.value == data2.id.toString();
          });
          if ($option.length === 0) {
            $option = this.option(data2);
            this.addOptions($option);
          }
          ArrayAdapter.__super__.select.call(this, data2);
        };
        ArrayAdapter.prototype.convertToOptions = function(data2) {
          var self2 = this;
          var $existing = this.$element.find("option");
          var existingIds = $existing.map(function() {
            return self2.item($2(this)).id;
          }).get();
          var $options = [];
          function onlyItem(item3) {
            return function() {
              return $2(this).val() == item3.id;
            };
          }
          for (var d2 = 0; d2 < data2.length; d2++) {
            var item2 = this._normalizeItem(data2[d2]);
            if ($2.inArray(item2.id, existingIds) >= 0) {
              var $existingOption = $existing.filter(onlyItem(item2));
              var existingData = this.item($existingOption);
              var newData = $2.extend(true, {}, item2, existingData);
              var $newOption = this.option(newData);
              $existingOption.replaceWith($newOption);
              continue;
            }
            var $option = this.option(item2);
            if (item2.children) {
              var $children = this.convertToOptions(item2.children);
              Utils.appendMany($option, $children);
            }
            $options.push($option);
          }
          return $options;
        };
        return ArrayAdapter;
      });
      S22.define("select2/data/ajax", [
        "./array",
        "../utils",
        "jquery"
      ], function(ArrayAdapter, Utils, $2) {
        function AjaxAdapter($element, options) {
          this.ajaxOptions = this._applyDefaults(options.get("ajax"));
          if (this.ajaxOptions.processResults != null) {
            this.processResults = this.ajaxOptions.processResults;
          }
          AjaxAdapter.__super__.constructor.call(this, $element, options);
        }
        Utils.Extend(AjaxAdapter, ArrayAdapter);
        AjaxAdapter.prototype._applyDefaults = function(options) {
          var defaults2 = {
            data: function(params) {
              return $2.extend({}, params, {
                q: params.term
              });
            },
            transport: function(params, success, failure) {
              var $request = $2.ajax(params);
              $request.then(success);
              $request.fail(failure);
              return $request;
            }
          };
          return $2.extend({}, defaults2, options, true);
        };
        AjaxAdapter.prototype.processResults = function(results) {
          return results;
        };
        AjaxAdapter.prototype.query = function(params, callback) {
          var self2 = this;
          if (this._request != null) {
            if ($2.isFunction(this._request.abort)) {
              this._request.abort();
            }
            this._request = null;
          }
          var options = $2.extend({
            type: "GET"
          }, this.ajaxOptions);
          if (typeof options.url === "function") {
            options.url = options.url.call(this.$element, params);
          }
          if (typeof options.data === "function") {
            options.data = options.data.call(this.$element, params);
          }
          function request() {
            var $request = options.transport(options, function(data2) {
              var results = self2.processResults(data2, params);
              if (self2.options.get("debug") && window.console && console.error) {
                if (!results || !results.results || !$2.isArray(results.results)) {
                  console.error(
                    "Select2: The AJAX results did not return an array in the `results` key of the response."
                  );
                }
              }
              callback(results);
            }, function() {
              if ("status" in $request && ($request.status === 0 || $request.status === "0")) {
                return;
              }
              self2.trigger("results:message", {
                message: "errorLoading"
              });
            });
            self2._request = $request;
          }
          if (this.ajaxOptions.delay && params.term != null) {
            if (this._queryTimeout) {
              window.clearTimeout(this._queryTimeout);
            }
            this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay);
          } else {
            request();
          }
        };
        return AjaxAdapter;
      });
      S22.define("select2/data/tags", [
        "jquery"
      ], function($2) {
        function Tags(decorated, $element, options) {
          var tags = options.get("tags");
          var createTag = options.get("createTag");
          if (createTag !== void 0) {
            this.createTag = createTag;
          }
          var insertTag = options.get("insertTag");
          if (insertTag !== void 0) {
            this.insertTag = insertTag;
          }
          decorated.call(this, $element, options);
          if ($2.isArray(tags)) {
            for (var t2 = 0; t2 < tags.length; t2++) {
              var tag = tags[t2];
              var item2 = this._normalizeItem(tag);
              var $option = this.option(item2);
              this.$element.append($option);
            }
          }
        }
        Tags.prototype.query = function(decorated, params, callback) {
          var self2 = this;
          this._removeOldTags();
          if (params.term == null || params.page != null) {
            decorated.call(this, params, callback);
            return;
          }
          function wrapper(obj, child) {
            var data2 = obj.results;
            for (var i = 0; i < data2.length; i++) {
              var option2 = data2[i];
              var checkChildren = option2.children != null && !wrapper({
                results: option2.children
              }, true);
              var optionText = (option2.text || "").toUpperCase();
              var paramsTerm = (params.term || "").toUpperCase();
              var checkText = optionText === paramsTerm;
              if (checkText || checkChildren) {
                if (child) {
                  return false;
                }
                obj.data = data2;
                callback(obj);
                return;
              }
            }
            if (child) {
              return true;
            }
            var tag = self2.createTag(params);
            if (tag != null) {
              var $option = self2.option(tag);
              $option.attr("data-select2-tag", true);
              self2.addOptions([$option]);
              self2.insertTag(data2, tag);
            }
            obj.results = data2;
            callback(obj);
          }
          decorated.call(this, params, wrapper);
        };
        Tags.prototype.createTag = function(decorated, params) {
          var term = $2.trim(params.term);
          if (term === "") {
            return null;
          }
          return {
            id: term,
            text: term
          };
        };
        Tags.prototype.insertTag = function(_2, data2, tag) {
          data2.unshift(tag);
        };
        Tags.prototype._removeOldTags = function(_2) {
          var $options = this.$element.find("option[data-select2-tag]");
          $options.each(function() {
            if (this.selected) {
              return;
            }
            $2(this).remove();
          });
        };
        return Tags;
      });
      S22.define("select2/data/tokenizer", [
        "jquery"
      ], function($2) {
        function Tokenizer(decorated, $element, options) {
          var tokenizer = options.get("tokenizer");
          if (tokenizer !== void 0) {
            this.tokenizer = tokenizer;
          }
          decorated.call(this, $element, options);
        }
        Tokenizer.prototype.bind = function(decorated, container, $container) {
          decorated.call(this, container, $container);
          this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
        };
        Tokenizer.prototype.query = function(decorated, params, callback) {
          var self2 = this;
          function createAndSelect(data2) {
            var item2 = self2._normalizeItem(data2);
            var $existingOptions = self2.$element.find("option").filter(function() {
              return $2(this).val() === item2.id;
            });
            if (!$existingOptions.length) {
              var $option = self2.option(item2);
              $option.attr("data-select2-tag", true);
              self2._removeOldTags();
              self2.addOptions([$option]);
            }
            select(item2);
          }
          function select(data2) {
            self2.trigger("select", {
              data: data2
            });
          }
          params.term = params.term || "";
          var tokenData = this.tokenizer(params, this.options, createAndSelect);
          if (tokenData.term !== params.term) {
            if (this.$search.length) {
              this.$search.val(tokenData.term);
              this.$search.trigger("focus");
            }
            params.term = tokenData.term;
          }
          decorated.call(this, params, callback);
        };
        Tokenizer.prototype.tokenizer = function(_2, params, options, callback) {
          var separators = options.get("tokenSeparators") || [];
          var term = params.term;
          var i = 0;
          var createTag = this.createTag || function(params2) {
            return {
              id: params2.term,
              text: params2.term
            };
          };
          while (i < term.length) {
            var termChar = term[i];
            if ($2.inArray(termChar, separators) === -1) {
              i++;
              continue;
            }
            var part = term.substr(0, i);
            var partParams = $2.extend({}, params, {
              term: part
            });
            var data2 = createTag(partParams);
            if (data2 == null) {
              i++;
              continue;
            }
            callback(data2);
            term = term.substr(i + 1) || "";
            i = 0;
          }
          return {
            term
          };
        };
        return Tokenizer;
      });
      S22.define("select2/data/minimumInputLength", [], function() {
        function MinimumInputLength(decorated, $e2, options) {
          this.minimumInputLength = options.get("minimumInputLength");
          decorated.call(this, $e2, options);
        }
        MinimumInputLength.prototype.query = function(decorated, params, callback) {
          params.term = params.term || "";
          if (params.term.length < this.minimumInputLength) {
            this.trigger("results:message", {
              message: "inputTooShort",
              args: {
                minimum: this.minimumInputLength,
                input: params.term,
                params
              }
            });
            return;
          }
          decorated.call(this, params, callback);
        };
        return MinimumInputLength;
      });
      S22.define("select2/data/maximumInputLength", [], function() {
        function MaximumInputLength(decorated, $e2, options) {
          this.maximumInputLength = options.get("maximumInputLength");
          decorated.call(this, $e2, options);
        }
        MaximumInputLength.prototype.query = function(decorated, params, callback) {
          params.term = params.term || "";
          if (this.maximumInputLength > 0 && params.term.length > this.maximumInputLength) {
            this.trigger("results:message", {
              message: "inputTooLong",
              args: {
                maximum: this.maximumInputLength,
                input: params.term,
                params
              }
            });
            return;
          }
          decorated.call(this, params, callback);
        };
        return MaximumInputLength;
      });
      S22.define("select2/data/maximumSelectionLength", [], function() {
        function MaximumSelectionLength(decorated, $e2, options) {
          this.maximumSelectionLength = options.get("maximumSelectionLength");
          decorated.call(this, $e2, options);
        }
        MaximumSelectionLength.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          container.on("select", function() {
            self2._checkIfMaximumSelected();
          });
        };
        MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
          var self2 = this;
          this._checkIfMaximumSelected(function() {
            decorated.call(self2, params, callback);
          });
        };
        MaximumSelectionLength.prototype._checkIfMaximumSelected = function(_2, successCallback) {
          var self2 = this;
          this.current(function(currentData) {
            var count = currentData != null ? currentData.length : 0;
            if (self2.maximumSelectionLength > 0 && count >= self2.maximumSelectionLength) {
              self2.trigger("results:message", {
                message: "maximumSelected",
                args: {
                  maximum: self2.maximumSelectionLength
                }
              });
              return;
            }
            if (successCallback) {
              successCallback();
            }
          });
        };
        return MaximumSelectionLength;
      });
      S22.define("select2/dropdown", [
        "jquery",
        "./utils"
      ], function($2, Utils) {
        function Dropdown2($element, options) {
          this.$element = $element;
          this.options = options;
          Dropdown2.__super__.constructor.call(this);
        }
        Utils.Extend(Dropdown2, Utils.Observable);
        Dropdown2.prototype.render = function() {
          var $dropdown = $2(
            '<span class="select2-dropdown"><span class="select2-results"></span></span>'
          );
          $dropdown.attr("dir", this.options.get("dir"));
          this.$dropdown = $dropdown;
          return $dropdown;
        };
        Dropdown2.prototype.bind = function() {
        };
        Dropdown2.prototype.position = function($dropdown, $container) {
        };
        Dropdown2.prototype.destroy = function() {
          this.$dropdown.remove();
        };
        return Dropdown2;
      });
      S22.define("select2/dropdown/search", [
        "jquery",
        "../utils"
      ], function($2, Utils) {
        function Search() {
        }
        Search.prototype.render = function(decorated) {
          var $rendered = decorated.call(this);
          var $search = $2(
            '<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false" role="searchbox" aria-autocomplete="list" /></span>'
          );
          this.$searchContainer = $search;
          this.$search = $search.find("input");
          $rendered.prepend($search);
          return $rendered;
        };
        Search.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          var resultsId = container.id + "-results";
          decorated.call(this, container, $container);
          this.$search.on("keydown", function(evt) {
            self2.trigger("keypress", evt);
            self2._keyUpPrevented = evt.isDefaultPrevented();
          });
          this.$search.on("input", function(evt) {
            $2(this).off("keyup");
          });
          this.$search.on("keyup input", function(evt) {
            self2.handleSearch(evt);
          });
          container.on("open", function() {
            self2.$search.attr("tabindex", 0);
            self2.$search.attr("aria-controls", resultsId);
            self2.$search.trigger("focus");
            window.setTimeout(function() {
              self2.$search.trigger("focus");
            }, 0);
          });
          container.on("close", function() {
            self2.$search.attr("tabindex", -1);
            self2.$search.removeAttr("aria-controls");
            self2.$search.removeAttr("aria-activedescendant");
            self2.$search.val("");
            self2.$search.trigger("blur");
          });
          container.on("focus", function() {
            if (!container.isOpen()) {
              self2.$search.trigger("focus");
            }
          });
          container.on("results:all", function(params) {
            if (params.query.term == null || params.query.term === "") {
              var showSearch = self2.showSearch(params);
              if (showSearch) {
                self2.$searchContainer.removeClass("select2-search--hide");
              } else {
                self2.$searchContainer.addClass("select2-search--hide");
              }
            }
          });
          container.on("results:focus", function(params) {
            if (params.data._resultId) {
              self2.$search.attr("aria-activedescendant", params.data._resultId);
            } else {
              self2.$search.removeAttr("aria-activedescendant");
            }
          });
        };
        Search.prototype.handleSearch = function(evt) {
          if (!this._keyUpPrevented) {
            var input = this.$search.val();
            this.trigger("query", {
              term: input
            });
          }
          this._keyUpPrevented = false;
        };
        Search.prototype.showSearch = function(_2, params) {
          return true;
        };
        return Search;
      });
      S22.define("select2/dropdown/hidePlaceholder", [], function() {
        function HidePlaceholder(decorated, $element, options, dataAdapter) {
          this.placeholder = this.normalizePlaceholder(options.get("placeholder"));
          decorated.call(this, $element, options, dataAdapter);
        }
        HidePlaceholder.prototype.append = function(decorated, data2) {
          data2.results = this.removePlaceholder(data2.results);
          decorated.call(this, data2);
        };
        HidePlaceholder.prototype.normalizePlaceholder = function(_2, placeholder) {
          if (typeof placeholder === "string") {
            placeholder = {
              id: "",
              text: placeholder
            };
          }
          return placeholder;
        };
        HidePlaceholder.prototype.removePlaceholder = function(_2, data2) {
          var modifiedData = data2.slice(0);
          for (var d2 = data2.length - 1; d2 >= 0; d2--) {
            var item2 = data2[d2];
            if (this.placeholder.id === item2.id) {
              modifiedData.splice(d2, 1);
            }
          }
          return modifiedData;
        };
        return HidePlaceholder;
      });
      S22.define("select2/dropdown/infiniteScroll", [
        "jquery"
      ], function($2) {
        function InfiniteScroll(decorated, $element, options, dataAdapter) {
          this.lastParams = {};
          decorated.call(this, $element, options, dataAdapter);
          this.$loadingMore = this.createLoadingMore();
          this.loading = false;
        }
        InfiniteScroll.prototype.append = function(decorated, data2) {
          this.$loadingMore.remove();
          this.loading = false;
          decorated.call(this, data2);
          if (this.showLoadingMore(data2)) {
            this.$results.append(this.$loadingMore);
            this.loadMoreIfNeeded();
          }
        };
        InfiniteScroll.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          container.on("query", function(params) {
            self2.lastParams = params;
            self2.loading = true;
          });
          container.on("query:append", function(params) {
            self2.lastParams = params;
            self2.loading = true;
          });
          this.$results.on("scroll", this.loadMoreIfNeeded.bind(this));
        };
        InfiniteScroll.prototype.loadMoreIfNeeded = function() {
          var isLoadMoreVisible = $2.contains(
            document.documentElement,
            this.$loadingMore[0]
          );
          if (this.loading || !isLoadMoreVisible) {
            return;
          }
          var currentOffset = this.$results.offset().top + this.$results.outerHeight(false);
          var loadingMoreOffset = this.$loadingMore.offset().top + this.$loadingMore.outerHeight(false);
          if (currentOffset + 50 >= loadingMoreOffset) {
            this.loadMore();
          }
        };
        InfiniteScroll.prototype.loadMore = function() {
          this.loading = true;
          var params = $2.extend({}, { page: 1 }, this.lastParams);
          params.page++;
          this.trigger("query:append", params);
        };
        InfiniteScroll.prototype.showLoadingMore = function(_2, data2) {
          return data2.pagination && data2.pagination.more;
        };
        InfiniteScroll.prototype.createLoadingMore = function() {
          var $option = $2(
            '<li class="select2-results__option select2-results__option--load-more"role="option" aria-disabled="true"></li>'
          );
          var message = this.options.get("translations").get("loadingMore");
          $option.html(message(this.lastParams));
          return $option;
        };
        return InfiniteScroll;
      });
      S22.define("select2/dropdown/attachBody", [
        "jquery",
        "../utils"
      ], function($2, Utils) {
        function AttachBody(decorated, $element, options) {
          this.$dropdownParent = $2(options.get("dropdownParent") || document.body);
          decorated.call(this, $element, options);
        }
        AttachBody.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          container.on("open", function() {
            self2._showDropdown();
            self2._attachPositioningHandler(container);
            self2._bindContainerResultHandlers(container);
          });
          container.on("close", function() {
            self2._hideDropdown();
            self2._detachPositioningHandler(container);
          });
          this.$dropdownContainer.on("mousedown", function(evt) {
            evt.stopPropagation();
          });
        };
        AttachBody.prototype.destroy = function(decorated) {
          decorated.call(this);
          this.$dropdownContainer.remove();
        };
        AttachBody.prototype.position = function(decorated, $dropdown, $container) {
          $dropdown.attr("class", $container.attr("class"));
          $dropdown.removeClass("select2");
          $dropdown.addClass("select2-container--open");
          $dropdown.css({
            position: "absolute",
            top: -999999
          });
          this.$container = $container;
        };
        AttachBody.prototype.render = function(decorated) {
          var $container = $2("<span></span>");
          var $dropdown = decorated.call(this);
          $container.append($dropdown);
          this.$dropdownContainer = $container;
          return $container;
        };
        AttachBody.prototype._hideDropdown = function(decorated) {
          this.$dropdownContainer.detach();
        };
        AttachBody.prototype._bindContainerResultHandlers = function(decorated, container) {
          if (this._containerResultsHandlersBound) {
            return;
          }
          var self2 = this;
          container.on("results:all", function() {
            self2._positionDropdown();
            self2._resizeDropdown();
          });
          container.on("results:append", function() {
            self2._positionDropdown();
            self2._resizeDropdown();
          });
          container.on("results:message", function() {
            self2._positionDropdown();
            self2._resizeDropdown();
          });
          container.on("select", function() {
            self2._positionDropdown();
            self2._resizeDropdown();
          });
          container.on("unselect", function() {
            self2._positionDropdown();
            self2._resizeDropdown();
          });
          this._containerResultsHandlersBound = true;
        };
        AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
          var self2 = this;
          var scrollEvent = "scroll.select2." + container.id;
          var resizeEvent = "resize.select2." + container.id;
          var orientationEvent = "orientationchange.select2." + container.id;
          var $watchers = this.$container.parents().filter(Utils.hasScroll);
          $watchers.each(function() {
            Utils.StoreData(this, "select2-scroll-position", {
              x: $2(this).scrollLeft(),
              y: $2(this).scrollTop()
            });
          });
          $watchers.on(scrollEvent, function(ev) {
            var position = Utils.GetData(this, "select2-scroll-position");
            $2(this).scrollTop(position.y);
          });
          $2(window).on(
            scrollEvent + " " + resizeEvent + " " + orientationEvent,
            function(e2) {
              self2._positionDropdown();
              self2._resizeDropdown();
            }
          );
        };
        AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
          var scrollEvent = "scroll.select2." + container.id;
          var resizeEvent = "resize.select2." + container.id;
          var orientationEvent = "orientationchange.select2." + container.id;
          var $watchers = this.$container.parents().filter(Utils.hasScroll);
          $watchers.off(scrollEvent);
          $2(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
        };
        AttachBody.prototype._positionDropdown = function() {
          var $window = $2(window);
          var isCurrentlyAbove = this.$dropdown.hasClass("select2-dropdown--above");
          var isCurrentlyBelow = this.$dropdown.hasClass("select2-dropdown--below");
          var newDirection = null;
          var offset2 = this.$container.offset();
          offset2.bottom = offset2.top + this.$container.outerHeight(false);
          var container = {
            height: this.$container.outerHeight(false)
          };
          container.top = offset2.top;
          container.bottom = offset2.top + container.height;
          var dropdown = {
            height: this.$dropdown.outerHeight(false)
          };
          var viewport2 = {
            top: $window.scrollTop(),
            bottom: $window.scrollTop() + $window.height()
          };
          var enoughRoomAbove = viewport2.top < offset2.top - dropdown.height;
          var enoughRoomBelow = viewport2.bottom > offset2.bottom + dropdown.height;
          var css = {
            left: offset2.left,
            top: container.bottom
          };
          var $offsetParent = this.$dropdownParent;
          if ($offsetParent.css("position") === "static") {
            $offsetParent = $offsetParent.offsetParent();
          }
          var parentOffset = {
            top: 0,
            left: 0
          };
          if ($2.contains(document.body, $offsetParent[0]) || $offsetParent[0].isConnected) {
            parentOffset = $offsetParent.offset();
          }
          css.top -= parentOffset.top;
          css.left -= parentOffset.left;
          if (!isCurrentlyAbove && !isCurrentlyBelow) {
            newDirection = "below";
          }
          if (!enoughRoomBelow && enoughRoomAbove && !isCurrentlyAbove) {
            newDirection = "above";
          } else if (!enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove) {
            newDirection = "below";
          }
          if (newDirection == "above" || isCurrentlyAbove && newDirection !== "below") {
            css.top = container.top - parentOffset.top - dropdown.height;
          }
          if (newDirection != null) {
            this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + newDirection);
            this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + newDirection);
          }
          this.$dropdownContainer.css(css);
        };
        AttachBody.prototype._resizeDropdown = function() {
          var css = {
            width: this.$container.outerWidth(false) + "px"
          };
          if (this.options.get("dropdownAutoWidth")) {
            css.minWidth = css.width;
            css.position = "relative";
            css.width = "auto";
          }
          this.$dropdown.css(css);
        };
        AttachBody.prototype._showDropdown = function(decorated) {
          this.$dropdownContainer.appendTo(this.$dropdownParent);
          this._positionDropdown();
          this._resizeDropdown();
        };
        return AttachBody;
      });
      S22.define("select2/dropdown/minimumResultsForSearch", [], function() {
        function countResults(data2) {
          var count = 0;
          for (var d2 = 0; d2 < data2.length; d2++) {
            var item2 = data2[d2];
            if (item2.children) {
              count += countResults(item2.children);
            } else {
              count++;
            }
          }
          return count;
        }
        function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
          this.minimumResultsForSearch = options.get("minimumResultsForSearch");
          if (this.minimumResultsForSearch < 0) {
            this.minimumResultsForSearch = Infinity;
          }
          decorated.call(this, $element, options, dataAdapter);
        }
        MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
          if (countResults(params.data.results) < this.minimumResultsForSearch) {
            return false;
          }
          return decorated.call(this, params);
        };
        return MinimumResultsForSearch;
      });
      S22.define("select2/dropdown/selectOnClose", [
        "../utils"
      ], function(Utils) {
        function SelectOnClose() {
        }
        SelectOnClose.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          container.on("close", function(params) {
            self2._handleSelectOnClose(params);
          });
        };
        SelectOnClose.prototype._handleSelectOnClose = function(_2, params) {
          if (params && params.originalSelect2Event != null) {
            var event = params.originalSelect2Event;
            if (event._type === "select" || event._type === "unselect") {
              return;
            }
          }
          var $highlightedResults = this.getHighlightedResults();
          if ($highlightedResults.length < 1) {
            return;
          }
          var data2 = Utils.GetData($highlightedResults[0], "data");
          if (data2.element != null && data2.element.selected || data2.element == null && data2.selected) {
            return;
          }
          this.trigger("select", {
            data: data2
          });
        };
        return SelectOnClose;
      });
      S22.define("select2/dropdown/closeOnSelect", [], function() {
        function CloseOnSelect() {
        }
        CloseOnSelect.prototype.bind = function(decorated, container, $container) {
          var self2 = this;
          decorated.call(this, container, $container);
          container.on("select", function(evt) {
            self2._selectTriggered(evt);
          });
          container.on("unselect", function(evt) {
            self2._selectTriggered(evt);
          });
        };
        CloseOnSelect.prototype._selectTriggered = function(_2, evt) {
          var originalEvent = evt.originalEvent;
          if (originalEvent && (originalEvent.ctrlKey || originalEvent.metaKey)) {
            return;
          }
          this.trigger("close", {
            originalEvent,
            originalSelect2Event: evt
          });
        };
        return CloseOnSelect;
      });
      S22.define("select2/i18n/en", [], function() {
        return {
          errorLoading: function() {
            return "The results could not be loaded.";
          },
          inputTooLong: function(args) {
            var overChars = args.input.length - args.maximum;
            var message = "Please delete " + overChars + " character";
            if (overChars != 1) {
              message += "s";
            }
            return message;
          },
          inputTooShort: function(args) {
            var remainingChars = args.minimum - args.input.length;
            var message = "Please enter " + remainingChars + " or more characters";
            return message;
          },
          loadingMore: function() {
            return "Loading more results…";
          },
          maximumSelected: function(args) {
            var message = "You can only select " + args.maximum + " item";
            if (args.maximum != 1) {
              message += "s";
            }
            return message;
          },
          noResults: function() {
            return "No results found";
          },
          searching: function() {
            return "Searching…";
          },
          removeAllItems: function() {
            return "Remove all items";
          }
        };
      });
      S22.define("select2/defaults", [
        "jquery",
        "require",
        "./results",
        "./selection/single",
        "./selection/multiple",
        "./selection/placeholder",
        "./selection/allowClear",
        "./selection/search",
        "./selection/eventRelay",
        "./utils",
        "./translation",
        "./diacritics",
        "./data/select",
        "./data/array",
        "./data/ajax",
        "./data/tags",
        "./data/tokenizer",
        "./data/minimumInputLength",
        "./data/maximumInputLength",
        "./data/maximumSelectionLength",
        "./dropdown",
        "./dropdown/search",
        "./dropdown/hidePlaceholder",
        "./dropdown/infiniteScroll",
        "./dropdown/attachBody",
        "./dropdown/minimumResultsForSearch",
        "./dropdown/selectOnClose",
        "./dropdown/closeOnSelect",
        "./i18n/en"
      ], function($2, require2, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown2, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
        function Defaults() {
          this.reset();
        }
        Defaults.prototype.apply = function(options) {
          options = $2.extend(true, {}, this.defaults, options);
          if (options.dataAdapter == null) {
            if (options.ajax != null) {
              options.dataAdapter = AjaxData;
            } else if (options.data != null) {
              options.dataAdapter = ArrayData;
            } else {
              options.dataAdapter = SelectData;
            }
            if (options.minimumInputLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MinimumInputLength
              );
            }
            if (options.maximumInputLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MaximumInputLength
              );
            }
            if (options.maximumSelectionLength > 0) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                MaximumSelectionLength
              );
            }
            if (options.tags) {
              options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags);
            }
            if (options.tokenSeparators != null || options.tokenizer != null) {
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                Tokenizer
              );
            }
            if (options.query != null) {
              var Query = require2(options.amdBase + "compat/query");
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                Query
              );
            }
            if (options.initSelection != null) {
              var InitSelection = require2(options.amdBase + "compat/initSelection");
              options.dataAdapter = Utils.Decorate(
                options.dataAdapter,
                InitSelection
              );
            }
          }
          if (options.resultsAdapter == null) {
            options.resultsAdapter = ResultsList;
            if (options.ajax != null) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                InfiniteScroll
              );
            }
            if (options.placeholder != null) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                HidePlaceholder
              );
            }
            if (options.selectOnClose) {
              options.resultsAdapter = Utils.Decorate(
                options.resultsAdapter,
                SelectOnClose
              );
            }
          }
          if (options.dropdownAdapter == null) {
            if (options.multiple) {
              options.dropdownAdapter = Dropdown2;
            } else {
              var SearchableDropdown = Utils.Decorate(Dropdown2, DropdownSearch);
              options.dropdownAdapter = SearchableDropdown;
            }
            if (options.minimumResultsForSearch !== 0) {
              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                MinimumResultsForSearch
              );
            }
            if (options.closeOnSelect) {
              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                CloseOnSelect
              );
            }
            if (options.dropdownCssClass != null || options.dropdownCss != null || options.adaptDropdownCssClass != null) {
              var DropdownCSS = require2(options.amdBase + "compat/dropdownCss");
              options.dropdownAdapter = Utils.Decorate(
                options.dropdownAdapter,
                DropdownCSS
              );
            }
            options.dropdownAdapter = Utils.Decorate(
              options.dropdownAdapter,
              AttachBody
            );
          }
          if (options.selectionAdapter == null) {
            if (options.multiple) {
              options.selectionAdapter = MultipleSelection;
            } else {
              options.selectionAdapter = SingleSelection;
            }
            if (options.placeholder != null) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                Placeholder
              );
            }
            if (options.allowClear) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                AllowClear
              );
            }
            if (options.multiple) {
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                SelectionSearch
              );
            }
            if (options.containerCssClass != null || options.containerCss != null || options.adaptContainerCssClass != null) {
              var ContainerCSS = require2(options.amdBase + "compat/containerCss");
              options.selectionAdapter = Utils.Decorate(
                options.selectionAdapter,
                ContainerCSS
              );
            }
            options.selectionAdapter = Utils.Decorate(
              options.selectionAdapter,
              EventRelay
            );
          }
          options.language = this._resolveLanguage(options.language);
          options.language.push("en");
          var uniqueLanguages = [];
          for (var l2 = 0; l2 < options.language.length; l2++) {
            var language = options.language[l2];
            if (uniqueLanguages.indexOf(language) === -1) {
              uniqueLanguages.push(language);
            }
          }
          options.language = uniqueLanguages;
          options.translations = this._processTranslations(
            options.language,
            options.debug
          );
          return options;
        };
        Defaults.prototype.reset = function() {
          function stripDiacritics(text2) {
            function match(a2) {
              return DIACRITICS[a2] || a2;
            }
            return text2.replace(/[^\u0000-\u007E]/g, match);
          }
          function matcher(params, data2) {
            if ($2.trim(params.term) === "") {
              return data2;
            }
            if (data2.children && data2.children.length > 0) {
              var match = $2.extend(true, {}, data2);
              for (var c2 = data2.children.length - 1; c2 >= 0; c2--) {
                var child = data2.children[c2];
                var matches = matcher(params, child);
                if (matches == null) {
                  match.children.splice(c2, 1);
                }
              }
              if (match.children.length > 0) {
                return match;
              }
              return matcher(params, match);
            }
            var original = stripDiacritics(data2.text).toUpperCase();
            var term = stripDiacritics(params.term).toUpperCase();
            if (original.indexOf(term) > -1) {
              return data2;
            }
            return null;
          }
          this.defaults = {
            amdBase: "./",
            amdLanguageBase: "./i18n/",
            closeOnSelect: true,
            debug: false,
            dropdownAutoWidth: false,
            escapeMarkup: Utils.escapeMarkup,
            language: {},
            matcher,
            minimumInputLength: 0,
            maximumInputLength: 0,
            maximumSelectionLength: 0,
            minimumResultsForSearch: 0,
            selectOnClose: false,
            scrollAfterSelect: false,
            sorter: function(data2) {
              return data2;
            },
            templateResult: function(result) {
              return result.text;
            },
            templateSelection: function(selection) {
              return selection.text;
            },
            theme: "default",
            width: "resolve"
          };
        };
        Defaults.prototype.applyFromElement = function(options, $element) {
          var optionLanguage = options.language;
          var defaultLanguage = this.defaults.language;
          var elementLanguage = $element.prop("lang");
          var parentLanguage = $element.closest("[lang]").prop("lang");
          var languages = Array.prototype.concat.call(
            this._resolveLanguage(elementLanguage),
            this._resolveLanguage(optionLanguage),
            this._resolveLanguage(defaultLanguage),
            this._resolveLanguage(parentLanguage)
          );
          options.language = languages;
          return options;
        };
        Defaults.prototype._resolveLanguage = function(language) {
          if (!language) {
            return [];
          }
          if ($2.isEmptyObject(language)) {
            return [];
          }
          if ($2.isPlainObject(language)) {
            return [language];
          }
          var languages;
          if (!$2.isArray(language)) {
            languages = [language];
          } else {
            languages = language;
          }
          var resolvedLanguages = [];
          for (var l2 = 0; l2 < languages.length; l2++) {
            resolvedLanguages.push(languages[l2]);
            if (typeof languages[l2] === "string" && languages[l2].indexOf("-") > 0) {
              var languageParts = languages[l2].split("-");
              var baseLanguage = languageParts[0];
              resolvedLanguages.push(baseLanguage);
            }
          }
          return resolvedLanguages;
        };
        Defaults.prototype._processTranslations = function(languages, debug) {
          var translations = new Translation();
          for (var l2 = 0; l2 < languages.length; l2++) {
            var languageData = new Translation();
            var language = languages[l2];
            if (typeof language === "string") {
              try {
                languageData = Translation.loadPath(language);
              } catch (e2) {
                try {
                  language = this.defaults.amdLanguageBase + language;
                  languageData = Translation.loadPath(language);
                } catch (ex) {
                  if (debug && window.console && console.warn) {
                    console.warn(
                      'Select2: The language file for "' + language + '" could not be automatically loaded. A fallback will be used instead.'
                    );
                  }
                }
              }
            } else if ($2.isPlainObject(language)) {
              languageData = new Translation(language);
            } else {
              languageData = language;
            }
            translations.extend(languageData);
          }
          return translations;
        };
        Defaults.prototype.set = function(key, value) {
          var camelKey = $2.camelCase(key);
          var data2 = {};
          data2[camelKey] = value;
          var convertedData = Utils._convertData(data2);
          $2.extend(true, this.defaults, convertedData);
        };
        var defaults2 = new Defaults();
        return defaults2;
      });
      S22.define("select2/options", [
        "require",
        "jquery",
        "./defaults",
        "./utils"
      ], function(require2, $2, Defaults, Utils) {
        function Options(options, $element) {
          this.options = options;
          if ($element != null) {
            this.fromElement($element);
          }
          if ($element != null) {
            this.options = Defaults.applyFromElement(this.options, $element);
          }
          this.options = Defaults.apply(this.options);
          if ($element && $element.is("input")) {
            var InputCompat = require2(this.get("amdBase") + "compat/inputData");
            this.options.dataAdapter = Utils.Decorate(
              this.options.dataAdapter,
              InputCompat
            );
          }
        }
        Options.prototype.fromElement = function($e2) {
          var excludedData = ["select2"];
          if (this.options.multiple == null) {
            this.options.multiple = $e2.prop("multiple");
          }
          if (this.options.disabled == null) {
            this.options.disabled = $e2.prop("disabled");
          }
          if (this.options.dir == null) {
            if ($e2.prop("dir")) {
              this.options.dir = $e2.prop("dir");
            } else if ($e2.closest("[dir]").prop("dir")) {
              this.options.dir = $e2.closest("[dir]").prop("dir");
            } else {
              this.options.dir = "ltr";
            }
          }
          $e2.prop("disabled", this.options.disabled);
          $e2.prop("multiple", this.options.multiple);
          if (Utils.GetData($e2[0], "select2Tags")) {
            if (this.options.debug && window.console && console.warn) {
              console.warn(
                'Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'
              );
            }
            Utils.StoreData($e2[0], "data", Utils.GetData($e2[0], "select2Tags"));
            Utils.StoreData($e2[0], "tags", true);
          }
          if (Utils.GetData($e2[0], "ajaxUrl")) {
            if (this.options.debug && window.console && console.warn) {
              console.warn(
                "Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."
              );
            }
            $e2.attr("ajax--url", Utils.GetData($e2[0], "ajaxUrl"));
            Utils.StoreData($e2[0], "ajax-Url", Utils.GetData($e2[0], "ajaxUrl"));
          }
          var dataset = {};
          function upperCaseLetter(_2, letter) {
            return letter.toUpperCase();
          }
          for (var attr2 = 0; attr2 < $e2[0].attributes.length; attr2++) {
            var attributeName = $e2[0].attributes[attr2].name;
            var prefix = "data-";
            if (attributeName.substr(0, prefix.length) == prefix) {
              var dataName = attributeName.substring(prefix.length);
              var dataValue = Utils.GetData($e2[0], dataName);
              var camelDataName = dataName.replace(/-([a-z])/g, upperCaseLetter);
              dataset[camelDataName] = dataValue;
            }
          }
          if ($2.fn.jquery && $2.fn.jquery.substr(0, 2) == "1." && $e2[0].dataset) {
            dataset = $2.extend(true, {}, $e2[0].dataset, dataset);
          }
          var data2 = $2.extend(true, {}, Utils.GetData($e2[0]), dataset);
          data2 = Utils._convertData(data2);
          for (var key in data2) {
            if ($2.inArray(key, excludedData) > -1) {
              continue;
            }
            if ($2.isPlainObject(this.options[key])) {
              $2.extend(this.options[key], data2[key]);
            } else {
              this.options[key] = data2[key];
            }
          }
          return this;
        };
        Options.prototype.get = function(key) {
          return this.options[key];
        };
        Options.prototype.set = function(key, val) {
          this.options[key] = val;
        };
        return Options;
      });
      S22.define("select2/core", [
        "jquery",
        "./options",
        "./utils",
        "./keys"
      ], function($2, Options, Utils, KEYS) {
        var Select2 = function($element, options) {
          if (Utils.GetData($element[0], "select2") != null) {
            Utils.GetData($element[0], "select2").destroy();
          }
          this.$element = $element;
          this.id = this._generateId($element);
          options = options || {};
          this.options = new Options(options, $element);
          Select2.__super__.constructor.call(this);
          var tabindex = $element.attr("tabindex") || 0;
          Utils.StoreData($element[0], "old-tabindex", tabindex);
          $element.attr("tabindex", "-1");
          var DataAdapter = this.options.get("dataAdapter");
          this.dataAdapter = new DataAdapter($element, this.options);
          var $container = this.render();
          this._placeContainer($container);
          var SelectionAdapter = this.options.get("selectionAdapter");
          this.selection = new SelectionAdapter($element, this.options);
          this.$selection = this.selection.render();
          this.selection.position(this.$selection, $container);
          var DropdownAdapter = this.options.get("dropdownAdapter");
          this.dropdown = new DropdownAdapter($element, this.options);
          this.$dropdown = this.dropdown.render();
          this.dropdown.position(this.$dropdown, $container);
          var ResultsAdapter = this.options.get("resultsAdapter");
          this.results = new ResultsAdapter($element, this.options, this.dataAdapter);
          this.$results = this.results.render();
          this.results.position(this.$results, this.$dropdown);
          var self2 = this;
          this._bindAdapters();
          this._registerDomEvents();
          this._registerDataEvents();
          this._registerSelectionEvents();
          this._registerDropdownEvents();
          this._registerResultsEvents();
          this._registerEvents();
          this.dataAdapter.current(function(initialData) {
            self2.trigger("selection:update", {
              data: initialData
            });
          });
          $element.addClass("select2-hidden-accessible");
          $element.attr("aria-hidden", "true");
          this._syncAttributes();
          Utils.StoreData($element[0], "select2", this);
          $element.data("select2", this);
        };
        Utils.Extend(Select2, Utils.Observable);
        Select2.prototype._generateId = function($element) {
          var id = "";
          if ($element.attr("id") != null) {
            id = $element.attr("id");
          } else if ($element.attr("name") != null) {
            id = $element.attr("name") + "-" + Utils.generateChars(2);
          } else {
            id = Utils.generateChars(4);
          }
          id = id.replace(/(:|\.|\[|\]|,)/g, "");
          id = "select2-" + id;
          return id;
        };
        Select2.prototype._placeContainer = function($container) {
          $container.insertAfter(this.$element);
          var width = this._resolveWidth(this.$element, this.options.get("width"));
          if (width != null) {
            $container.css("width", width);
          }
        };
        Select2.prototype._resolveWidth = function($element, method) {
          var WIDTH2 = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
          if (method == "resolve") {
            var styleWidth = this._resolveWidth($element, "style");
            if (styleWidth != null) {
              return styleWidth;
            }
            return this._resolveWidth($element, "element");
          }
          if (method == "element") {
            var elementWidth = $element.outerWidth(false);
            if (elementWidth <= 0) {
              return "auto";
            }
            return elementWidth + "px";
          }
          if (method == "style") {
            var style = $element.attr("style");
            if (typeof style !== "string") {
              return null;
            }
            var attrs = style.split(";");
            for (var i = 0, l2 = attrs.length; i < l2; i = i + 1) {
              var attr2 = attrs[i].replace(/\s/g, "");
              var matches = attr2.match(WIDTH2);
              if (matches !== null && matches.length >= 1) {
                return matches[1];
              }
            }
            return null;
          }
          if (method == "computedstyle") {
            var computedStyle = window.getComputedStyle($element[0]);
            return computedStyle.width;
          }
          return method;
        };
        Select2.prototype._bindAdapters = function() {
          this.dataAdapter.bind(this, this.$container);
          this.selection.bind(this, this.$container);
          this.dropdown.bind(this, this.$container);
          this.results.bind(this, this.$container);
        };
        Select2.prototype._registerDomEvents = function() {
          var self2 = this;
          this.$element.on("change.select2", function() {
            self2.dataAdapter.current(function(data2) {
              self2.trigger("selection:update", {
                data: data2
              });
            });
          });
          this.$element.on("focus.select2", function(evt) {
            self2.trigger("focus", evt);
          });
          this._syncA = Utils.bind(this._syncAttributes, this);
          this._syncS = Utils.bind(this._syncSubtree, this);
          if (this.$element[0].attachEvent) {
            this.$element[0].attachEvent("onpropertychange", this._syncA);
          }
          var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
          if (observer != null) {
            this._observer = new observer(function(mutations) {
              self2._syncA();
              self2._syncS(null, mutations);
            });
            this._observer.observe(this.$element[0], {
              attributes: true,
              childList: true,
              subtree: false
            });
          } else if (this.$element[0].addEventListener) {
            this.$element[0].addEventListener(
              "DOMAttrModified",
              self2._syncA,
              false
            );
            this.$element[0].addEventListener(
              "DOMNodeInserted",
              self2._syncS,
              false
            );
            this.$element[0].addEventListener(
              "DOMNodeRemoved",
              self2._syncS,
              false
            );
          }
        };
        Select2.prototype._registerDataEvents = function() {
          var self2 = this;
          this.dataAdapter.on("*", function(name2, params) {
            self2.trigger(name2, params);
          });
        };
        Select2.prototype._registerSelectionEvents = function() {
          var self2 = this;
          var nonRelayEvents = ["toggle", "focus"];
          this.selection.on("toggle", function() {
            self2.toggleDropdown();
          });
          this.selection.on("focus", function(params) {
            self2.focus(params);
          });
          this.selection.on("*", function(name2, params) {
            if ($2.inArray(name2, nonRelayEvents) !== -1) {
              return;
            }
            self2.trigger(name2, params);
          });
        };
        Select2.prototype._registerDropdownEvents = function() {
          var self2 = this;
          this.dropdown.on("*", function(name2, params) {
            self2.trigger(name2, params);
          });
        };
        Select2.prototype._registerResultsEvents = function() {
          var self2 = this;
          this.results.on("*", function(name2, params) {
            self2.trigger(name2, params);
          });
        };
        Select2.prototype._registerEvents = function() {
          var self2 = this;
          this.on("open", function() {
            self2.$container.addClass("select2-container--open");
          });
          this.on("close", function() {
            self2.$container.removeClass("select2-container--open");
          });
          this.on("enable", function() {
            self2.$container.removeClass("select2-container--disabled");
          });
          this.on("disable", function() {
            self2.$container.addClass("select2-container--disabled");
          });
          this.on("blur", function() {
            self2.$container.removeClass("select2-container--focus");
          });
          this.on("query", function(params) {
            if (!self2.isOpen()) {
              self2.trigger("open", {});
            }
            this.dataAdapter.query(params, function(data2) {
              self2.trigger("results:all", {
                data: data2,
                query: params
              });
            });
          });
          this.on("query:append", function(params) {
            this.dataAdapter.query(params, function(data2) {
              self2.trigger("results:append", {
                data: data2,
                query: params
              });
            });
          });
          this.on("keypress", function(evt) {
            var key = evt.which;
            if (self2.isOpen()) {
              if (key === KEYS.ESC || key === KEYS.TAB || key === KEYS.UP && evt.altKey) {
                self2.close(evt);
                evt.preventDefault();
              } else if (key === KEYS.ENTER) {
                self2.trigger("results:select", {});
                evt.preventDefault();
              } else if (key === KEYS.SPACE && evt.ctrlKey) {
                self2.trigger("results:toggle", {});
                evt.preventDefault();
              } else if (key === KEYS.UP) {
                self2.trigger("results:previous", {});
                evt.preventDefault();
              } else if (key === KEYS.DOWN) {
                self2.trigger("results:next", {});
                evt.preventDefault();
              }
            } else {
              if (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) {
                self2.open();
                evt.preventDefault();
              }
            }
          });
        };
        Select2.prototype._syncAttributes = function() {
          this.options.set("disabled", this.$element.prop("disabled"));
          if (this.isDisabled()) {
            if (this.isOpen()) {
              this.close();
            }
            this.trigger("disable", {});
          } else {
            this.trigger("enable", {});
          }
        };
        Select2.prototype._isChangeMutation = function(evt, mutations) {
          var changed = false;
          var self2 = this;
          if (evt && evt.target && (evt.target.nodeName !== "OPTION" && evt.target.nodeName !== "OPTGROUP")) {
            return;
          }
          if (!mutations) {
            changed = true;
          } else if (mutations.addedNodes && mutations.addedNodes.length > 0) {
            for (var n2 = 0; n2 < mutations.addedNodes.length; n2++) {
              var node = mutations.addedNodes[n2];
              if (node.selected) {
                changed = true;
              }
            }
          } else if (mutations.removedNodes && mutations.removedNodes.length > 0) {
            changed = true;
          } else if ($2.isArray(mutations)) {
            $2.each(mutations, function(evt2, mutation) {
              if (self2._isChangeMutation(evt2, mutation)) {
                changed = true;
                return false;
              }
            });
          }
          return changed;
        };
        Select2.prototype._syncSubtree = function(evt, mutations) {
          var changed = this._isChangeMutation(evt, mutations);
          var self2 = this;
          if (changed) {
            this.dataAdapter.current(function(currentData) {
              self2.trigger("selection:update", {
                data: currentData
              });
            });
          }
        };
        Select2.prototype.trigger = function(name2, args) {
          var actualTrigger = Select2.__super__.trigger;
          var preTriggerMap = {
            "open": "opening",
            "close": "closing",
            "select": "selecting",
            "unselect": "unselecting",
            "clear": "clearing"
          };
          if (args === void 0) {
            args = {};
          }
          if (name2 in preTriggerMap) {
            var preTriggerName = preTriggerMap[name2];
            var preTriggerArgs = {
              prevented: false,
              name: name2,
              args
            };
            actualTrigger.call(this, preTriggerName, preTriggerArgs);
            if (preTriggerArgs.prevented) {
              args.prevented = true;
              return;
            }
          }
          actualTrigger.call(this, name2, args);
        };
        Select2.prototype.toggleDropdown = function() {
          if (this.isDisabled()) {
            return;
          }
          if (this.isOpen()) {
            this.close();
          } else {
            this.open();
          }
        };
        Select2.prototype.open = function() {
          if (this.isOpen()) {
            return;
          }
          if (this.isDisabled()) {
            return;
          }
          this.trigger("query", {});
        };
        Select2.prototype.close = function(evt) {
          if (!this.isOpen()) {
            return;
          }
          this.trigger("close", { originalEvent: evt });
        };
        Select2.prototype.isEnabled = function() {
          return !this.isDisabled();
        };
        Select2.prototype.isDisabled = function() {
          return this.options.get("disabled");
        };
        Select2.prototype.isOpen = function() {
          return this.$container.hasClass("select2-container--open");
        };
        Select2.prototype.hasFocus = function() {
          return this.$container.hasClass("select2-container--focus");
        };
        Select2.prototype.focus = function(data2) {
          if (this.hasFocus()) {
            return;
          }
          this.$container.addClass("select2-container--focus");
          this.trigger("focus", {});
        };
        Select2.prototype.enable = function(args) {
          if (this.options.get("debug") && window.console && console.warn) {
            console.warn(
              'Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'
            );
          }
          if (args == null || args.length === 0) {
            args = [true];
          }
          var disabled = !args[0];
          this.$element.prop("disabled", disabled);
        };
        Select2.prototype.data = function() {
          if (this.options.get("debug") && arguments.length > 0 && window.console && console.warn) {
            console.warn(
              'Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.'
            );
          }
          var data2 = [];
          this.dataAdapter.current(function(currentData) {
            data2 = currentData;
          });
          return data2;
        };
        Select2.prototype.val = function(args) {
          if (this.options.get("debug") && window.console && console.warn) {
            console.warn(
              'Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'
            );
          }
          if (args == null || args.length === 0) {
            return this.$element.val();
          }
          var newVal = args[0];
          if ($2.isArray(newVal)) {
            newVal = $2.map(newVal, function(obj) {
              return obj.toString();
            });
          }
          this.$element.val(newVal).trigger("input").trigger("change");
        };
        Select2.prototype.destroy = function() {
          this.$container.remove();
          if (this.$element[0].detachEvent) {
            this.$element[0].detachEvent("onpropertychange", this._syncA);
          }
          if (this._observer != null) {
            this._observer.disconnect();
            this._observer = null;
          } else if (this.$element[0].removeEventListener) {
            this.$element[0].removeEventListener("DOMAttrModified", this._syncA, false);
            this.$element[0].removeEventListener("DOMNodeInserted", this._syncS, false);
            this.$element[0].removeEventListener("DOMNodeRemoved", this._syncS, false);
          }
          this._syncA = null;
          this._syncS = null;
          this.$element.off(".select2");
          this.$element.attr(
            "tabindex",
            Utils.GetData(this.$element[0], "old-tabindex")
          );
          this.$element.removeClass("select2-hidden-accessible");
          this.$element.attr("aria-hidden", "false");
          Utils.RemoveData(this.$element[0]);
          this.$element.removeData("select2");
          this.dataAdapter.destroy();
          this.selection.destroy();
          this.dropdown.destroy();
          this.results.destroy();
          this.dataAdapter = null;
          this.selection = null;
          this.dropdown = null;
          this.results = null;
        };
        Select2.prototype.render = function() {
          var $container = $2(
            '<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>'
          );
          $container.attr("dir", this.options.get("dir"));
          this.$container = $container;
          this.$container.addClass("select2-container--" + this.options.get("theme"));
          Utils.StoreData($container[0], "element", this.$element);
          return $container;
        };
        return Select2;
      });
      S22.define("jquery-mousewheel", [
        "jquery"
      ], function($2) {
        return $2;
      });
      S22.define("jquery.select2", [
        "jquery",
        "jquery-mousewheel",
        "./select2/core",
        "./select2/defaults",
        "./select2/utils"
      ], function($2, _2, Select2, Defaults, Utils) {
        if ($2.fn.select2 == null) {
          var thisMethods = ["open", "close", "destroy"];
          $2.fn.select2 = function(options) {
            options = options || {};
            if (typeof options === "object") {
              this.each(function() {
                var instanceOptions = $2.extend(true, {}, options);
                new Select2($2(this), instanceOptions);
              });
              return this;
            } else if (typeof options === "string") {
              var ret;
              var args = Array.prototype.slice.call(arguments, 1);
              this.each(function() {
                var instance = Utils.GetData(this, "select2");
                if (instance == null && window.console && console.error) {
                  console.error(
                    "The select2('" + options + "') method was called on an element that is not using Select2."
                  );
                }
                ret = instance[options].apply(instance, args);
              });
              if ($2.inArray(options, thisMethods) > -1) {
                return this;
              }
              return ret;
            } else {
              throw new Error("Invalid arguments for Select2: " + options);
            }
          };
        }
        if ($2.fn.select2.defaults == null) {
          $2.fn.select2.defaults = Defaults;
        }
        return Select2;
      });
      return {
        define: S22.define,
        require: S22.require
      };
    }();
    var select22 = S2.require("jquery.select2");
    jQuery2.fn.select2.amd = S2;
    return select22;
  });
})(select2$1);
var select2Exports = select2$1.exports;
const select2 = /* @__PURE__ */ getDefaultExportFromCjs(select2Exports);
const select2_min = "";
var pace = { exports: {} };
/*!
 * pace.js v1.2.4
 * https://github.com/CodeByZach/pace/
 * Licensed MIT © HubSpot, Inc.
 */
(function(module, exports) {
  (function() {
    var AjaxMonitor, Bar, DocumentMonitor, ElementMonitor, ElementTracker, EventLagMonitor, Evented, Events, NoTargetError, Pace2, RequestIntercept, SOURCE_KEYS, Scaler, SocketRequestTracker, XHRRequestTracker, addEventListener, animation, avgAmplitude, bar, cancelAnimation, cancelAnimationFrame, defaultOptions2, extend2, extendNative, getFromDOM, getIntercept, handlePushState, ignoreStack, init2, now, options, requestAnimationFrame, result, runAnimation, scalers, shouldIgnoreURL, shouldTrack, source, sources, uniScaler, _WebSocket, _XDomainRequest, _XMLHttpRequest, _i2, _intercept, _len, _pushState, _ref, _ref1, _replaceState, __slice = [].slice, __hasProp = {}.hasOwnProperty, __extends = function(child, parent) {
      for (var key in parent) {
        if (__hasProp.call(parent, key))
          child[key] = parent[key];
      }
      function ctor() {
        this.constructor = child;
      }
      ctor.prototype = parent.prototype;
      child.prototype = new ctor();
      child.__super__ = parent.prototype;
      return child;
    }, __indexOf = [].indexOf || function(item2) {
      for (var i = 0, l2 = this.length; i < l2; i++) {
        if (i in this && this[i] === item2)
          return i;
      }
      return -1;
    }, __bind = function(fn3, me2) {
      return function() {
        return fn3.apply(me2, arguments);
      };
    };
    defaultOptions2 = {
      className: "",
      catchupTime: 100,
      initialRate: 0.03,
      minTime: 250,
      ghostTime: 100,
      maxProgressPerFrame: 20,
      easeFactor: 1.25,
      startOnPageLoad: true,
      restartOnPushState: true,
      restartOnRequestAfter: 500,
      target: "body",
      elements: {
        checkInterval: 100,
        selectors: ["body"]
      },
      eventLag: {
        minSamples: 10,
        sampleCount: 3,
        lagThreshold: 3
      },
      ajax: {
        trackMethods: ["GET"],
        trackWebSockets: true,
        ignoreURLs: []
      }
    };
    now = function() {
      var _ref2;
      return (_ref2 = typeof performance !== "undefined" && performance !== null ? typeof performance.now === "function" ? performance.now() : void 0 : void 0) != null ? _ref2 : +/* @__PURE__ */ new Date();
    };
    requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
    cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;
    addEventListener = function(obj, event, callback) {
      if (typeof obj.addEventListener === "function") {
        return obj.addEventListener(event, callback, false);
      } else {
        return function() {
          if (typeof obj["on" + event] !== "function" || typeof obj["on" + event].eventListeners !== "object") {
            var eventListeners2 = new Events();
            if (typeof obj["on" + event] === "function") {
              eventListeners2.on(event, obj["on" + event]);
            }
            obj["on" + event] = function(evt) {
              return eventListeners2.trigger(event, evt);
            };
            obj["on" + event].eventListeners = eventListeners2;
          } else {
            var eventListeners2 = obj["on" + event].eventListeners;
          }
          eventListeners2.on(event, callback);
        }();
      }
    };
    if (requestAnimationFrame == null) {
      requestAnimationFrame = function(fn3) {
        return setTimeout(fn3, 50);
      };
      cancelAnimationFrame = function(id) {
        return clearTimeout(id);
      };
    }
    runAnimation = function(fn3) {
      var last, tick;
      last = now();
      tick = function() {
        var diff;
        diff = now() - last;
        if (diff >= 33) {
          last = now();
          return fn3(diff, function() {
            return requestAnimationFrame(tick);
          });
        } else {
          return setTimeout(tick, 33 - diff);
        }
      };
      return tick();
    };
    result = function() {
      var args, key, obj;
      obj = arguments[0], key = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
      if (typeof obj[key] === "function") {
        return obj[key].apply(obj, args);
      } else {
        return obj[key];
      }
    };
    extend2 = function() {
      var key, out, source2, sources2, val, _i3, _len2;
      out = arguments[0], sources2 = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      for (_i3 = 0, _len2 = sources2.length; _i3 < _len2; _i3++) {
        source2 = sources2[_i3];
        if (source2) {
          for (key in source2) {
            if (!__hasProp.call(source2, key))
              continue;
            val = source2[key];
            if (out[key] != null && typeof out[key] === "object" && val != null && typeof val === "object") {
              extend2(out[key], val);
            } else {
              out[key] = val;
            }
          }
        }
      }
      return out;
    };
    avgAmplitude = function(arr) {
      var count, sum, v2, _i3, _len2;
      sum = count = 0;
      for (_i3 = 0, _len2 = arr.length; _i3 < _len2; _i3++) {
        v2 = arr[_i3];
        sum += Math.abs(v2);
        count++;
      }
      return sum / count;
    };
    getFromDOM = function(key, json) {
      var data2, e2, el;
      if (key == null) {
        key = "options";
      }
      if (json == null) {
        json = true;
      }
      el = document.querySelector("[data-pace-" + key + "]");
      if (!el) {
        return;
      }
      data2 = el.getAttribute("data-pace-" + key);
      if (!json) {
        return data2;
      }
      try {
        return JSON.parse(data2);
      } catch (_error) {
        e2 = _error;
        return typeof console !== "undefined" && console !== null ? console.error("Error parsing inline pace options", e2) : void 0;
      }
    };
    Evented = function() {
      function Evented2() {
      }
      Evented2.prototype.on = function(event, handler, ctx, once2) {
        var _base;
        if (once2 == null) {
          once2 = false;
        }
        if (this.bindings == null) {
          this.bindings = {};
        }
        if ((_base = this.bindings)[event] == null) {
          _base[event] = [];
        }
        return this.bindings[event].push({
          handler,
          ctx,
          once: once2
        });
      };
      Evented2.prototype.once = function(event, handler, ctx) {
        return this.on(event, handler, ctx, true);
      };
      Evented2.prototype.off = function(event, handler) {
        var i, _ref2, _results;
        if (((_ref2 = this.bindings) != null ? _ref2[event] : void 0) == null) {
          return;
        }
        if (handler == null) {
          return delete this.bindings[event];
        } else {
          i = 0;
          _results = [];
          while (i < this.bindings[event].length) {
            if (this.bindings[event][i].handler === handler) {
              _results.push(this.bindings[event].splice(i, 1));
            } else {
              _results.push(i++);
            }
          }
          return _results;
        }
      };
      Evented2.prototype.trigger = function() {
        var args, ctx, event, handler, i, once2, _ref2, _ref12, _results;
        event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        if ((_ref2 = this.bindings) != null ? _ref2[event] : void 0) {
          i = 0;
          _results = [];
          while (i < this.bindings[event].length) {
            _ref12 = this.bindings[event][i], handler = _ref12.handler, ctx = _ref12.ctx, once2 = _ref12.once;
            handler.apply(ctx != null ? ctx : this, args);
            if (once2) {
              _results.push(this.bindings[event].splice(i, 1));
            } else {
              _results.push(i++);
            }
          }
          return _results;
        }
      };
      return Evented2;
    }();
    Pace2 = window.Pace || {};
    window.Pace = Pace2;
    extend2(Pace2, Evented.prototype);
    options = Pace2.options = extend2({}, defaultOptions2, window.paceOptions, getFromDOM());
    _ref = ["ajax", "document", "eventLag", "elements"];
    for (_i2 = 0, _len = _ref.length; _i2 < _len; _i2++) {
      source = _ref[_i2];
      if (options[source] === true) {
        options[source] = defaultOptions2[source];
      }
    }
    NoTargetError = function(_super) {
      __extends(NoTargetError2, _super);
      function NoTargetError2() {
        _ref1 = NoTargetError2.__super__.constructor.apply(this, arguments);
        return _ref1;
      }
      return NoTargetError2;
    }(Error);
    Bar = function() {
      function Bar2() {
        this.progress = 0;
      }
      Bar2.prototype.getElement = function() {
        var targetElement;
        if (this.el == null) {
          targetElement = document.querySelector(options.target);
          if (!targetElement) {
            throw new NoTargetError();
          }
          this.el = document.createElement("div");
          this.el.className = "pace pace-active";
          document.body.className = document.body.className.replace(/(pace-done )|/, "pace-running ");
          var _custom_class_name = options.className !== "" ? " " + options.className : "";
          this.el.innerHTML = '<div class="pace-progress' + _custom_class_name + '">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>';
          if (targetElement.firstChild != null) {
            targetElement.insertBefore(this.el, targetElement.firstChild);
          } else {
            targetElement.appendChild(this.el);
          }
        }
        return this.el;
      };
      Bar2.prototype.finish = function() {
        var el;
        el = this.getElement();
        el.className = el.className.replace("pace-active", "pace-inactive");
        return document.body.className = document.body.className.replace("pace-running ", "pace-done ");
      };
      Bar2.prototype.update = function(prog) {
        this.progress = prog;
        Pace2.trigger("progress", prog);
        return this.render();
      };
      Bar2.prototype.destroy = function() {
        try {
          this.getElement().parentNode.removeChild(this.getElement());
        } catch (_error) {
          NoTargetError = _error;
        }
        return this.el = void 0;
      };
      Bar2.prototype.render = function() {
        var el, key, progressStr, transform, _j, _len1, _ref2;
        if (document.querySelector(options.target) == null) {
          return false;
        }
        el = this.getElement();
        transform = "translate3d(" + this.progress + "%, 0, 0)";
        _ref2 = ["webkitTransform", "msTransform", "transform"];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          key = _ref2[_j];
          el.children[0].style[key] = transform;
        }
        if (!this.lastRenderedProgress || this.lastRenderedProgress | 0 !== this.progress | 0) {
          el.children[0].setAttribute("data-progress-text", "" + (this.progress | 0) + "%");
          if (this.progress >= 100) {
            progressStr = "99";
          } else {
            progressStr = this.progress < 10 ? "0" : "";
            progressStr += this.progress | 0;
          }
          el.children[0].setAttribute("data-progress", "" + progressStr);
        }
        Pace2.trigger("change", this.progress);
        return this.lastRenderedProgress = this.progress;
      };
      Bar2.prototype.done = function() {
        return this.progress >= 100;
      };
      return Bar2;
    }();
    Events = function() {
      function Events2() {
        this.bindings = {};
      }
      Events2.prototype.trigger = function(name2, val) {
        var binding, _j, _len1, _ref2, _results;
        if (this.bindings[name2] != null) {
          _ref2 = this.bindings[name2];
          _results = [];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            binding = _ref2[_j];
            _results.push(binding.call(this, val));
          }
          return _results;
        }
      };
      Events2.prototype.on = function(name2, fn3) {
        var _base;
        if ((_base = this.bindings)[name2] == null) {
          _base[name2] = [];
        }
        return this.bindings[name2].push(fn3);
      };
      return Events2;
    }();
    _XMLHttpRequest = window.XMLHttpRequest;
    _XDomainRequest = window.XDomainRequest;
    _WebSocket = window.WebSocket;
    extendNative = function(to, from) {
      var key, _results;
      _results = [];
      for (key in from.prototype) {
        try {
          if (to[key] == null && typeof from[key] !== "function") {
            if (typeof Object.defineProperty === "function") {
              _results.push(Object.defineProperty(to, key, {
                get: function(key2) {
                  return function() {
                    return from.prototype[key2];
                  };
                }(key),
                configurable: true,
                enumerable: true
              }));
            } else {
              _results.push(to[key] = from.prototype[key]);
            }
          } else {
            _results.push(void 0);
          }
        } catch (_error) {
        }
      }
      return _results;
    };
    ignoreStack = [];
    Pace2.ignore = function() {
      var args, fn3, ret;
      fn3 = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      ignoreStack.unshift("ignore");
      ret = fn3.apply(null, args);
      ignoreStack.shift();
      return ret;
    };
    Pace2.track = function() {
      var args, fn3, ret;
      fn3 = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      ignoreStack.unshift("track");
      ret = fn3.apply(null, args);
      ignoreStack.shift();
      return ret;
    };
    shouldTrack = function(method) {
      var _ref2;
      if (method == null) {
        method = "GET";
      }
      if (ignoreStack[0] === "track") {
        return "force";
      }
      if (!ignoreStack.length && options.ajax) {
        if (method === "socket" && options.ajax.trackWebSockets) {
          return true;
        } else if (_ref2 = method.toUpperCase(), __indexOf.call(options.ajax.trackMethods, _ref2) >= 0) {
          return true;
        }
      }
      return false;
    };
    RequestIntercept = function(_super) {
      __extends(RequestIntercept2, _super);
      function RequestIntercept2() {
        var monitorXHR, _this = this;
        RequestIntercept2.__super__.constructor.apply(this, arguments);
        monitorXHR = function(req) {
          var _open;
          _open = req.open;
          return req.open = function(type, url, async) {
            if (shouldTrack(type)) {
              _this.trigger("request", {
                type,
                url,
                request: req
              });
            }
            return _open.apply(req, arguments);
          };
        };
        window.XMLHttpRequest = function(flags) {
          var req;
          req = new _XMLHttpRequest(flags);
          monitorXHR(req);
          return req;
        };
        try {
          extendNative(window.XMLHttpRequest, _XMLHttpRequest);
        } catch (_error) {
        }
        if (_XDomainRequest != null) {
          window.XDomainRequest = function() {
            var req;
            req = new _XDomainRequest();
            monitorXHR(req);
            return req;
          };
          try {
            extendNative(window.XDomainRequest, _XDomainRequest);
          } catch (_error) {
          }
        }
        if (_WebSocket != null && options.ajax.trackWebSockets) {
          window.WebSocket = function(url, protocols) {
            var req;
            if (protocols != null) {
              req = new _WebSocket(url, protocols);
            } else {
              req = new _WebSocket(url);
            }
            if (shouldTrack("socket")) {
              _this.trigger("request", {
                type: "socket",
                url,
                protocols,
                request: req
              });
            }
            return req;
          };
          try {
            extendNative(window.WebSocket, _WebSocket);
          } catch (_error) {
          }
        }
      }
      return RequestIntercept2;
    }(Events);
    _intercept = null;
    getIntercept = function() {
      if (_intercept == null) {
        _intercept = new RequestIntercept();
      }
      return _intercept;
    };
    shouldIgnoreURL = function(url) {
      var pattern, _j, _len1, _ref2;
      _ref2 = options.ajax.ignoreURLs;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        pattern = _ref2[_j];
        if (typeof pattern === "string") {
          if (url.indexOf(pattern) !== -1) {
            return true;
          }
        } else {
          if (pattern.test(url)) {
            return true;
          }
        }
      }
      return false;
    };
    getIntercept().on("request", function(_arg) {
      var after, args, request, type, url;
      type = _arg.type, request = _arg.request, url = _arg.url;
      if (shouldIgnoreURL(url)) {
        return;
      }
      if (!Pace2.running && (options.restartOnRequestAfter !== false || shouldTrack(type) === "force")) {
        args = arguments;
        after = options.restartOnRequestAfter || 0;
        if (typeof after === "boolean") {
          after = 0;
        }
        return setTimeout(function() {
          var stillActive, _j, _len1, _ref2, _ref3, _results;
          if (type === "socket") {
            stillActive = request.readyState < 1;
          } else {
            stillActive = 0 < (_ref2 = request.readyState) && _ref2 < 4;
          }
          if (stillActive) {
            Pace2.restart();
            _ref3 = Pace2.sources;
            _results = [];
            for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
              source = _ref3[_j];
              if (source instanceof AjaxMonitor) {
                source.watch.apply(source, args);
                break;
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }, after);
      }
    });
    AjaxMonitor = function() {
      function AjaxMonitor2() {
        this.complete = __bind(this.complete, this);
        var _this = this;
        this.elements = [];
        getIntercept().on("request", function() {
          return _this.watch.apply(_this, arguments);
        });
      }
      AjaxMonitor2.prototype.watch = function(_arg) {
        var request, tracker, type, url;
        type = _arg.type, request = _arg.request, url = _arg.url;
        if (shouldIgnoreURL(url)) {
          return;
        }
        if (type === "socket") {
          tracker = new SocketRequestTracker(request, this.complete);
        } else {
          tracker = new XHRRequestTracker(request, this.complete);
        }
        return this.elements.push(tracker);
      };
      AjaxMonitor2.prototype.complete = function(tracker) {
        return this.elements = this.elements.filter(function(e2) {
          return e2 !== tracker;
        });
      };
      return AjaxMonitor2;
    }();
    XHRRequestTracker = function() {
      function XHRRequestTracker2(request, completeCallback) {
        var event, _j, _len1, _onreadystatechange, _ref2, _this = this;
        this.progress = 0;
        if (window.ProgressEvent != null) {
          addEventListener(request, "progress", function(evt) {
            if (evt.lengthComputable) {
              return _this.progress = 100 * evt.loaded / evt.total;
            } else {
              return _this.progress = _this.progress + (100 - _this.progress) / 2;
            }
          }, false);
          _ref2 = ["load", "abort", "timeout", "error"];
          for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
            event = _ref2[_j];
            addEventListener(request, event, function() {
              completeCallback(_this);
              return _this.progress = 100;
            }, false);
          }
        } else {
          _onreadystatechange = request.onreadystatechange;
          request.onreadystatechange = function() {
            var _ref3;
            if ((_ref3 = request.readyState) === 0 || _ref3 === 4) {
              completeCallback(_this);
              _this.progress = 100;
            } else if (request.readyState === 3) {
              _this.progress = 50;
            }
            return typeof _onreadystatechange === "function" ? _onreadystatechange.apply(null, arguments) : void 0;
          };
        }
      }
      return XHRRequestTracker2;
    }();
    SocketRequestTracker = function() {
      function SocketRequestTracker2(request, completeCallback) {
        var event, _j, _len1, _ref2, _this = this;
        this.progress = 0;
        _ref2 = ["error", "open"];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          event = _ref2[_j];
          addEventListener(request, event, function() {
            completeCallback(_this);
            return _this.progress = 100;
          }, false);
        }
      }
      return SocketRequestTracker2;
    }();
    ElementMonitor = function() {
      function ElementMonitor2(options2) {
        var selector, _j, _len1, _ref2;
        if (options2 == null) {
          options2 = {};
        }
        this.complete = __bind(this.complete, this);
        this.elements = [];
        if (options2.selectors == null) {
          options2.selectors = [];
        }
        _ref2 = options2.selectors;
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          selector = _ref2[_j];
          this.elements.push(new ElementTracker(selector, this.complete));
        }
      }
      ElementMonitor2.prototype.complete = function(tracker) {
        return this.elements = this.elements.filter(function(e2) {
          return e2 !== tracker;
        });
      };
      return ElementMonitor2;
    }();
    ElementTracker = function() {
      function ElementTracker2(selector, completeCallback) {
        this.selector = selector;
        this.completeCallback = completeCallback;
        this.progress = 0;
        this.check();
      }
      ElementTracker2.prototype.check = function() {
        var _this = this;
        if (document.querySelector(this.selector)) {
          return this.done();
        } else {
          return setTimeout(function() {
            return _this.check();
          }, options.elements.checkInterval);
        }
      };
      ElementTracker2.prototype.done = function() {
        this.completeCallback(this);
        this.completeCallback = null;
        return this.progress = 100;
      };
      return ElementTracker2;
    }();
    DocumentMonitor = function() {
      DocumentMonitor2.prototype.states = {
        loading: 0,
        interactive: 50,
        complete: 100
      };
      function DocumentMonitor2() {
        var _onreadystatechange, _ref2, _this = this;
        this.progress = (_ref2 = this.states[document.readyState]) != null ? _ref2 : 100;
        _onreadystatechange = document.onreadystatechange;
        document.onreadystatechange = function() {
          if (_this.states[document.readyState] != null) {
            _this.progress = _this.states[document.readyState];
          }
          return typeof _onreadystatechange === "function" ? _onreadystatechange.apply(null, arguments) : void 0;
        };
      }
      return DocumentMonitor2;
    }();
    EventLagMonitor = function() {
      function EventLagMonitor2() {
        var avg, interval, last, points, samples, _this = this;
        this.progress = 0;
        avg = 0;
        samples = [];
        points = 0;
        last = now();
        interval = setInterval(function() {
          var diff;
          diff = now() - last - 50;
          last = now();
          samples.push(diff);
          if (samples.length > options.eventLag.sampleCount) {
            samples.shift();
          }
          avg = avgAmplitude(samples);
          if (++points >= options.eventLag.minSamples && avg < options.eventLag.lagThreshold) {
            _this.progress = 100;
            return clearInterval(interval);
          } else {
            return _this.progress = 100 * (3 / (avg + 3));
          }
        }, 50);
      }
      return EventLagMonitor2;
    }();
    Scaler = function() {
      function Scaler2(source2) {
        this.source = source2;
        this.last = this.sinceLastUpdate = 0;
        this.rate = options.initialRate;
        this.catchup = 0;
        this.progress = this.lastProgress = 0;
        if (this.source != null) {
          this.progress = result(this.source, "progress");
        }
      }
      Scaler2.prototype.tick = function(frameTime, val) {
        var scaling;
        if (val == null) {
          val = result(this.source, "progress");
        }
        if (val >= 100) {
          this.done = true;
        }
        if (val === this.last) {
          this.sinceLastUpdate += frameTime;
        } else {
          if (this.sinceLastUpdate) {
            this.rate = (val - this.last) / this.sinceLastUpdate;
          }
          this.catchup = (val - this.progress) / options.catchupTime;
          this.sinceLastUpdate = 0;
          this.last = val;
        }
        if (val > this.progress) {
          this.progress += this.catchup * frameTime;
        }
        scaling = 1 - Math.pow(this.progress / 100, options.easeFactor);
        this.progress += scaling * this.rate * frameTime;
        this.progress = Math.min(this.lastProgress + options.maxProgressPerFrame, this.progress);
        this.progress = Math.max(0, this.progress);
        this.progress = Math.min(100, this.progress);
        this.lastProgress = this.progress;
        return this.progress;
      };
      return Scaler2;
    }();
    sources = null;
    scalers = null;
    bar = null;
    uniScaler = null;
    animation = null;
    cancelAnimation = null;
    Pace2.running = false;
    handlePushState = function() {
      if (options.restartOnPushState) {
        return Pace2.restart();
      }
    };
    if (window.history.pushState != null) {
      _pushState = window.history.pushState;
      window.history.pushState = function() {
        handlePushState();
        return _pushState.apply(window.history, arguments);
      };
    }
    if (window.history.replaceState != null) {
      _replaceState = window.history.replaceState;
      window.history.replaceState = function() {
        handlePushState();
        return _replaceState.apply(window.history, arguments);
      };
    }
    SOURCE_KEYS = {
      ajax: AjaxMonitor,
      elements: ElementMonitor,
      document: DocumentMonitor,
      eventLag: EventLagMonitor
    };
    (init2 = function() {
      var type, _j, _k, _len1, _len2, _ref2, _ref3, _ref4;
      Pace2.sources = sources = [];
      _ref2 = ["ajax", "elements", "document", "eventLag"];
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        type = _ref2[_j];
        if (options[type] !== false) {
          sources.push(new SOURCE_KEYS[type](options[type]));
        }
      }
      _ref4 = (_ref3 = options.extraSources) != null ? _ref3 : [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        source = _ref4[_k];
        sources.push(new source(options));
      }
      Pace2.bar = bar = new Bar();
      scalers = [];
      return uniScaler = new Scaler();
    })();
    Pace2.stop = function() {
      Pace2.trigger("stop");
      Pace2.running = false;
      bar.destroy();
      cancelAnimation = true;
      if (animation != null) {
        if (typeof cancelAnimationFrame === "function") {
          cancelAnimationFrame(animation);
        }
        animation = null;
      }
      return init2();
    };
    Pace2.restart = function() {
      Pace2.trigger("restart");
      Pace2.stop();
      return Pace2.start();
    };
    Pace2.go = function() {
      var start2;
      Pace2.running = true;
      bar.render();
      start2 = now();
      cancelAnimation = false;
      return animation = runAnimation(function(frameTime, enqueueNextFrame) {
        var avg, count, done, element, elements, i, j2, scaler, scalerList, sum, _j, _k, _len1, _len2, _ref2;
        100 - bar.progress;
        count = sum = 0;
        done = true;
        for (i = _j = 0, _len1 = sources.length; _j < _len1; i = ++_j) {
          source = sources[i];
          scalerList = scalers[i] != null ? scalers[i] : scalers[i] = [];
          elements = (_ref2 = source.elements) != null ? _ref2 : [source];
          for (j2 = _k = 0, _len2 = elements.length; _k < _len2; j2 = ++_k) {
            element = elements[j2];
            scaler = scalerList[j2] != null ? scalerList[j2] : scalerList[j2] = new Scaler(element);
            done &= scaler.done;
            if (scaler.done) {
              continue;
            }
            count++;
            sum += scaler.tick(frameTime);
          }
        }
        avg = sum / count;
        bar.update(uniScaler.tick(frameTime, avg));
        if (bar.done() || done || cancelAnimation) {
          bar.update(100);
          Pace2.trigger("done");
          return setTimeout(function() {
            bar.finish();
            Pace2.running = false;
            return Pace2.trigger("hide");
          }, Math.max(options.ghostTime, Math.max(options.minTime - (now() - start2), 0)));
        } else {
          return enqueueNextFrame();
        }
      });
    };
    Pace2.start = function(_options) {
      extend2(options, _options);
      Pace2.running = true;
      try {
        bar.render();
      } catch (_error) {
        NoTargetError = _error;
      }
      if (!document.querySelector(".pace")) {
        return setTimeout(Pace2.start, 50);
      } else {
        Pace2.trigger("start");
        return Pace2.go();
      }
    };
    {
      module.exports = Pace2;
    }
  }).call(commonjsGlobal);
})(pace);
var bootstrap_bundle_min = { exports: {} };
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    const t2 = /* @__PURE__ */ new Map(), e2 = { set(e3, i2, n3) {
      t2.has(e3) || t2.set(e3, /* @__PURE__ */ new Map());
      const s3 = t2.get(e3);
      s3.has(i2) || 0 === s3.size ? s3.set(i2, n3) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s3.keys())[0]}.`);
    }, get: (e3, i2) => t2.has(e3) && t2.get(e3).get(i2) || null, remove(e3, i2) {
      if (!t2.has(e3))
        return;
      const n3 = t2.get(e3);
      n3.delete(i2), 0 === n3.size && t2.delete(e3);
    } }, i = "transitionend", n2 = (t3) => (t3 && window.CSS && window.CSS.escape && (t3 = t3.replace(/#([^\s"#']+)/g, (t4, e3) => `#${CSS.escape(e3)}`)), t3), s2 = (t3) => {
      t3.dispatchEvent(new Event(i));
    }, o2 = (t3) => !(!t3 || "object" != typeof t3) && (void 0 !== t3.jquery && (t3 = t3[0]), void 0 !== t3.nodeType), r2 = (t3) => o2(t3) ? t3.jquery ? t3[0] : t3 : "string" == typeof t3 && t3.length > 0 ? document.querySelector(n2(t3)) : null, a2 = (t3) => {
      if (!o2(t3) || 0 === t3.getClientRects().length)
        return false;
      const e3 = "visible" === getComputedStyle(t3).getPropertyValue("visibility"), i2 = t3.closest("details:not([open])");
      if (!i2)
        return e3;
      if (i2 !== t3) {
        const e4 = t3.closest("summary");
        if (e4 && e4.parentNode !== i2)
          return false;
        if (null === e4)
          return false;
      }
      return e3;
    }, l2 = (t3) => !t3 || t3.nodeType !== Node.ELEMENT_NODE || !!t3.classList.contains("disabled") || (void 0 !== t3.disabled ? t3.disabled : t3.hasAttribute("disabled") && "false" !== t3.getAttribute("disabled")), c2 = (t3) => {
      if (!document.documentElement.attachShadow)
        return null;
      if ("function" == typeof t3.getRootNode) {
        const e3 = t3.getRootNode();
        return e3 instanceof ShadowRoot ? e3 : null;
      }
      return t3 instanceof ShadowRoot ? t3 : t3.parentNode ? c2(t3.parentNode) : null;
    }, h2 = () => {
    }, d2 = (t3) => {
      t3.offsetHeight;
    }, u2 = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, f2 = [], p2 = () => "rtl" === document.documentElement.dir, m2 = (t3) => {
      var e3;
      e3 = () => {
        const e4 = u2();
        if (e4) {
          const i2 = t3.NAME, n3 = e4.fn[i2];
          e4.fn[i2] = t3.jQueryInterface, e4.fn[i2].Constructor = t3, e4.fn[i2].noConflict = () => (e4.fn[i2] = n3, t3.jQueryInterface);
        }
      }, "loading" === document.readyState ? (f2.length || document.addEventListener("DOMContentLoaded", () => {
        for (const t4 of f2)
          t4();
      }), f2.push(e3)) : e3();
    }, g2 = (t3, e3 = [], i2 = t3) => "function" == typeof t3 ? t3(...e3) : i2, _2 = (t3, e3, n3 = true) => {
      if (!n3)
        return void g2(t3);
      const o3 = ((t4) => {
        if (!t4)
          return 0;
        let { transitionDuration: e4, transitionDelay: i2 } = window.getComputedStyle(t4);
        const n4 = Number.parseFloat(e4), s3 = Number.parseFloat(i2);
        return n4 || s3 ? (e4 = e4.split(",")[0], i2 = i2.split(",")[0], 1e3 * (Number.parseFloat(e4) + Number.parseFloat(i2))) : 0;
      })(e3) + 5;
      let r3 = false;
      const a3 = ({ target: n4 }) => {
        n4 === e3 && (r3 = true, e3.removeEventListener(i, a3), g2(t3));
      };
      e3.addEventListener(i, a3), setTimeout(() => {
        r3 || s2(e3);
      }, o3);
    }, b2 = (t3, e3, i2, n3) => {
      const s3 = t3.length;
      let o3 = t3.indexOf(e3);
      return -1 === o3 ? !i2 && n3 ? t3[s3 - 1] : t3[0] : (o3 += i2 ? 1 : -1, n3 && (o3 = (o3 + s3) % s3), t3[Math.max(0, Math.min(o3, s3 - 1))]);
    }, v2 = /[^.]*(?=\..*)\.|.*/, y2 = /\..*/, w2 = /::\d+$/, A2 = {};
    let E2 = 1;
    const T2 = { mouseenter: "mouseover", mouseleave: "mouseout" }, C2 = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
    function O2(t3, e3) {
      return e3 && `${e3}::${E2++}` || t3.uidEvent || E2++;
    }
    function x2(t3) {
      const e3 = O2(t3);
      return t3.uidEvent = e3, A2[e3] = A2[e3] || {}, A2[e3];
    }
    function k2(t3, e3, i2 = null) {
      return Object.values(t3).find((t4) => t4.callable === e3 && t4.delegationSelector === i2);
    }
    function L2(t3, e3, i2) {
      const n3 = "string" == typeof e3, s3 = n3 ? i2 : e3 || i2;
      let o3 = I2(t3);
      return C2.has(o3) || (o3 = t3), [n3, s3, o3];
    }
    function S2(t3, e3, i2, n3, s3) {
      if ("string" != typeof e3 || !t3)
        return;
      let [o3, r3, a3] = L2(e3, i2, n3);
      if (e3 in T2) {
        const t4 = (t5) => function(e4) {
          if (!e4.relatedTarget || e4.relatedTarget !== e4.delegateTarget && !e4.delegateTarget.contains(e4.relatedTarget))
            return t5.call(this, e4);
        };
        r3 = t4(r3);
      }
      const l3 = x2(t3), c3 = l3[a3] || (l3[a3] = {}), h3 = k2(c3, r3, o3 ? i2 : null);
      if (h3)
        return void (h3.oneOff = h3.oneOff && s3);
      const d3 = O2(r3, e3.replace(v2, "")), u3 = o3 ? function(t4, e4, i3) {
        return function n4(s4) {
          const o4 = t4.querySelectorAll(e4);
          for (let { target: r4 } = s4; r4 && r4 !== this; r4 = r4.parentNode)
            for (const a4 of o4)
              if (a4 === r4)
                return P2(s4, { delegateTarget: r4 }), n4.oneOff && N2.off(t4, s4.type, e4, i3), i3.apply(r4, [s4]);
        };
      }(t3, i2, r3) : function(t4, e4) {
        return function i3(n4) {
          return P2(n4, { delegateTarget: t4 }), i3.oneOff && N2.off(t4, n4.type, e4), e4.apply(t4, [n4]);
        };
      }(t3, r3);
      u3.delegationSelector = o3 ? i2 : null, u3.callable = r3, u3.oneOff = s3, u3.uidEvent = d3, c3[d3] = u3, t3.addEventListener(a3, u3, o3);
    }
    function D2(t3, e3, i2, n3, s3) {
      const o3 = k2(e3[i2], n3, s3);
      o3 && (t3.removeEventListener(i2, o3, Boolean(s3)), delete e3[i2][o3.uidEvent]);
    }
    function $2(t3, e3, i2, n3) {
      const s3 = e3[i2] || {};
      for (const [o3, r3] of Object.entries(s3))
        o3.includes(n3) && D2(t3, e3, i2, r3.callable, r3.delegationSelector);
    }
    function I2(t3) {
      return t3 = t3.replace(y2, ""), T2[t3] || t3;
    }
    const N2 = { on(t3, e3, i2, n3) {
      S2(t3, e3, i2, n3, false);
    }, one(t3, e3, i2, n3) {
      S2(t3, e3, i2, n3, true);
    }, off(t3, e3, i2, n3) {
      if ("string" != typeof e3 || !t3)
        return;
      const [s3, o3, r3] = L2(e3, i2, n3), a3 = r3 !== e3, l3 = x2(t3), c3 = l3[r3] || {}, h3 = e3.startsWith(".");
      if (void 0 === o3) {
        if (h3)
          for (const i3 of Object.keys(l3))
            $2(t3, l3, i3, e3.slice(1));
        for (const [i3, n4] of Object.entries(c3)) {
          const s4 = i3.replace(w2, "");
          a3 && !e3.includes(s4) || D2(t3, l3, r3, n4.callable, n4.delegationSelector);
        }
      } else {
        if (!Object.keys(c3).length)
          return;
        D2(t3, l3, r3, o3, s3 ? i2 : null);
      }
    }, trigger(t3, e3, i2) {
      if ("string" != typeof e3 || !t3)
        return null;
      const n3 = u2();
      let s3 = null, o3 = true, r3 = true, a3 = false;
      e3 !== I2(e3) && n3 && (s3 = n3.Event(e3, i2), n3(t3).trigger(s3), o3 = !s3.isPropagationStopped(), r3 = !s3.isImmediatePropagationStopped(), a3 = s3.isDefaultPrevented());
      const l3 = P2(new Event(e3, { bubbles: o3, cancelable: true }), i2);
      return a3 && l3.preventDefault(), r3 && t3.dispatchEvent(l3), l3.defaultPrevented && s3 && s3.preventDefault(), l3;
    } };
    function P2(t3, e3 = {}) {
      for (const [i2, n3] of Object.entries(e3))
        try {
          t3[i2] = n3;
        } catch (e4) {
          Object.defineProperty(t3, i2, { configurable: true, get: () => n3 });
        }
      return t3;
    }
    function j2(t3) {
      if ("true" === t3)
        return true;
      if ("false" === t3)
        return false;
      if (t3 === Number(t3).toString())
        return Number(t3);
      if ("" === t3 || "null" === t3)
        return null;
      if ("string" != typeof t3)
        return t3;
      try {
        return JSON.parse(decodeURIComponent(t3));
      } catch (e3) {
        return t3;
      }
    }
    function M2(t3) {
      return t3.replace(/[A-Z]/g, (t4) => `-${t4.toLowerCase()}`);
    }
    const F2 = { setDataAttribute(t3, e3, i2) {
      t3.setAttribute(`data-bs-${M2(e3)}`, i2);
    }, removeDataAttribute(t3, e3) {
      t3.removeAttribute(`data-bs-${M2(e3)}`);
    }, getDataAttributes(t3) {
      if (!t3)
        return {};
      const e3 = {}, i2 = Object.keys(t3.dataset).filter((t4) => t4.startsWith("bs") && !t4.startsWith("bsConfig"));
      for (const n3 of i2) {
        let i3 = n3.replace(/^bs/, "");
        i3 = i3.charAt(0).toLowerCase() + i3.slice(1, i3.length), e3[i3] = j2(t3.dataset[n3]);
      }
      return e3;
    }, getDataAttribute: (t3, e3) => j2(t3.getAttribute(`data-bs-${M2(e3)}`)) };
    class H2 {
      static get Default() {
        return {};
      }
      static get DefaultType() {
        return {};
      }
      static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!');
      }
      _getConfig(t3) {
        return t3 = this._mergeConfigObj(t3), t3 = this._configAfterMerge(t3), this._typeCheckConfig(t3), t3;
      }
      _configAfterMerge(t3) {
        return t3;
      }
      _mergeConfigObj(t3, e3) {
        const i2 = o2(e3) ? F2.getDataAttribute(e3, "config") : {};
        return { ...this.constructor.Default, ..."object" == typeof i2 ? i2 : {}, ...o2(e3) ? F2.getDataAttributes(e3) : {}, ..."object" == typeof t3 ? t3 : {} };
      }
      _typeCheckConfig(t3, e3 = this.constructor.DefaultType) {
        for (const [n3, s3] of Object.entries(e3)) {
          const e4 = t3[n3], r3 = o2(e4) ? "element" : null == (i2 = e4) ? `${i2}` : Object.prototype.toString.call(i2).match(/\s([a-z]+)/i)[1].toLowerCase();
          if (!new RegExp(s3).test(r3))
            throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n3}" provided type "${r3}" but expected type "${s3}".`);
        }
        var i2;
      }
    }
    class W2 extends H2 {
      constructor(t3, i2) {
        super(), (t3 = r2(t3)) && (this._element = t3, this._config = this._getConfig(i2), e2.set(this._element, this.constructor.DATA_KEY, this));
      }
      dispose() {
        e2.remove(this._element, this.constructor.DATA_KEY), N2.off(this._element, this.constructor.EVENT_KEY);
        for (const t3 of Object.getOwnPropertyNames(this))
          this[t3] = null;
      }
      _queueCallback(t3, e3, i2 = true) {
        _2(t3, e3, i2);
      }
      _getConfig(t3) {
        return t3 = this._mergeConfigObj(t3, this._element), t3 = this._configAfterMerge(t3), this._typeCheckConfig(t3), t3;
      }
      static getInstance(t3) {
        return e2.get(r2(t3), this.DATA_KEY);
      }
      static getOrCreateInstance(t3, e3 = {}) {
        return this.getInstance(t3) || new this(t3, "object" == typeof e3 ? e3 : null);
      }
      static get VERSION() {
        return "5.3.3";
      }
      static get DATA_KEY() {
        return `bs.${this.NAME}`;
      }
      static get EVENT_KEY() {
        return `.${this.DATA_KEY}`;
      }
      static eventName(t3) {
        return `${t3}${this.EVENT_KEY}`;
      }
    }
    const B2 = (t3) => {
      let e3 = t3.getAttribute("data-bs-target");
      if (!e3 || "#" === e3) {
        let i2 = t3.getAttribute("href");
        if (!i2 || !i2.includes("#") && !i2.startsWith("."))
          return null;
        i2.includes("#") && !i2.startsWith("#") && (i2 = `#${i2.split("#")[1]}`), e3 = i2 && "#" !== i2 ? i2.trim() : null;
      }
      return e3 ? e3.split(",").map((t4) => n2(t4)).join(",") : null;
    }, z2 = { find: (t3, e3 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(e3, t3)), findOne: (t3, e3 = document.documentElement) => Element.prototype.querySelector.call(e3, t3), children: (t3, e3) => [].concat(...t3.children).filter((t4) => t4.matches(e3)), parents(t3, e3) {
      const i2 = [];
      let n3 = t3.parentNode.closest(e3);
      for (; n3; )
        i2.push(n3), n3 = n3.parentNode.closest(e3);
      return i2;
    }, prev(t3, e3) {
      let i2 = t3.previousElementSibling;
      for (; i2; ) {
        if (i2.matches(e3))
          return [i2];
        i2 = i2.previousElementSibling;
      }
      return [];
    }, next(t3, e3) {
      let i2 = t3.nextElementSibling;
      for (; i2; ) {
        if (i2.matches(e3))
          return [i2];
        i2 = i2.nextElementSibling;
      }
      return [];
    }, focusableChildren(t3) {
      const e3 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((t4) => `${t4}:not([tabindex^="-"])`).join(",");
      return this.find(e3, t3).filter((t4) => !l2(t4) && a2(t4));
    }, getSelectorFromElement(t3) {
      const e3 = B2(t3);
      return e3 && z2.findOne(e3) ? e3 : null;
    }, getElementFromSelector(t3) {
      const e3 = B2(t3);
      return e3 ? z2.findOne(e3) : null;
    }, getMultipleElementsFromSelector(t3) {
      const e3 = B2(t3);
      return e3 ? z2.find(e3) : [];
    } }, R2 = (t3, e3 = "hide") => {
      const i2 = `click.dismiss${t3.EVENT_KEY}`, n3 = t3.NAME;
      N2.on(document, i2, `[data-bs-dismiss="${n3}"]`, function(i3) {
        if (["A", "AREA"].includes(this.tagName) && i3.preventDefault(), l2(this))
          return;
        const s3 = z2.getElementFromSelector(this) || this.closest(`.${n3}`);
        t3.getOrCreateInstance(s3)[e3]();
      });
    }, q2 = ".bs.alert", V2 = `close${q2}`, K2 = `closed${q2}`;
    class Q2 extends W2 {
      static get NAME() {
        return "alert";
      }
      close() {
        if (N2.trigger(this._element, V2).defaultPrevented)
          return;
        this._element.classList.remove("show");
        const t3 = this._element.classList.contains("fade");
        this._queueCallback(() => this._destroyElement(), this._element, t3);
      }
      _destroyElement() {
        this._element.remove(), N2.trigger(this._element, K2), this.dispose();
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = Q2.getOrCreateInstance(this);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
              throw new TypeError(`No method named "${t3}"`);
            e3[t3](this);
          }
        });
      }
    }
    R2(Q2, "close"), m2(Q2);
    const X2 = '[data-bs-toggle="button"]';
    class Y2 extends W2 {
      static get NAME() {
        return "button";
      }
      toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = Y2.getOrCreateInstance(this);
          "toggle" === t3 && e3[t3]();
        });
      }
    }
    N2.on(document, "click.bs.button.data-api", X2, (t3) => {
      t3.preventDefault();
      const e3 = t3.target.closest(X2);
      Y2.getOrCreateInstance(e3).toggle();
    }), m2(Y2);
    const U2 = ".bs.swipe", G2 = `touchstart${U2}`, J2 = `touchmove${U2}`, Z2 = `touchend${U2}`, tt2 = `pointerdown${U2}`, et2 = `pointerup${U2}`, it2 = { endCallback: null, leftCallback: null, rightCallback: null }, nt2 = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
    class st2 extends H2 {
      constructor(t3, e3) {
        super(), this._element = t3, t3 && st2.isSupported() && (this._config = this._getConfig(e3), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
      }
      static get Default() {
        return it2;
      }
      static get DefaultType() {
        return nt2;
      }
      static get NAME() {
        return "swipe";
      }
      dispose() {
        N2.off(this._element, U2);
      }
      _start(t3) {
        this._supportPointerEvents ? this._eventIsPointerPenTouch(t3) && (this._deltaX = t3.clientX) : this._deltaX = t3.touches[0].clientX;
      }
      _end(t3) {
        this._eventIsPointerPenTouch(t3) && (this._deltaX = t3.clientX - this._deltaX), this._handleSwipe(), g2(this._config.endCallback);
      }
      _move(t3) {
        this._deltaX = t3.touches && t3.touches.length > 1 ? 0 : t3.touches[0].clientX - this._deltaX;
      }
      _handleSwipe() {
        const t3 = Math.abs(this._deltaX);
        if (t3 <= 40)
          return;
        const e3 = t3 / this._deltaX;
        this._deltaX = 0, e3 && g2(e3 > 0 ? this._config.rightCallback : this._config.leftCallback);
      }
      _initEvents() {
        this._supportPointerEvents ? (N2.on(this._element, tt2, (t3) => this._start(t3)), N2.on(this._element, et2, (t3) => this._end(t3)), this._element.classList.add("pointer-event")) : (N2.on(this._element, G2, (t3) => this._start(t3)), N2.on(this._element, J2, (t3) => this._move(t3)), N2.on(this._element, Z2, (t3) => this._end(t3)));
      }
      _eventIsPointerPenTouch(t3) {
        return this._supportPointerEvents && ("pen" === t3.pointerType || "touch" === t3.pointerType);
      }
      static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
      }
    }
    const ot2 = ".bs.carousel", rt2 = ".data-api", at2 = "next", lt2 = "prev", ct2 = "left", ht2 = "right", dt2 = `slide${ot2}`, ut2 = `slid${ot2}`, ft2 = `keydown${ot2}`, pt2 = `mouseenter${ot2}`, mt2 = `mouseleave${ot2}`, gt2 = `dragstart${ot2}`, _t2 = `load${ot2}${rt2}`, bt2 = `click${ot2}${rt2}`, vt2 = "carousel", yt2 = "active", wt2 = ".active", At2 = ".carousel-item", Et2 = wt2 + At2, Tt2 = { ArrowLeft: ht2, ArrowRight: ct2 }, Ct2 = { interval: 5e3, keyboard: true, pause: "hover", ride: false, touch: true, wrap: true }, Ot2 = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
    class xt2 extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._interval = null, this._activeElement = null, this._isSliding = false, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = z2.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === vt2 && this.cycle();
      }
      static get Default() {
        return Ct2;
      }
      static get DefaultType() {
        return Ot2;
      }
      static get NAME() {
        return "carousel";
      }
      next() {
        this._slide(at2);
      }
      nextWhenVisible() {
        !document.hidden && a2(this._element) && this.next();
      }
      prev() {
        this._slide(lt2);
      }
      pause() {
        this._isSliding && s2(this._element), this._clearInterval();
      }
      cycle() {
        this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
      }
      _maybeEnableCycle() {
        this._config.ride && (this._isSliding ? N2.one(this._element, ut2, () => this.cycle()) : this.cycle());
      }
      to(t3) {
        const e3 = this._getItems();
        if (t3 > e3.length - 1 || t3 < 0)
          return;
        if (this._isSliding)
          return void N2.one(this._element, ut2, () => this.to(t3));
        const i2 = this._getItemIndex(this._getActive());
        if (i2 === t3)
          return;
        const n3 = t3 > i2 ? at2 : lt2;
        this._slide(n3, e3[t3]);
      }
      dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
      }
      _configAfterMerge(t3) {
        return t3.defaultInterval = t3.interval, t3;
      }
      _addEventListeners() {
        this._config.keyboard && N2.on(this._element, ft2, (t3) => this._keydown(t3)), "hover" === this._config.pause && (N2.on(this._element, pt2, () => this.pause()), N2.on(this._element, mt2, () => this._maybeEnableCycle())), this._config.touch && st2.isSupported() && this._addTouchEventListeners();
      }
      _addTouchEventListeners() {
        for (const t4 of z2.find(".carousel-item img", this._element))
          N2.on(t4, gt2, (t5) => t5.preventDefault());
        const t3 = { leftCallback: () => this._slide(this._directionToOrder(ct2)), rightCallback: () => this._slide(this._directionToOrder(ht2)), endCallback: () => {
          "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
        } };
        this._swipeHelper = new st2(this._element, t3);
      }
      _keydown(t3) {
        if (/input|textarea/i.test(t3.target.tagName))
          return;
        const e3 = Tt2[t3.key];
        e3 && (t3.preventDefault(), this._slide(this._directionToOrder(e3)));
      }
      _getItemIndex(t3) {
        return this._getItems().indexOf(t3);
      }
      _setActiveIndicatorElement(t3) {
        if (!this._indicatorsElement)
          return;
        const e3 = z2.findOne(wt2, this._indicatorsElement);
        e3.classList.remove(yt2), e3.removeAttribute("aria-current");
        const i2 = z2.findOne(`[data-bs-slide-to="${t3}"]`, this._indicatorsElement);
        i2 && (i2.classList.add(yt2), i2.setAttribute("aria-current", "true"));
      }
      _updateInterval() {
        const t3 = this._activeElement || this._getActive();
        if (!t3)
          return;
        const e3 = Number.parseInt(t3.getAttribute("data-bs-interval"), 10);
        this._config.interval = e3 || this._config.defaultInterval;
      }
      _slide(t3, e3 = null) {
        if (this._isSliding)
          return;
        const i2 = this._getActive(), n3 = t3 === at2, s3 = e3 || b2(this._getItems(), i2, n3, this._config.wrap);
        if (s3 === i2)
          return;
        const o3 = this._getItemIndex(s3), r3 = (e4) => N2.trigger(this._element, e4, { relatedTarget: s3, direction: this._orderToDirection(t3), from: this._getItemIndex(i2), to: o3 });
        if (r3(dt2).defaultPrevented)
          return;
        if (!i2 || !s3)
          return;
        const a3 = Boolean(this._interval);
        this.pause(), this._isSliding = true, this._setActiveIndicatorElement(o3), this._activeElement = s3;
        const l3 = n3 ? "carousel-item-start" : "carousel-item-end", c3 = n3 ? "carousel-item-next" : "carousel-item-prev";
        s3.classList.add(c3), d2(s3), i2.classList.add(l3), s3.classList.add(l3), this._queueCallback(() => {
          s3.classList.remove(l3, c3), s3.classList.add(yt2), i2.classList.remove(yt2, c3, l3), this._isSliding = false, r3(ut2);
        }, i2, this._isAnimated()), a3 && this.cycle();
      }
      _isAnimated() {
        return this._element.classList.contains("slide");
      }
      _getActive() {
        return z2.findOne(Et2, this._element);
      }
      _getItems() {
        return z2.find(At2, this._element);
      }
      _clearInterval() {
        this._interval && (clearInterval(this._interval), this._interval = null);
      }
      _directionToOrder(t3) {
        return p2() ? t3 === ct2 ? lt2 : at2 : t3 === ct2 ? at2 : lt2;
      }
      _orderToDirection(t3) {
        return p2() ? t3 === lt2 ? ct2 : ht2 : t3 === lt2 ? ht2 : ct2;
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = xt2.getOrCreateInstance(this, t3);
          if ("number" != typeof t3) {
            if ("string" == typeof t3) {
              if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
                throw new TypeError(`No method named "${t3}"`);
              e3[t3]();
            }
          } else
            e3.to(t3);
        });
      }
    }
    N2.on(document, bt2, "[data-bs-slide], [data-bs-slide-to]", function(t3) {
      const e3 = z2.getElementFromSelector(this);
      if (!e3 || !e3.classList.contains(vt2))
        return;
      t3.preventDefault();
      const i2 = xt2.getOrCreateInstance(e3), n3 = this.getAttribute("data-bs-slide-to");
      return n3 ? (i2.to(n3), void i2._maybeEnableCycle()) : "next" === F2.getDataAttribute(this, "slide") ? (i2.next(), void i2._maybeEnableCycle()) : (i2.prev(), void i2._maybeEnableCycle());
    }), N2.on(window, _t2, () => {
      const t3 = z2.find('[data-bs-ride="carousel"]');
      for (const e3 of t3)
        xt2.getOrCreateInstance(e3);
    }), m2(xt2);
    const kt2 = ".bs.collapse", Lt2 = `show${kt2}`, St2 = `shown${kt2}`, Dt2 = `hide${kt2}`, $t2 = `hidden${kt2}`, It2 = `click${kt2}.data-api`, Nt2 = "show", Pt2 = "collapse", jt2 = "collapsing", Mt2 = `:scope .${Pt2} .${Pt2}`, Ft2 = '[data-bs-toggle="collapse"]', Ht2 = { parent: null, toggle: true }, Wt2 = { parent: "(null|element)", toggle: "boolean" };
    class Bt2 extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._isTransitioning = false, this._triggerArray = [];
        const i2 = z2.find(Ft2);
        for (const t4 of i2) {
          const e4 = z2.getSelectorFromElement(t4), i3 = z2.find(e4).filter((t5) => t5 === this._element);
          null !== e4 && i3.length && this._triggerArray.push(t4);
        }
        this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
      }
      static get Default() {
        return Ht2;
      }
      static get DefaultType() {
        return Wt2;
      }
      static get NAME() {
        return "collapse";
      }
      toggle() {
        this._isShown() ? this.hide() : this.show();
      }
      show() {
        if (this._isTransitioning || this._isShown())
          return;
        let t3 = [];
        if (this._config.parent && (t3 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((t4) => t4 !== this._element).map((t4) => Bt2.getOrCreateInstance(t4, { toggle: false }))), t3.length && t3[0]._isTransitioning)
          return;
        if (N2.trigger(this._element, Lt2).defaultPrevented)
          return;
        for (const e4 of t3)
          e4.hide();
        const e3 = this._getDimension();
        this._element.classList.remove(Pt2), this._element.classList.add(jt2), this._element.style[e3] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
        const i2 = `scroll${e3[0].toUpperCase() + e3.slice(1)}`;
        this._queueCallback(() => {
          this._isTransitioning = false, this._element.classList.remove(jt2), this._element.classList.add(Pt2, Nt2), this._element.style[e3] = "", N2.trigger(this._element, St2);
        }, this._element, true), this._element.style[e3] = `${this._element[i2]}px`;
      }
      hide() {
        if (this._isTransitioning || !this._isShown())
          return;
        if (N2.trigger(this._element, Dt2).defaultPrevented)
          return;
        const t3 = this._getDimension();
        this._element.style[t3] = `${this._element.getBoundingClientRect()[t3]}px`, d2(this._element), this._element.classList.add(jt2), this._element.classList.remove(Pt2, Nt2);
        for (const t4 of this._triggerArray) {
          const e3 = z2.getElementFromSelector(t4);
          e3 && !this._isShown(e3) && this._addAriaAndCollapsedClass([t4], false);
        }
        this._isTransitioning = true, this._element.style[t3] = "", this._queueCallback(() => {
          this._isTransitioning = false, this._element.classList.remove(jt2), this._element.classList.add(Pt2), N2.trigger(this._element, $t2);
        }, this._element, true);
      }
      _isShown(t3 = this._element) {
        return t3.classList.contains(Nt2);
      }
      _configAfterMerge(t3) {
        return t3.toggle = Boolean(t3.toggle), t3.parent = r2(t3.parent), t3;
      }
      _getDimension() {
        return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
      }
      _initializeChildren() {
        if (!this._config.parent)
          return;
        const t3 = this._getFirstLevelChildren(Ft2);
        for (const e3 of t3) {
          const t4 = z2.getElementFromSelector(e3);
          t4 && this._addAriaAndCollapsedClass([e3], this._isShown(t4));
        }
      }
      _getFirstLevelChildren(t3) {
        const e3 = z2.find(Mt2, this._config.parent);
        return z2.find(t3, this._config.parent).filter((t4) => !e3.includes(t4));
      }
      _addAriaAndCollapsedClass(t3, e3) {
        if (t3.length)
          for (const i2 of t3)
            i2.classList.toggle("collapsed", !e3), i2.setAttribute("aria-expanded", e3);
      }
      static jQueryInterface(t3) {
        const e3 = {};
        return "string" == typeof t3 && /show|hide/.test(t3) && (e3.toggle = false), this.each(function() {
          const i2 = Bt2.getOrCreateInstance(this, e3);
          if ("string" == typeof t3) {
            if (void 0 === i2[t3])
              throw new TypeError(`No method named "${t3}"`);
            i2[t3]();
          }
        });
      }
    }
    N2.on(document, It2, Ft2, function(t3) {
      ("A" === t3.target.tagName || t3.delegateTarget && "A" === t3.delegateTarget.tagName) && t3.preventDefault();
      for (const t4 of z2.getMultipleElementsFromSelector(this))
        Bt2.getOrCreateInstance(t4, { toggle: false }).toggle();
    }), m2(Bt2);
    var zt2 = "top", Rt2 = "bottom", qt2 = "right", Vt2 = "left", Kt2 = "auto", Qt2 = [zt2, Rt2, qt2, Vt2], Xt2 = "start", Yt2 = "end", Ut2 = "clippingParents", Gt2 = "viewport", Jt2 = "popper", Zt2 = "reference", te2 = Qt2.reduce(function(t3, e3) {
      return t3.concat([e3 + "-" + Xt2, e3 + "-" + Yt2]);
    }, []), ee2 = [].concat(Qt2, [Kt2]).reduce(function(t3, e3) {
      return t3.concat([e3, e3 + "-" + Xt2, e3 + "-" + Yt2]);
    }, []), ie2 = "beforeRead", ne2 = "read", se2 = "afterRead", oe2 = "beforeMain", re2 = "main", ae2 = "afterMain", le2 = "beforeWrite", ce2 = "write", he2 = "afterWrite", de2 = [ie2, ne2, se2, oe2, re2, ae2, le2, ce2, he2];
    function ue2(t3) {
      return t3 ? (t3.nodeName || "").toLowerCase() : null;
    }
    function fe2(t3) {
      if (null == t3)
        return window;
      if ("[object Window]" !== t3.toString()) {
        var e3 = t3.ownerDocument;
        return e3 && e3.defaultView || window;
      }
      return t3;
    }
    function pe2(t3) {
      return t3 instanceof fe2(t3).Element || t3 instanceof Element;
    }
    function me2(t3) {
      return t3 instanceof fe2(t3).HTMLElement || t3 instanceof HTMLElement;
    }
    function ge2(t3) {
      return "undefined" != typeof ShadowRoot && (t3 instanceof fe2(t3).ShadowRoot || t3 instanceof ShadowRoot);
    }
    const _e2 = { name: "applyStyles", enabled: true, phase: "write", fn: function(t3) {
      var e3 = t3.state;
      Object.keys(e3.elements).forEach(function(t4) {
        var i2 = e3.styles[t4] || {}, n3 = e3.attributes[t4] || {}, s3 = e3.elements[t4];
        me2(s3) && ue2(s3) && (Object.assign(s3.style, i2), Object.keys(n3).forEach(function(t5) {
          var e4 = n3[t5];
          false === e4 ? s3.removeAttribute(t5) : s3.setAttribute(t5, true === e4 ? "" : e4);
        }));
      });
    }, effect: function(t3) {
      var e3 = t3.state, i2 = { popper: { position: e3.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
      return Object.assign(e3.elements.popper.style, i2.popper), e3.styles = i2, e3.elements.arrow && Object.assign(e3.elements.arrow.style, i2.arrow), function() {
        Object.keys(e3.elements).forEach(function(t4) {
          var n3 = e3.elements[t4], s3 = e3.attributes[t4] || {}, o3 = Object.keys(e3.styles.hasOwnProperty(t4) ? e3.styles[t4] : i2[t4]).reduce(function(t5, e4) {
            return t5[e4] = "", t5;
          }, {});
          me2(n3) && ue2(n3) && (Object.assign(n3.style, o3), Object.keys(s3).forEach(function(t5) {
            n3.removeAttribute(t5);
          }));
        });
      };
    }, requires: ["computeStyles"] };
    function be2(t3) {
      return t3.split("-")[0];
    }
    var ve2 = Math.max, ye2 = Math.min, we2 = Math.round;
    function Ae2() {
      var t3 = navigator.userAgentData;
      return null != t3 && t3.brands && Array.isArray(t3.brands) ? t3.brands.map(function(t4) {
        return t4.brand + "/" + t4.version;
      }).join(" ") : navigator.userAgent;
    }
    function Ee2() {
      return !/^((?!chrome|android).)*safari/i.test(Ae2());
    }
    function Te2(t3, e3, i2) {
      void 0 === e3 && (e3 = false), void 0 === i2 && (i2 = false);
      var n3 = t3.getBoundingClientRect(), s3 = 1, o3 = 1;
      e3 && me2(t3) && (s3 = t3.offsetWidth > 0 && we2(n3.width) / t3.offsetWidth || 1, o3 = t3.offsetHeight > 0 && we2(n3.height) / t3.offsetHeight || 1);
      var r3 = (pe2(t3) ? fe2(t3) : window).visualViewport, a3 = !Ee2() && i2, l3 = (n3.left + (a3 && r3 ? r3.offsetLeft : 0)) / s3, c3 = (n3.top + (a3 && r3 ? r3.offsetTop : 0)) / o3, h3 = n3.width / s3, d3 = n3.height / o3;
      return { width: h3, height: d3, top: c3, right: l3 + h3, bottom: c3 + d3, left: l3, x: l3, y: c3 };
    }
    function Ce2(t3) {
      var e3 = Te2(t3), i2 = t3.offsetWidth, n3 = t3.offsetHeight;
      return Math.abs(e3.width - i2) <= 1 && (i2 = e3.width), Math.abs(e3.height - n3) <= 1 && (n3 = e3.height), { x: t3.offsetLeft, y: t3.offsetTop, width: i2, height: n3 };
    }
    function Oe2(t3, e3) {
      var i2 = e3.getRootNode && e3.getRootNode();
      if (t3.contains(e3))
        return true;
      if (i2 && ge2(i2)) {
        var n3 = e3;
        do {
          if (n3 && t3.isSameNode(n3))
            return true;
          n3 = n3.parentNode || n3.host;
        } while (n3);
      }
      return false;
    }
    function xe2(t3) {
      return fe2(t3).getComputedStyle(t3);
    }
    function ke2(t3) {
      return ["table", "td", "th"].indexOf(ue2(t3)) >= 0;
    }
    function Le2(t3) {
      return ((pe2(t3) ? t3.ownerDocument : t3.document) || window.document).documentElement;
    }
    function Se2(t3) {
      return "html" === ue2(t3) ? t3 : t3.assignedSlot || t3.parentNode || (ge2(t3) ? t3.host : null) || Le2(t3);
    }
    function De2(t3) {
      return me2(t3) && "fixed" !== xe2(t3).position ? t3.offsetParent : null;
    }
    function $e2(t3) {
      for (var e3 = fe2(t3), i2 = De2(t3); i2 && ke2(i2) && "static" === xe2(i2).position; )
        i2 = De2(i2);
      return i2 && ("html" === ue2(i2) || "body" === ue2(i2) && "static" === xe2(i2).position) ? e3 : i2 || function(t4) {
        var e4 = /firefox/i.test(Ae2());
        if (/Trident/i.test(Ae2()) && me2(t4) && "fixed" === xe2(t4).position)
          return null;
        var i3 = Se2(t4);
        for (ge2(i3) && (i3 = i3.host); me2(i3) && ["html", "body"].indexOf(ue2(i3)) < 0; ) {
          var n3 = xe2(i3);
          if ("none" !== n3.transform || "none" !== n3.perspective || "paint" === n3.contain || -1 !== ["transform", "perspective"].indexOf(n3.willChange) || e4 && "filter" === n3.willChange || e4 && n3.filter && "none" !== n3.filter)
            return i3;
          i3 = i3.parentNode;
        }
        return null;
      }(t3) || e3;
    }
    function Ie2(t3) {
      return ["top", "bottom"].indexOf(t3) >= 0 ? "x" : "y";
    }
    function Ne2(t3, e3, i2) {
      return ve2(t3, ye2(e3, i2));
    }
    function Pe2(t3) {
      return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t3);
    }
    function je2(t3, e3) {
      return e3.reduce(function(e4, i2) {
        return e4[i2] = t3, e4;
      }, {});
    }
    const Me2 = { name: "arrow", enabled: true, phase: "main", fn: function(t3) {
      var e3, i2 = t3.state, n3 = t3.name, s3 = t3.options, o3 = i2.elements.arrow, r3 = i2.modifiersData.popperOffsets, a3 = be2(i2.placement), l3 = Ie2(a3), c3 = [Vt2, qt2].indexOf(a3) >= 0 ? "height" : "width";
      if (o3 && r3) {
        var h3 = function(t4, e4) {
          return Pe2("number" != typeof (t4 = "function" == typeof t4 ? t4(Object.assign({}, e4.rects, { placement: e4.placement })) : t4) ? t4 : je2(t4, Qt2));
        }(s3.padding, i2), d3 = Ce2(o3), u3 = "y" === l3 ? zt2 : Vt2, f3 = "y" === l3 ? Rt2 : qt2, p3 = i2.rects.reference[c3] + i2.rects.reference[l3] - r3[l3] - i2.rects.popper[c3], m3 = r3[l3] - i2.rects.reference[l3], g3 = $e2(o3), _3 = g3 ? "y" === l3 ? g3.clientHeight || 0 : g3.clientWidth || 0 : 0, b3 = p3 / 2 - m3 / 2, v3 = h3[u3], y3 = _3 - d3[c3] - h3[f3], w3 = _3 / 2 - d3[c3] / 2 + b3, A3 = Ne2(v3, w3, y3), E3 = l3;
        i2.modifiersData[n3] = ((e3 = {})[E3] = A3, e3.centerOffset = A3 - w3, e3);
      }
    }, effect: function(t3) {
      var e3 = t3.state, i2 = t3.options.element, n3 = void 0 === i2 ? "[data-popper-arrow]" : i2;
      null != n3 && ("string" != typeof n3 || (n3 = e3.elements.popper.querySelector(n3))) && Oe2(e3.elements.popper, n3) && (e3.elements.arrow = n3);
    }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
    function Fe2(t3) {
      return t3.split("-")[1];
    }
    var He2 = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
    function We2(t3) {
      var e3, i2 = t3.popper, n3 = t3.popperRect, s3 = t3.placement, o3 = t3.variation, r3 = t3.offsets, a3 = t3.position, l3 = t3.gpuAcceleration, c3 = t3.adaptive, h3 = t3.roundOffsets, d3 = t3.isFixed, u3 = r3.x, f3 = void 0 === u3 ? 0 : u3, p3 = r3.y, m3 = void 0 === p3 ? 0 : p3, g3 = "function" == typeof h3 ? h3({ x: f3, y: m3 }) : { x: f3, y: m3 };
      f3 = g3.x, m3 = g3.y;
      var _3 = r3.hasOwnProperty("x"), b3 = r3.hasOwnProperty("y"), v3 = Vt2, y3 = zt2, w3 = window;
      if (c3) {
        var A3 = $e2(i2), E3 = "clientHeight", T3 = "clientWidth";
        A3 === fe2(i2) && "static" !== xe2(A3 = Le2(i2)).position && "absolute" === a3 && (E3 = "scrollHeight", T3 = "scrollWidth"), (s3 === zt2 || (s3 === Vt2 || s3 === qt2) && o3 === Yt2) && (y3 = Rt2, m3 -= (d3 && A3 === w3 && w3.visualViewport ? w3.visualViewport.height : A3[E3]) - n3.height, m3 *= l3 ? 1 : -1), s3 !== Vt2 && (s3 !== zt2 && s3 !== Rt2 || o3 !== Yt2) || (v3 = qt2, f3 -= (d3 && A3 === w3 && w3.visualViewport ? w3.visualViewport.width : A3[T3]) - n3.width, f3 *= l3 ? 1 : -1);
      }
      var C3, O3 = Object.assign({ position: a3 }, c3 && He2), x3 = true === h3 ? function(t4, e4) {
        var i3 = t4.x, n4 = t4.y, s4 = e4.devicePixelRatio || 1;
        return { x: we2(i3 * s4) / s4 || 0, y: we2(n4 * s4) / s4 || 0 };
      }({ x: f3, y: m3 }, fe2(i2)) : { x: f3, y: m3 };
      return f3 = x3.x, m3 = x3.y, l3 ? Object.assign({}, O3, ((C3 = {})[y3] = b3 ? "0" : "", C3[v3] = _3 ? "0" : "", C3.transform = (w3.devicePixelRatio || 1) <= 1 ? "translate(" + f3 + "px, " + m3 + "px)" : "translate3d(" + f3 + "px, " + m3 + "px, 0)", C3)) : Object.assign({}, O3, ((e3 = {})[y3] = b3 ? m3 + "px" : "", e3[v3] = _3 ? f3 + "px" : "", e3.transform = "", e3));
    }
    const Be2 = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(t3) {
      var e3 = t3.state, i2 = t3.options, n3 = i2.gpuAcceleration, s3 = void 0 === n3 || n3, o3 = i2.adaptive, r3 = void 0 === o3 || o3, a3 = i2.roundOffsets, l3 = void 0 === a3 || a3, c3 = { placement: be2(e3.placement), variation: Fe2(e3.placement), popper: e3.elements.popper, popperRect: e3.rects.popper, gpuAcceleration: s3, isFixed: "fixed" === e3.options.strategy };
      null != e3.modifiersData.popperOffsets && (e3.styles.popper = Object.assign({}, e3.styles.popper, We2(Object.assign({}, c3, { offsets: e3.modifiersData.popperOffsets, position: e3.options.strategy, adaptive: r3, roundOffsets: l3 })))), null != e3.modifiersData.arrow && (e3.styles.arrow = Object.assign({}, e3.styles.arrow, We2(Object.assign({}, c3, { offsets: e3.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: l3 })))), e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-placement": e3.placement });
    }, data: {} };
    var ze2 = { passive: true };
    const Re2 = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
    }, effect: function(t3) {
      var e3 = t3.state, i2 = t3.instance, n3 = t3.options, s3 = n3.scroll, o3 = void 0 === s3 || s3, r3 = n3.resize, a3 = void 0 === r3 || r3, l3 = fe2(e3.elements.popper), c3 = [].concat(e3.scrollParents.reference, e3.scrollParents.popper);
      return o3 && c3.forEach(function(t4) {
        t4.addEventListener("scroll", i2.update, ze2);
      }), a3 && l3.addEventListener("resize", i2.update, ze2), function() {
        o3 && c3.forEach(function(t4) {
          t4.removeEventListener("scroll", i2.update, ze2);
        }), a3 && l3.removeEventListener("resize", i2.update, ze2);
      };
    }, data: {} };
    var qe2 = { left: "right", right: "left", bottom: "top", top: "bottom" };
    function Ve2(t3) {
      return t3.replace(/left|right|bottom|top/g, function(t4) {
        return qe2[t4];
      });
    }
    var Ke2 = { start: "end", end: "start" };
    function Qe2(t3) {
      return t3.replace(/start|end/g, function(t4) {
        return Ke2[t4];
      });
    }
    function Xe2(t3) {
      var e3 = fe2(t3);
      return { scrollLeft: e3.pageXOffset, scrollTop: e3.pageYOffset };
    }
    function Ye2(t3) {
      return Te2(Le2(t3)).left + Xe2(t3).scrollLeft;
    }
    function Ue2(t3) {
      var e3 = xe2(t3), i2 = e3.overflow, n3 = e3.overflowX, s3 = e3.overflowY;
      return /auto|scroll|overlay|hidden/.test(i2 + s3 + n3);
    }
    function Ge2(t3) {
      return ["html", "body", "#document"].indexOf(ue2(t3)) >= 0 ? t3.ownerDocument.body : me2(t3) && Ue2(t3) ? t3 : Ge2(Se2(t3));
    }
    function Je2(t3, e3) {
      var i2;
      void 0 === e3 && (e3 = []);
      var n3 = Ge2(t3), s3 = n3 === (null == (i2 = t3.ownerDocument) ? void 0 : i2.body), o3 = fe2(n3), r3 = s3 ? [o3].concat(o3.visualViewport || [], Ue2(n3) ? n3 : []) : n3, a3 = e3.concat(r3);
      return s3 ? a3 : a3.concat(Je2(Se2(r3)));
    }
    function Ze2(t3) {
      return Object.assign({}, t3, { left: t3.x, top: t3.y, right: t3.x + t3.width, bottom: t3.y + t3.height });
    }
    function ti2(t3, e3, i2) {
      return e3 === Gt2 ? Ze2(function(t4, e4) {
        var i3 = fe2(t4), n3 = Le2(t4), s3 = i3.visualViewport, o3 = n3.clientWidth, r3 = n3.clientHeight, a3 = 0, l3 = 0;
        if (s3) {
          o3 = s3.width, r3 = s3.height;
          var c3 = Ee2();
          (c3 || !c3 && "fixed" === e4) && (a3 = s3.offsetLeft, l3 = s3.offsetTop);
        }
        return { width: o3, height: r3, x: a3 + Ye2(t4), y: l3 };
      }(t3, i2)) : pe2(e3) ? function(t4, e4) {
        var i3 = Te2(t4, false, "fixed" === e4);
        return i3.top = i3.top + t4.clientTop, i3.left = i3.left + t4.clientLeft, i3.bottom = i3.top + t4.clientHeight, i3.right = i3.left + t4.clientWidth, i3.width = t4.clientWidth, i3.height = t4.clientHeight, i3.x = i3.left, i3.y = i3.top, i3;
      }(e3, i2) : Ze2(function(t4) {
        var e4, i3 = Le2(t4), n3 = Xe2(t4), s3 = null == (e4 = t4.ownerDocument) ? void 0 : e4.body, o3 = ve2(i3.scrollWidth, i3.clientWidth, s3 ? s3.scrollWidth : 0, s3 ? s3.clientWidth : 0), r3 = ve2(i3.scrollHeight, i3.clientHeight, s3 ? s3.scrollHeight : 0, s3 ? s3.clientHeight : 0), a3 = -n3.scrollLeft + Ye2(t4), l3 = -n3.scrollTop;
        return "rtl" === xe2(s3 || i3).direction && (a3 += ve2(i3.clientWidth, s3 ? s3.clientWidth : 0) - o3), { width: o3, height: r3, x: a3, y: l3 };
      }(Le2(t3)));
    }
    function ei2(t3) {
      var e3, i2 = t3.reference, n3 = t3.element, s3 = t3.placement, o3 = s3 ? be2(s3) : null, r3 = s3 ? Fe2(s3) : null, a3 = i2.x + i2.width / 2 - n3.width / 2, l3 = i2.y + i2.height / 2 - n3.height / 2;
      switch (o3) {
        case zt2:
          e3 = { x: a3, y: i2.y - n3.height };
          break;
        case Rt2:
          e3 = { x: a3, y: i2.y + i2.height };
          break;
        case qt2:
          e3 = { x: i2.x + i2.width, y: l3 };
          break;
        case Vt2:
          e3 = { x: i2.x - n3.width, y: l3 };
          break;
        default:
          e3 = { x: i2.x, y: i2.y };
      }
      var c3 = o3 ? Ie2(o3) : null;
      if (null != c3) {
        var h3 = "y" === c3 ? "height" : "width";
        switch (r3) {
          case Xt2:
            e3[c3] = e3[c3] - (i2[h3] / 2 - n3[h3] / 2);
            break;
          case Yt2:
            e3[c3] = e3[c3] + (i2[h3] / 2 - n3[h3] / 2);
        }
      }
      return e3;
    }
    function ii2(t3, e3) {
      void 0 === e3 && (e3 = {});
      var i2 = e3, n3 = i2.placement, s3 = void 0 === n3 ? t3.placement : n3, o3 = i2.strategy, r3 = void 0 === o3 ? t3.strategy : o3, a3 = i2.boundary, l3 = void 0 === a3 ? Ut2 : a3, c3 = i2.rootBoundary, h3 = void 0 === c3 ? Gt2 : c3, d3 = i2.elementContext, u3 = void 0 === d3 ? Jt2 : d3, f3 = i2.altBoundary, p3 = void 0 !== f3 && f3, m3 = i2.padding, g3 = void 0 === m3 ? 0 : m3, _3 = Pe2("number" != typeof g3 ? g3 : je2(g3, Qt2)), b3 = u3 === Jt2 ? Zt2 : Jt2, v3 = t3.rects.popper, y3 = t3.elements[p3 ? b3 : u3], w3 = function(t4, e4, i3, n4) {
        var s4 = "clippingParents" === e4 ? function(t5) {
          var e5 = Je2(Se2(t5)), i4 = ["absolute", "fixed"].indexOf(xe2(t5).position) >= 0 && me2(t5) ? $e2(t5) : t5;
          return pe2(i4) ? e5.filter(function(t6) {
            return pe2(t6) && Oe2(t6, i4) && "body" !== ue2(t6);
          }) : [];
        }(t4) : [].concat(e4), o4 = [].concat(s4, [i3]), r4 = o4[0], a4 = o4.reduce(function(e5, i4) {
          var s5 = ti2(t4, i4, n4);
          return e5.top = ve2(s5.top, e5.top), e5.right = ye2(s5.right, e5.right), e5.bottom = ye2(s5.bottom, e5.bottom), e5.left = ve2(s5.left, e5.left), e5;
        }, ti2(t4, r4, n4));
        return a4.width = a4.right - a4.left, a4.height = a4.bottom - a4.top, a4.x = a4.left, a4.y = a4.top, a4;
      }(pe2(y3) ? y3 : y3.contextElement || Le2(t3.elements.popper), l3, h3, r3), A3 = Te2(t3.elements.reference), E3 = ei2({ reference: A3, element: v3, strategy: "absolute", placement: s3 }), T3 = Ze2(Object.assign({}, v3, E3)), C3 = u3 === Jt2 ? T3 : A3, O3 = { top: w3.top - C3.top + _3.top, bottom: C3.bottom - w3.bottom + _3.bottom, left: w3.left - C3.left + _3.left, right: C3.right - w3.right + _3.right }, x3 = t3.modifiersData.offset;
      if (u3 === Jt2 && x3) {
        var k3 = x3[s3];
        Object.keys(O3).forEach(function(t4) {
          var e4 = [qt2, Rt2].indexOf(t4) >= 0 ? 1 : -1, i3 = [zt2, Rt2].indexOf(t4) >= 0 ? "y" : "x";
          O3[t4] += k3[i3] * e4;
        });
      }
      return O3;
    }
    function ni2(t3, e3) {
      void 0 === e3 && (e3 = {});
      var i2 = e3, n3 = i2.placement, s3 = i2.boundary, o3 = i2.rootBoundary, r3 = i2.padding, a3 = i2.flipVariations, l3 = i2.allowedAutoPlacements, c3 = void 0 === l3 ? ee2 : l3, h3 = Fe2(n3), d3 = h3 ? a3 ? te2 : te2.filter(function(t4) {
        return Fe2(t4) === h3;
      }) : Qt2, u3 = d3.filter(function(t4) {
        return c3.indexOf(t4) >= 0;
      });
      0 === u3.length && (u3 = d3);
      var f3 = u3.reduce(function(e4, i3) {
        return e4[i3] = ii2(t3, { placement: i3, boundary: s3, rootBoundary: o3, padding: r3 })[be2(i3)], e4;
      }, {});
      return Object.keys(f3).sort(function(t4, e4) {
        return f3[t4] - f3[e4];
      });
    }
    const si2 = { name: "flip", enabled: true, phase: "main", fn: function(t3) {
      var e3 = t3.state, i2 = t3.options, n3 = t3.name;
      if (!e3.modifiersData[n3]._skip) {
        for (var s3 = i2.mainAxis, o3 = void 0 === s3 || s3, r3 = i2.altAxis, a3 = void 0 === r3 || r3, l3 = i2.fallbackPlacements, c3 = i2.padding, h3 = i2.boundary, d3 = i2.rootBoundary, u3 = i2.altBoundary, f3 = i2.flipVariations, p3 = void 0 === f3 || f3, m3 = i2.allowedAutoPlacements, g3 = e3.options.placement, _3 = be2(g3), b3 = l3 || (_3 !== g3 && p3 ? function(t4) {
          if (be2(t4) === Kt2)
            return [];
          var e4 = Ve2(t4);
          return [Qe2(t4), e4, Qe2(e4)];
        }(g3) : [Ve2(g3)]), v3 = [g3].concat(b3).reduce(function(t4, i3) {
          return t4.concat(be2(i3) === Kt2 ? ni2(e3, { placement: i3, boundary: h3, rootBoundary: d3, padding: c3, flipVariations: p3, allowedAutoPlacements: m3 }) : i3);
        }, []), y3 = e3.rects.reference, w3 = e3.rects.popper, A3 = /* @__PURE__ */ new Map(), E3 = true, T3 = v3[0], C3 = 0; C3 < v3.length; C3++) {
          var O3 = v3[C3], x3 = be2(O3), k3 = Fe2(O3) === Xt2, L3 = [zt2, Rt2].indexOf(x3) >= 0, S3 = L3 ? "width" : "height", D3 = ii2(e3, { placement: O3, boundary: h3, rootBoundary: d3, altBoundary: u3, padding: c3 }), $3 = L3 ? k3 ? qt2 : Vt2 : k3 ? Rt2 : zt2;
          y3[S3] > w3[S3] && ($3 = Ve2($3));
          var I3 = Ve2($3), N3 = [];
          if (o3 && N3.push(D3[x3] <= 0), a3 && N3.push(D3[$3] <= 0, D3[I3] <= 0), N3.every(function(t4) {
            return t4;
          })) {
            T3 = O3, E3 = false;
            break;
          }
          A3.set(O3, N3);
        }
        if (E3)
          for (var P3 = function(t4) {
            var e4 = v3.find(function(e5) {
              var i3 = A3.get(e5);
              if (i3)
                return i3.slice(0, t4).every(function(t5) {
                  return t5;
                });
            });
            if (e4)
              return T3 = e4, "break";
          }, j3 = p3 ? 3 : 1; j3 > 0 && "break" !== P3(j3); j3--)
            ;
        e3.placement !== T3 && (e3.modifiersData[n3]._skip = true, e3.placement = T3, e3.reset = true);
      }
    }, requiresIfExists: ["offset"], data: { _skip: false } };
    function oi2(t3, e3, i2) {
      return void 0 === i2 && (i2 = { x: 0, y: 0 }), { top: t3.top - e3.height - i2.y, right: t3.right - e3.width + i2.x, bottom: t3.bottom - e3.height + i2.y, left: t3.left - e3.width - i2.x };
    }
    function ri2(t3) {
      return [zt2, qt2, Rt2, Vt2].some(function(e3) {
        return t3[e3] >= 0;
      });
    }
    const ai2 = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(t3) {
      var e3 = t3.state, i2 = t3.name, n3 = e3.rects.reference, s3 = e3.rects.popper, o3 = e3.modifiersData.preventOverflow, r3 = ii2(e3, { elementContext: "reference" }), a3 = ii2(e3, { altBoundary: true }), l3 = oi2(r3, n3), c3 = oi2(a3, s3, o3), h3 = ri2(l3), d3 = ri2(c3);
      e3.modifiersData[i2] = { referenceClippingOffsets: l3, popperEscapeOffsets: c3, isReferenceHidden: h3, hasPopperEscaped: d3 }, e3.attributes.popper = Object.assign({}, e3.attributes.popper, { "data-popper-reference-hidden": h3, "data-popper-escaped": d3 });
    } }, li2 = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(t3) {
      var e3 = t3.state, i2 = t3.options, n3 = t3.name, s3 = i2.offset, o3 = void 0 === s3 ? [0, 0] : s3, r3 = ee2.reduce(function(t4, i3) {
        return t4[i3] = function(t5, e4, i4) {
          var n4 = be2(t5), s4 = [Vt2, zt2].indexOf(n4) >= 0 ? -1 : 1, o4 = "function" == typeof i4 ? i4(Object.assign({}, e4, { placement: t5 })) : i4, r4 = o4[0], a4 = o4[1];
          return r4 = r4 || 0, a4 = (a4 || 0) * s4, [Vt2, qt2].indexOf(n4) >= 0 ? { x: a4, y: r4 } : { x: r4, y: a4 };
        }(i3, e3.rects, o3), t4;
      }, {}), a3 = r3[e3.placement], l3 = a3.x, c3 = a3.y;
      null != e3.modifiersData.popperOffsets && (e3.modifiersData.popperOffsets.x += l3, e3.modifiersData.popperOffsets.y += c3), e3.modifiersData[n3] = r3;
    } }, ci2 = { name: "popperOffsets", enabled: true, phase: "read", fn: function(t3) {
      var e3 = t3.state, i2 = t3.name;
      e3.modifiersData[i2] = ei2({ reference: e3.rects.reference, element: e3.rects.popper, strategy: "absolute", placement: e3.placement });
    }, data: {} }, hi2 = { name: "preventOverflow", enabled: true, phase: "main", fn: function(t3) {
      var e3 = t3.state, i2 = t3.options, n3 = t3.name, s3 = i2.mainAxis, o3 = void 0 === s3 || s3, r3 = i2.altAxis, a3 = void 0 !== r3 && r3, l3 = i2.boundary, c3 = i2.rootBoundary, h3 = i2.altBoundary, d3 = i2.padding, u3 = i2.tether, f3 = void 0 === u3 || u3, p3 = i2.tetherOffset, m3 = void 0 === p3 ? 0 : p3, g3 = ii2(e3, { boundary: l3, rootBoundary: c3, padding: d3, altBoundary: h3 }), _3 = be2(e3.placement), b3 = Fe2(e3.placement), v3 = !b3, y3 = Ie2(_3), w3 = "x" === y3 ? "y" : "x", A3 = e3.modifiersData.popperOffsets, E3 = e3.rects.reference, T3 = e3.rects.popper, C3 = "function" == typeof m3 ? m3(Object.assign({}, e3.rects, { placement: e3.placement })) : m3, O3 = "number" == typeof C3 ? { mainAxis: C3, altAxis: C3 } : Object.assign({ mainAxis: 0, altAxis: 0 }, C3), x3 = e3.modifiersData.offset ? e3.modifiersData.offset[e3.placement] : null, k3 = { x: 0, y: 0 };
      if (A3) {
        if (o3) {
          var L3, S3 = "y" === y3 ? zt2 : Vt2, D3 = "y" === y3 ? Rt2 : qt2, $3 = "y" === y3 ? "height" : "width", I3 = A3[y3], N3 = I3 + g3[S3], P3 = I3 - g3[D3], j3 = f3 ? -T3[$3] / 2 : 0, M3 = b3 === Xt2 ? E3[$3] : T3[$3], F3 = b3 === Xt2 ? -T3[$3] : -E3[$3], H3 = e3.elements.arrow, W3 = f3 && H3 ? Ce2(H3) : { width: 0, height: 0 }, B3 = e3.modifiersData["arrow#persistent"] ? e3.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, z3 = B3[S3], R3 = B3[D3], q3 = Ne2(0, E3[$3], W3[$3]), V3 = v3 ? E3[$3] / 2 - j3 - q3 - z3 - O3.mainAxis : M3 - q3 - z3 - O3.mainAxis, K3 = v3 ? -E3[$3] / 2 + j3 + q3 + R3 + O3.mainAxis : F3 + q3 + R3 + O3.mainAxis, Q3 = e3.elements.arrow && $e2(e3.elements.arrow), X3 = Q3 ? "y" === y3 ? Q3.clientTop || 0 : Q3.clientLeft || 0 : 0, Y3 = null != (L3 = null == x3 ? void 0 : x3[y3]) ? L3 : 0, U3 = I3 + K3 - Y3, G3 = Ne2(f3 ? ye2(N3, I3 + V3 - Y3 - X3) : N3, I3, f3 ? ve2(P3, U3) : P3);
          A3[y3] = G3, k3[y3] = G3 - I3;
        }
        if (a3) {
          var J3, Z3 = "x" === y3 ? zt2 : Vt2, tt3 = "x" === y3 ? Rt2 : qt2, et3 = A3[w3], it3 = "y" === w3 ? "height" : "width", nt3 = et3 + g3[Z3], st3 = et3 - g3[tt3], ot3 = -1 !== [zt2, Vt2].indexOf(_3), rt3 = null != (J3 = null == x3 ? void 0 : x3[w3]) ? J3 : 0, at3 = ot3 ? nt3 : et3 - E3[it3] - T3[it3] - rt3 + O3.altAxis, lt3 = ot3 ? et3 + E3[it3] + T3[it3] - rt3 - O3.altAxis : st3, ct3 = f3 && ot3 ? function(t4, e4, i3) {
            var n4 = Ne2(t4, e4, i3);
            return n4 > i3 ? i3 : n4;
          }(at3, et3, lt3) : Ne2(f3 ? at3 : nt3, et3, f3 ? lt3 : st3);
          A3[w3] = ct3, k3[w3] = ct3 - et3;
        }
        e3.modifiersData[n3] = k3;
      }
    }, requiresIfExists: ["offset"] };
    function di2(t3, e3, i2) {
      void 0 === i2 && (i2 = false);
      var n3, s3, o3 = me2(e3), r3 = me2(e3) && function(t4) {
        var e4 = t4.getBoundingClientRect(), i3 = we2(e4.width) / t4.offsetWidth || 1, n4 = we2(e4.height) / t4.offsetHeight || 1;
        return 1 !== i3 || 1 !== n4;
      }(e3), a3 = Le2(e3), l3 = Te2(t3, r3, i2), c3 = { scrollLeft: 0, scrollTop: 0 }, h3 = { x: 0, y: 0 };
      return (o3 || !o3 && !i2) && (("body" !== ue2(e3) || Ue2(a3)) && (c3 = (n3 = e3) !== fe2(n3) && me2(n3) ? { scrollLeft: (s3 = n3).scrollLeft, scrollTop: s3.scrollTop } : Xe2(n3)), me2(e3) ? ((h3 = Te2(e3, true)).x += e3.clientLeft, h3.y += e3.clientTop) : a3 && (h3.x = Ye2(a3))), { x: l3.left + c3.scrollLeft - h3.x, y: l3.top + c3.scrollTop - h3.y, width: l3.width, height: l3.height };
    }
    function ui2(t3) {
      var e3 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Set(), n3 = [];
      function s3(t4) {
        i2.add(t4.name), [].concat(t4.requires || [], t4.requiresIfExists || []).forEach(function(t5) {
          if (!i2.has(t5)) {
            var n4 = e3.get(t5);
            n4 && s3(n4);
          }
        }), n3.push(t4);
      }
      return t3.forEach(function(t4) {
        e3.set(t4.name, t4);
      }), t3.forEach(function(t4) {
        i2.has(t4.name) || s3(t4);
      }), n3;
    }
    var fi2 = { placement: "bottom", modifiers: [], strategy: "absolute" };
    function pi2() {
      for (var t3 = arguments.length, e3 = new Array(t3), i2 = 0; i2 < t3; i2++)
        e3[i2] = arguments[i2];
      return !e3.some(function(t4) {
        return !(t4 && "function" == typeof t4.getBoundingClientRect);
      });
    }
    function mi2(t3) {
      void 0 === t3 && (t3 = {});
      var e3 = t3, i2 = e3.defaultModifiers, n3 = void 0 === i2 ? [] : i2, s3 = e3.defaultOptions, o3 = void 0 === s3 ? fi2 : s3;
      return function(t4, e4, i3) {
        void 0 === i3 && (i3 = o3);
        var s4, r3, a3 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, fi2, o3), modifiersData: {}, elements: { reference: t4, popper: e4 }, attributes: {}, styles: {} }, l3 = [], c3 = false, h3 = { state: a3, setOptions: function(i4) {
          var s5 = "function" == typeof i4 ? i4(a3.options) : i4;
          d3(), a3.options = Object.assign({}, o3, a3.options, s5), a3.scrollParents = { reference: pe2(t4) ? Je2(t4) : t4.contextElement ? Je2(t4.contextElement) : [], popper: Je2(e4) };
          var r4, c4, u3 = function(t5) {
            var e5 = ui2(t5);
            return de2.reduce(function(t6, i5) {
              return t6.concat(e5.filter(function(t7) {
                return t7.phase === i5;
              }));
            }, []);
          }((r4 = [].concat(n3, a3.options.modifiers), c4 = r4.reduce(function(t5, e5) {
            var i5 = t5[e5.name];
            return t5[e5.name] = i5 ? Object.assign({}, i5, e5, { options: Object.assign({}, i5.options, e5.options), data: Object.assign({}, i5.data, e5.data) }) : e5, t5;
          }, {}), Object.keys(c4).map(function(t5) {
            return c4[t5];
          })));
          return a3.orderedModifiers = u3.filter(function(t5) {
            return t5.enabled;
          }), a3.orderedModifiers.forEach(function(t5) {
            var e5 = t5.name, i5 = t5.options, n4 = void 0 === i5 ? {} : i5, s6 = t5.effect;
            if ("function" == typeof s6) {
              var o4 = s6({ state: a3, name: e5, instance: h3, options: n4 });
              l3.push(o4 || function() {
              });
            }
          }), h3.update();
        }, forceUpdate: function() {
          if (!c3) {
            var t5 = a3.elements, e5 = t5.reference, i4 = t5.popper;
            if (pi2(e5, i4)) {
              a3.rects = { reference: di2(e5, $e2(i4), "fixed" === a3.options.strategy), popper: Ce2(i4) }, a3.reset = false, a3.placement = a3.options.placement, a3.orderedModifiers.forEach(function(t6) {
                return a3.modifiersData[t6.name] = Object.assign({}, t6.data);
              });
              for (var n4 = 0; n4 < a3.orderedModifiers.length; n4++)
                if (true !== a3.reset) {
                  var s5 = a3.orderedModifiers[n4], o4 = s5.fn, r4 = s5.options, l4 = void 0 === r4 ? {} : r4, d4 = s5.name;
                  "function" == typeof o4 && (a3 = o4({ state: a3, options: l4, name: d4, instance: h3 }) || a3);
                } else
                  a3.reset = false, n4 = -1;
            }
          }
        }, update: (s4 = function() {
          return new Promise(function(t5) {
            h3.forceUpdate(), t5(a3);
          });
        }, function() {
          return r3 || (r3 = new Promise(function(t5) {
            Promise.resolve().then(function() {
              r3 = void 0, t5(s4());
            });
          })), r3;
        }), destroy: function() {
          d3(), c3 = true;
        } };
        if (!pi2(t4, e4))
          return h3;
        function d3() {
          l3.forEach(function(t5) {
            return t5();
          }), l3 = [];
        }
        return h3.setOptions(i3).then(function(t5) {
          !c3 && i3.onFirstUpdate && i3.onFirstUpdate(t5);
        }), h3;
      };
    }
    var gi2 = mi2(), _i2 = mi2({ defaultModifiers: [Re2, ci2, Be2, _e2] }), bi2 = mi2({ defaultModifiers: [Re2, ci2, Be2, _e2, li2, si2, hi2, Me2, ai2] });
    const vi2 = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: ae2, afterRead: se2, afterWrite: he2, applyStyles: _e2, arrow: Me2, auto: Kt2, basePlacements: Qt2, beforeMain: oe2, beforeRead: ie2, beforeWrite: le2, bottom: Rt2, clippingParents: Ut2, computeStyles: Be2, createPopper: bi2, createPopperBase: gi2, createPopperLite: _i2, detectOverflow: ii2, end: Yt2, eventListeners: Re2, flip: si2, hide: ai2, left: Vt2, main: re2, modifierPhases: de2, offset: li2, placements: ee2, popper: Jt2, popperGenerator: mi2, popperOffsets: ci2, preventOverflow: hi2, read: ne2, reference: Zt2, right: qt2, start: Xt2, top: zt2, variationPlacements: te2, viewport: Gt2, write: ce2 }, Symbol.toStringTag, { value: "Module" })), yi2 = "dropdown", wi2 = ".bs.dropdown", Ai2 = ".data-api", Ei2 = "ArrowUp", Ti2 = "ArrowDown", Ci2 = `hide${wi2}`, Oi2 = `hidden${wi2}`, xi2 = `show${wi2}`, ki2 = `shown${wi2}`, Li2 = `click${wi2}${Ai2}`, Si2 = `keydown${wi2}${Ai2}`, Di2 = `keyup${wi2}${Ai2}`, $i2 = "show", Ii2 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Ni2 = `${Ii2}.${$i2}`, Pi2 = ".dropdown-menu", ji2 = p2() ? "top-end" : "top-start", Mi2 = p2() ? "top-start" : "top-end", Fi2 = p2() ? "bottom-end" : "bottom-start", Hi2 = p2() ? "bottom-start" : "bottom-end", Wi2 = p2() ? "left-start" : "right-start", Bi2 = p2() ? "right-start" : "left-start", zi2 = { autoClose: true, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, Ri2 = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
    class qi2 extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._popper = null, this._parent = this._element.parentNode, this._menu = z2.next(this._element, Pi2)[0] || z2.prev(this._element, Pi2)[0] || z2.findOne(Pi2, this._parent), this._inNavbar = this._detectNavbar();
      }
      static get Default() {
        return zi2;
      }
      static get DefaultType() {
        return Ri2;
      }
      static get NAME() {
        return yi2;
      }
      toggle() {
        return this._isShown() ? this.hide() : this.show();
      }
      show() {
        if (l2(this._element) || this._isShown())
          return;
        const t3 = { relatedTarget: this._element };
        if (!N2.trigger(this._element, xi2, t3).defaultPrevented) {
          if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav"))
            for (const t4 of [].concat(...document.body.children))
              N2.on(t4, "mouseover", h2);
          this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add($i2), this._element.classList.add($i2), N2.trigger(this._element, ki2, t3);
        }
      }
      hide() {
        if (l2(this._element) || !this._isShown())
          return;
        const t3 = { relatedTarget: this._element };
        this._completeHide(t3);
      }
      dispose() {
        this._popper && this._popper.destroy(), super.dispose();
      }
      update() {
        this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
      }
      _completeHide(t3) {
        if (!N2.trigger(this._element, Ci2, t3).defaultPrevented) {
          if ("ontouchstart" in document.documentElement)
            for (const t4 of [].concat(...document.body.children))
              N2.off(t4, "mouseover", h2);
          this._popper && this._popper.destroy(), this._menu.classList.remove($i2), this._element.classList.remove($i2), this._element.setAttribute("aria-expanded", "false"), F2.removeDataAttribute(this._menu, "popper"), N2.trigger(this._element, Oi2, t3);
        }
      }
      _getConfig(t3) {
        if ("object" == typeof (t3 = super._getConfig(t3)).reference && !o2(t3.reference) && "function" != typeof t3.reference.getBoundingClientRect)
          throw new TypeError(`${yi2.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return t3;
      }
      _createPopper() {
        if (void 0 === vi2)
          throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        let t3 = this._element;
        "parent" === this._config.reference ? t3 = this._parent : o2(this._config.reference) ? t3 = r2(this._config.reference) : "object" == typeof this._config.reference && (t3 = this._config.reference);
        const e3 = this._getPopperConfig();
        this._popper = bi2(t3, this._menu, e3);
      }
      _isShown() {
        return this._menu.classList.contains($i2);
      }
      _getPlacement() {
        const t3 = this._parent;
        if (t3.classList.contains("dropend"))
          return Wi2;
        if (t3.classList.contains("dropstart"))
          return Bi2;
        if (t3.classList.contains("dropup-center"))
          return "top";
        if (t3.classList.contains("dropdown-center"))
          return "bottom";
        const e3 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
        return t3.classList.contains("dropup") ? e3 ? Mi2 : ji2 : e3 ? Hi2 : Fi2;
      }
      _detectNavbar() {
        return null !== this._element.closest(".navbar");
      }
      _getOffset() {
        const { offset: t3 } = this._config;
        return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e3) => t3(e3, this._element) : t3;
      }
      _getPopperConfig() {
        const t3 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
        return (this._inNavbar || "static" === this._config.display) && (F2.setDataAttribute(this._menu, "popper", "static"), t3.modifiers = [{ name: "applyStyles", enabled: false }]), { ...t3, ...g2(this._config.popperConfig, [t3]) };
      }
      _selectMenuItem({ key: t3, target: e3 }) {
        const i2 = z2.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((t4) => a2(t4));
        i2.length && b2(i2, e3, t3 === Ti2, !i2.includes(e3)).focus();
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = qi2.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3])
              throw new TypeError(`No method named "${t3}"`);
            e3[t3]();
          }
        });
      }
      static clearMenus(t3) {
        if (2 === t3.button || "keyup" === t3.type && "Tab" !== t3.key)
          return;
        const e3 = z2.find(Ni2);
        for (const i2 of e3) {
          const e4 = qi2.getInstance(i2);
          if (!e4 || false === e4._config.autoClose)
            continue;
          const n3 = t3.composedPath(), s3 = n3.includes(e4._menu);
          if (n3.includes(e4._element) || "inside" === e4._config.autoClose && !s3 || "outside" === e4._config.autoClose && s3)
            continue;
          if (e4._menu.contains(t3.target) && ("keyup" === t3.type && "Tab" === t3.key || /input|select|option|textarea|form/i.test(t3.target.tagName)))
            continue;
          const o3 = { relatedTarget: e4._element };
          "click" === t3.type && (o3.clickEvent = t3), e4._completeHide(o3);
        }
      }
      static dataApiKeydownHandler(t3) {
        const e3 = /input|textarea/i.test(t3.target.tagName), i2 = "Escape" === t3.key, n3 = [Ei2, Ti2].includes(t3.key);
        if (!n3 && !i2)
          return;
        if (e3 && !i2)
          return;
        t3.preventDefault();
        const s3 = this.matches(Ii2) ? this : z2.prev(this, Ii2)[0] || z2.next(this, Ii2)[0] || z2.findOne(Ii2, t3.delegateTarget.parentNode), o3 = qi2.getOrCreateInstance(s3);
        if (n3)
          return t3.stopPropagation(), o3.show(), void o3._selectMenuItem(t3);
        o3._isShown() && (t3.stopPropagation(), o3.hide(), s3.focus());
      }
    }
    N2.on(document, Si2, Ii2, qi2.dataApiKeydownHandler), N2.on(document, Si2, Pi2, qi2.dataApiKeydownHandler), N2.on(document, Li2, qi2.clearMenus), N2.on(document, Di2, qi2.clearMenus), N2.on(document, Li2, Ii2, function(t3) {
      t3.preventDefault(), qi2.getOrCreateInstance(this).toggle();
    }), m2(qi2);
    const Vi2 = "backdrop", Ki2 = "show", Qi2 = `mousedown.bs.${Vi2}`, Xi2 = { className: "modal-backdrop", clickCallback: null, isAnimated: false, isVisible: true, rootElement: "body" }, Yi2 = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
    class Ui2 extends H2 {
      constructor(t3) {
        super(), this._config = this._getConfig(t3), this._isAppended = false, this._element = null;
      }
      static get Default() {
        return Xi2;
      }
      static get DefaultType() {
        return Yi2;
      }
      static get NAME() {
        return Vi2;
      }
      show(t3) {
        if (!this._config.isVisible)
          return void g2(t3);
        this._append();
        const e3 = this._getElement();
        this._config.isAnimated && d2(e3), e3.classList.add(Ki2), this._emulateAnimation(() => {
          g2(t3);
        });
      }
      hide(t3) {
        this._config.isVisible ? (this._getElement().classList.remove(Ki2), this._emulateAnimation(() => {
          this.dispose(), g2(t3);
        })) : g2(t3);
      }
      dispose() {
        this._isAppended && (N2.off(this._element, Qi2), this._element.remove(), this._isAppended = false);
      }
      _getElement() {
        if (!this._element) {
          const t3 = document.createElement("div");
          t3.className = this._config.className, this._config.isAnimated && t3.classList.add("fade"), this._element = t3;
        }
        return this._element;
      }
      _configAfterMerge(t3) {
        return t3.rootElement = r2(t3.rootElement), t3;
      }
      _append() {
        if (this._isAppended)
          return;
        const t3 = this._getElement();
        this._config.rootElement.append(t3), N2.on(t3, Qi2, () => {
          g2(this._config.clickCallback);
        }), this._isAppended = true;
      }
      _emulateAnimation(t3) {
        _2(t3, this._getElement(), this._config.isAnimated);
      }
    }
    const Gi2 = ".bs.focustrap", Ji2 = `focusin${Gi2}`, Zi2 = `keydown.tab${Gi2}`, tn = "backward", en = { autofocus: true, trapElement: null }, nn = { autofocus: "boolean", trapElement: "element" };
    class sn extends H2 {
      constructor(t3) {
        super(), this._config = this._getConfig(t3), this._isActive = false, this._lastTabNavDirection = null;
      }
      static get Default() {
        return en;
      }
      static get DefaultType() {
        return nn;
      }
      static get NAME() {
        return "focustrap";
      }
      activate() {
        this._isActive || (this._config.autofocus && this._config.trapElement.focus(), N2.off(document, Gi2), N2.on(document, Ji2, (t3) => this._handleFocusin(t3)), N2.on(document, Zi2, (t3) => this._handleKeydown(t3)), this._isActive = true);
      }
      deactivate() {
        this._isActive && (this._isActive = false, N2.off(document, Gi2));
      }
      _handleFocusin(t3) {
        const { trapElement: e3 } = this._config;
        if (t3.target === document || t3.target === e3 || e3.contains(t3.target))
          return;
        const i2 = z2.focusableChildren(e3);
        0 === i2.length ? e3.focus() : this._lastTabNavDirection === tn ? i2[i2.length - 1].focus() : i2[0].focus();
      }
      _handleKeydown(t3) {
        "Tab" === t3.key && (this._lastTabNavDirection = t3.shiftKey ? tn : "forward");
      }
    }
    const on2 = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", rn = ".sticky-top", an = "padding-right", ln = "margin-right";
    class cn {
      constructor() {
        this._element = document.body;
      }
      getWidth() {
        const t3 = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - t3);
      }
      hide() {
        const t3 = this.getWidth();
        this._disableOverFlow(), this._setElementAttributes(this._element, an, (e3) => e3 + t3), this._setElementAttributes(on2, an, (e3) => e3 + t3), this._setElementAttributes(rn, ln, (e3) => e3 - t3);
      }
      reset() {
        this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, an), this._resetElementAttributes(on2, an), this._resetElementAttributes(rn, ln);
      }
      isOverflowing() {
        return this.getWidth() > 0;
      }
      _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
      }
      _setElementAttributes(t3, e3, i2) {
        const n3 = this.getWidth();
        this._applyManipulationCallback(t3, (t4) => {
          if (t4 !== this._element && window.innerWidth > t4.clientWidth + n3)
            return;
          this._saveInitialAttribute(t4, e3);
          const s3 = window.getComputedStyle(t4).getPropertyValue(e3);
          t4.style.setProperty(e3, `${i2(Number.parseFloat(s3))}px`);
        });
      }
      _saveInitialAttribute(t3, e3) {
        const i2 = t3.style.getPropertyValue(e3);
        i2 && F2.setDataAttribute(t3, e3, i2);
      }
      _resetElementAttributes(t3, e3) {
        this._applyManipulationCallback(t3, (t4) => {
          const i2 = F2.getDataAttribute(t4, e3);
          null !== i2 ? (F2.removeDataAttribute(t4, e3), t4.style.setProperty(e3, i2)) : t4.style.removeProperty(e3);
        });
      }
      _applyManipulationCallback(t3, e3) {
        if (o2(t3))
          e3(t3);
        else
          for (const i2 of z2.find(t3, this._element))
            e3(i2);
      }
    }
    const hn = ".bs.modal", dn = `hide${hn}`, un = `hidePrevented${hn}`, fn3 = `hidden${hn}`, pn = `show${hn}`, mn = `shown${hn}`, gn = `resize${hn}`, _n = `click.dismiss${hn}`, bn = `mousedown.dismiss${hn}`, vn = `keydown.dismiss${hn}`, yn = `click${hn}.data-api`, wn = "modal-open", An = "show", En = "modal-static", Tn = { backdrop: true, focus: true, keyboard: true }, Cn = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
    class On extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._dialog = z2.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._isTransitioning = false, this._scrollBar = new cn(), this._addEventListeners();
      }
      static get Default() {
        return Tn;
      }
      static get DefaultType() {
        return Cn;
      }
      static get NAME() {
        return "modal";
      }
      toggle(t3) {
        return this._isShown ? this.hide() : this.show(t3);
      }
      show(t3) {
        this._isShown || this._isTransitioning || N2.trigger(this._element, pn, { relatedTarget: t3 }).defaultPrevented || (this._isShown = true, this._isTransitioning = true, this._scrollBar.hide(), document.body.classList.add(wn), this._adjustDialog(), this._backdrop.show(() => this._showElement(t3)));
      }
      hide() {
        this._isShown && !this._isTransitioning && (N2.trigger(this._element, dn).defaultPrevented || (this._isShown = false, this._isTransitioning = true, this._focustrap.deactivate(), this._element.classList.remove(An), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
      }
      dispose() {
        N2.off(window, hn), N2.off(this._dialog, hn), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
      }
      handleUpdate() {
        this._adjustDialog();
      }
      _initializeBackDrop() {
        return new Ui2({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
      }
      _initializeFocusTrap() {
        return new sn({ trapElement: this._element });
      }
      _showElement(t3) {
        document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
        const e3 = z2.findOne(".modal-body", this._dialog);
        e3 && (e3.scrollTop = 0), d2(this._element), this._element.classList.add(An), this._queueCallback(() => {
          this._config.focus && this._focustrap.activate(), this._isTransitioning = false, N2.trigger(this._element, mn, { relatedTarget: t3 });
        }, this._dialog, this._isAnimated());
      }
      _addEventListeners() {
        N2.on(this._element, vn, (t3) => {
          "Escape" === t3.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
        }), N2.on(window, gn, () => {
          this._isShown && !this._isTransitioning && this._adjustDialog();
        }), N2.on(this._element, bn, (t3) => {
          N2.one(this._element, _n, (e3) => {
            this._element === t3.target && this._element === e3.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
          });
        });
      }
      _hideModal() {
        this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
          document.body.classList.remove(wn), this._resetAdjustments(), this._scrollBar.reset(), N2.trigger(this._element, fn3);
        });
      }
      _isAnimated() {
        return this._element.classList.contains("fade");
      }
      _triggerBackdropTransition() {
        if (N2.trigger(this._element, un).defaultPrevented)
          return;
        const t3 = this._element.scrollHeight > document.documentElement.clientHeight, e3 = this._element.style.overflowY;
        "hidden" === e3 || this._element.classList.contains(En) || (t3 || (this._element.style.overflowY = "hidden"), this._element.classList.add(En), this._queueCallback(() => {
          this._element.classList.remove(En), this._queueCallback(() => {
            this._element.style.overflowY = e3;
          }, this._dialog);
        }, this._dialog), this._element.focus());
      }
      _adjustDialog() {
        const t3 = this._element.scrollHeight > document.documentElement.clientHeight, e3 = this._scrollBar.getWidth(), i2 = e3 > 0;
        if (i2 && !t3) {
          const t4 = p2() ? "paddingLeft" : "paddingRight";
          this._element.style[t4] = `${e3}px`;
        }
        if (!i2 && t3) {
          const t4 = p2() ? "paddingRight" : "paddingLeft";
          this._element.style[t4] = `${e3}px`;
        }
      }
      _resetAdjustments() {
        this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
      }
      static jQueryInterface(t3, e3) {
        return this.each(function() {
          const i2 = On.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === i2[t3])
              throw new TypeError(`No method named "${t3}"`);
            i2[t3](e3);
          }
        });
      }
    }
    N2.on(document, yn, '[data-bs-toggle="modal"]', function(t3) {
      const e3 = z2.getElementFromSelector(this);
      ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), N2.one(e3, pn, (t4) => {
        t4.defaultPrevented || N2.one(e3, fn3, () => {
          a2(this) && this.focus();
        });
      });
      const i2 = z2.findOne(".modal.show");
      i2 && On.getInstance(i2).hide(), On.getOrCreateInstance(e3).toggle(this);
    }), R2(On), m2(On);
    const xn = ".bs.offcanvas", kn = ".data-api", Ln = `load${xn}${kn}`, Sn = "show", Dn = "showing", $n = "hiding", In = ".offcanvas.show", Nn = `show${xn}`, Pn = `shown${xn}`, jn = `hide${xn}`, Mn = `hidePrevented${xn}`, Fn = `hidden${xn}`, Hn = `resize${xn}`, Wn = `click${xn}${kn}`, Bn = `keydown.dismiss${xn}`, zn = { backdrop: true, keyboard: true, scroll: false }, Rn = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
    class qn extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
      }
      static get Default() {
        return zn;
      }
      static get DefaultType() {
        return Rn;
      }
      static get NAME() {
        return "offcanvas";
      }
      toggle(t3) {
        return this._isShown ? this.hide() : this.show(t3);
      }
      show(t3) {
        this._isShown || N2.trigger(this._element, Nn, { relatedTarget: t3 }).defaultPrevented || (this._isShown = true, this._backdrop.show(), this._config.scroll || new cn().hide(), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(Dn), this._queueCallback(() => {
          this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Sn), this._element.classList.remove(Dn), N2.trigger(this._element, Pn, { relatedTarget: t3 });
        }, this._element, true));
      }
      hide() {
        this._isShown && (N2.trigger(this._element, jn).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.add($n), this._backdrop.hide(), this._queueCallback(() => {
          this._element.classList.remove(Sn, $n), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new cn().reset(), N2.trigger(this._element, Fn);
        }, this._element, true)));
      }
      dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
      }
      _initializeBackDrop() {
        const t3 = Boolean(this._config.backdrop);
        return new Ui2({ className: "offcanvas-backdrop", isVisible: t3, isAnimated: true, rootElement: this._element.parentNode, clickCallback: t3 ? () => {
          "static" !== this._config.backdrop ? this.hide() : N2.trigger(this._element, Mn);
        } : null });
      }
      _initializeFocusTrap() {
        return new sn({ trapElement: this._element });
      }
      _addEventListeners() {
        N2.on(this._element, Bn, (t3) => {
          "Escape" === t3.key && (this._config.keyboard ? this.hide() : N2.trigger(this._element, Mn));
        });
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = qn.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
              throw new TypeError(`No method named "${t3}"`);
            e3[t3](this);
          }
        });
      }
    }
    N2.on(document, Wn, '[data-bs-toggle="offcanvas"]', function(t3) {
      const e3 = z2.getElementFromSelector(this);
      if (["A", "AREA"].includes(this.tagName) && t3.preventDefault(), l2(this))
        return;
      N2.one(e3, Fn, () => {
        a2(this) && this.focus();
      });
      const i2 = z2.findOne(In);
      i2 && i2 !== e3 && qn.getInstance(i2).hide(), qn.getOrCreateInstance(e3).toggle(this);
    }), N2.on(window, Ln, () => {
      for (const t3 of z2.find(In))
        qn.getOrCreateInstance(t3).show();
    }), N2.on(window, Hn, () => {
      for (const t3 of z2.find("[aria-modal][class*=show][class*=offcanvas-]"))
        "fixed" !== getComputedStyle(t3).position && qn.getOrCreateInstance(t3).hide();
    }), R2(qn), m2(qn);
    const Vn = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, Kn = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Qn = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Xn = (t3, e3) => {
      const i2 = t3.nodeName.toLowerCase();
      return e3.includes(i2) ? !Kn.has(i2) || Boolean(Qn.test(t3.nodeValue)) : e3.filter((t4) => t4 instanceof RegExp).some((t4) => t4.test(i2));
    }, Yn = { allowList: Vn, content: {}, extraClass: "", html: false, sanitize: true, sanitizeFn: null, template: "<div></div>" }, Un = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, Gn = { entry: "(string|element|function|null)", selector: "(string|element)" };
    class Jn extends H2 {
      constructor(t3) {
        super(), this._config = this._getConfig(t3);
      }
      static get Default() {
        return Yn;
      }
      static get DefaultType() {
        return Un;
      }
      static get NAME() {
        return "TemplateFactory";
      }
      getContent() {
        return Object.values(this._config.content).map((t3) => this._resolvePossibleFunction(t3)).filter(Boolean);
      }
      hasContent() {
        return this.getContent().length > 0;
      }
      changeContent(t3) {
        return this._checkContent(t3), this._config.content = { ...this._config.content, ...t3 }, this;
      }
      toHtml() {
        const t3 = document.createElement("div");
        t3.innerHTML = this._maybeSanitize(this._config.template);
        for (const [e4, i3] of Object.entries(this._config.content))
          this._setContent(t3, i3, e4);
        const e3 = t3.children[0], i2 = this._resolvePossibleFunction(this._config.extraClass);
        return i2 && e3.classList.add(...i2.split(" ")), e3;
      }
      _typeCheckConfig(t3) {
        super._typeCheckConfig(t3), this._checkContent(t3.content);
      }
      _checkContent(t3) {
        for (const [e3, i2] of Object.entries(t3))
          super._typeCheckConfig({ selector: e3, entry: i2 }, Gn);
      }
      _setContent(t3, e3, i2) {
        const n3 = z2.findOne(i2, t3);
        n3 && ((e3 = this._resolvePossibleFunction(e3)) ? o2(e3) ? this._putElementInTemplate(r2(e3), n3) : this._config.html ? n3.innerHTML = this._maybeSanitize(e3) : n3.textContent = e3 : n3.remove());
      }
      _maybeSanitize(t3) {
        return this._config.sanitize ? function(t4, e3, i2) {
          if (!t4.length)
            return t4;
          if (i2 && "function" == typeof i2)
            return i2(t4);
          const n3 = new window.DOMParser().parseFromString(t4, "text/html"), s3 = [].concat(...n3.body.querySelectorAll("*"));
          for (const t5 of s3) {
            const i3 = t5.nodeName.toLowerCase();
            if (!Object.keys(e3).includes(i3)) {
              t5.remove();
              continue;
            }
            const n4 = [].concat(...t5.attributes), s4 = [].concat(e3["*"] || [], e3[i3] || []);
            for (const e4 of n4)
              Xn(e4, s4) || t5.removeAttribute(e4.nodeName);
          }
          return n3.body.innerHTML;
        }(t3, this._config.allowList, this._config.sanitizeFn) : t3;
      }
      _resolvePossibleFunction(t3) {
        return g2(t3, [this]);
      }
      _putElementInTemplate(t3, e3) {
        if (this._config.html)
          return e3.innerHTML = "", void e3.append(t3);
        e3.textContent = t3.textContent;
      }
    }
    const Zn = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), ts2 = "fade", es2 = "show", is2 = ".modal", ns2 = "hide.bs.modal", ss2 = "hover", os2 = "focus", rs2 = { AUTO: "auto", TOP: "top", RIGHT: p2() ? "left" : "right", BOTTOM: "bottom", LEFT: p2() ? "right" : "left" }, as2 = { allowList: Vn, animation: true, boundary: "clippingParents", container: false, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: false, offset: [0, 6], placement: "top", popperConfig: null, sanitize: true, sanitizeFn: null, selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, ls2 = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
    class cs2 extends W2 {
      constructor(t3, e3) {
        if (void 0 === vi2)
          throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        super(t3, e3), this._isEnabled = true, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
      }
      static get Default() {
        return as2;
      }
      static get DefaultType() {
        return ls2;
      }
      static get NAME() {
        return "tooltip";
      }
      enable() {
        this._isEnabled = true;
      }
      disable() {
        this._isEnabled = false;
      }
      toggleEnabled() {
        this._isEnabled = !this._isEnabled;
      }
      toggle() {
        this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter());
      }
      dispose() {
        clearTimeout(this._timeout), N2.off(this._element.closest(is2), ns2, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
      }
      show() {
        if ("none" === this._element.style.display)
          throw new Error("Please use show on visible elements");
        if (!this._isWithContent() || !this._isEnabled)
          return;
        const t3 = N2.trigger(this._element, this.constructor.eventName("show")), e3 = (c2(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
        if (t3.defaultPrevented || !e3)
          return;
        this._disposePopper();
        const i2 = this._getTipElement();
        this._element.setAttribute("aria-describedby", i2.getAttribute("id"));
        const { container: n3 } = this._config;
        if (this._element.ownerDocument.documentElement.contains(this.tip) || (n3.append(i2), N2.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(i2), i2.classList.add(es2), "ontouchstart" in document.documentElement)
          for (const t4 of [].concat(...document.body.children))
            N2.on(t4, "mouseover", h2);
        this._queueCallback(() => {
          N2.trigger(this._element, this.constructor.eventName("shown")), false === this._isHovered && this._leave(), this._isHovered = false;
        }, this.tip, this._isAnimated());
      }
      hide() {
        if (this._isShown() && !N2.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
          if (this._getTipElement().classList.remove(es2), "ontouchstart" in document.documentElement)
            for (const t3 of [].concat(...document.body.children))
              N2.off(t3, "mouseover", h2);
          this._activeTrigger.click = false, this._activeTrigger[os2] = false, this._activeTrigger[ss2] = false, this._isHovered = null, this._queueCallback(() => {
            this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), N2.trigger(this._element, this.constructor.eventName("hidden")));
          }, this.tip, this._isAnimated());
        }
      }
      update() {
        this._popper && this._popper.update();
      }
      _isWithContent() {
        return Boolean(this._getTitle());
      }
      _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
      }
      _createTipElement(t3) {
        const e3 = this._getTemplateFactory(t3).toHtml();
        if (!e3)
          return null;
        e3.classList.remove(ts2, es2), e3.classList.add(`bs-${this.constructor.NAME}-auto`);
        const i2 = ((t4) => {
          do {
            t4 += Math.floor(1e6 * Math.random());
          } while (document.getElementById(t4));
          return t4;
        })(this.constructor.NAME).toString();
        return e3.setAttribute("id", i2), this._isAnimated() && e3.classList.add(ts2), e3;
      }
      setContent(t3) {
        this._newContent = t3, this._isShown() && (this._disposePopper(), this.show());
      }
      _getTemplateFactory(t3) {
        return this._templateFactory ? this._templateFactory.changeContent(t3) : this._templateFactory = new Jn({ ...this._config, content: t3, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory;
      }
      _getContentForTemplate() {
        return { ".tooltip-inner": this._getTitle() };
      }
      _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
      }
      _initializeOnDelegatedTarget(t3) {
        return this.constructor.getOrCreateInstance(t3.delegateTarget, this._getDelegateConfig());
      }
      _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(ts2);
      }
      _isShown() {
        return this.tip && this.tip.classList.contains(es2);
      }
      _createPopper(t3) {
        const e3 = g2(this._config.placement, [this, t3, this._element]), i2 = rs2[e3.toUpperCase()];
        return bi2(this._element, t3, this._getPopperConfig(i2));
      }
      _getOffset() {
        const { offset: t3 } = this._config;
        return "string" == typeof t3 ? t3.split(",").map((t4) => Number.parseInt(t4, 10)) : "function" == typeof t3 ? (e3) => t3(e3, this._element) : t3;
      }
      _resolvePossibleFunction(t3) {
        return g2(t3, [this._element]);
      }
      _getPopperConfig(t3) {
        const e3 = { placement: t3, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: true, phase: "beforeMain", fn: (t4) => {
          this._getTipElement().setAttribute("data-popper-placement", t4.state.placement);
        } }] };
        return { ...e3, ...g2(this._config.popperConfig, [e3]) };
      }
      _setListeners() {
        const t3 = this._config.trigger.split(" ");
        for (const e3 of t3)
          if ("click" === e3)
            N2.on(this._element, this.constructor.eventName("click"), this._config.selector, (t4) => {
              this._initializeOnDelegatedTarget(t4).toggle();
            });
          else if ("manual" !== e3) {
            const t4 = e3 === ss2 ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), i2 = e3 === ss2 ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
            N2.on(this._element, t4, this._config.selector, (t5) => {
              const e4 = this._initializeOnDelegatedTarget(t5);
              e4._activeTrigger["focusin" === t5.type ? os2 : ss2] = true, e4._enter();
            }), N2.on(this._element, i2, this._config.selector, (t5) => {
              const e4 = this._initializeOnDelegatedTarget(t5);
              e4._activeTrigger["focusout" === t5.type ? os2 : ss2] = e4._element.contains(t5.relatedTarget), e4._leave();
            });
          }
        this._hideModalHandler = () => {
          this._element && this.hide();
        }, N2.on(this._element.closest(is2), ns2, this._hideModalHandler);
      }
      _fixTitle() {
        const t3 = this._element.getAttribute("title");
        t3 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", t3), this._element.setAttribute("data-bs-original-title", t3), this._element.removeAttribute("title"));
      }
      _enter() {
        this._isShown() || this._isHovered ? this._isHovered = true : (this._isHovered = true, this._setTimeout(() => {
          this._isHovered && this.show();
        }, this._config.delay.show));
      }
      _leave() {
        this._isWithActiveTrigger() || (this._isHovered = false, this._setTimeout(() => {
          this._isHovered || this.hide();
        }, this._config.delay.hide));
      }
      _setTimeout(t3, e3) {
        clearTimeout(this._timeout), this._timeout = setTimeout(t3, e3);
      }
      _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(true);
      }
      _getConfig(t3) {
        const e3 = F2.getDataAttributes(this._element);
        for (const t4 of Object.keys(e3))
          Zn.has(t4) && delete e3[t4];
        return t3 = { ...e3, ..."object" == typeof t3 && t3 ? t3 : {} }, t3 = this._mergeConfigObj(t3), t3 = this._configAfterMerge(t3), this._typeCheckConfig(t3), t3;
      }
      _configAfterMerge(t3) {
        return t3.container = false === t3.container ? document.body : r2(t3.container), "number" == typeof t3.delay && (t3.delay = { show: t3.delay, hide: t3.delay }), "number" == typeof t3.title && (t3.title = t3.title.toString()), "number" == typeof t3.content && (t3.content = t3.content.toString()), t3;
      }
      _getDelegateConfig() {
        const t3 = {};
        for (const [e3, i2] of Object.entries(this._config))
          this.constructor.Default[e3] !== i2 && (t3[e3] = i2);
        return t3.selector = false, t3.trigger = "manual", t3;
      }
      _disposePopper() {
        this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = cs2.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3])
              throw new TypeError(`No method named "${t3}"`);
            e3[t3]();
          }
        });
      }
    }
    m2(cs2);
    const hs2 = { ...cs2.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, ds2 = { ...cs2.DefaultType, content: "(null|string|element|function)" };
    class us2 extends cs2 {
      static get Default() {
        return hs2;
      }
      static get DefaultType() {
        return ds2;
      }
      static get NAME() {
        return "popover";
      }
      _isWithContent() {
        return this._getTitle() || this._getContent();
      }
      _getContentForTemplate() {
        return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() };
      }
      _getContent() {
        return this._resolvePossibleFunction(this._config.content);
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = us2.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3])
              throw new TypeError(`No method named "${t3}"`);
            e3[t3]();
          }
        });
      }
    }
    m2(us2);
    const fs = ".bs.scrollspy", ps = `activate${fs}`, ms = `click${fs}`, gs = `load${fs}.data-api`, _s = "active", bs = "[href]", vs = ".nav-link", ys = `${vs}, .nav-item > ${vs}, .list-group-item`, ws = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: false, target: null, threshold: [0.1, 0.5, 1] }, As = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
    class Es extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh();
      }
      static get Default() {
        return ws;
      }
      static get DefaultType() {
        return As;
      }
      static get NAME() {
        return "scrollspy";
      }
      refresh() {
        this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
        for (const t3 of this._observableSections.values())
          this._observer.observe(t3);
      }
      dispose() {
        this._observer.disconnect(), super.dispose();
      }
      _configAfterMerge(t3) {
        return t3.target = r2(t3.target) || document.body, t3.rootMargin = t3.offset ? `${t3.offset}px 0px -30%` : t3.rootMargin, "string" == typeof t3.threshold && (t3.threshold = t3.threshold.split(",").map((t4) => Number.parseFloat(t4))), t3;
      }
      _maybeEnableSmoothScroll() {
        this._config.smoothScroll && (N2.off(this._config.target, ms), N2.on(this._config.target, ms, bs, (t3) => {
          const e3 = this._observableSections.get(t3.target.hash);
          if (e3) {
            t3.preventDefault();
            const i2 = this._rootElement || window, n3 = e3.offsetTop - this._element.offsetTop;
            if (i2.scrollTo)
              return void i2.scrollTo({ top: n3, behavior: "smooth" });
            i2.scrollTop = n3;
          }
        }));
      }
      _getNewObserver() {
        const t3 = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
        return new IntersectionObserver((t4) => this._observerCallback(t4), t3);
      }
      _observerCallback(t3) {
        const e3 = (t4) => this._targetLinks.get(`#${t4.target.id}`), i2 = (t4) => {
          this._previousScrollData.visibleEntryTop = t4.target.offsetTop, this._process(e3(t4));
        }, n3 = (this._rootElement || document.documentElement).scrollTop, s3 = n3 >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = n3;
        for (const o3 of t3) {
          if (!o3.isIntersecting) {
            this._activeTarget = null, this._clearActiveClass(e3(o3));
            continue;
          }
          const t4 = o3.target.offsetTop >= this._previousScrollData.visibleEntryTop;
          if (s3 && t4) {
            if (i2(o3), !n3)
              return;
          } else
            s3 || t4 || i2(o3);
        }
      }
      _initializeTargetsAndObservables() {
        this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
        const t3 = z2.find(bs, this._config.target);
        for (const e3 of t3) {
          if (!e3.hash || l2(e3))
            continue;
          const t4 = z2.findOne(decodeURI(e3.hash), this._element);
          a2(t4) && (this._targetLinks.set(decodeURI(e3.hash), e3), this._observableSections.set(e3.hash, t4));
        }
      }
      _process(t3) {
        this._activeTarget !== t3 && (this._clearActiveClass(this._config.target), this._activeTarget = t3, t3.classList.add(_s), this._activateParents(t3), N2.trigger(this._element, ps, { relatedTarget: t3 }));
      }
      _activateParents(t3) {
        if (t3.classList.contains("dropdown-item"))
          z2.findOne(".dropdown-toggle", t3.closest(".dropdown")).classList.add(_s);
        else
          for (const e3 of z2.parents(t3, ".nav, .list-group"))
            for (const t4 of z2.prev(e3, ys))
              t4.classList.add(_s);
      }
      _clearActiveClass(t3) {
        t3.classList.remove(_s);
        const e3 = z2.find(`${bs}.${_s}`, t3);
        for (const t4 of e3)
          t4.classList.remove(_s);
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = Es.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
              throw new TypeError(`No method named "${t3}"`);
            e3[t3]();
          }
        });
      }
    }
    N2.on(window, gs, () => {
      for (const t3 of z2.find('[data-bs-spy="scroll"]'))
        Es.getOrCreateInstance(t3);
    }), m2(Es);
    const Ts = ".bs.tab", Cs = `hide${Ts}`, Os = `hidden${Ts}`, xs = `show${Ts}`, ks = `shown${Ts}`, Ls = `click${Ts}`, Ss = `keydown${Ts}`, Ds = `load${Ts}`, $s = "ArrowLeft", Is = "ArrowRight", Ns = "ArrowUp", Ps = "ArrowDown", js = "Home", Ms = "End", Fs = "active", Hs = "fade", Ws = "show", Bs = ".dropdown-toggle", zs = `:not(${Bs})`, Rs = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', qs = `.nav-link${zs}, .list-group-item${zs}, [role="tab"]${zs}, ${Rs}`, Vs = `.${Fs}[data-bs-toggle="tab"], .${Fs}[data-bs-toggle="pill"], .${Fs}[data-bs-toggle="list"]`;
    class Ks extends W2 {
      constructor(t3) {
        super(t3), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), N2.on(this._element, Ss, (t4) => this._keydown(t4)));
      }
      static get NAME() {
        return "tab";
      }
      show() {
        const t3 = this._element;
        if (this._elemIsActive(t3))
          return;
        const e3 = this._getActiveElem(), i2 = e3 ? N2.trigger(e3, Cs, { relatedTarget: t3 }) : null;
        N2.trigger(t3, xs, { relatedTarget: e3 }).defaultPrevented || i2 && i2.defaultPrevented || (this._deactivate(e3, t3), this._activate(t3, e3));
      }
      _activate(t3, e3) {
        t3 && (t3.classList.add(Fs), this._activate(z2.getElementFromSelector(t3)), this._queueCallback(() => {
          "tab" === t3.getAttribute("role") ? (t3.removeAttribute("tabindex"), t3.setAttribute("aria-selected", true), this._toggleDropDown(t3, true), N2.trigger(t3, ks, { relatedTarget: e3 })) : t3.classList.add(Ws);
        }, t3, t3.classList.contains(Hs)));
      }
      _deactivate(t3, e3) {
        t3 && (t3.classList.remove(Fs), t3.blur(), this._deactivate(z2.getElementFromSelector(t3)), this._queueCallback(() => {
          "tab" === t3.getAttribute("role") ? (t3.setAttribute("aria-selected", false), t3.setAttribute("tabindex", "-1"), this._toggleDropDown(t3, false), N2.trigger(t3, Os, { relatedTarget: e3 })) : t3.classList.remove(Ws);
        }, t3, t3.classList.contains(Hs)));
      }
      _keydown(t3) {
        if (![$s, Is, Ns, Ps, js, Ms].includes(t3.key))
          return;
        t3.stopPropagation(), t3.preventDefault();
        const e3 = this._getChildren().filter((t4) => !l2(t4));
        let i2;
        if ([js, Ms].includes(t3.key))
          i2 = e3[t3.key === js ? 0 : e3.length - 1];
        else {
          const n3 = [Is, Ps].includes(t3.key);
          i2 = b2(e3, t3.target, n3, true);
        }
        i2 && (i2.focus({ preventScroll: true }), Ks.getOrCreateInstance(i2).show());
      }
      _getChildren() {
        return z2.find(qs, this._parent);
      }
      _getActiveElem() {
        return this._getChildren().find((t3) => this._elemIsActive(t3)) || null;
      }
      _setInitialAttributes(t3, e3) {
        this._setAttributeIfNotExists(t3, "role", "tablist");
        for (const t4 of e3)
          this._setInitialAttributesOnChild(t4);
      }
      _setInitialAttributesOnChild(t3) {
        t3 = this._getInnerElement(t3);
        const e3 = this._elemIsActive(t3), i2 = this._getOuterElement(t3);
        t3.setAttribute("aria-selected", e3), i2 !== t3 && this._setAttributeIfNotExists(i2, "role", "presentation"), e3 || t3.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t3, "role", "tab"), this._setInitialAttributesOnTargetPanel(t3);
      }
      _setInitialAttributesOnTargetPanel(t3) {
        const e3 = z2.getElementFromSelector(t3);
        e3 && (this._setAttributeIfNotExists(e3, "role", "tabpanel"), t3.id && this._setAttributeIfNotExists(e3, "aria-labelledby", `${t3.id}`));
      }
      _toggleDropDown(t3, e3) {
        const i2 = this._getOuterElement(t3);
        if (!i2.classList.contains("dropdown"))
          return;
        const n3 = (t4, n4) => {
          const s3 = z2.findOne(t4, i2);
          s3 && s3.classList.toggle(n4, e3);
        };
        n3(Bs, Fs), n3(".dropdown-menu", Ws), i2.setAttribute("aria-expanded", e3);
      }
      _setAttributeIfNotExists(t3, e3, i2) {
        t3.hasAttribute(e3) || t3.setAttribute(e3, i2);
      }
      _elemIsActive(t3) {
        return t3.classList.contains(Fs);
      }
      _getInnerElement(t3) {
        return t3.matches(qs) ? t3 : z2.findOne(qs, t3);
      }
      _getOuterElement(t3) {
        return t3.closest(".nav-item, .list-group-item") || t3;
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = Ks.getOrCreateInstance(this);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3] || t3.startsWith("_") || "constructor" === t3)
              throw new TypeError(`No method named "${t3}"`);
            e3[t3]();
          }
        });
      }
    }
    N2.on(document, Ls, Rs, function(t3) {
      ["A", "AREA"].includes(this.tagName) && t3.preventDefault(), l2(this) || Ks.getOrCreateInstance(this).show();
    }), N2.on(window, Ds, () => {
      for (const t3 of z2.find(Vs))
        Ks.getOrCreateInstance(t3);
    }), m2(Ks);
    const Qs = ".bs.toast", Xs = `mouseover${Qs}`, Ys = `mouseout${Qs}`, Us = `focusin${Qs}`, Gs = `focusout${Qs}`, Js = `hide${Qs}`, Zs = `hidden${Qs}`, to = `show${Qs}`, eo = `shown${Qs}`, io = "hide", no = "show", so = "showing", oo = { animation: "boolean", autohide: "boolean", delay: "number" }, ro = { animation: true, autohide: true, delay: 5e3 };
    class ao extends W2 {
      constructor(t3, e3) {
        super(t3, e3), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
      }
      static get Default() {
        return ro;
      }
      static get DefaultType() {
        return oo;
      }
      static get NAME() {
        return "toast";
      }
      show() {
        N2.trigger(this._element, to).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(io), d2(this._element), this._element.classList.add(no, so), this._queueCallback(() => {
          this._element.classList.remove(so), N2.trigger(this._element, eo), this._maybeScheduleHide();
        }, this._element, this._config.animation));
      }
      hide() {
        this.isShown() && (N2.trigger(this._element, Js).defaultPrevented || (this._element.classList.add(so), this._queueCallback(() => {
          this._element.classList.add(io), this._element.classList.remove(so, no), N2.trigger(this._element, Zs);
        }, this._element, this._config.animation)));
      }
      dispose() {
        this._clearTimeout(), this.isShown() && this._element.classList.remove(no), super.dispose();
      }
      isShown() {
        return this._element.classList.contains(no);
      }
      _maybeScheduleHide() {
        this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
          this.hide();
        }, this._config.delay)));
      }
      _onInteraction(t3, e3) {
        switch (t3.type) {
          case "mouseover":
          case "mouseout":
            this._hasMouseInteraction = e3;
            break;
          case "focusin":
          case "focusout":
            this._hasKeyboardInteraction = e3;
        }
        if (e3)
          return void this._clearTimeout();
        const i2 = t3.relatedTarget;
        this._element === i2 || this._element.contains(i2) || this._maybeScheduleHide();
      }
      _setListeners() {
        N2.on(this._element, Xs, (t3) => this._onInteraction(t3, true)), N2.on(this._element, Ys, (t3) => this._onInteraction(t3, false)), N2.on(this._element, Us, (t3) => this._onInteraction(t3, true)), N2.on(this._element, Gs, (t3) => this._onInteraction(t3, false));
      }
      _clearTimeout() {
        clearTimeout(this._timeout), this._timeout = null;
      }
      static jQueryInterface(t3) {
        return this.each(function() {
          const e3 = ao.getOrCreateInstance(this, t3);
          if ("string" == typeof t3) {
            if (void 0 === e3[t3])
              throw new TypeError(`No method named "${t3}"`);
            e3[t3](this);
          }
        });
      }
    }
    return R2(ao), m2(ao), { Alert: Q2, Button: Y2, Carousel: xt2, Collapse: Bt2, Dropdown: qi2, Modal: On, Offcanvas: qn, Popover: us2, ScrollSpy: Es, Tab: Ks, Toast: ao, Tooltip: cs2 };
  });
})(bootstrap_bundle_min);
var bootstrap_bundle_minExports = bootstrap_bundle_min.exports;
const bootstrap$1 = /* @__PURE__ */ getDefaultExportFromCjs(bootstrap_bundle_minExports);
select2(jQuery$1);
window.$ = window.jQuery = jQuery$1;
console.log(window.jQuery, window.$);
window.bootstrap = bootstrap$1;
console.log("jQuery.event.global:", jQuery$1.event.global);
/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.8
 *
 */
(function($2) {
  $2.fn.extend({
    slimScroll: function(options) {
      var defaults2 = {
        // width in pixels of the visible scroll area
        width: "auto",
        // height in pixels of the visible scroll area
        height: "250px",
        // width in pixels of the scrollbar and rail
        size: "7px",
        // scrollbar color, accepts any hex/color value
        color: "#000",
        // scrollbar position - left/right
        position: "right",
        // distance in pixels between the side edge and the scrollbar
        distance: "1px",
        // default scroll position on load - top / bottom / $('selector')
        start: "top",
        // sets scrollbar opacity
        opacity: 0.4,
        // enables always-on mode for the scrollbar
        alwaysVisible: false,
        // check if we should hide the scrollbar when user is hovering over
        disableFadeOut: false,
        // sets visibility of the rail
        railVisible: false,
        // sets rail color
        railColor: "#333",
        // sets rail opacity
        railOpacity: 0.2,
        // whether  we should use jQuery UI Draggable to enable bar dragging
        railDraggable: true,
        // defautlt CSS class of the slimscroll rail
        railClass: "slimScrollRail",
        // defautlt CSS class of the slimscroll bar
        barClass: "slimScrollBar",
        // defautlt CSS class of the slimscroll wrapper
        wrapperClass: "slimScrollDiv",
        // check if mousewheel should scroll the window if we reach top/bottom
        allowPageScroll: false,
        // scroll amount applied to each mouse wheel step
        wheelStep: 20,
        // scroll amount applied when user is using gestures
        touchScrollStep: 200,
        // sets border radius
        borderRadius: "7px",
        // sets border radius of the rail
        railBorderRadius: "7px"
      };
      var o2 = $2.extend(defaults2, options);
      this.each(function() {
        var isOverPanel, isOverBar, isDragg, queueHide, touchDif, barHeight, percentScroll, lastScroll, divS = "<div></div>", minBarHeight = 30, releaseScroll = false;
        var me2 = $2(this);
        if (me2.parent().hasClass(o2.wrapperClass)) {
          var offset2 = me2.scrollTop();
          bar = me2.siblings("." + o2.barClass);
          rail = me2.siblings("." + o2.railClass);
          getBarHeight();
          if ($2.isPlainObject(options)) {
            if ("height" in options && options.height == "auto") {
              me2.parent().css("height", "auto");
              me2.css("height", "auto");
              var height = me2.parent().parent().height();
              me2.parent().css("height", height);
              me2.css("height", height);
            } else if ("height" in options) {
              var h2 = options.height;
              me2.parent().css("height", h2);
              me2.css("height", h2);
            }
            if ("scrollTo" in options) {
              offset2 = parseInt(o2.scrollTo);
            } else if ("scrollBy" in options) {
              offset2 += parseInt(o2.scrollBy);
            } else if ("destroy" in options) {
              bar.remove();
              rail.remove();
              me2.unwrap();
              return;
            }
            scrollContent(offset2, false, true);
          }
          return;
        } else if ($2.isPlainObject(options)) {
          if ("destroy" in options) {
            return;
          }
        }
        o2.height = o2.height == "auto" ? me2.parent().height() : o2.height;
        var wrapper = $2(divS).addClass(o2.wrapperClass).css({
          position: "relative",
          overflow: "hidden",
          width: o2.width,
          height: o2.height
        });
        me2.css({
          overflow: "hidden",
          width: o2.width,
          height: o2.height
        });
        var rail = $2(divS).addClass(o2.railClass).css({
          width: o2.size,
          height: "100%",
          position: "absolute",
          top: 0,
          display: o2.alwaysVisible && o2.railVisible ? "block" : "none",
          "border-radius": o2.railBorderRadius,
          background: o2.railColor,
          opacity: o2.railOpacity,
          zIndex: 90
        });
        var bar = $2(divS).addClass(o2.barClass).css({
          background: o2.color,
          width: o2.size,
          position: "absolute",
          top: 0,
          opacity: o2.opacity,
          display: o2.alwaysVisible ? "block" : "none",
          "border-radius": o2.borderRadius,
          BorderRadius: o2.borderRadius,
          MozBorderRadius: o2.borderRadius,
          WebkitBorderRadius: o2.borderRadius,
          zIndex: 99
        });
        var posCss = o2.position == "right" ? { right: o2.distance } : { left: o2.distance };
        rail.css(posCss);
        bar.css(posCss);
        me2.wrap(wrapper);
        me2.parent().append(bar);
        me2.parent().append(rail);
        if (o2.railDraggable) {
          bar.bind("mousedown", function(e2) {
            var $doc = $2(document);
            isDragg = true;
            t = parseFloat(bar.css("top"));
            pageY = e2.pageY;
            $doc.bind("mousemove.slimscroll", function(e3) {
              currTop = t + e3.pageY - pageY;
              bar.css("top", currTop);
              scrollContent(0, bar.position().top, false);
            });
            $doc.bind("mouseup.slimscroll", function(e3) {
              isDragg = false;
              hideBar();
              $doc.unbind(".slimscroll");
            });
            return false;
          }).bind("selectstart.slimscroll", function(e2) {
            e2.stopPropagation();
            e2.preventDefault();
            return false;
          });
        }
        rail.hover(function() {
          showBar();
        }, function() {
          hideBar();
        });
        bar.hover(function() {
          isOverBar = true;
        }, function() {
          isOverBar = false;
        });
        me2.hover(function() {
          isOverPanel = true;
          showBar();
          hideBar();
        }, function() {
          isOverPanel = false;
          hideBar();
        });
        me2.bind("touchstart", function(e2, b2) {
          if (e2.originalEvent.touches.length) {
            touchDif = e2.originalEvent.touches[0].pageY;
          }
        });
        me2.bind("touchmove", function(e2) {
          if (!releaseScroll) {
            e2.originalEvent.preventDefault();
          }
          if (e2.originalEvent.touches.length) {
            var diff = (touchDif - e2.originalEvent.touches[0].pageY) / o2.touchScrollStep;
            scrollContent(diff, true);
            touchDif = e2.originalEvent.touches[0].pageY;
          }
        });
        getBarHeight();
        if (o2.start === "bottom") {
          bar.css({ top: me2.outerHeight() - bar.outerHeight() });
          scrollContent(0, true);
        } else if (o2.start !== "top") {
          scrollContent($2(o2.start).position().top, null, true);
          if (!o2.alwaysVisible) {
            bar.hide();
          }
        }
        attachWheel(this);
        function _onWheel(e2) {
          if (!isOverPanel) {
            return;
          }
          var e2 = e2 || window.event;
          var delta = 0;
          if (e2.wheelDelta) {
            delta = -e2.wheelDelta / 120;
          }
          if (e2.detail) {
            delta = e2.detail / 3;
          }
          var target = e2.target || e2.srcTarget || e2.srcElement;
          if ($2(target).closest("." + o2.wrapperClass).is(me2.parent())) {
            scrollContent(delta, true);
          }
          if (e2.preventDefault && !releaseScroll) {
            e2.preventDefault();
          }
          if (!releaseScroll) {
            e2.returnValue = false;
          }
        }
        function scrollContent(y2, isWheel, isJump) {
          releaseScroll = false;
          var delta = y2;
          var maxTop = me2.outerHeight() - bar.outerHeight();
          if (isWheel) {
            delta = parseInt(bar.css("top")) + y2 * parseInt(o2.wheelStep) / 100 * bar.outerHeight();
            delta = Math.min(Math.max(delta, 0), maxTop);
            delta = y2 > 0 ? Math.ceil(delta) : Math.floor(delta);
            bar.css({ top: delta + "px" });
          }
          percentScroll = parseInt(bar.css("top")) / (me2.outerHeight() - bar.outerHeight());
          delta = percentScroll * (me2[0].scrollHeight - me2.outerHeight());
          if (isJump) {
            delta = y2;
            var offsetTop = delta / me2[0].scrollHeight * me2.outerHeight();
            offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
            bar.css({ top: offsetTop + "px" });
          }
          me2.scrollTop(delta);
          me2.trigger("slimscrolling", ~~delta);
          showBar();
          hideBar();
        }
        function attachWheel(target) {
          if (window.addEventListener) {
            target.addEventListener("DOMMouseScroll", _onWheel, false);
            target.addEventListener("mousewheel", _onWheel, false);
          } else {
            document.attachEvent("onmousewheel", _onWheel);
          }
        }
        function getBarHeight() {
          barHeight = Math.max(me2.outerHeight() / me2[0].scrollHeight * me2.outerHeight(), minBarHeight);
          bar.css({ height: barHeight + "px" });
          var display = barHeight == me2.outerHeight() ? "none" : "block";
          bar.css({ display });
        }
        function showBar() {
          getBarHeight();
          clearTimeout(queueHide);
          if (percentScroll == ~~percentScroll) {
            releaseScroll = o2.allowPageScroll;
            if (lastScroll != percentScroll) {
              var msg = ~~percentScroll == 0 ? "top" : "bottom";
              me2.trigger("slimscroll", msg);
            }
          } else {
            releaseScroll = false;
          }
          lastScroll = percentScroll;
          if (barHeight >= me2.outerHeight()) {
            releaseScroll = true;
            return;
          }
          bar.stop(true, true).fadeIn("fast");
          if (o2.railVisible) {
            rail.stop(true, true).fadeIn("fast");
          }
        }
        function hideBar() {
          if (!o2.alwaysVisible) {
            queueHide = setTimeout(function() {
              if (!(o2.disableFadeOut && isOverPanel) && !isOverBar && !isDragg) {
                bar.fadeOut("slow");
                rail.fadeOut("slow");
              }
            }, 1e3);
          }
        }
      });
      return this;
    }
  });
  $2.fn.extend({
    slimscroll: $2.fn.slimScroll
  });
})(jQuery);
var objectExtend = extend$1;
function extend$1() {
  var args = [].slice.call(arguments);
  var deep = false;
  if (typeof args[0] == "boolean") {
    deep = args.shift();
  }
  var result = args[0];
  if (isUnextendable(result)) {
    throw new Error("extendee must be an object");
  }
  var extenders = args.slice(1);
  var len = extenders.length;
  for (var i = 0; i < len; i++) {
    var extender = extenders[i];
    for (var key in extender) {
      if (Object.prototype.hasOwnProperty.call(extender, key)) {
        var value = extender[key];
        if (deep && isCloneable(value)) {
          var base = Array.isArray(value) ? [] : {};
          result[key] = extend$1(
            true,
            Object.prototype.hasOwnProperty.call(result, key) && !isUnextendable(result[key]) ? result[key] : base,
            value
          );
        } else {
          result[key] = value;
        }
      }
    }
  }
  return result;
}
function isCloneable(obj) {
  return Array.isArray(obj) || {}.toString.call(obj) == "[object Object]";
}
function isUnextendable(val) {
  return !val || typeof val != "object" && typeof val != "function";
}
function $parcel$interopDefault(a2) {
  return a2 && a2.__esModule ? a2.default : a2;
}
class $4040acfd8584338d$export$2e2bcd8739ae039 {
  // Add an event listener for given event
  on(event, fn3) {
    this._callbacks = this._callbacks || {};
    if (!this._callbacks[event])
      this._callbacks[event] = [];
    this._callbacks[event].push(fn3);
    return this;
  }
  emit(event, ...args) {
    this._callbacks = this._callbacks || {};
    let callbacks = this._callbacks[event];
    if (callbacks)
      for (let callback of callbacks)
        callback.apply(this, args);
    if (this.element)
      this.element.dispatchEvent(this.makeEvent("dropzone:" + event, {
        args
      }));
    return this;
  }
  makeEvent(eventName, detail) {
    let params = {
      bubbles: true,
      cancelable: true,
      detail
    };
    if (typeof window.CustomEvent === "function")
      return new CustomEvent(eventName, params);
    else {
      var evt = document.createEvent("CustomEvent");
      evt.initCustomEvent(eventName, params.bubbles, params.cancelable, params.detail);
      return evt;
    }
  }
  // Remove event listener for given event. If fn is not provided, all event
  // listeners for that event will be removed. If neither is provided, all
  // event listeners will be removed.
  off(event, fn3) {
    if (!this._callbacks || arguments.length === 0) {
      this._callbacks = {};
      return this;
    }
    let callbacks = this._callbacks[event];
    if (!callbacks)
      return this;
    if (arguments.length === 1) {
      delete this._callbacks[event];
      return this;
    }
    for (let i = 0; i < callbacks.length; i++) {
      let callback = callbacks[i];
      if (callback === fn3) {
        callbacks.splice(i, 1);
        break;
      }
    }
    return this;
  }
}
var $fd6031f88dce2e32$exports = {};
$fd6031f88dce2e32$exports = '<div class="dz-preview dz-file-preview">\n  <div class="dz-image"><img data-dz-thumbnail=""></div>\n  <div class="dz-details">\n    <div class="dz-size"><span data-dz-size=""></span></div>\n    <div class="dz-filename"><span data-dz-name=""></span></div>\n  </div>\n  <div class="dz-progress">\n    <span class="dz-upload" data-dz-uploadprogress=""></span>\n  </div>\n  <div class="dz-error-message"><span data-dz-errormessage=""></span></div>\n  <div class="dz-success-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M10.2071 29.7929L14.2929 25.7071C14.6834 25.3166 15.3166 25.3166 15.7071 25.7071L21.2929 31.2929C21.6834 31.6834 22.3166 31.6834 22.7071 31.2929L38.2929 15.7071C38.6834 15.3166 39.3166 15.3166 39.7071 15.7071L43.7929 19.7929C44.1834 20.1834 44.1834 20.8166 43.7929 21.2071L22.7071 42.2929C22.3166 42.6834 21.6834 42.6834 21.2929 42.2929L10.2071 31.2071C9.81658 30.8166 9.81658 30.1834 10.2071 29.7929Z"></path>\n    </svg>\n  </div>\n  <div class="dz-error-mark">\n    <svg width="54" height="54" viewBox="0 0 54 54" fill="white" xmlns="http://www.w3.org/2000/svg">\n      <path d="M26.2929 20.2929L19.2071 13.2071C18.8166 12.8166 18.1834 12.8166 17.7929 13.2071L13.2071 17.7929C12.8166 18.1834 12.8166 18.8166 13.2071 19.2071L20.2929 26.2929C20.6834 26.6834 20.6834 27.3166 20.2929 27.7071L13.2071 34.7929C12.8166 35.1834 12.8166 35.8166 13.2071 36.2071L17.7929 40.7929C18.1834 41.1834 18.8166 41.1834 19.2071 40.7929L26.2929 33.7071C26.6834 33.3166 27.3166 33.3166 27.7071 33.7071L34.7929 40.7929C35.1834 41.1834 35.8166 41.1834 36.2071 40.7929L40.7929 36.2071C41.1834 35.8166 41.1834 35.1834 40.7929 34.7929L33.7071 27.7071C33.3166 27.3166 33.3166 26.6834 33.7071 26.2929L40.7929 19.2071C41.1834 18.8166 41.1834 18.1834 40.7929 17.7929L36.2071 13.2071C35.8166 12.8166 35.1834 12.8166 34.7929 13.2071L27.7071 20.2929C27.3166 20.6834 26.6834 20.6834 26.2929 20.2929Z"></path>\n    </svg>\n  </div>\n</div>\n';
let $4ca367182776f80b$var$defaultOptions = {
  /**
  * Has to be specified on elements other than form (or when the form doesn't
  * have an `action` attribute).
  *
  * You can also provide a function that will be called with `files` and
  * `dataBlocks`  and must return the url as string.
  */
  url: null,
  /**
  * Can be changed to `"put"` if necessary. You can also provide a function
  * that will be called with `files` and must return the method (since `v3.12.0`).
  */
  method: "post",
  /**
  * Will be set on the XHRequest.
  */
  withCredentials: false,
  /**
  * The timeout for the XHR requests in milliseconds (since `v4.4.0`).
  * If set to null or 0, no timeout is going to be set.
  */
  timeout: null,
  /**
  * How many file uploads to process in parallel (See the
  * Enqueuing file uploads documentation section for more info)
  */
  parallelUploads: 2,
  /**
  * Whether to send multiple files in one request. If
  * this it set to true, then the fallback file input element will
  * have the `multiple` attribute as well. This option will
  * also trigger additional events (like `processingmultiple`). See the events
  * documentation section for more information.
  */
  uploadMultiple: false,
  /**
  * Whether you want files to be uploaded in chunks to your server. This can't be
  * used in combination with `uploadMultiple`.
  *
  * See [chunksUploaded](#config-chunksUploaded) for the callback to finalise an upload.
  */
  chunking: false,
  /**
  * If `chunking` is enabled, this defines whether **every** file should be chunked,
  * even if the file size is below chunkSize. This means, that the additional chunk
  * form data will be submitted and the `chunksUploaded` callback will be invoked.
  */
  forceChunking: false,
  /**
  * If `chunking` is `true`, then this defines the chunk size in bytes.
  */
  chunkSize: 2097152,
  /**
  * If `true`, the individual chunks of a file are being uploaded simultaneously.
  */
  parallelChunkUploads: false,
  /**
  * Whether a chunk should be retried if it fails.
  */
  retryChunks: false,
  /**
  * If `retryChunks` is true, how many times should it be retried.
  */
  retryChunksLimit: 3,
  /**
  * The maximum filesize (in MiB) that is allowed to be uploaded.
  */
  maxFilesize: 256,
  /**
  * The name of the file param that gets transferred.
  * **NOTE**: If you have the option  `uploadMultiple` set to `true`, then
  * Dropzone will append `[]` to the name.
  */
  paramName: "file",
  /**
  * Whether thumbnails for images should be generated
  */
  createImageThumbnails: true,
  /**
  * In MB. When the filename exceeds this limit, the thumbnail will not be generated.
  */
  maxThumbnailFilesize: 10,
  /**
  * If `null`, the ratio of the image will be used to calculate it.
  */
  thumbnailWidth: 120,
  /**
  * The same as `thumbnailWidth`. If both are null, images will not be resized.
  */
  thumbnailHeight: 120,
  /**
  * How the images should be scaled down in case both, `thumbnailWidth` and `thumbnailHeight` are provided.
  * Can be either `contain` or `crop`.
  */
  thumbnailMethod: "crop",
  /**
  * If set, images will be resized to these dimensions before being **uploaded**.
  * If only one, `resizeWidth` **or** `resizeHeight` is provided, the original aspect
  * ratio of the file will be preserved.
  *
  * The `options.transformFile` function uses these options, so if the `transformFile` function
  * is overridden, these options don't do anything.
  */
  resizeWidth: null,
  /**
  * See `resizeWidth`.
  */
  resizeHeight: null,
  /**
  * The mime type of the resized image (before it gets uploaded to the server).
  * If `null` the original mime type will be used. To force jpeg, for example, use `image/jpeg`.
  * See `resizeWidth` for more information.
  */
  resizeMimeType: null,
  /**
  * The quality of the resized images. See `resizeWidth`.
  */
  resizeQuality: 0.8,
  /**
  * How the images should be scaled down in case both, `resizeWidth` and `resizeHeight` are provided.
  * Can be either `contain` or `crop`.
  */
  resizeMethod: "contain",
  /**
  * The base that is used to calculate the **displayed** filesize. You can
  * change this to 1024 if you would rather display kibibytes, mebibytes,
  * etc... 1024 is technically incorrect, because `1024 bytes` are `1 kibibyte`
  * not `1 kilobyte`. You can change this to `1024` if you don't care about
  * validity.
  */
  filesizeBase: 1e3,
  /**
  * If not `null` defines how many files this Dropzone handles. If it exceeds,
  * the event `maxfilesexceeded` will be called. The dropzone element gets the
  * class `dz-max-files-reached` accordingly so you can provide visual
  * feedback.
  */
  maxFiles: null,
  /**
  * An optional object to send additional headers to the server. Eg:
  * `{ "My-Awesome-Header": "header value" }`
  */
  headers: null,
  /**
  * Should the default headers be set or not?
  * Accept: application/json <- for requesting json response
  * Cache-Control: no-cache <- Request shouldnt be cached
  * X-Requested-With: XMLHttpRequest <- We sent the request via XMLHttpRequest
  */
  defaultHeaders: true,
  /**
  * If `true`, the dropzone element itself will be clickable, if `false`
  * nothing will be clickable.
  *
  * You can also pass an HTML element, a CSS selector (for multiple elements)
  * or an array of those. In that case, all of those elements will trigger an
  * upload when clicked.
  */
  clickable: true,
  /**
  * Whether hidden files in directories should be ignored.
  */
  ignoreHiddenFiles: true,
  /**
  * The default implementation of `accept` checks the file's mime type or
  * extension against this list. This is a comma separated list of mime
  * types or file extensions.
  *
  * Eg.: `image/*,application/pdf,.psd`
  *
  * If the Dropzone is `clickable` this option will also be used as
  * [`accept`](https://developer.mozilla.org/en-US/docs/HTML/Element/input#attr-accept)
  * parameter on the hidden file input as well.
  */
  acceptedFiles: null,
  /**
  * **Deprecated!**
  * Use acceptedFiles instead.
  */
  acceptedMimeTypes: null,
  /**
  * If false, files will be added to the queue but the queue will not be
  * processed automatically.
  * This can be useful if you need some additional user input before sending
  * files (or if you want want all files sent at once).
  * If you're ready to send the file simply call `myDropzone.processQueue()`.
  *
  * See the [enqueuing file uploads](#enqueuing-file-uploads) documentation
  * section for more information.
  */
  autoProcessQueue: true,
  /**
  * If false, files added to the dropzone will not be queued by default.
  * You'll have to call `enqueueFile(file)` manually.
  */
  autoQueue: true,
  /**
  * If `true`, this will add a link to every file preview to remove or cancel (if
  * already uploading) the file. The `dictCancelUpload`, `dictCancelUploadConfirmation`
  * and `dictRemoveFile` options are used for the wording.
  */
  addRemoveLinks: false,
  /**
  * Defines where to display the file previews – if `null` the
  * Dropzone element itself is used. Can be a plain `HTMLElement` or a CSS
  * selector. The element should have the `dropzone-previews` class so
  * the previews are displayed properly.
  */
  previewsContainer: null,
  /**
  * Set this to `true` if you don't want previews to be shown.
  */
  disablePreviews: false,
  /**
  * This is the element the hidden input field (which is used when clicking on the
  * dropzone to trigger file selection) will be appended to. This might
  * be important in case you use frameworks to switch the content of your page.
  *
  * Can be a selector string, or an element directly.
  */
  hiddenInputContainer: "body",
  /**
  * If null, no capture type will be specified
  * If camera, mobile devices will skip the file selection and choose camera
  * If microphone, mobile devices will skip the file selection and choose the microphone
  * If camcorder, mobile devices will skip the file selection and choose the camera in video mode
  * On apple devices multiple must be set to false.  AcceptedFiles may need to
  * be set to an appropriate mime type (e.g. "image/*", "audio/*", or "video/*").
  */
  capture: null,
  /**
  * **Deprecated**. Use `renameFile` instead.
  */
  renameFilename: null,
  /**
  * A function that is invoked before the file is uploaded to the server and renames the file.
  * This function gets the `File` as argument and can use the `file.name`. The actual name of the
  * file that gets used during the upload can be accessed through `file.upload.filename`.
  */
  renameFile: null,
  /**
  * If `true` the fallback will be forced. This is very useful to test your server
  * implementations first and make sure that everything works as
  * expected without dropzone if you experience problems, and to test
  * how your fallbacks will look.
  */
  forceFallback: false,
  /**
  * The text used before any files are dropped.
  */
  dictDefaultMessage: "Drop files here to upload",
  /**
  * The text that replaces the default message text it the browser is not supported.
  */
  dictFallbackMessage: "Your browser does not support drag'n'drop file uploads.",
  /**
  * The text that will be added before the fallback form.
  * If you provide a  fallback element yourself, or if this option is `null` this will
  * be ignored.
  */
  dictFallbackText: "Please use the fallback form below to upload your files like in the olden days.",
  /**
  * If the filesize is too big.
  * `{{filesize}}` and `{{maxFilesize}}` will be replaced with the respective configuration values.
  */
  dictFileTooBig: "File is too big ({{filesize}}MiB). Max filesize: {{maxFilesize}}MiB.",
  /**
  * If the file doesn't match the file type.
  */
  dictInvalidFileType: "You can't upload files of this type.",
  /**
  * If the server response was invalid.
  * `{{statusCode}}` will be replaced with the servers status code.
  */
  dictResponseError: "Server responded with {{statusCode}} code.",
  /**
  * If `addRemoveLinks` is true, the text to be used for the cancel upload link.
  */
  dictCancelUpload: "Cancel upload",
  /**
  * The text that is displayed if an upload was manually canceled
  */
  dictUploadCanceled: "Upload canceled.",
  /**
  * If `addRemoveLinks` is true, the text to be used for confirmation when cancelling upload.
  */
  dictCancelUploadConfirmation: "Are you sure you want to cancel this upload?",
  /**
  * If `addRemoveLinks` is true, the text to be used to remove a file.
  */
  dictRemoveFile: "Remove file",
  /**
  * If this is not null, then the user will be prompted before removing a file.
  */
  dictRemoveFileConfirmation: null,
  /**
  * Displayed if `maxFiles` is st and exceeded.
  * The string `{{maxFiles}}` will be replaced by the configuration value.
  */
  dictMaxFilesExceeded: "You can not upload any more files.",
  /**
  * Allows you to translate the different units. Starting with `tb` for terabytes and going down to
  * `b` for bytes.
  */
  dictFileSizeUnits: {
    tb: "TB",
    gb: "GB",
    mb: "MB",
    kb: "KB",
    b: "b"
  },
  /**
  * Called when dropzone initialized
  * You can add event listeners here
  */
  init() {
  },
  /**
  * Can be an **object** of additional parameters to transfer to the server, **or** a `Function`
  * that gets invoked with the `files`, `xhr` and, if it's a chunked upload, `chunk` arguments. In case
  * of a function, this needs to return a map.
  *
  * The default implementation does nothing for normal uploads, but adds relevant information for
  * chunked uploads.
  *
  * This is the same as adding hidden input fields in the form element.
  */
  params(files, xhr, chunk) {
    if (chunk)
      return {
        dzuuid: chunk.file.upload.uuid,
        dzchunkindex: chunk.index,
        dztotalfilesize: chunk.file.size,
        dzchunksize: this.options.chunkSize,
        dztotalchunkcount: chunk.file.upload.totalChunkCount,
        dzchunkbyteoffset: chunk.index * this.options.chunkSize
      };
  },
  /**
  * A function that gets a [file](https://developer.mozilla.org/en-US/docs/DOM/File)
  * and a `done` function as parameters.
  *
  * If the done function is invoked without arguments, the file is "accepted" and will
  * be processed. If you pass an error message, the file is rejected, and the error
  * message will be displayed.
  * This function will not be called if the file is too big or doesn't match the mime types.
  */
  accept(file2, done) {
    return done();
  },
  /**
  * The callback that will be invoked when all chunks have been uploaded for a file.
  * It gets the file for which the chunks have been uploaded as the first parameter,
  * and the `done` function as second. `done()` needs to be invoked when everything
  * needed to finish the upload process is done.
  */
  chunksUploaded: function(file2, done) {
    done();
  },
  /**
  * Sends the file as binary blob in body instead of form data.
  * If this is set, the `params` option will be ignored.
  * It's an error to set this to `true` along with `uploadMultiple` since
  * multiple files cannot be in a single binary body.
  */
  binaryBody: false,
  /**
  * Gets called when the browser is not supported.
  * The default implementation shows the fallback input field and adds
  * a text.
  */
  fallback() {
    let messageElement;
    this.element.className = `${this.element.className} dz-browser-not-supported`;
    for (let child of this.element.getElementsByTagName("div"))
      if (/(^| )dz-message($| )/.test(child.className)) {
        messageElement = child;
        child.className = "dz-message";
        break;
      }
    if (!messageElement) {
      messageElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement('<div class="dz-message"><span></span></div>');
      this.element.appendChild(messageElement);
    }
    let span = messageElement.getElementsByTagName("span")[0];
    if (span) {
      if (span.textContent != null)
        span.textContent = this.options.dictFallbackMessage;
      else if (span.innerText != null)
        span.innerText = this.options.dictFallbackMessage;
    }
    return this.element.appendChild(this.getFallbackForm());
  },
  /**
  * Gets called to calculate the thumbnail dimensions.
  *
  * It gets `file`, `width` and `height` (both may be `null`) as parameters and must return an object containing:
  *
  *  - `srcWidth` & `srcHeight` (required)
  *  - `trgWidth` & `trgHeight` (required)
  *  - `srcX` & `srcY` (optional, default `0`)
  *  - `trgX` & `trgY` (optional, default `0`)
  *
  * Those values are going to be used by `ctx.drawImage()`.
  */
  resize(file2, width, height, resizeMethod) {
    let info = {
      srcX: 0,
      srcY: 0,
      srcWidth: file2.width,
      srcHeight: file2.height
    };
    let srcRatio = file2.width / file2.height;
    if (width == null && height == null) {
      width = info.srcWidth;
      height = info.srcHeight;
    } else if (width == null)
      width = height * srcRatio;
    else if (height == null)
      height = width / srcRatio;
    width = Math.min(width, info.srcWidth);
    height = Math.min(height, info.srcHeight);
    let trgRatio = width / height;
    if (info.srcWidth > width || info.srcHeight > height) {
      if (resizeMethod === "crop") {
        if (srcRatio > trgRatio) {
          info.srcHeight = file2.height;
          info.srcWidth = info.srcHeight * trgRatio;
        } else {
          info.srcWidth = file2.width;
          info.srcHeight = info.srcWidth / trgRatio;
        }
      } else if (resizeMethod === "contain") {
        if (srcRatio > trgRatio)
          height = width / srcRatio;
        else
          width = height * srcRatio;
      } else
        throw new Error(`Unknown resizeMethod '${resizeMethod}'`);
    }
    info.srcX = (file2.width - info.srcWidth) / 2;
    info.srcY = (file2.height - info.srcHeight) / 2;
    info.trgWidth = width;
    info.trgHeight = height;
    return info;
  },
  /**
  * Can be used to transform the file (for example, resize an image if necessary).
  *
  * The default implementation uses `resizeWidth` and `resizeHeight` (if provided) and resizes
  * images according to those dimensions.
  *
  * Gets the `file` as the first parameter, and a `done()` function as the second, that needs
  * to be invoked with the file when the transformation is done.
  */
  transformFile(file2, done) {
    if ((this.options.resizeWidth || this.options.resizeHeight) && file2.type.match(/image.*/))
      return this.resizeImage(file2, this.options.resizeWidth, this.options.resizeHeight, this.options.resizeMethod, done);
    else
      return done(file2);
  },
  /**
  * A string that contains the template used for each dropped
  * file. Change it to fulfill your needs but make sure to properly
  * provide all elements.
  *
  * If you want to use an actual HTML element instead of providing a String
  * as a config option, you could create a div with the id `tpl`,
  * put the template inside it and provide the element like this:
  *
  *     document
  *       .querySelector('#tpl')
  *       .innerHTML
  *
  */
  previewTemplate: /* @__PURE__ */ $parcel$interopDefault($fd6031f88dce2e32$exports),
  /*
  Those functions register themselves to the events on init and handle all
  the user interface specific stuff. Overwriting them won't break the upload
  but can break the way it's displayed.
  You can overwrite them if you don't like the default behavior. If you just
  want to add an additional event handler, register it on the dropzone object
  and don't overwrite those options.
  */
  // Those are self explanatory and simply concern the DragnDrop.
  drop(e2) {
    return this.element.classList.remove("dz-drag-hover");
  },
  dragstart(e2) {
  },
  dragend(e2) {
    return this.element.classList.remove("dz-drag-hover");
  },
  dragenter(e2) {
    return this.element.classList.add("dz-drag-hover");
  },
  dragover(e2) {
    return this.element.classList.add("dz-drag-hover");
  },
  dragleave(e2) {
    return this.element.classList.remove("dz-drag-hover");
  },
  paste(e2) {
  },
  // Called whenever there are no files left in the dropzone anymore, and the
  // dropzone should be displayed as if in the initial state.
  reset() {
    return this.element.classList.remove("dz-started");
  },
  // Called when a file is added to the queue
  // Receives `file`
  addedfile(file2) {
    if (this.element === this.previewsContainer)
      this.element.classList.add("dz-started");
    if (this.previewsContainer && !this.options.disablePreviews) {
      file2.previewElement = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(this.options.previewTemplate.trim());
      file2.previewTemplate = file2.previewElement;
      this.previewsContainer.appendChild(file2.previewElement);
      for (var node of file2.previewElement.querySelectorAll("[data-dz-name]"))
        node.textContent = file2.name;
      for (node of file2.previewElement.querySelectorAll("[data-dz-size]"))
        node.innerHTML = this.filesize(file2.size);
      if (this.options.addRemoveLinks) {
        file2._removeLink = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<a class="dz-remove" href="javascript:undefined;" data-dz-remove>${this.options.dictRemoveFile}</a>`);
        file2.previewElement.appendChild(file2._removeLink);
      }
      let removeFileEvent = (e2) => {
        e2.preventDefault();
        e2.stopPropagation();
        if (file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING)
          return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(
            this.options.dictCancelUploadConfirmation,
            () => this.removeFile(file2)
          );
        else {
          if (this.options.dictRemoveFileConfirmation)
            return $3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm(
              this.options.dictRemoveFileConfirmation,
              () => this.removeFile(file2)
            );
          else
            return this.removeFile(file2);
        }
      };
      for (let removeLink of file2.previewElement.querySelectorAll("[data-dz-remove]"))
        removeLink.addEventListener("click", removeFileEvent);
    }
  },
  // Called whenever a file is removed.
  removedfile(file2) {
    if (file2.previewElement != null && file2.previewElement.parentNode != null)
      file2.previewElement.parentNode.removeChild(file2.previewElement);
    return this._updateMaxFilesReachedClass();
  },
  // Called when a thumbnail has been generated
  // Receives `file` and `dataUrl`
  thumbnail(file2, dataUrl) {
    if (file2.previewElement) {
      file2.previewElement.classList.remove("dz-file-preview");
      for (let thumbnailElement of file2.previewElement.querySelectorAll("[data-dz-thumbnail]")) {
        thumbnailElement.alt = file2.name;
        thumbnailElement.src = dataUrl;
      }
      return setTimeout(
        () => file2.previewElement.classList.add("dz-image-preview"),
        1
      );
    }
  },
  // Called whenever an error occurs
  // Receives `file` and `message`
  error(file2, message) {
    if (file2.previewElement) {
      file2.previewElement.classList.add("dz-error");
      if (typeof message !== "string" && message.error)
        message = message.error;
      for (let node of file2.previewElement.querySelectorAll("[data-dz-errormessage]"))
        node.textContent = message;
    }
  },
  errormultiple() {
  },
  // Called when a file gets processed. Since there is a cue, not all added
  // files are processed immediately.
  // Receives `file`
  processing(file2) {
    if (file2.previewElement) {
      file2.previewElement.classList.add("dz-processing");
      if (file2._removeLink)
        return file2._removeLink.innerHTML = this.options.dictCancelUpload;
    }
  },
  processingmultiple() {
  },
  // Called whenever the upload progress gets updated.
  // Receives `file`, `progress` (percentage 0-100) and `bytesSent`.
  // To get the total number of bytes of the file, use `file.size`
  uploadprogress(file2, progress, bytesSent) {
    if (file2.previewElement)
      for (let node of file2.previewElement.querySelectorAll("[data-dz-uploadprogress]"))
        node.nodeName === "PROGRESS" ? node.value = progress : node.style.width = `${progress}%`;
  },
  // Called whenever the total upload progress gets updated.
  // Called with totalUploadProgress (0-100), totalBytes and totalBytesSent
  totaluploadprogress() {
  },
  // Called just before the file is sent. Gets the `xhr` object as second
  // parameter, so you can modify it (for example to add a CSRF token) and a
  // `formData` object to add additional information.
  sending() {
  },
  sendingmultiple() {
  },
  // When the complete upload is finished and successful
  // Receives `file`
  success(file2) {
    if (file2.previewElement)
      return file2.previewElement.classList.add("dz-success");
  },
  successmultiple() {
  },
  // When the upload is canceled.
  canceled(file2) {
    return this.emit("error", file2, this.options.dictUploadCanceled);
  },
  canceledmultiple() {
  },
  // When the upload is finished, either with success or an error.
  // Receives `file`
  complete(file2) {
    if (file2._removeLink)
      file2._removeLink.innerHTML = this.options.dictRemoveFile;
    if (file2.previewElement)
      return file2.previewElement.classList.add("dz-complete");
  },
  completemultiple() {
  },
  maxfilesexceeded() {
  },
  maxfilesreached() {
  },
  queuecomplete() {
  },
  addedfiles() {
  }
};
var $4ca367182776f80b$export$2e2bcd8739ae039 = $4ca367182776f80b$var$defaultOptions;
class $3ed269f2f0fb224b$export$2e2bcd8739ae039 extends $4040acfd8584338d$export$2e2bcd8739ae039 {
  static initClass() {
    this.prototype.Emitter = $4040acfd8584338d$export$2e2bcd8739ae039;
    this.prototype.events = [
      "drop",
      "dragstart",
      "dragend",
      "dragenter",
      "dragover",
      "dragleave",
      "addedfile",
      "addedfiles",
      "removedfile",
      "thumbnail",
      "error",
      "errormultiple",
      "processing",
      "processingmultiple",
      "uploadprogress",
      "totaluploadprogress",
      "sending",
      "sendingmultiple",
      "success",
      "successmultiple",
      "canceled",
      "canceledmultiple",
      "complete",
      "completemultiple",
      "reset",
      "maxfilesexceeded",
      "maxfilesreached",
      "queuecomplete"
    ];
    this.prototype._thumbnailQueue = [];
    this.prototype._processingThumbnail = false;
  }
  // Returns all files that have been accepted
  getAcceptedFiles() {
    return this.files.filter(
      (file2) => file2.accepted
    ).map(
      (file2) => file2
    );
  }
  // Returns all files that have been rejected
  // Not sure when that's going to be useful, but added for completeness.
  getRejectedFiles() {
    return this.files.filter(
      (file2) => !file2.accepted
    ).map(
      (file2) => file2
    );
  }
  getFilesWithStatus(status) {
    return this.files.filter(
      (file2) => file2.status === status
    ).map(
      (file2) => file2
    );
  }
  // Returns all files that are in the queue
  getQueuedFiles() {
    return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED);
  }
  getUploadingFiles() {
    return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING);
  }
  getAddedFiles() {
    return this.getFilesWithStatus($3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED);
  }
  // Files that are either queued or uploading
  getActiveFiles() {
    return this.files.filter(
      (file2) => file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED
    ).map(
      (file2) => file2
    );
  }
  // The function that gets called when Dropzone is initialized. You
  // can (and should) setup event listeners inside this function.
  init() {
    if (this.element.tagName === "form")
      this.element.setAttribute("enctype", "multipart/form-data");
    if (this.element.classList.contains("dropzone") && !this.element.querySelector(".dz-message"))
      this.element.appendChild($3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<div class="dz-default dz-message"><button class="dz-button" type="button">${this.options.dictDefaultMessage}</button></div>`));
    if (this.clickableElements.length) {
      let setupHiddenFileInput = () => {
        if (this.hiddenFileInput)
          this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
        this.hiddenFileInput = document.createElement("input");
        this.hiddenFileInput.setAttribute("type", "file");
        if (this.options.maxFiles === null || this.options.maxFiles > 1)
          this.hiddenFileInput.setAttribute("multiple", "multiple");
        this.hiddenFileInput.className = "dz-hidden-input";
        if (this.options.acceptedFiles !== null)
          this.hiddenFileInput.setAttribute("accept", this.options.acceptedFiles);
        if (this.options.capture !== null)
          this.hiddenFileInput.setAttribute("capture", this.options.capture);
        this.hiddenFileInput.setAttribute("tabindex", "-1");
        this.hiddenFileInput.style.visibility = "hidden";
        this.hiddenFileInput.style.position = "absolute";
        this.hiddenFileInput.style.top = "0";
        this.hiddenFileInput.style.left = "0";
        this.hiddenFileInput.style.height = "0";
        this.hiddenFileInput.style.width = "0";
        $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.hiddenInputContainer, "hiddenInputContainer").appendChild(this.hiddenFileInput);
        this.hiddenFileInput.addEventListener("change", () => {
          let { files } = this.hiddenFileInput;
          if (files.length)
            for (let file2 of files)
              this.addFile(file2);
          this.emit("addedfiles", files);
          setupHiddenFileInput();
        });
      };
      setupHiddenFileInput();
    }
    this.URL = window.URL !== null ? window.URL : window.webkitURL;
    for (let eventName of this.events)
      this.on(eventName, this.options[eventName]);
    this.on(
      "uploadprogress",
      () => this.updateTotalUploadProgress()
    );
    this.on(
      "removedfile",
      () => this.updateTotalUploadProgress()
    );
    this.on(
      "canceled",
      (file2) => this.emit("complete", file2)
    );
    this.on("complete", (file2) => {
      if (this.getAddedFiles().length === 0 && this.getUploadingFiles().length === 0 && this.getQueuedFiles().length === 0)
        return setTimeout(
          () => this.emit("queuecomplete"),
          0
        );
    });
    const containsFiles = function(e2) {
      if (e2.dataTransfer.types)
        for (var i = 0; i < e2.dataTransfer.types.length; i++) {
          if (e2.dataTransfer.types[i] === "Files")
            return true;
        }
      return false;
    };
    let noPropagation = function(e2) {
      if (!containsFiles(e2))
        return;
      e2.stopPropagation();
      if (e2.preventDefault)
        return e2.preventDefault();
      else
        return e2.returnValue = false;
    };
    this.listeners = [
      {
        element: this.element,
        events: {
          dragstart: (e2) => {
            return this.emit("dragstart", e2);
          },
          dragenter: (e2) => {
            noPropagation(e2);
            return this.emit("dragenter", e2);
          },
          dragover: (e2) => {
            let efct;
            try {
              efct = e2.dataTransfer.effectAllowed;
            } catch (error2) {
            }
            e2.dataTransfer.dropEffect = "move" === efct || "linkMove" === efct ? "move" : "copy";
            noPropagation(e2);
            return this.emit("dragover", e2);
          },
          dragleave: (e2) => {
            return this.emit("dragleave", e2);
          },
          drop: (e2) => {
            noPropagation(e2);
            return this.drop(e2);
          },
          dragend: (e2) => {
            return this.emit("dragend", e2);
          }
        }
      }
    ];
    this.clickableElements.forEach((clickableElement) => {
      return this.listeners.push({
        element: clickableElement,
        events: {
          click: (evt) => {
            if (clickableElement !== this.element || evt.target === this.element || $3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside(evt.target, this.element.querySelector(".dz-message")))
              this.hiddenFileInput.click();
            return true;
          }
        }
      });
    });
    this.enable();
    return this.options.init.call(this);
  }
  // Not fully tested yet
  destroy() {
    this.disable();
    this.removeAllFiles(true);
    if (this.hiddenFileInput != null ? this.hiddenFileInput.parentNode : void 0) {
      this.hiddenFileInput.parentNode.removeChild(this.hiddenFileInput);
      this.hiddenFileInput = null;
    }
    delete this.element.dropzone;
    return $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.splice($3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.indexOf(this), 1);
  }
  updateTotalUploadProgress() {
    let totalUploadProgress;
    let totalBytesSent = 0;
    let totalBytes = 0;
    let activeFiles = this.getActiveFiles();
    if (activeFiles.length) {
      for (let file2 of this.getActiveFiles()) {
        totalBytesSent += file2.upload.bytesSent;
        totalBytes += file2.upload.total;
      }
      totalUploadProgress = 100 * totalBytesSent / totalBytes;
    } else
      totalUploadProgress = 100;
    return this.emit("totaluploadprogress", totalUploadProgress, totalBytes, totalBytesSent);
  }
  // @options.paramName can be a function taking one parameter rather than a string.
  // A parameter name for a file is obtained simply by calling this with an index number.
  _getParamName(n2) {
    if (typeof this.options.paramName === "function")
      return this.options.paramName(n2);
    else
      return `${this.options.paramName}${this.options.uploadMultiple ? `[${n2}]` : ""}`;
  }
  // If @options.renameFile is a function,
  // the function will be used to rename the file.name before appending it to the formData
  _renameFile(file2) {
    if (typeof this.options.renameFile !== "function")
      return file2.name;
    return this.options.renameFile(file2);
  }
  // Returns a form that can be used as fallback if the browser does not support DragnDrop
  //
  // If the dropzone is already a form, only the input field and button are returned. Otherwise a complete form element is provided.
  // This code has to pass in IE7 :(
  getFallbackForm() {
    let existingFallback, form;
    if (existingFallback = this.getExistingFallback())
      return existingFallback;
    let fieldsString = '<div class="dz-fallback">';
    if (this.options.dictFallbackText)
      fieldsString += `<p>${this.options.dictFallbackText}</p>`;
    fieldsString += `<input type="file" name="${this._getParamName(0)}" ${this.options.uploadMultiple ? 'multiple="multiple"' : void 0} /><input type="submit" value="Upload!"></div>`;
    let fields = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(fieldsString);
    if (this.element.tagName !== "FORM") {
      form = $3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement(`<form action="${this.options.url}" enctype="multipart/form-data" method="${this.options.method}"></form>`);
      form.appendChild(fields);
    } else {
      this.element.setAttribute("enctype", "multipart/form-data");
      this.element.setAttribute("method", this.options.method);
    }
    return form != null ? form : fields;
  }
  // Returns the fallback elements if they exist already
  //
  // This code has to pass in IE7 :(
  getExistingFallback() {
    let getFallback = function(elements) {
      for (let el of elements) {
        if (/(^| )fallback($| )/.test(el.className))
          return el;
      }
    };
    for (let tagName of [
      "div",
      "form"
    ]) {
      var fallback;
      if (fallback = getFallback(this.element.getElementsByTagName(tagName)))
        return fallback;
    }
  }
  // Activates all listeners stored in @listeners
  setupEventListeners() {
    return this.listeners.map(
      (elementListeners) => (() => {
        let result = [];
        for (let event in elementListeners.events) {
          let listener = elementListeners.events[event];
          result.push(elementListeners.element.addEventListener(event, listener, false));
        }
        return result;
      })()
    );
  }
  // Deactivates all listeners stored in @listeners
  removeEventListeners() {
    return this.listeners.map(
      (elementListeners) => (() => {
        let result = [];
        for (let event in elementListeners.events) {
          let listener = elementListeners.events[event];
          result.push(elementListeners.element.removeEventListener(event, listener, false));
        }
        return result;
      })()
    );
  }
  // Removes all event listeners and cancels all files in the queue or being processed.
  disable() {
    this.clickableElements.forEach(
      (element) => element.classList.remove("dz-clickable")
    );
    this.removeEventListeners();
    this.disabled = true;
    return this.files.map(
      (file2) => this.cancelUpload(file2)
    );
  }
  enable() {
    delete this.disabled;
    this.clickableElements.forEach(
      (element) => element.classList.add("dz-clickable")
    );
    return this.setupEventListeners();
  }
  // Returns a nicely formatted filesize
  filesize(size) {
    let selectedSize = 0;
    let selectedUnit = "b";
    if (size > 0) {
      let units = [
        "tb",
        "gb",
        "mb",
        "kb",
        "b"
      ];
      for (let i = 0; i < units.length; i++) {
        let unit = units[i];
        let cutoff = Math.pow(this.options.filesizeBase, 4 - i) / 10;
        if (size >= cutoff) {
          selectedSize = size / Math.pow(this.options.filesizeBase, 4 - i);
          selectedUnit = unit;
          break;
        }
      }
      selectedSize = Math.round(10 * selectedSize) / 10;
    }
    return `<strong>${selectedSize}</strong> ${this.options.dictFileSizeUnits[selectedUnit]}`;
  }
  // Adds or removes the `dz-max-files-reached` class from the form.
  _updateMaxFilesReachedClass() {
    if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
      if (this.getAcceptedFiles().length === this.options.maxFiles)
        this.emit("maxfilesreached", this.files);
      return this.element.classList.add("dz-max-files-reached");
    } else
      return this.element.classList.remove("dz-max-files-reached");
  }
  drop(e2) {
    if (!e2.dataTransfer)
      return;
    this.emit("drop", e2);
    let files = [];
    for (let i = 0; i < e2.dataTransfer.files.length; i++)
      files[i] = e2.dataTransfer.files[i];
    if (files.length) {
      let { items } = e2.dataTransfer;
      if (items && items.length && items[0].webkitGetAsEntry != null)
        this._addFilesFromItems(items);
      else
        this.handleFiles(files);
    }
    this.emit("addedfiles", files);
  }
  paste(e2) {
    if ($3ed269f2f0fb224b$var$__guard__(
      e2 != null ? e2.clipboardData : void 0,
      (x2) => x2.items
    ) == null)
      return;
    this.emit("paste", e2);
    let { items } = e2.clipboardData;
    if (items.length)
      return this._addFilesFromItems(items);
  }
  handleFiles(files) {
    for (let file2 of files)
      this.addFile(file2);
  }
  // When a folder is dropped (or files are pasted), items must be handled
  // instead of files.
  _addFilesFromItems(items) {
    return (() => {
      let result = [];
      for (let item2 of items) {
        var entry;
        if (item2.webkitGetAsEntry != null && (entry = item2.webkitGetAsEntry())) {
          if (entry.isFile)
            result.push(this.addFile(item2.getAsFile()));
          else if (entry.isDirectory)
            result.push(this._addFilesFromDirectory(entry, entry.name));
          else
            result.push(void 0);
        } else if (item2.getAsFile != null) {
          if (item2.kind == null || item2.kind === "file")
            result.push(this.addFile(item2.getAsFile()));
          else
            result.push(void 0);
        } else
          result.push(void 0);
      }
      return result;
    })();
  }
  // Goes through the directory, and adds each file it finds recursively
  _addFilesFromDirectory(directory, path) {
    let dirReader = directory.createReader();
    let errorHandler = (error2) => $3ed269f2f0fb224b$var$__guardMethod__(
      console,
      "log",
      (o2) => o2.log(error2)
    );
    var readEntries = () => {
      return dirReader.readEntries((entries) => {
        if (entries.length > 0) {
          for (let entry of entries) {
            if (entry.isFile)
              entry.file((file2) => {
                if (this.options.ignoreHiddenFiles && file2.name.substring(0, 1) === ".")
                  return;
                file2.fullPath = `${path}/${file2.name}`;
                return this.addFile(file2);
              });
            else if (entry.isDirectory)
              this._addFilesFromDirectory(entry, `${path}/${entry.name}`);
          }
          readEntries();
        }
        return null;
      }, errorHandler);
    };
    return readEntries();
  }
  // If `done()` is called without argument the file is accepted
  // If you call it with an error message, the file is rejected
  // (This allows for asynchronous validation)
  //
  // This function checks the filesize, and if the file.type passes the
  // `acceptedFiles` check.
  accept(file2, done) {
    if (this.options.maxFilesize && file2.size > this.options.maxFilesize * 1048576)
      done(this.options.dictFileTooBig.replace("{{filesize}}", Math.round(file2.size / 1024 / 10.24) / 100).replace("{{maxFilesize}}", this.options.maxFilesize));
    else if (!$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile(file2, this.options.acceptedFiles))
      done(this.options.dictInvalidFileType);
    else if (this.options.maxFiles != null && this.getAcceptedFiles().length >= this.options.maxFiles) {
      done(this.options.dictMaxFilesExceeded.replace("{{maxFiles}}", this.options.maxFiles));
      this.emit("maxfilesexceeded", file2);
    } else
      this.options.accept.call(this, file2, done);
  }
  addFile(file2) {
    file2.upload = {
      uuid: $3ed269f2f0fb224b$export$2e2bcd8739ae039.uuidv4(),
      progress: 0,
      // Setting the total upload size to file.size for the beginning
      // It's actual different than the size to be transmitted.
      total: file2.size,
      bytesSent: 0,
      filename: this._renameFile(file2)
    };
    this.files.push(file2);
    file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED;
    this.emit("addedfile", file2);
    this._enqueueThumbnail(file2);
    this.accept(file2, (error2) => {
      if (error2) {
        file2.accepted = false;
        this._errorProcessing([
          file2
        ], error2);
      } else {
        file2.accepted = true;
        if (this.options.autoQueue)
          this.enqueueFile(file2);
      }
      this._updateMaxFilesReachedClass();
    });
  }
  // Wrapper for enqueueFile
  enqueueFiles(files) {
    for (let file2 of files)
      this.enqueueFile(file2);
    return null;
  }
  enqueueFile(file2) {
    if (file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED && file2.accepted === true) {
      file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
      if (this.options.autoProcessQueue)
        return setTimeout(
          () => this.processQueue(),
          0
        );
    } else
      throw new Error("This file can't be queued because it has already been processed or was rejected.");
  }
  _enqueueThumbnail(file2) {
    if (this.options.createImageThumbnails && file2.type.match(/image.*/) && file2.size <= this.options.maxThumbnailFilesize * 1048576) {
      this._thumbnailQueue.push(file2);
      return setTimeout(
        () => this._processThumbnailQueue(),
        0
      );
    }
  }
  _processThumbnailQueue() {
    if (this._processingThumbnail || this._thumbnailQueue.length === 0)
      return;
    this._processingThumbnail = true;
    let file2 = this._thumbnailQueue.shift();
    return this.createThumbnail(file2, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, true, (dataUrl) => {
      this.emit("thumbnail", file2, dataUrl);
      this._processingThumbnail = false;
      return this._processThumbnailQueue();
    });
  }
  // Can be called by the user to remove a file
  removeFile(file2) {
    if (file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING)
      this.cancelUpload(file2);
    this.files = $3ed269f2f0fb224b$var$without(this.files, file2);
    this.emit("removedfile", file2);
    if (this.files.length === 0)
      return this.emit("reset");
  }
  // Removes all files that aren't currently processed from the list
  removeAllFiles(cancelIfNecessary) {
    if (cancelIfNecessary == null)
      cancelIfNecessary = false;
    for (let file2 of this.files.slice())
      if (file2.status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING || cancelIfNecessary)
        this.removeFile(file2);
    return null;
  }
  // Resizes an image before it gets sent to the server. This function is the default behavior of
  // `options.transformFile` if `resizeWidth` or `resizeHeight` are set. The callback is invoked with
  // the resized blob.
  resizeImage(file2, width, height, resizeMethod, callback) {
    return this.createThumbnail(file2, width, height, resizeMethod, true, (dataUrl, canvas) => {
      if (canvas == null)
        return callback(file2);
      else {
        let { resizeMimeType } = this.options;
        if (resizeMimeType == null)
          resizeMimeType = file2.type;
        let resizedDataURL = canvas.toDataURL(resizeMimeType, this.options.resizeQuality);
        if (resizeMimeType === "image/jpeg" || resizeMimeType === "image/jpg")
          resizedDataURL = $3ed269f2f0fb224b$var$ExifRestore.restore(file2.dataURL, resizedDataURL);
        return callback($3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob(resizedDataURL));
      }
    });
  }
  createThumbnail(file2, width, height, resizeMethod, fixOrientation, callback) {
    let fileReader = new FileReader();
    fileReader.onload = () => {
      file2.dataURL = fileReader.result;
      if (file2.type === "image/svg+xml") {
        if (callback != null)
          callback(fileReader.result);
        return;
      }
      this.createThumbnailFromUrl(file2, width, height, resizeMethod, fixOrientation, callback);
    };
    fileReader.readAsDataURL(file2);
  }
  // `mockFile` needs to have these attributes:
  //
  //     { name: 'name', size: 12345, imageUrl: '' }
  //
  // `callback` will be invoked when the image has been downloaded and displayed.
  // `crossOrigin` will be added to the `img` tag when accessing the file.
  displayExistingFile(mockFile, imageUrl, callback, crossOrigin, resizeThumbnail = true) {
    this.emit("addedfile", mockFile);
    this.emit("complete", mockFile);
    if (!resizeThumbnail) {
      this.emit("thumbnail", mockFile, imageUrl);
      if (callback)
        callback();
    } else {
      let onDone = (thumbnail) => {
        this.emit("thumbnail", mockFile, thumbnail);
        if (callback)
          callback();
      };
      mockFile.dataURL = imageUrl;
      this.createThumbnailFromUrl(mockFile, this.options.thumbnailWidth, this.options.thumbnailHeight, this.options.thumbnailMethod, this.options.fixOrientation, onDone, crossOrigin);
    }
  }
  createThumbnailFromUrl(file2, width, height, resizeMethod, fixOrientation, callback, crossOrigin) {
    let img = document.createElement("img");
    if (crossOrigin)
      img.crossOrigin = crossOrigin;
    fixOrientation = getComputedStyle(document.body)["imageOrientation"] == "from-image" ? false : fixOrientation;
    img.onload = () => {
      let loadExif = (callback2) => callback2(1);
      if (typeof EXIF !== "undefined" && EXIF !== null && fixOrientation)
        loadExif = (callback2) => EXIF.getData(img, function() {
          return callback2(EXIF.getTag(this, "Orientation"));
        });
      return loadExif((orientation) => {
        file2.width = img.width;
        file2.height = img.height;
        let resizeInfo = this.options.resize.call(this, file2, width, height, resizeMethod);
        let canvas = document.createElement("canvas");
        let ctx = canvas.getContext("2d");
        canvas.width = resizeInfo.trgWidth;
        canvas.height = resizeInfo.trgHeight;
        if (orientation > 4) {
          canvas.width = resizeInfo.trgHeight;
          canvas.height = resizeInfo.trgWidth;
        }
        switch (orientation) {
          case 2:
            ctx.translate(canvas.width, 0);
            ctx.scale(-1, 1);
            break;
          case 3:
            ctx.translate(canvas.width, canvas.height);
            ctx.rotate(Math.PI);
            break;
          case 4:
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
            break;
          case 5:
            ctx.rotate(0.5 * Math.PI);
            ctx.scale(1, -1);
            break;
          case 6:
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(0, -canvas.width);
            break;
          case 7:
            ctx.rotate(0.5 * Math.PI);
            ctx.translate(canvas.height, -canvas.width);
            ctx.scale(-1, 1);
            break;
          case 8:
            ctx.rotate(-0.5 * Math.PI);
            ctx.translate(-canvas.height, 0);
            break;
        }
        $3ed269f2f0fb224b$var$drawImageIOSFix(ctx, img, resizeInfo.srcX != null ? resizeInfo.srcX : 0, resizeInfo.srcY != null ? resizeInfo.srcY : 0, resizeInfo.srcWidth, resizeInfo.srcHeight, resizeInfo.trgX != null ? resizeInfo.trgX : 0, resizeInfo.trgY != null ? resizeInfo.trgY : 0, resizeInfo.trgWidth, resizeInfo.trgHeight);
        let thumbnail = canvas.toDataURL("image/png");
        if (callback != null)
          return callback(thumbnail, canvas);
      });
    };
    if (callback != null)
      img.onerror = callback;
    return img.src = file2.dataURL;
  }
  // Goes through the queue and processes files if there aren't too many already.
  processQueue() {
    let { parallelUploads } = this.options;
    let processingLength = this.getUploadingFiles().length;
    let i = processingLength;
    if (processingLength >= parallelUploads)
      return;
    let queuedFiles = this.getQueuedFiles();
    if (!(queuedFiles.length > 0))
      return;
    if (this.options.uploadMultiple)
      return this.processFiles(queuedFiles.slice(0, parallelUploads - processingLength));
    else
      while (i < parallelUploads) {
        if (!queuedFiles.length)
          return;
        this.processFile(queuedFiles.shift());
        i++;
      }
  }
  // Wrapper for `processFiles`
  processFile(file2) {
    return this.processFiles([
      file2
    ]);
  }
  // Loads the file, then calls finishedLoading()
  processFiles(files) {
    for (let file2 of files) {
      file2.processing = true;
      file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
      this.emit("processing", file2);
    }
    if (this.options.uploadMultiple)
      this.emit("processingmultiple", files);
    return this.uploadFiles(files);
  }
  _getFilesWithXhr(xhr) {
    return this.files.filter(
      (file2) => file2.xhr === xhr
    ).map(
      (file2) => file2
    );
  }
  // Cancels the file upload and sets the status to CANCELED
  // **if** the file is actually being uploaded.
  // If it's still in the queue, the file is being removed from it and the status
  // set to CANCELED.
  cancelUpload(file2) {
    if (file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING) {
      let groupedFiles = this._getFilesWithXhr(file2.xhr);
      for (let groupedFile of groupedFiles)
        groupedFile.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
      if (typeof file2.xhr !== "undefined")
        file2.xhr.abort();
      for (let groupedFile1 of groupedFiles)
        this.emit("canceled", groupedFile1);
      if (this.options.uploadMultiple)
        this.emit("canceledmultiple", groupedFiles);
    } else if (file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED || file2.status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED) {
      file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED;
      this.emit("canceled", file2);
      if (this.options.uploadMultiple)
        this.emit("canceledmultiple", [
          file2
        ]);
    }
    if (this.options.autoProcessQueue)
      return this.processQueue();
  }
  resolveOption(option2, ...args) {
    if (typeof option2 === "function")
      return option2.apply(this, args);
    return option2;
  }
  uploadFile(file2) {
    return this.uploadFiles([
      file2
    ]);
  }
  uploadFiles(files) {
    this._transformFiles(files, (transformedFiles) => {
      if (this.options.chunking) {
        let transformedFile = transformedFiles[0];
        files[0].upload.chunked = this.options.chunking && (this.options.forceChunking || transformedFile.size > this.options.chunkSize);
        files[0].upload.totalChunkCount = Math.ceil(transformedFile.size / this.options.chunkSize);
      }
      if (files[0].upload.chunked) {
        let file2 = files[0];
        let transformedFile = transformedFiles[0];
        file2.upload.chunks = [];
        let handleNextChunk = () => {
          let chunkIndex = 0;
          while (file2.upload.chunks[chunkIndex] !== void 0)
            chunkIndex++;
          if (chunkIndex >= file2.upload.totalChunkCount)
            return;
          let start2 = chunkIndex * this.options.chunkSize;
          let end2 = Math.min(start2 + this.options.chunkSize, transformedFile.size);
          let dataBlock = {
            name: this._getParamName(0),
            data: transformedFile.webkitSlice ? transformedFile.webkitSlice(start2, end2) : transformedFile.slice(start2, end2),
            filename: file2.upload.filename,
            chunkIndex
          };
          file2.upload.chunks[chunkIndex] = {
            file: file2,
            index: chunkIndex,
            dataBlock,
            status: $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING,
            progress: 0,
            retries: 0
          };
          this._uploadData(files, [
            dataBlock
          ]);
        };
        file2.upload.finishedChunkUpload = (chunk, response2) => {
          let allFinished = true;
          chunk.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
          chunk.dataBlock = null;
          chunk.response = chunk.xhr.responseText;
          chunk.responseHeaders = chunk.xhr.getAllResponseHeaders();
          chunk.xhr = null;
          for (let i = 0; i < file2.upload.totalChunkCount; i++) {
            if (file2.upload.chunks[i] === void 0)
              return handleNextChunk();
            if (file2.upload.chunks[i].status !== $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS)
              allFinished = false;
          }
          if (allFinished)
            this.options.chunksUploaded(file2, () => {
              this._finished(files, response2, null);
            });
        };
        if (this.options.parallelChunkUploads)
          for (let i = 0; i < file2.upload.totalChunkCount; i++)
            handleNextChunk();
        else
          handleNextChunk();
      } else {
        let dataBlocks = [];
        for (let i = 0; i < files.length; i++)
          dataBlocks[i] = {
            name: this._getParamName(i),
            data: transformedFiles[i],
            filename: files[i].upload.filename
          };
        this._uploadData(files, dataBlocks);
      }
    });
  }
  /// Returns the right chunk for given file and xhr
  _getChunk(file2, xhr) {
    for (let i = 0; i < file2.upload.totalChunkCount; i++) {
      if (file2.upload.chunks[i] !== void 0 && file2.upload.chunks[i].xhr === xhr)
        return file2.upload.chunks[i];
    }
  }
  // This function actually uploads the file(s) to the server.
  //
  //  If dataBlocks contains the actual data to upload (meaning, that this could
  // either be transformed files, or individual chunks for chunked upload) then
  // they will be used for the actual data to upload.
  _uploadData(files, dataBlocks) {
    let xhr = new XMLHttpRequest();
    for (let file2 of files)
      file2.xhr = xhr;
    if (files[0].upload.chunked)
      files[0].upload.chunks[dataBlocks[0].chunkIndex].xhr = xhr;
    let method = this.resolveOption(this.options.method, files, dataBlocks);
    let url = this.resolveOption(this.options.url, files, dataBlocks);
    xhr.open(method, url, true);
    let timeout2 = this.resolveOption(this.options.timeout, files);
    if (timeout2)
      xhr.timeout = this.resolveOption(this.options.timeout, files);
    xhr.withCredentials = !!this.options.withCredentials;
    xhr.onload = (e2) => {
      this._finishedUploading(files, xhr, e2);
    };
    xhr.ontimeout = () => {
      this._handleUploadError(files, xhr, `Request timedout after ${this.options.timeout / 1e3} seconds`);
    };
    xhr.onerror = () => {
      this._handleUploadError(files, xhr);
    };
    let progressObj = xhr.upload != null ? xhr.upload : xhr;
    progressObj.onprogress = (e2) => this._updateFilesUploadProgress(files, xhr, e2);
    let headers = this.options.defaultHeaders ? {
      Accept: "application/json",
      "Cache-Control": "no-cache",
      "X-Requested-With": "XMLHttpRequest"
    } : {};
    if (this.options.binaryBody)
      headers["Content-Type"] = files[0].type;
    if (this.options.headers)
      objectExtend(headers, this.options.headers);
    for (let headerName in headers) {
      let headerValue = headers[headerName];
      if (headerValue)
        xhr.setRequestHeader(headerName, headerValue);
    }
    if (this.options.binaryBody) {
      for (let file2 of files)
        this.emit("sending", file2, xhr);
      if (this.options.uploadMultiple)
        this.emit("sendingmultiple", files, xhr);
      this.submitRequest(xhr, null, files);
    } else {
      let formData = new FormData();
      if (this.options.params) {
        let additionalParams = this.options.params;
        if (typeof additionalParams === "function")
          additionalParams = additionalParams.call(this, files, xhr, files[0].upload.chunked ? this._getChunk(files[0], xhr) : null);
        for (let key in additionalParams) {
          let value = additionalParams[key];
          if (Array.isArray(value))
            for (let i = 0; i < value.length; i++)
              formData.append(key, value[i]);
          else
            formData.append(key, value);
        }
      }
      for (let file2 of files)
        this.emit("sending", file2, xhr, formData);
      if (this.options.uploadMultiple)
        this.emit("sendingmultiple", files, xhr, formData);
      this._addFormElementData(formData);
      for (let i = 0; i < dataBlocks.length; i++) {
        let dataBlock = dataBlocks[i];
        formData.append(dataBlock.name, dataBlock.data, dataBlock.filename);
      }
      this.submitRequest(xhr, formData, files);
    }
  }
  // Transforms all files with this.options.transformFile and invokes done with the transformed files when done.
  _transformFiles(files, done) {
    let transformedFiles = [];
    let doneCounter = 0;
    for (let i = 0; i < files.length; i++)
      this.options.transformFile.call(this, files[i], (transformedFile) => {
        transformedFiles[i] = transformedFile;
        if (++doneCounter === files.length)
          done(transformedFiles);
      });
  }
  // Takes care of adding other input elements of the form to the AJAX request
  _addFormElementData(formData) {
    if (this.element.tagName === "FORM")
      for (let input of this.element.querySelectorAll("input, textarea, select, button")) {
        let inputName = input.getAttribute("name");
        let inputType = input.getAttribute("type");
        if (inputType)
          inputType = inputType.toLowerCase();
        if (typeof inputName === "undefined" || inputName === null)
          continue;
        if (input.tagName === "SELECT" && input.hasAttribute("multiple")) {
          for (let option2 of input.options)
            if (option2.selected)
              formData.append(inputName, option2.value);
        } else if (!inputType || inputType !== "checkbox" && inputType !== "radio" || input.checked)
          formData.append(inputName, input.value);
      }
  }
  // Invoked when there is new progress information about given files.
  // If e is not provided, it is assumed that the upload is finished.
  _updateFilesUploadProgress(files, xhr, e2) {
    if (!files[0].upload.chunked)
      for (let file2 of files) {
        if (file2.upload.total && file2.upload.bytesSent && file2.upload.bytesSent == file2.upload.total)
          continue;
        if (e2) {
          file2.upload.progress = 100 * e2.loaded / e2.total;
          file2.upload.total = e2.total;
          file2.upload.bytesSent = e2.loaded;
        } else {
          file2.upload.progress = 100;
          file2.upload.bytesSent = file2.upload.total;
        }
        this.emit("uploadprogress", file2, file2.upload.progress, file2.upload.bytesSent);
      }
    else {
      let file2 = files[0];
      let chunk = this._getChunk(file2, xhr);
      if (e2) {
        chunk.progress = 100 * e2.loaded / e2.total;
        chunk.total = e2.total;
        chunk.bytesSent = e2.loaded;
      } else {
        chunk.progress = 100;
        chunk.bytesSent = chunk.total;
      }
      file2.upload.progress = 0;
      file2.upload.total = 0;
      file2.upload.bytesSent = 0;
      for (let i = 0; i < file2.upload.totalChunkCount; i++)
        if (file2.upload.chunks[i] && typeof file2.upload.chunks[i].progress !== "undefined") {
          file2.upload.progress += file2.upload.chunks[i].progress;
          file2.upload.total += file2.upload.chunks[i].total;
          file2.upload.bytesSent += file2.upload.chunks[i].bytesSent;
        }
      file2.upload.progress = file2.upload.progress / file2.upload.totalChunkCount;
      this.emit("uploadprogress", file2, file2.upload.progress, file2.upload.bytesSent);
    }
  }
  _finishedUploading(files, xhr, e2) {
    let response2;
    if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED)
      return;
    if (xhr.readyState !== 4)
      return;
    if (xhr.responseType !== "arraybuffer" && xhr.responseType !== "blob") {
      response2 = xhr.responseText;
      if (xhr.getResponseHeader("content-type") && ~xhr.getResponseHeader("content-type").indexOf("application/json"))
        try {
          response2 = JSON.parse(response2);
        } catch (error2) {
          e2 = error2;
          response2 = "Invalid JSON response from server.";
        }
    }
    this._updateFilesUploadProgress(files, xhr);
    if (!(200 <= xhr.status && xhr.status < 300))
      this._handleUploadError(files, xhr, response2);
    else if (files[0].upload.chunked)
      files[0].upload.finishedChunkUpload(this._getChunk(files[0], xhr), response2);
    else
      this._finished(files, response2, e2);
  }
  _handleUploadError(files, xhr, response2) {
    if (files[0].status === $3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED)
      return;
    if (files[0].upload.chunked && this.options.retryChunks) {
      let chunk = this._getChunk(files[0], xhr);
      if (chunk.retries++ < this.options.retryChunksLimit) {
        this._uploadData(files, [
          chunk.dataBlock
        ]);
        return;
      } else
        console.warn("Retried this chunk too often. Giving up.");
    }
    this._errorProcessing(files, response2 || this.options.dictResponseError.replace("{{statusCode}}", xhr.status), xhr);
  }
  submitRequest(xhr, formData, files) {
    if (xhr.readyState != 1) {
      console.warn("Cannot send this request because the XMLHttpRequest.readyState is not OPENED.");
      return;
    }
    if (this.options.binaryBody) {
      if (files[0].upload.chunked) {
        const chunk = this._getChunk(files[0], xhr);
        xhr.send(chunk.dataBlock.data);
      } else
        xhr.send(files[0]);
    } else
      xhr.send(formData);
  }
  // Called internally when processing is finished.
  // Individual callbacks have to be called in the appropriate sections.
  _finished(files, responseText, e2) {
    for (let file2 of files) {
      file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS;
      this.emit("success", file2, responseText, e2);
      this.emit("complete", file2);
    }
    if (this.options.uploadMultiple) {
      this.emit("successmultiple", files, responseText, e2);
      this.emit("completemultiple", files);
    }
    if (this.options.autoProcessQueue)
      return this.processQueue();
  }
  // Called internally when processing is finished.
  // Individual callbacks have to be called in the appropriate sections.
  _errorProcessing(files, message, xhr) {
    for (let file2 of files) {
      file2.status = $3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR;
      this.emit("error", file2, message, xhr);
      this.emit("complete", file2);
    }
    if (this.options.uploadMultiple) {
      this.emit("errormultiple", files, message, xhr);
      this.emit("completemultiple", files);
    }
    if (this.options.autoProcessQueue)
      return this.processQueue();
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c2) {
      let r2 = Math.random() * 16 | 0, v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    });
  }
  constructor(el, options) {
    super();
    let fallback, left2;
    this.element = el;
    this.clickableElements = [];
    this.listeners = [];
    this.files = [];
    if (typeof this.element === "string")
      this.element = document.querySelector(this.element);
    if (!this.element || this.element.nodeType == null)
      throw new Error("Invalid dropzone element.");
    if (this.element.dropzone)
      throw new Error("Dropzone already attached.");
    $3ed269f2f0fb224b$export$2e2bcd8739ae039.instances.push(this);
    this.element.dropzone = this;
    let elementOptions = (left2 = $3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(this.element)) != null ? left2 : {};
    this.options = objectExtend(true, {}, $4ca367182776f80b$export$2e2bcd8739ae039, elementOptions, options != null ? options : {});
    this.options.previewTemplate = this.options.previewTemplate.replace(/\n*/g, "");
    if (this.options.forceFallback || !$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported())
      return this.options.fallback.call(this);
    if (this.options.url == null)
      this.options.url = this.element.getAttribute("action");
    if (!this.options.url)
      throw new Error("No URL provided.");
    if (this.options.acceptedFiles && this.options.acceptedMimeTypes)
      throw new Error("You can't provide both 'acceptedFiles' and 'acceptedMimeTypes'. 'acceptedMimeTypes' is deprecated.");
    if (this.options.uploadMultiple && this.options.chunking)
      throw new Error("You cannot set both: uploadMultiple and chunking.");
    if (this.options.binaryBody && this.options.uploadMultiple)
      throw new Error("You cannot set both: binaryBody and uploadMultiple.");
    if (this.options.acceptedMimeTypes) {
      this.options.acceptedFiles = this.options.acceptedMimeTypes;
      delete this.options.acceptedMimeTypes;
    }
    if (this.options.renameFilename != null)
      this.options.renameFile = (file2) => this.options.renameFilename.call(this, file2.name, file2);
    if (typeof this.options.method === "string")
      this.options.method = this.options.method.toUpperCase();
    if ((fallback = this.getExistingFallback()) && fallback.parentNode)
      fallback.parentNode.removeChild(fallback);
    if (this.options.previewsContainer !== false) {
      if (this.options.previewsContainer)
        this.previewsContainer = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement(this.options.previewsContainer, "previewsContainer");
      else
        this.previewsContainer = this.element;
    }
    if (this.options.clickable) {
      if (this.options.clickable === true)
        this.clickableElements = [
          this.element
        ];
      else
        this.clickableElements = $3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements(this.options.clickable, "clickable");
    }
    this.init();
  }
}
$3ed269f2f0fb224b$export$2e2bcd8739ae039.initClass();
$3ed269f2f0fb224b$export$2e2bcd8739ae039.options = {};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement = function(element) {
  if (element.getAttribute("id"))
    return $3ed269f2f0fb224b$export$2e2bcd8739ae039.options[$3ed269f2f0fb224b$var$camelize(element.getAttribute("id"))];
  else
    return void 0;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.instances = [];
$3ed269f2f0fb224b$export$2e2bcd8739ae039.forElement = function(element) {
  if (typeof element === "string")
    element = document.querySelector(element);
  if ((element != null ? element.dropzone : void 0) == null)
    throw new Error("No Dropzone found for given element. This is probably because you're trying to access it before Dropzone had the time to initialize. Use the `init` option to setup any additional observers on your Dropzone.");
  return element.dropzone;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.discover = function() {
  let dropzones;
  if (document.querySelectorAll)
    dropzones = document.querySelectorAll(".dropzone");
  else {
    dropzones = [];
    let checkElements = (elements) => (() => {
      let result = [];
      for (let el of elements)
        if (/(^| )dropzone($| )/.test(el.className))
          result.push(dropzones.push(el));
        else
          result.push(void 0);
      return result;
    })();
    checkElements(document.getElementsByTagName("div"));
    checkElements(document.getElementsByTagName("form"));
  }
  return (() => {
    let result = [];
    for (let dropzone of dropzones)
      if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.optionsForElement(dropzone) !== false)
        result.push(new $3ed269f2f0fb224b$export$2e2bcd8739ae039(dropzone));
      else
        result.push(void 0);
    return result;
  })();
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = [
  // The mac os and windows phone version of opera 12 seems to have a problem with the File drag'n'drop API.
  /opera.*(Macintosh|Windows Phone).*version\/12/i
];
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isBrowserSupported = function() {
  let capableBrowser = true;
  if (window.File && window.FileReader && window.FileList && window.Blob && window.FormData && document.querySelector) {
    if (!("classList" in document.createElement("a")))
      capableBrowser = false;
    else {
      if ($3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers !== void 0)
        $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers = $3ed269f2f0fb224b$export$2e2bcd8739ae039.blacklistedBrowsers;
      for (let regex of $3ed269f2f0fb224b$export$2e2bcd8739ae039.blockedBrowsers)
        if (regex.test(navigator.userAgent)) {
          capableBrowser = false;
          continue;
        }
    }
  } else
    capableBrowser = false;
  return capableBrowser;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.dataURItoBlob = function(dataURI) {
  let byteString = atob(dataURI.split(",")[1]);
  let mimeString = dataURI.split(",")[0].split(":")[1].split(";")[0];
  let ab = new ArrayBuffer(byteString.length);
  let ia2 = new Uint8Array(ab);
  for (let i = 0, end2 = byteString.length, asc = 0 <= end2; asc ? i <= end2 : i >= end2; asc ? i++ : i--)
    ia2[i] = byteString.charCodeAt(i);
  return new Blob([
    ab
  ], {
    type: mimeString
  });
};
const $3ed269f2f0fb224b$var$without = (list2, rejectedItem) => list2.filter(
  (item2) => item2 !== rejectedItem
).map(
  (item2) => item2
);
const $3ed269f2f0fb224b$var$camelize = (str2) => str2.replace(
  /[\-_](\w)/g,
  (match) => match.charAt(1).toUpperCase()
);
$3ed269f2f0fb224b$export$2e2bcd8739ae039.createElement = function(string) {
  let div = document.createElement("div");
  div.innerHTML = string;
  return div.childNodes[0];
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.elementInside = function(element, container) {
  if (element === container)
    return true;
  while (element = element.parentNode) {
    if (element === container)
      return true;
  }
  return false;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElement = function(el, name2) {
  let element;
  if (typeof el === "string")
    element = document.querySelector(el);
  else if (el.nodeType != null)
    element = el;
  if (element == null)
    throw new Error(`Invalid \`${name2}\` option provided. Please provide a CSS selector or a plain HTML element.`);
  return element;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.getElements = function(els, name2) {
  let el, elements;
  if (els instanceof Array) {
    elements = [];
    try {
      for (el of els)
        elements.push(this.getElement(el, name2));
    } catch (e2) {
      elements = null;
    }
  } else if (typeof els === "string") {
    elements = [];
    for (el of document.querySelectorAll(els))
      elements.push(el);
  } else if (els.nodeType != null)
    elements = [
      els
    ];
  if (elements == null || !elements.length)
    throw new Error(`Invalid \`${name2}\` option provided. Please provide a CSS selector, a plain HTML element or a list of those.`);
  return elements;
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.confirm = function(question, accepted, rejected) {
  if (window.confirm(question))
    return accepted();
  else if (rejected != null)
    return rejected();
};
$3ed269f2f0fb224b$export$2e2bcd8739ae039.isValidFile = function(file2, acceptedFiles) {
  if (!acceptedFiles)
    return true;
  acceptedFiles = acceptedFiles.split(",");
  let mimeType = file2.type;
  let baseMimeType = mimeType.replace(/\/.*$/, "");
  for (let validType of acceptedFiles) {
    validType = validType.trim();
    if (validType.charAt(0) === ".") {
      if (file2.name.toLowerCase().indexOf(validType.toLowerCase(), file2.name.length - validType.length) !== -1)
        return true;
    } else if (/\/\*$/.test(validType)) {
      if (baseMimeType === validType.replace(/\/.*$/, ""))
        return true;
    } else {
      if (mimeType === validType)
        return true;
    }
  }
  return false;
};
if (typeof jQuery !== "undefined" && jQuery !== null)
  jQuery.fn.dropzone = function(options) {
    return this.each(function() {
      return new $3ed269f2f0fb224b$export$2e2bcd8739ae039(this, options);
    });
  };
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ADDED = "added";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED = "queued";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ACCEPTED = $3ed269f2f0fb224b$export$2e2bcd8739ae039.QUEUED;
$3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING = "uploading";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.PROCESSING = $3ed269f2f0fb224b$export$2e2bcd8739ae039.UPLOADING;
$3ed269f2f0fb224b$export$2e2bcd8739ae039.CANCELED = "canceled";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.ERROR = "error";
$3ed269f2f0fb224b$export$2e2bcd8739ae039.SUCCESS = "success";
let $3ed269f2f0fb224b$var$detectVerticalSquash = function(img) {
  img.naturalWidth;
  let ih = img.naturalHeight;
  let canvas = document.createElement("canvas");
  canvas.width = 1;
  canvas.height = ih;
  let ctx = canvas.getContext("2d");
  ctx.drawImage(img, 0, 0);
  let { data: data2 } = ctx.getImageData(1, 0, 1, ih);
  let sy = 0;
  let ey = ih;
  let py = ih;
  while (py > sy) {
    let alpha = data2[(py - 1) * 4 + 3];
    if (alpha === 0)
      ey = py;
    else
      sy = py;
    py = ey + sy >> 1;
  }
  let ratio = py / ih;
  if (ratio === 0)
    return 1;
  else
    return ratio;
};
var $3ed269f2f0fb224b$var$drawImageIOSFix = function(ctx, img, sx, sy, sw, sh, dx, dy, dw, dh) {
  let vertSquashRatio = $3ed269f2f0fb224b$var$detectVerticalSquash(img);
  return ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh / vertSquashRatio);
};
class $3ed269f2f0fb224b$var$ExifRestore {
  static initClass() {
    this.KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  }
  static encode64(input) {
    let output = "";
    let chr1 = void 0;
    let chr2 = void 0;
    let chr3 = "";
    let enc1 = void 0;
    let enc2 = void 0;
    let enc3 = void 0;
    let enc4 = "";
    let i = 0;
    while (true) {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
      enc4 = chr3 & 63;
      if (isNaN(chr2))
        enc3 = enc4 = 64;
      else if (isNaN(chr3))
        enc4 = 64;
      output = output + this.KEY_STR.charAt(enc1) + this.KEY_STR.charAt(enc2) + this.KEY_STR.charAt(enc3) + this.KEY_STR.charAt(enc4);
      chr1 = chr2 = chr3 = "";
      enc1 = enc2 = enc3 = enc4 = "";
      if (!(i < input.length))
        break;
    }
    return output;
  }
  static restore(origFileBase64, resizedFileBase64) {
    if (!origFileBase64.match("data:image/jpeg;base64,"))
      return resizedFileBase64;
    let rawImage = this.decode64(origFileBase64.replace("data:image/jpeg;base64,", ""));
    let segments = this.slice2Segments(rawImage);
    let image = this.exifManipulation(resizedFileBase64, segments);
    return `data:image/jpeg;base64,${this.encode64(image)}`;
  }
  static exifManipulation(resizedFileBase64, segments) {
    let exifArray = this.getExifArray(segments);
    let newImageArray = this.insertExif(resizedFileBase64, exifArray);
    let aBuffer = new Uint8Array(newImageArray);
    return aBuffer;
  }
  static getExifArray(segments) {
    let seg = void 0;
    let x2 = 0;
    while (x2 < segments.length) {
      seg = segments[x2];
      if (seg[0] === 255 & seg[1] === 225)
        return seg;
      x2++;
    }
    return [];
  }
  static insertExif(resizedFileBase64, exifArray) {
    let imageData = resizedFileBase64.replace("data:image/jpeg;base64,", "");
    let buf = this.decode64(imageData);
    let separatePoint = buf.indexOf(255, 3);
    let mae = buf.slice(0, separatePoint);
    let ato = buf.slice(separatePoint);
    let array = mae;
    array = array.concat(exifArray);
    array = array.concat(ato);
    return array;
  }
  static slice2Segments(rawImageArray) {
    let head = 0;
    let segments = [];
    while (true) {
      var length;
      if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 218)
        break;
      if (rawImageArray[head] === 255 & rawImageArray[head + 1] === 216)
        head += 2;
      else {
        length = rawImageArray[head + 2] * 256 + rawImageArray[head + 3];
        let endPoint = head + length + 2;
        let seg = rawImageArray.slice(head, endPoint);
        segments.push(seg);
        head = endPoint;
      }
      if (head > rawImageArray.length)
        break;
    }
    return segments;
  }
  static decode64(input) {
    let chr1 = void 0;
    let chr2 = void 0;
    let chr3 = "";
    let enc1 = void 0;
    let enc2 = void 0;
    let enc3 = void 0;
    let enc4 = "";
    let i = 0;
    let buf = [];
    let base64test = /[^A-Za-z0-9\+\/\=]/g;
    if (base64test.exec(input))
      console.warn("There were invalid base64 characters in the input text.\nValid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\nExpect errors in decoding.");
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    while (true) {
      enc1 = this.KEY_STR.indexOf(input.charAt(i++));
      enc2 = this.KEY_STR.indexOf(input.charAt(i++));
      enc3 = this.KEY_STR.indexOf(input.charAt(i++));
      enc4 = this.KEY_STR.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      buf.push(chr1);
      if (enc3 !== 64)
        buf.push(chr2);
      if (enc4 !== 64)
        buf.push(chr3);
      chr1 = chr2 = chr3 = "";
      enc1 = enc2 = enc3 = enc4 = "";
      if (!(i < input.length))
        break;
    }
    return buf;
  }
}
$3ed269f2f0fb224b$var$ExifRestore.initClass();
function $3ed269f2f0fb224b$var$__guard__(value, transform) {
  return typeof value !== "undefined" && value !== null ? transform(value) : void 0;
}
function $3ed269f2f0fb224b$var$__guardMethod__(obj, methodName, transform) {
  if (typeof obj !== "undefined" && obj !== null && typeof obj[methodName] === "function")
    return transform(obj, methodName);
  else
    return void 0;
}
var summernote = { exports: {} };
/*!
 * 
 * Super simple WYSIWYG editor v0.9.1
 * https://summernote.org
 *
 * Copyright 2013~ Hackerwins and contributors
 * Summernote may be freely distributed under the MIT license.
 *
 * Date: 2024-10-09T10:28Z
 *
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory(requireJquery());
  })(self, (__WEBPACK_EXTERNAL_MODULE__8938__) => {
    return (
      /******/
      (() => {
        var __webpack_modules__ = {
          /***/
          7e3: (
            /***/
            (__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__2) => {
              var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__2(8938);
              var jquery__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__2.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
              jquery__WEBPACK_IMPORTED_MODULE_0___default().summernote = jquery__WEBPACK_IMPORTED_MODULE_0___default().summernote || {
                lang: {}
              };
              jquery__WEBPACK_IMPORTED_MODULE_0___default().extend(true, jquery__WEBPACK_IMPORTED_MODULE_0___default().summernote.lang, {
                "en-US": {
                  font: {
                    bold: "Bold",
                    italic: "Italic",
                    underline: "Underline",
                    clear: "Remove Font Style",
                    height: "Line Height",
                    name: "Font Family",
                    strikethrough: "Strikethrough",
                    subscript: "Subscript",
                    superscript: "Superscript",
                    size: "Font Size",
                    sizeunit: "Font Size Unit"
                  },
                  image: {
                    image: "Picture",
                    insert: "Insert Image",
                    resizeFull: "Resize full",
                    resizeHalf: "Resize half",
                    resizeQuarter: "Resize quarter",
                    resizeNone: "Original size",
                    floatLeft: "Float Left",
                    floatRight: "Float Right",
                    floatNone: "Remove float",
                    shapeRounded: "Shape: Rounded",
                    shapeCircle: "Shape: Circle",
                    shapeThumbnail: "Shape: Thumbnail",
                    shapeNone: "Shape: None",
                    dragImageHere: "Drag image or text here",
                    dropImage: "Drop image or Text",
                    selectFromFiles: "Select from files",
                    maximumFileSize: "Maximum file size",
                    maximumFileSizeError: "Maximum file size exceeded.",
                    url: "Image URL",
                    remove: "Remove Image",
                    original: "Original"
                  },
                  video: {
                    video: "Video",
                    videoLink: "Video Link",
                    insert: "Insert Video",
                    url: "Video URL",
                    providers: "(YouTube, Google Drive, Vimeo, Vine, Instagram, DailyMotion, Youku, Peertube)"
                  },
                  link: {
                    link: "Link",
                    insert: "Insert Link",
                    unlink: "Unlink",
                    edit: "Edit",
                    textToDisplay: "Text to display",
                    url: "To what URL should this link go?",
                    openInNewWindow: "Open in new window"
                  },
                  table: {
                    table: "Table",
                    addRowAbove: "Add row above",
                    addRowBelow: "Add row below",
                    addColLeft: "Add column left",
                    addColRight: "Add column right",
                    delRow: "Delete row",
                    delCol: "Delete column",
                    delTable: "Delete table"
                  },
                  hr: {
                    insert: "Insert Horizontal Rule"
                  },
                  style: {
                    style: "Style",
                    p: "Normal",
                    blockquote: "Quote",
                    pre: "Code",
                    h1: "Header 1",
                    h2: "Header 2",
                    h3: "Header 3",
                    h4: "Header 4",
                    h5: "Header 5",
                    h6: "Header 6"
                  },
                  lists: {
                    unordered: "Unordered list",
                    ordered: "Ordered list"
                  },
                  options: {
                    help: "Help",
                    fullscreen: "Full Screen",
                    codeview: "Code View"
                  },
                  paragraph: {
                    paragraph: "Paragraph",
                    outdent: "Outdent",
                    indent: "Indent",
                    left: "Align left",
                    center: "Align center",
                    right: "Align right",
                    justify: "Justify full"
                  },
                  color: {
                    recent: "Recent Color",
                    more: "More Color",
                    background: "Background Color",
                    foreground: "Text Color",
                    transparent: "Transparent",
                    setTransparent: "Set transparent",
                    reset: "Reset",
                    resetToDefault: "Reset to default",
                    cpSelect: "Select"
                  },
                  shortcut: {
                    shortcuts: "Keyboard shortcuts",
                    close: "Close",
                    textFormatting: "Text formatting",
                    action: "Action",
                    paragraphFormatting: "Paragraph formatting",
                    documentStyle: "Document Style",
                    extraKeys: "Extra keys"
                  },
                  help: {
                    "escape": "Escape",
                    "insertParagraph": "Insert Paragraph",
                    "undo": "Undo the last command",
                    "redo": "Redo the last command",
                    "tab": "Tab",
                    "untab": "Untab",
                    "bold": "Set a bold style",
                    "italic": "Set a italic style",
                    "underline": "Set a underline style",
                    "strikethrough": "Set a strikethrough style",
                    "removeFormat": "Clean a style",
                    "justifyLeft": "Set left align",
                    "justifyCenter": "Set center align",
                    "justifyRight": "Set right align",
                    "justifyFull": "Set full align",
                    "insertUnorderedList": "Toggle unordered list",
                    "insertOrderedList": "Toggle ordered list",
                    "outdent": "Outdent on current paragraph",
                    "indent": "Indent on current paragraph",
                    "formatPara": "Change current block's format as a paragraph(P tag)",
                    "formatH1": "Change current block's format as H1",
                    "formatH2": "Change current block's format as H2",
                    "formatH3": "Change current block's format as H3",
                    "formatH4": "Change current block's format as H4",
                    "formatH5": "Change current block's format as H5",
                    "formatH6": "Change current block's format as H6",
                    "insertHorizontalRule": "Insert horizontal rule",
                    "linkDialog.show": "Show Link Dialog"
                  },
                  history: {
                    undo: "Undo",
                    redo: "Redo"
                  },
                  specialChar: {
                    specialChar: "SPECIAL CHARACTERS",
                    select: "Select Special characters"
                  },
                  output: {
                    noSelection: "No Selection Made!"
                  }
                }
              });
            }
          ),
          /***/
          8938: (
            /***/
            (module2) => {
              module2.exports = __WEBPACK_EXTERNAL_MODULE__8938__;
            }
          )
          /******/
        };
        var __webpack_module_cache__ = {};
        function __webpack_require__(moduleId) {
          var cachedModule = __webpack_module_cache__[moduleId];
          if (cachedModule !== void 0) {
            return cachedModule.exports;
          }
          var module2 = __webpack_module_cache__[moduleId] = {
            /******/
            // no module.id needed
            /******/
            // no module.loaded needed
            /******/
            exports: {}
            /******/
          };
          __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
          return module2.exports;
        }
        (() => {
          __webpack_require__.n = (module2) => {
            var getter = module2 && module2.__esModule ? (
              /******/
              () => module2["default"]
            ) : (
              /******/
              () => module2
            );
            __webpack_require__.d(getter, { a: getter });
            return getter;
          };
        })();
        (() => {
          __webpack_require__.d = (exports2, definition) => {
            for (var key2 in definition) {
              if (__webpack_require__.o(definition, key2) && !__webpack_require__.o(exports2, key2)) {
                Object.defineProperty(exports2, key2, { enumerable: true, get: definition[key2] });
              }
            }
          };
        })();
        (() => {
          __webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
        })();
        var __webpack_exports__ = {};
        var external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_ = __webpack_require__(8938);
        var external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default = /* @__PURE__ */ __webpack_require__.n(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_);
        __webpack_require__(7e3);
        var genericFontFamilies = ["sans-serif", "serif", "monospace", "cursive", "fantasy"];
        function validFontName(fontName) {
          return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().inArray(fontName.toLowerCase(), genericFontFamilies) === -1 ? "'".concat(fontName, "'") : fontName;
        }
        function createIsFontInstalledFunc() {
          var testText = "mw";
          var fontSize = "20px";
          var canvasWidth = 40;
          var canvasHeight = 20;
          var canvas = document.createElement("canvas");
          var context = canvas.getContext("2d", {
            willReadFrequently: true
          });
          canvas.width = canvasWidth;
          canvas.height = canvasHeight;
          context.textAlign = "center";
          context.fillStyle = "black";
          context.textBaseline = "middle";
          function getPxInfo(font, testFontName) {
            context.clearRect(0, 0, canvasWidth, canvasHeight);
            context.font = fontSize + " " + validFontName(font) + ', "' + testFontName + '"';
            context.fillText(testText, canvasWidth / 2, canvasHeight / 2);
            var pxInfo = context.getImageData(0, 0, canvasWidth, canvasHeight).data;
            return pxInfo.join("");
          }
          return function(fontName) {
            var testFontName = fontName === "Comic Sans MS" ? "Courier New" : "Comic Sans MS";
            var testInfo = getPxInfo(testFontName, testFontName);
            var fontInfo = getPxInfo(fontName, testFontName);
            return testInfo !== fontInfo;
          };
        }
        var userAgent = navigator.userAgent;
        var isMSIE = /MSIE|Trident/i.test(userAgent);
        var browserVersion;
        if (isMSIE) {
          var matches = /MSIE (\d+[.]\d+)/.exec(userAgent);
          if (matches) {
            browserVersion = parseFloat(matches[1]);
          }
          matches = /Trident\/.*rv:([0-9]{1,}[.0-9]{0,})/.exec(userAgent);
          if (matches) {
            browserVersion = parseFloat(matches[1]);
          }
        }
        var isEdge = /Edge\/\d+/.test(userAgent);
        var isSupportTouch = "ontouchstart" in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
        var inputEventName = isMSIE ? "DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted" : "input";
        const env = {
          isMac: navigator.appVersion.indexOf("Mac") > -1,
          isMSIE,
          isEdge,
          isFF: !isEdge && /firefox/i.test(userAgent),
          isPhantom: /PhantomJS/i.test(userAgent),
          isWebkit: !isEdge && /webkit/i.test(userAgent),
          isChrome: !isEdge && /chrome/i.test(userAgent),
          isSafari: !isEdge && /safari/i.test(userAgent) && !/chrome/i.test(userAgent),
          browserVersion,
          isSupportTouch,
          isFontInstalled: createIsFontInstalledFunc(),
          isW3CRangeSupport: !!document.createRange,
          inputEventName,
          genericFontFamilies,
          validFontName
        };
        function eq(itemA) {
          return function(itemB) {
            return itemA === itemB;
          };
        }
        function eq2(itemA, itemB) {
          return itemA === itemB;
        }
        function peq2(propName) {
          return function(itemA, itemB) {
            return itemA[propName] === itemB[propName];
          };
        }
        function ok() {
          return true;
        }
        function fail() {
          return false;
        }
        function not(f2) {
          return function() {
            return !f2.apply(f2, arguments);
          };
        }
        function and(fA, fB) {
          return function(item2) {
            return fA(item2) && fB(item2);
          };
        }
        function func_self(a2) {
          return a2;
        }
        function invoke(obj, method) {
          return function() {
            return obj[method].apply(obj, arguments);
          };
        }
        var idCounter = 0;
        function resetUniqueId() {
          idCounter = 0;
        }
        function uniqueId(prefix) {
          var id = ++idCounter + "";
          return prefix ? prefix + id : id;
        }
        function rect2bnd(rect) {
          var $document = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document);
          return {
            top: rect.top + $document.scrollTop(),
            left: rect.left + $document.scrollLeft(),
            width: rect.right - rect.left,
            height: rect.bottom - rect.top
          };
        }
        function invertObject(obj) {
          var inverted = {};
          for (var key2 in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key2)) {
              inverted[obj[key2]] = key2;
            }
          }
          return inverted;
        }
        function namespaceToCamel(namespace, prefix) {
          prefix = prefix || "";
          return prefix + namespace.split(".").map(function(name2) {
            return name2.substring(0, 1).toUpperCase() + name2.substring(1);
          }).join("");
        }
        function debounce2(func2, wait, immediate) {
          var timeout2;
          return function() {
            var context = this;
            var args = arguments;
            var later = function later2() {
              timeout2 = null;
              if (!immediate) {
                func2.apply(context, args);
              }
            };
            var callNow = immediate && !timeout2;
            clearTimeout(timeout2);
            timeout2 = setTimeout(later, wait);
            if (callNow) {
              func2.apply(context, args);
            }
          };
        }
        function isValidUrl(url) {
          var expression = /[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi;
          return expression.test(url);
        }
        const func = {
          eq,
          eq2,
          peq2,
          ok,
          fail,
          self: func_self,
          not,
          and,
          invoke,
          resetUniqueId,
          uniqueId,
          rect2bnd,
          invertObject,
          namespaceToCamel,
          debounce: debounce2,
          isValidUrl
        };
        function head(array) {
          return array[0];
        }
        function last(array) {
          return array[array.length - 1];
        }
        function initial(array) {
          return array.slice(0, array.length - 1);
        }
        function tail(array) {
          return array.slice(1);
        }
        function find2(array, pred) {
          for (var idx = 0, len = array.length; idx < len; idx++) {
            var item2 = array[idx];
            if (pred(item2)) {
              return item2;
            }
          }
        }
        function lists_all(array, pred) {
          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!pred(array[idx])) {
              return false;
            }
          }
          return true;
        }
        function contains2(array, item2) {
          if (array && array.length && item2) {
            if (array.indexOf) {
              return array.indexOf(item2) !== -1;
            } else if (array.contains) {
              return array.contains(item2);
            }
          }
          return false;
        }
        function sum(array, fn3) {
          fn3 = fn3 || func.self;
          return array.reduce(function(memo, v2) {
            return memo + fn3(v2);
          }, 0);
        }
        function from(collection) {
          var result = [];
          var length = collection.length;
          var idx = -1;
          while (++idx < length) {
            result[idx] = collection[idx];
          }
          return result;
        }
        function isEmpty2(array) {
          return !array || !array.length;
        }
        function clusterBy(array, fn3) {
          if (!array.length) {
            return [];
          }
          var aTail = tail(array);
          return aTail.reduce(function(memo, v2) {
            var aLast = last(memo);
            if (fn3(last(aLast), v2)) {
              aLast[aLast.length] = v2;
            } else {
              memo[memo.length] = [v2];
            }
            return memo;
          }, [[head(array)]]);
        }
        function compact(array) {
          var aResult = [];
          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (array[idx]) {
              aResult.push(array[idx]);
            }
          }
          return aResult;
        }
        function unique(array) {
          var results = [];
          for (var idx = 0, len = array.length; idx < len; idx++) {
            if (!contains2(results, array[idx])) {
              results.push(array[idx]);
            }
          }
          return results;
        }
        function next(array, item2) {
          if (array && array.length && item2) {
            var idx = array.indexOf(item2);
            return idx === -1 ? null : array[idx + 1];
          }
          return null;
        }
        function prev(array, item2) {
          if (array && array.length && item2) {
            var idx = array.indexOf(item2);
            return idx === -1 ? null : array[idx - 1];
          }
          return null;
        }
        const lists = {
          head,
          last,
          initial,
          tail,
          prev,
          next,
          find: find2,
          contains: contains2,
          all: lists_all,
          sum,
          from,
          isEmpty: isEmpty2,
          clusterBy,
          compact,
          unique
        };
        var NBSP_CHAR = String.fromCharCode(160);
        var ZERO_WIDTH_NBSP_CHAR = "\uFEFF";
        function isEditable(node) {
          return node && external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(node).hasClass("note-editable");
        }
        function isControlSizing(node) {
          return node && external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(node).hasClass("note-control-sizing");
        }
        function makePredByNodeName(nodeName) {
          nodeName = nodeName.toUpperCase();
          return function(node) {
            return node && node.nodeName.toUpperCase() === nodeName;
          };
        }
        function isText(node) {
          return node && node.nodeType === 3;
        }
        function isElement2(node) {
          return node && node.nodeType === 1;
        }
        function isVoid(node) {
          return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON|^INPUT|^AUDIO|^VIDEO|^EMBED/.test(node.nodeName.toUpperCase());
        }
        function isPara(node) {
          if (isEditable(node)) {
            return false;
          }
          return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());
        }
        function isHeading(node) {
          return node && /^H[1-7]/.test(node.nodeName.toUpperCase());
        }
        var isPre = makePredByNodeName("PRE");
        var isLi = makePredByNodeName("LI");
        function isPurePara(node) {
          return isPara(node) && !isLi(node);
        }
        var isTable = makePredByNodeName("TABLE");
        var isData = makePredByNodeName("DATA");
        function isInline(node) {
          return !isBodyContainer(node) && !isList(node) && !isHr(node) && !isPara(node) && !isTable(node) && !isBlockquote(node) && !isData(node);
        }
        function isList(node) {
          return node && /^UL|^OL/.test(node.nodeName.toUpperCase());
        }
        var isHr = makePredByNodeName("HR");
        function isCell(node) {
          return node && /^TD|^TH/.test(node.nodeName.toUpperCase());
        }
        var isBlockquote = makePredByNodeName("BLOCKQUOTE");
        function isBodyContainer(node) {
          return isCell(node) || isBlockquote(node) || isEditable(node);
        }
        var isAnchor = makePredByNodeName("A");
        function isParaInline(node) {
          return isInline(node) && !!ancestor(node, isPara);
        }
        function isBodyInline(node) {
          return isInline(node) && !ancestor(node, isPara);
        }
        var isBody = makePredByNodeName("BODY");
        function isClosestSibling(nodeA, nodeB) {
          return nodeA.nextSibling === nodeB || nodeA.previousSibling === nodeB;
        }
        function withClosestSiblings(node, pred) {
          pred = pred || func.ok;
          var siblings = [];
          if (node.previousSibling && pred(node.previousSibling)) {
            siblings.push(node.previousSibling);
          }
          siblings.push(node);
          if (node.nextSibling && pred(node.nextSibling)) {
            siblings.push(node.nextSibling);
          }
          return siblings;
        }
        var blankHTML = env.isMSIE && env.browserVersion < 11 ? "&nbsp;" : "<br>";
        function nodeLength(node) {
          if (isText(node)) {
            return node.nodeValue.length;
          }
          if (node) {
            return node.childNodes.length;
          }
          return 0;
        }
        function deepestChildIsEmpty(node) {
          do {
            if (node.firstElementChild === null || node.firstElementChild.innerHTML === "")
              break;
          } while (node = node.firstElementChild);
          return dom_isEmpty(node);
        }
        function dom_isEmpty(node) {
          var len = nodeLength(node);
          if (len === 0) {
            return true;
          } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {
            return true;
          } else if (lists.all(node.childNodes, isText) && node.innerHTML === "") {
            return true;
          }
          return false;
        }
        function paddingBlankHTML(node) {
          if (!isVoid(node) && !nodeLength(node)) {
            node.innerHTML = blankHTML;
          }
        }
        function ancestor(node, pred) {
          while (node) {
            if (pred(node)) {
              return node;
            }
            if (isEditable(node)) {
              break;
            }
            node = node.parentNode;
          }
          return null;
        }
        function singleChildAncestor(node, pred) {
          node = node.parentNode;
          while (node) {
            if (nodeLength(node) !== 1) {
              break;
            }
            if (pred(node)) {
              return node;
            }
            if (isEditable(node)) {
              break;
            }
            node = node.parentNode;
          }
          return null;
        }
        function listAncestor(node, pred) {
          pred = pred || func.fail;
          var ancestors = [];
          ancestor(node, function(el) {
            if (!isEditable(el)) {
              ancestors.push(el);
            }
            return pred(el);
          });
          return ancestors;
        }
        function lastAncestor(node, pred) {
          var ancestors = listAncestor(node);
          return lists.last(ancestors.filter(pred));
        }
        function commonAncestor(nodeA, nodeB) {
          var ancestors = listAncestor(nodeA);
          for (var n2 = nodeB; n2; n2 = n2.parentNode) {
            if (ancestors.indexOf(n2) > -1)
              return n2;
          }
          return null;
        }
        function listPrev(node, pred) {
          pred = pred || func.fail;
          var nodes = [];
          while (node) {
            if (pred(node)) {
              break;
            }
            nodes.push(node);
            node = node.previousSibling;
          }
          return nodes;
        }
        function listNext(node, pred) {
          pred = pred || func.fail;
          var nodes = [];
          while (node) {
            if (pred(node)) {
              break;
            }
            nodes.push(node);
            node = node.nextSibling;
          }
          return nodes;
        }
        function listDescendant(node, pred) {
          var descendants = [];
          pred = pred || func.ok;
          (function fnWalk(current) {
            if (node !== current && pred(current)) {
              descendants.push(current);
            }
            for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {
              fnWalk(current.childNodes[idx]);
            }
          })(node);
          return descendants;
        }
        function wrap(node, wrapperName) {
          var parent = node.parentNode;
          var wrapper = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<" + wrapperName + ">")[0];
          parent.insertBefore(wrapper, node);
          wrapper.appendChild(node);
          return wrapper;
        }
        function insertAfter2(node, preceding) {
          var next2 = preceding.nextSibling;
          var parent = preceding.parentNode;
          if (next2) {
            parent.insertBefore(node, next2);
          } else {
            parent.appendChild(node);
          }
          return node;
        }
        function appendChildNodes(node, aChild, isSkipPaddingBlankHTML) {
          external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(aChild, function(idx, child) {
            if (!isSkipPaddingBlankHTML && isLi(node) && node.firstChild === null && isList(child)) {
              node.appendChild(create2("br"));
            }
            node.appendChild(child);
          });
          return node;
        }
        function isLeftEdgePoint(point) {
          return point.offset === 0;
        }
        function isRightEdgePoint(point) {
          return point.offset === nodeLength(point.node);
        }
        function isEdgePoint(point) {
          return isLeftEdgePoint(point) || isRightEdgePoint(point);
        }
        function isLeftEdgeOf(node, ancestor2) {
          while (node && node !== ancestor2) {
            if (position(node) !== 0) {
              return false;
            }
            node = node.parentNode;
          }
          return true;
        }
        function isRightEdgeOf(node, ancestor2) {
          if (!ancestor2) {
            return false;
          }
          while (node && node !== ancestor2) {
            if (position(node) !== nodeLength(node.parentNode) - 1) {
              return false;
            }
            node = node.parentNode;
          }
          return true;
        }
        function isLeftEdgePointOf(point, ancestor2) {
          return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor2);
        }
        function isRightEdgePointOf(point, ancestor2) {
          return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor2);
        }
        function position(node) {
          var offset2 = 0;
          while (node = node.previousSibling) {
            offset2 += 1;
          }
          return offset2;
        }
        function hasChildren(node) {
          return !!(node && node.childNodes && node.childNodes.length);
        }
        function prevPoint(point, isSkipInnerOffset) {
          var node;
          var offset2;
          if (point.offset === 0) {
            if (isEditable(point.node)) {
              return null;
            }
            node = point.node.parentNode;
            offset2 = position(point.node);
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset - 1];
            offset2 = nodeLength(node);
          } else {
            node = point.node;
            offset2 = isSkipInnerOffset ? 0 : point.offset - 1;
          }
          return {
            node,
            offset: offset2
          };
        }
        function nextPoint(point, isSkipInnerOffset) {
          var node, offset2;
          if (nodeLength(point.node) === point.offset) {
            if (isEditable(point.node)) {
              return null;
            }
            var nextTextNode = getNextTextNode(point.node);
            if (nextTextNode) {
              node = nextTextNode;
              offset2 = 0;
            } else {
              node = point.node.parentNode;
              offset2 = position(point.node) + 1;
            }
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset];
            offset2 = 0;
          } else {
            node = point.node;
            offset2 = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
          }
          return {
            node,
            offset: offset2
          };
        }
        function nextPointWithEmptyNode(point, isSkipInnerOffset) {
          var node, offset2 = 0;
          if (nodeLength(point.node) === point.offset) {
            if (isEditable(point.node)) {
              return null;
            }
            node = point.node.parentNode;
            offset2 = position(point.node) + 1;
            if (isEditable(node)) {
              node = point.node.nextSibling;
              offset2 = 0;
            }
          } else if (hasChildren(point.node)) {
            node = point.node.childNodes[point.offset];
            offset2 = 0;
          } else {
            node = point.node;
            offset2 = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;
          }
          return {
            node,
            offset: offset2
          };
        }
        function getNextTextNode(actual) {
          if (!actual.nextSibling)
            return void 0;
          if (actual.parent !== actual.nextSibling.parent)
            return void 0;
          if (isText(actual.nextSibling))
            return actual.nextSibling;
          else
            return getNextTextNode(actual.nextSibling);
        }
        function isSamePoint(pointA, pointB) {
          return pointA.node === pointB.node && pointA.offset === pointB.offset;
        }
        function isVisiblePoint(point) {
          if (isText(point.node) || !hasChildren(point.node) || dom_isEmpty(point.node)) {
            return true;
          }
          var leftNode = point.node.childNodes[point.offset - 1];
          var rightNode = point.node.childNodes[point.offset];
          if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode)) || isTable(rightNode)) {
            return true;
          }
          return false;
        }
        function prevPointUntil(point, pred) {
          while (point) {
            if (pred(point)) {
              return point;
            }
            point = prevPoint(point);
          }
          return null;
        }
        function nextPointUntil(point, pred) {
          while (point) {
            if (pred(point)) {
              return point;
            }
            point = nextPoint(point);
          }
          return null;
        }
        function isCharPoint(point) {
          if (!isText(point.node)) {
            return false;
          }
          var ch = point.node.nodeValue.charAt(point.offset - 1);
          return ch && ch !== " " && ch !== NBSP_CHAR;
        }
        function isSpacePoint(point) {
          if (!isText(point.node)) {
            return false;
          }
          var ch = point.node.nodeValue.charAt(point.offset - 1);
          return ch === " " || ch === NBSP_CHAR;
        }
        function walkPoint(startPoint, endPoint, handler, isSkipInnerOffset) {
          var point = startPoint;
          while (point && point.node) {
            handler(point);
            if (isSamePoint(point, endPoint)) {
              break;
            }
            var isSkipOffset = isSkipInnerOffset && startPoint.node !== point.node && endPoint.node !== point.node;
            point = nextPointWithEmptyNode(point, isSkipOffset);
          }
        }
        function makeOffsetPath(ancestor2, node) {
          var ancestors = listAncestor(node, func.eq(ancestor2));
          return ancestors.map(position).reverse();
        }
        function fromOffsetPath(ancestor2, offsets) {
          var current = ancestor2;
          for (var i = 0, len = offsets.length; i < len; i++) {
            if (current.childNodes.length <= offsets[i]) {
              current = current.childNodes[current.childNodes.length - 1];
            } else {
              current = current.childNodes[offsets[i]];
            }
          }
          return current;
        }
        function splitNode(point, options) {
          var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;
          var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;
          var isDiscardEmptySplits = options && options.isDiscardEmptySplits;
          if (isDiscardEmptySplits) {
            isSkipPaddingBlankHTML = true;
          }
          if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {
            if (isLeftEdgePoint(point)) {
              return point.node;
            } else if (isRightEdgePoint(point)) {
              return point.node.nextSibling;
            }
          }
          if (isText(point.node)) {
            return point.node.splitText(point.offset);
          } else {
            var childNode = point.node.childNodes[point.offset];
            var childNodes = listNext(childNode);
            var clone = insertAfter2(point.node.cloneNode(false), point.node);
            appendChildNodes(clone, childNodes);
            if (!isSkipPaddingBlankHTML) {
              paddingBlankHTML(point.node);
              paddingBlankHTML(clone);
            }
            if (isDiscardEmptySplits) {
              if (dom_isEmpty(point.node)) {
                remove(point.node);
              }
              if (dom_isEmpty(clone)) {
                remove(clone);
                return point.node.nextSibling;
              }
            }
            return clone;
          }
        }
        function splitTree(root2, point, options) {
          var ancestors = listAncestor(point.node, func.eq(root2));
          if (!ancestors.length) {
            return null;
          } else if (ancestors.length === 1) {
            return splitNode(point, options);
          }
          if (ancestors.length > 2) {
            var domList = ancestors.slice(0, ancestors.length - 1);
            var ifHasNextSibling = domList.find(function(item2) {
              return item2.nextSibling;
            });
            if (ifHasNextSibling && point.offset != 0 && isRightEdgePoint(point)) {
              var nestSibling = ifHasNextSibling.nextSibling;
              var textNode;
              if (nestSibling.nodeType == 1) {
                textNode = nestSibling.childNodes[0];
                ancestors = listAncestor(textNode, func.eq(root2));
                point = {
                  node: textNode,
                  offset: 0
                };
              } else if (nestSibling.nodeType == 3 && !nestSibling.data.match(/[\n\r]/g)) {
                textNode = nestSibling;
                ancestors = listAncestor(textNode, func.eq(root2));
                point = {
                  node: textNode,
                  offset: 0
                };
              }
            }
          }
          return ancestors.reduce(function(node, parent) {
            if (node === point.node) {
              node = splitNode(point, options);
            }
            return splitNode({
              node: parent,
              offset: node ? position(node) : nodeLength(parent)
            }, options);
          });
        }
        function splitPoint(point, isInline2) {
          var pred = isInline2 ? isPara : isBodyContainer;
          var ancestors = listAncestor(point.node, pred);
          var topAncestor = lists.last(ancestors) || point.node;
          var splitRoot, container;
          if (pred(topAncestor)) {
            splitRoot = ancestors[ancestors.length - 2];
            container = topAncestor;
          } else {
            splitRoot = topAncestor;
            container = splitRoot.parentNode;
          }
          var pivot = splitRoot && splitTree(splitRoot, point, {
            isSkipPaddingBlankHTML: isInline2,
            isNotSplitEdgePoint: isInline2
          });
          if (!pivot && container === point.node) {
            pivot = point.node.childNodes[point.offset];
          }
          return {
            rightNode: pivot,
            container
          };
        }
        function create2(nodeName) {
          return document.createElement(nodeName);
        }
        function createText(text2) {
          return document.createTextNode(text2);
        }
        function remove(node, isRemoveChild) {
          if (!node || !node.parentNode) {
            return;
          }
          if (node.removeNode) {
            return node.removeNode(isRemoveChild);
          }
          var parent = node.parentNode;
          if (!isRemoveChild) {
            var nodes = [];
            for (var i = 0, len = node.childNodes.length; i < len; i++) {
              nodes.push(node.childNodes[i]);
            }
            for (var _i2 = 0, _len = nodes.length; _i2 < _len; _i2++) {
              parent.insertBefore(nodes[_i2], node);
            }
          }
          parent.removeChild(node);
        }
        function removeWhile(node, pred) {
          while (node) {
            if (isEditable(node) || !pred(node)) {
              break;
            }
            var parent = node.parentNode;
            remove(node);
            node = parent;
          }
        }
        function replace(node, nodeName) {
          if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {
            return node;
          }
          var newNode = create2(nodeName);
          if (node.style.cssText) {
            newNode.style.cssText = node.style.cssText;
          }
          appendChildNodes(newNode, lists.from(node.childNodes));
          insertAfter2(newNode, node);
          remove(node);
          return newNode;
        }
        var isTextarea = makePredByNodeName("TEXTAREA");
        function value($node, stripLinebreaks) {
          var val = isTextarea($node[0]) ? $node.val() : $node.html();
          if (stripLinebreaks) {
            return val.replace(/[\n\r]/g, "");
          }
          return val;
        }
        function html($node, isNewlineOnBlock) {
          var markup = value($node);
          if (isNewlineOnBlock) {
            var regexTag = /<(\/?)(\b(?!!)[^>\s]*)(.*?)(\s*\/?>)/g;
            markup = markup.replace(regexTag, function(match, endSlash, name2) {
              name2 = name2.toUpperCase();
              var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name2) && !!endSlash;
              var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name2);
              return match + (isEndOfInlineContainer || isBlockNode ? "\n" : "");
            });
            markup = markup.trim();
          }
          return markup;
        }
        function posFromPlaceholder(placeholder) {
          var $placeholder = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(placeholder);
          var pos = $placeholder.offset();
          var height = $placeholder.outerHeight(true);
          return {
            left: pos.left,
            top: pos.top + height
          };
        }
        function attachEvents($node, events) {
          Object.keys(events).forEach(function(key2) {
            $node.on(key2, events[key2]);
          });
        }
        function detachEvents($node, events) {
          Object.keys(events).forEach(function(key2) {
            $node.off(key2, events[key2]);
          });
        }
        function isCustomStyleTag(node) {
          return node && !isText(node) && lists.contains(node.classList, "note-styletag");
        }
        const dom = {
          /** @property {String} NBSP_CHAR */
          NBSP_CHAR,
          /** @property {String} ZERO_WIDTH_NBSP_CHAR */
          ZERO_WIDTH_NBSP_CHAR,
          /** @property {String} blank */
          blank: blankHTML,
          /** @property {String} emptyPara */
          emptyPara: "<p>".concat(blankHTML, "</p>"),
          makePredByNodeName,
          isEditable,
          isControlSizing,
          isText,
          isElement: isElement2,
          isVoid,
          isPara,
          isPurePara,
          isHeading,
          isInline,
          isBlock: func.not(isInline),
          isBodyInline,
          isBody,
          isParaInline,
          isPre,
          isList,
          isTable,
          isData,
          isCell,
          isBlockquote,
          isBodyContainer,
          isAnchor,
          isDiv: makePredByNodeName("DIV"),
          isLi,
          isBR: makePredByNodeName("BR"),
          isSpan: makePredByNodeName("SPAN"),
          isB: makePredByNodeName("B"),
          isU: makePredByNodeName("U"),
          isS: makePredByNodeName("S"),
          isI: makePredByNodeName("I"),
          isImg: makePredByNodeName("IMG"),
          isTextarea,
          deepestChildIsEmpty,
          isEmpty: dom_isEmpty,
          isEmptyAnchor: func.and(isAnchor, dom_isEmpty),
          isClosestSibling,
          withClosestSiblings,
          nodeLength,
          isLeftEdgePoint,
          isRightEdgePoint,
          isEdgePoint,
          isLeftEdgeOf,
          isRightEdgeOf,
          isLeftEdgePointOf,
          isRightEdgePointOf,
          prevPoint,
          nextPoint,
          nextPointWithEmptyNode,
          isSamePoint,
          isVisiblePoint,
          prevPointUntil,
          nextPointUntil,
          isCharPoint,
          isSpacePoint,
          walkPoint,
          ancestor,
          singleChildAncestor,
          listAncestor,
          lastAncestor,
          listNext,
          listPrev,
          listDescendant,
          commonAncestor,
          wrap,
          insertAfter: insertAfter2,
          appendChildNodes,
          position,
          hasChildren,
          makeOffsetPath,
          fromOffsetPath,
          splitTree,
          splitPoint,
          create: create2,
          createText,
          remove,
          removeWhile,
          replace,
          html,
          value,
          posFromPlaceholder,
          attachEvents,
          detachEvents,
          isCustomStyleTag
        };
        function _typeof(o2) {
          "@babel/helpers - typeof";
          return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, _typeof(o2);
        }
        function _classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, _toPropertyKey(o2.key), o2);
          }
        }
        function _createClass(e2, r2, t2) {
          return r2 && _defineProperties(e2.prototype, r2), t2 && _defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function _toPropertyKey(t2) {
          var i = _toPrimitive(t2, "string");
          return "symbol" == _typeof(i) ? i : i + "";
        }
        function _toPrimitive(t2, r2) {
          if ("object" != _typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != _typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Context = /* @__PURE__ */ function() {
          function Context2($note, options) {
            _classCallCheck(this, Context2);
            this.$note = $note;
            this.memos = {};
            this.modules = {};
            this.layoutInfo = {};
            this.options = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(true, {}, options);
            external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui_template(this.options);
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.initialize();
          }
          return _createClass(Context2, [{
            key: "initialize",
            value: function initialize2() {
              this.layoutInfo = this.ui.createLayout(this.$note);
              this._initialize();
              this.$note.hide();
              return this;
            }
            /**
             * destroy modules and other resources and remove layout
             */
          }, {
            key: "destroy",
            value: function destroy2() {
              this._destroy();
              this.$note.removeData("summernote");
              this.ui.removeLayout(this.$note, this.layoutInfo);
            }
            /**
             * destory modules and other resources and initialize it again
             */
          }, {
            key: "reset",
            value: function reset() {
              var disabled = this.isDisabled();
              this.code(dom.emptyPara);
              this._destroy();
              this._initialize();
              if (disabled) {
                this.disable();
              }
            }
          }, {
            key: "_initialize",
            value: function _initialize() {
              var _this = this;
              this.options.id = func.uniqueId(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().now());
              this.options.container = this.options.container || this.layoutInfo.editor;
              var buttons = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend({}, this.options.buttons);
              Object.keys(buttons).forEach(function(key2) {
                _this.memo("button." + key2, buttons[key2]);
              });
              var modules = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend({}, this.options.modules, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.plugins || {});
              Object.keys(modules).forEach(function(key2) {
                _this.module(key2, modules[key2], true);
              });
              Object.keys(this.modules).forEach(function(key2) {
                _this.initializeModule(key2);
              });
            }
          }, {
            key: "_destroy",
            value: function _destroy2() {
              var _this2 = this;
              Object.keys(this.modules).reverse().forEach(function(key2) {
                _this2.removeModule(key2);
              });
              Object.keys(this.memos).forEach(function(key2) {
                _this2.removeMemo(key2);
              });
              this.triggerEvent("destroy", this);
            }
          }, {
            key: "code",
            value: function code(html2) {
              var isActivated = this.invoke("codeview.isActivated");
              if (html2 === void 0) {
                this.invoke("codeview.sync");
                return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();
              } else {
                if (isActivated) {
                  this.invoke("codeview.sync", html2);
                } else {
                  this.layoutInfo.editable.html(html2);
                }
                this.$note.val(html2);
                this.triggerEvent("change", html2, this.layoutInfo.editable);
              }
            }
          }, {
            key: "isDisabled",
            value: function isDisabled2() {
              return this.layoutInfo.editable.attr("contenteditable") === "false";
            }
          }, {
            key: "enable",
            value: function enable() {
              this.layoutInfo.editable.attr("contenteditable", true);
              this.invoke("toolbar.activate", true);
              this.triggerEvent("disable", false);
              this.options.editing = true;
            }
          }, {
            key: "disable",
            value: function disable() {
              if (this.invoke("codeview.isActivated")) {
                this.invoke("codeview.deactivate");
              }
              this.layoutInfo.editable.attr("contenteditable", false);
              this.options.editing = false;
              this.invoke("toolbar.deactivate", true);
              this.triggerEvent("disable", true);
            }
          }, {
            key: "triggerEvent",
            value: function triggerEvent2() {
              var namespace = lists.head(arguments);
              var args = lists.tail(lists.from(arguments));
              var callback = this.options.callbacks[func.namespaceToCamel(namespace, "on")];
              if (callback) {
                callback.apply(this.$note[0], args);
              }
              this.$note.trigger("summernote." + namespace, args);
            }
          }, {
            key: "initializeModule",
            value: function initializeModule(key2) {
              var module2 = this.modules[key2];
              module2.shouldInitialize = module2.shouldInitialize || func.ok;
              if (!module2.shouldInitialize()) {
                return;
              }
              if (module2.initialize) {
                module2.initialize();
              }
              if (module2.events) {
                dom.attachEvents(this.$note, module2.events);
              }
            }
          }, {
            key: "module",
            value: function module2(key2, ModuleClass, withoutIntialize) {
              if (arguments.length === 1) {
                return this.modules[key2];
              }
              this.modules[key2] = new ModuleClass(this);
              if (!withoutIntialize) {
                this.initializeModule(key2);
              }
            }
          }, {
            key: "removeModule",
            value: function removeModule(key2) {
              var module2 = this.modules[key2];
              if (module2.shouldInitialize()) {
                if (module2.events) {
                  dom.detachEvents(this.$note, module2.events);
                }
                if (module2.destroy) {
                  module2.destroy();
                }
              }
              delete this.modules[key2];
            }
          }, {
            key: "memo",
            value: function memo(key2, obj) {
              if (arguments.length === 1) {
                return this.memos[key2];
              }
              this.memos[key2] = obj;
            }
          }, {
            key: "removeMemo",
            value: function removeMemo(key2) {
              if (this.memos[key2] && this.memos[key2].destroy) {
                this.memos[key2].destroy();
              }
              delete this.memos[key2];
            }
            /**
             * Some buttons need to change their visual style immediately once they get pressed
             */
          }, {
            key: "createInvokeHandlerAndUpdateState",
            value: function createInvokeHandlerAndUpdateState(namespace, value2) {
              var _this3 = this;
              return function(event) {
                _this3.createInvokeHandler(namespace, value2)(event);
                _this3.invoke("buttons.updateCurrentStyle");
              };
            }
          }, {
            key: "createInvokeHandler",
            value: function createInvokeHandler(namespace, value2) {
              var _this4 = this;
              return function(event) {
                event.preventDefault();
                var $target = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.target);
                _this4.invoke(namespace, value2 || $target.closest("[data-value]").data("value"), $target);
              };
            }
          }, {
            key: "invoke",
            value: function invoke2() {
              var namespace = lists.head(arguments);
              var args = lists.tail(lists.from(arguments));
              var splits = namespace.split(".");
              var hasSeparator = splits.length > 1;
              var moduleName = hasSeparator && lists.head(splits);
              var methodName = hasSeparator ? lists.last(splits) : lists.head(splits);
              var module2 = this.modules[moduleName || "editor"];
              if (!moduleName && this[methodName]) {
                return this[methodName].apply(this, args);
              } else if (module2 && module2[methodName] && module2.shouldInitialize()) {
                return module2[methodName].apply(module2, args);
              }
            }
          }]);
        }();
        function summernote_typeof(o2) {
          "@babel/helpers - typeof";
          return summernote_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, summernote_typeof(o2);
        }
        external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().fn.extend({
          /**
           * Summernote API
           *
           * @param {Object|String}
           * @return {this}
           */
          summernote: function summernote2() {
            var type = summernote_typeof(lists.head(arguments));
            var isExternalAPICalled = type === "string";
            var hasInitOptions = type === "object";
            var options = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend({}, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.options, hasInitOptions ? lists.head(arguments) : {});
            options.langInfo = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(true, {}, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.lang["en-US"], external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.lang[options.lang]);
            options.icons = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(true, {}, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.options.icons, options.icons);
            options.tooltip = options.tooltip === "auto" ? !env.isSupportTouch : options.tooltip;
            this.each(function(idx, note) {
              var $note2 = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(note);
              if (!$note2.data("summernote")) {
                var context2 = new Context($note2, options);
                $note2.data("summernote", context2);
                $note2.data("summernote").triggerEvent("init", context2.layoutInfo);
              }
            });
            var $note = this.first();
            if ($note.length) {
              var context = $note.data("summernote");
              if (isExternalAPICalled) {
                return context.invoke.apply(context, lists.from(arguments));
              } else if (options.focus) {
                context.invoke("editor.focus");
              }
            }
            return this;
          }
        });
        function range_typeof(o2) {
          "@babel/helpers - typeof";
          return range_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, range_typeof(o2);
        }
        function range_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function range_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, range_toPropertyKey(o2.key), o2);
          }
        }
        function range_createClass(e2, r2, t2) {
          return r2 && range_defineProperties(e2.prototype, r2), t2 && range_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function range_toPropertyKey(t2) {
          var i = range_toPrimitive(t2, "string");
          return "symbol" == range_typeof(i) ? i : i + "";
        }
        function range_toPrimitive(t2, r2) {
          if ("object" != range_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != range_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        function textRangeToPoint(textRange, isStart) {
          var container = textRange.parentElement();
          var offset2;
          var tester = document.body.createTextRange();
          var prevContainer;
          var childNodes = lists.from(container.childNodes);
          for (offset2 = 0; offset2 < childNodes.length; offset2++) {
            if (dom.isText(childNodes[offset2])) {
              continue;
            }
            tester.moveToElementText(childNodes[offset2]);
            if (tester.compareEndPoints("StartToStart", textRange) >= 0) {
              break;
            }
            prevContainer = childNodes[offset2];
          }
          if (offset2 !== 0 && dom.isText(childNodes[offset2 - 1])) {
            var textRangeStart = document.body.createTextRange();
            var curTextNode = null;
            textRangeStart.moveToElementText(prevContainer || container);
            textRangeStart.collapse(!prevContainer);
            curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;
            var pointTester = textRange.duplicate();
            pointTester.setEndPoint("StartToStart", textRangeStart);
            var textCount = pointTester.text.replace(/[\r\n]/g, "").length;
            while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {
              textCount -= curTextNode.nodeValue.length;
              curTextNode = curTextNode.nextSibling;
            }
            curTextNode.nodeValue;
            if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) && textCount === curTextNode.nodeValue.length) {
              textCount -= curTextNode.nodeValue.length;
              curTextNode = curTextNode.nextSibling;
            }
            container = curTextNode;
            offset2 = textCount;
          }
          return {
            cont: container,
            offset: offset2
          };
        }
        function pointToTextRange(point) {
          var textRangeInfo = function textRangeInfo2(container, offset2) {
            var node, isCollapseToStart;
            if (dom.isText(container)) {
              var prevTextNodes = dom.listPrev(container, func.not(dom.isText));
              var prevContainer = lists.last(prevTextNodes).previousSibling;
              node = prevContainer || container.parentNode;
              offset2 += lists.sum(lists.tail(prevTextNodes), dom.nodeLength);
              isCollapseToStart = !prevContainer;
            } else {
              node = container.childNodes[offset2] || container;
              if (dom.isText(node)) {
                return textRangeInfo2(node, 0);
              }
              offset2 = 0;
              isCollapseToStart = false;
            }
            return {
              node,
              collapseToStart: isCollapseToStart,
              offset: offset2
            };
          };
          var textRange = document.body.createTextRange();
          var info = textRangeInfo(point.node, point.offset);
          textRange.moveToElementText(info.node);
          textRange.collapse(info.collapseToStart);
          textRange.moveStart("character", info.offset);
          return textRange;
        }
        var WrappedRange = /* @__PURE__ */ function() {
          function WrappedRange2(sc, so, ec, eo) {
            range_classCallCheck(this, WrappedRange2);
            this.sc = sc;
            this.so = so;
            this.ec = ec;
            this.eo = eo;
            this.isOnEditable = this.makeIsOn(dom.isEditable);
            this.isOnList = this.makeIsOn(dom.isList);
            this.isOnAnchor = this.makeIsOn(dom.isAnchor);
            this.isOnCell = this.makeIsOn(dom.isCell);
            this.isOnData = this.makeIsOn(dom.isData);
          }
          return range_createClass(WrappedRange2, [{
            key: "nativeRange",
            value: function nativeRange() {
              if (env.isW3CRangeSupport) {
                var w3cRange = document.createRange();
                w3cRange.setStart(this.sc, this.so);
                w3cRange.setEnd(this.ec, this.eo);
                return w3cRange;
              } else {
                var textRange = pointToTextRange({
                  node: this.sc,
                  offset: this.so
                });
                textRange.setEndPoint("EndToEnd", pointToTextRange({
                  node: this.ec,
                  offset: this.eo
                }));
                return textRange;
              }
            }
          }, {
            key: "getPoints",
            value: function getPoints() {
              return {
                sc: this.sc,
                so: this.so,
                ec: this.ec,
                eo: this.eo
              };
            }
          }, {
            key: "getStartPoint",
            value: function getStartPoint() {
              return {
                node: this.sc,
                offset: this.so
              };
            }
          }, {
            key: "getEndPoint",
            value: function getEndPoint() {
              return {
                node: this.ec,
                offset: this.eo
              };
            }
            /**
             * select update visible range
             */
          }, {
            key: "select",
            value: function select() {
              var nativeRng = this.nativeRange();
              if (env.isW3CRangeSupport) {
                var selection = document.getSelection();
                if (selection.rangeCount > 0) {
                  selection.removeAllRanges();
                }
                selection.addRange(nativeRng);
              } else {
                nativeRng.select();
              }
              return this;
            }
            /**
             * Moves the scrollbar to start container(sc) of current range
             *
             * @return {WrappedRange}
             */
          }, {
            key: "scrollIntoView",
            value: function scrollIntoView(container) {
              var height = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(container).height();
              if (container.scrollTop + height < this.sc.offsetTop) {
                container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);
              }
              return this;
            }
            /**
             * @return {WrappedRange}
             */
          }, {
            key: "normalize",
            value: function normalize2() {
              var getVisiblePoint = function getVisiblePoint2(point, isLeftToRight) {
                if (!point) {
                  return point;
                }
                if (dom.isVisiblePoint(point)) {
                  if (!dom.isEdgePoint(point) || dom.isRightEdgePoint(point) && !isLeftToRight || dom.isLeftEdgePoint(point) && isLeftToRight || dom.isRightEdgePoint(point) && isLeftToRight && dom.isVoid(point.node.nextSibling) || dom.isLeftEdgePoint(point) && !isLeftToRight && dom.isVoid(point.node.previousSibling) || dom.isBlock(point.node) && dom.isEmpty(point.node)) {
                    return point;
                  }
                }
                var block = dom.ancestor(point.node, dom.isBlock);
                var hasRightNode = false;
                if (!hasRightNode) {
                  var prevPoint2 = dom.prevPoint(point) || {
                    node: null
                  };
                  hasRightNode = (dom.isLeftEdgePointOf(point, block) || dom.isVoid(prevPoint2.node)) && !isLeftToRight;
                }
                var hasLeftNode = false;
                if (!hasLeftNode) {
                  var _nextPoint = dom.nextPoint(point) || {
                    node: null
                  };
                  hasLeftNode = (dom.isRightEdgePointOf(point, block) || dom.isVoid(_nextPoint.node)) && isLeftToRight;
                }
                if (hasRightNode || hasLeftNode) {
                  if (dom.isVisiblePoint(point)) {
                    return point;
                  }
                  isLeftToRight = !isLeftToRight;
                }
                var nextPoint2 = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) : dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);
                return nextPoint2 || point;
              };
              var endPoint = getVisiblePoint(this.getEndPoint(), false);
              var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);
              return new WrappedRange2(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns matched nodes on range
             *
             * @param {Function} [pred] - predicate function
             * @param {Object} [options]
             * @param {Boolean} [options.includeAncestor]
             * @param {Boolean} [options.fullyContains]
             * @return {Node[]}
             */
          }, {
            key: "nodes",
            value: function nodes(pred, options) {
              pred = pred || func.ok;
              var includeAncestor = options && options.includeAncestor;
              var fullyContains = options && options.fullyContains;
              var startPoint = this.getStartPoint();
              var endPoint = this.getEndPoint();
              var nodes2 = [];
              var leftEdgeNodes = [];
              dom.walkPoint(startPoint, endPoint, function(point) {
                if (dom.isEditable(point.node)) {
                  return;
                }
                var node;
                if (fullyContains) {
                  if (dom.isLeftEdgePoint(point)) {
                    leftEdgeNodes.push(point.node);
                  }
                  if (dom.isRightEdgePoint(point) && lists.contains(leftEdgeNodes, point.node)) {
                    node = point.node;
                  }
                } else if (includeAncestor) {
                  node = dom.ancestor(point.node, pred);
                } else {
                  node = point.node;
                }
                if (node && pred(node)) {
                  nodes2.push(node);
                }
              }, true);
              return lists.unique(nodes2);
            }
            /**
             * returns commonAncestor of range
             * @return {Element} - commonAncestor
             */
          }, {
            key: "commonAncestor",
            value: function commonAncestor2() {
              return dom.commonAncestor(this.sc, this.ec);
            }
            /**
             * returns expanded range by pred
             *
             * @param {Function} pred - predicate function
             * @return {WrappedRange}
             */
          }, {
            key: "expand",
            value: function expand(pred) {
              var startAncestor = dom.ancestor(this.sc, pred);
              var endAncestor = dom.ancestor(this.ec, pred);
              if (!startAncestor && !endAncestor) {
                return new WrappedRange2(this.sc, this.so, this.ec, this.eo);
              }
              var boundaryPoints = this.getPoints();
              if (startAncestor) {
                boundaryPoints.sc = startAncestor;
                boundaryPoints.so = 0;
              }
              if (endAncestor) {
                boundaryPoints.ec = endAncestor;
                boundaryPoints.eo = dom.nodeLength(endAncestor);
              }
              return new WrappedRange2(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            }
            /**
             * @param {Boolean} isCollapseToStart
             * @return {WrappedRange}
             */
          }, {
            key: "collapse",
            value: function collapse(isCollapseToStart) {
              if (isCollapseToStart) {
                return new WrappedRange2(this.sc, this.so, this.sc, this.so);
              } else {
                return new WrappedRange2(this.ec, this.eo, this.ec, this.eo);
              }
            }
            /**
             * splitText on range
             */
          }, {
            key: "splitText",
            value: function splitText() {
              var isSameContainer = this.sc === this.ec;
              var boundaryPoints = this.getPoints();
              if (dom.isText(this.ec) && !dom.isEdgePoint(this.getEndPoint())) {
                this.ec.splitText(this.eo);
              }
              if (dom.isText(this.sc) && !dom.isEdgePoint(this.getStartPoint())) {
                boundaryPoints.sc = this.sc.splitText(this.so);
                boundaryPoints.so = 0;
                if (isSameContainer) {
                  boundaryPoints.ec = boundaryPoints.sc;
                  boundaryPoints.eo = this.eo - this.so;
                }
              }
              return new WrappedRange2(boundaryPoints.sc, boundaryPoints.so, boundaryPoints.ec, boundaryPoints.eo);
            }
            /**
             * delete contents on range
             * @return {WrappedRange}
             */
          }, {
            key: "deleteContents",
            value: function deleteContents() {
              if (this.isCollapsed()) {
                return this;
              }
              var rng = this.splitText();
              var nodes = rng.nodes(null, {
                fullyContains: true
              });
              var point = dom.prevPointUntil(rng.getStartPoint(), function(point2) {
                return !lists.contains(nodes, point2.node);
              });
              var emptyParents = [];
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(nodes, function(idx, node) {
                var parent = node.parentNode;
                if (point.node !== parent && dom.nodeLength(parent) === 1) {
                  emptyParents.push(parent);
                }
                dom.remove(node, false);
              });
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(emptyParents, function(idx, node) {
                dom.remove(node, false);
              });
              return new WrappedRange2(point.node, point.offset, point.node, point.offset).normalize();
            }
            /**
             * makeIsOn: return isOn(pred) function
             */
          }, {
            key: "makeIsOn",
            value: function makeIsOn(pred) {
              return function() {
                var ancestor2 = dom.ancestor(this.sc, pred);
                return !!ancestor2 && ancestor2 === dom.ancestor(this.ec, pred);
              };
            }
            /**
             * @param {Function} pred
             * @return {Boolean}
             */
          }, {
            key: "isLeftEdgeOf",
            value: function isLeftEdgeOf2(pred) {
              if (!dom.isLeftEdgePoint(this.getStartPoint())) {
                return false;
              }
              var node = dom.ancestor(this.sc, pred);
              return node && dom.isLeftEdgeOf(this.sc, node);
            }
            /**
             * returns whether range was collapsed or not
             */
          }, {
            key: "isCollapsed",
            value: function isCollapsed() {
              return this.sc === this.ec && this.so === this.eo;
            }
            /**
             * wrap inline nodes which children of body with paragraph
             *
             * @return {WrappedRange}
             */
          }, {
            key: "wrapBodyInlineWithPara",
            value: function wrapBodyInlineWithPara() {
              if (dom.isBodyContainer(this.sc) && dom.isEmpty(this.sc)) {
                this.sc.innerHTML = dom.emptyPara;
                return new WrappedRange2(this.sc.firstChild, 0, this.sc.firstChild, 0);
              }
              var rng = this.normalize();
              if (dom.isParaInline(this.sc) || dom.isPara(this.sc)) {
                return rng;
              }
              var topAncestor;
              if (dom.isInline(rng.sc)) {
                var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));
                topAncestor = lists.last(ancestors);
                if (!dom.isInline(topAncestor)) {
                  topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];
                }
              } else {
                topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];
              }
              if (topAncestor) {
                var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();
                inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));
                if (inlineSiblings.length) {
                  var para = dom.wrap(lists.head(inlineSiblings), "p");
                  dom.appendChildNodes(para, lists.tail(inlineSiblings));
                }
              }
              return this.normalize();
            }
            /**
             * insert node at current cursor
             *
             * @param {Node} node
             * @param {Boolean} doNotInsertPara - default is false, removes added <p> that's added if true
             * @return {Node}
             */
          }, {
            key: "insertNode",
            value: function insertNode(node) {
              var doNotInsertPara = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              var rng = this;
              if (dom.isText(node) || dom.isInline(node)) {
                rng = this.wrapBodyInlineWithPara().deleteContents();
              }
              var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));
              if (info.rightNode) {
                info.rightNode.parentNode.insertBefore(node, info.rightNode);
                if (dom.isEmpty(info.rightNode) && (doNotInsertPara || dom.isPara(node))) {
                  info.rightNode.parentNode.removeChild(info.rightNode);
                }
              } else {
                info.container.appendChild(node);
              }
              return node;
            }
            /**
             * insert html at current cursor
             */
          }, {
            key: "pasteHTML",
            value: function pasteHTML(markup) {
              markup = ((markup || "") + "").trim(markup);
              var contentsContainer = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<div></div>").html(markup)[0];
              var childNodes = lists.from(contentsContainer.childNodes);
              var rng = this;
              var reversed = false;
              if (rng.so >= 0) {
                childNodes = childNodes.reverse();
                reversed = true;
              }
              childNodes = childNodes.map(function(childNode) {
                return rng.insertNode(childNode, !dom.isInline(childNode));
              });
              if (reversed) {
                childNodes = childNodes.reverse();
              }
              return childNodes;
            }
            /**
             * returns text in range
             *
             * @return {String}
             */
          }, {
            key: "toString",
            value: function toString3() {
              var nativeRng = this.nativeRange();
              return env.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;
            }
            /**
             * returns range for word before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */
          }, {
            key: "getWordRange",
            value: function getWordRange(findAfter) {
              var endPoint = this.getEndPoint();
              if (!dom.isCharPoint(endPoint)) {
                return this;
              }
              var startPoint = dom.prevPointUntil(endPoint, function(point) {
                return !dom.isCharPoint(point);
              });
              if (findAfter) {
                endPoint = dom.nextPointUntil(endPoint, function(point) {
                  return !dom.isCharPoint(point);
                });
              }
              return new WrappedRange2(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns range for words before cursor
             *
             * @param {Boolean} [findAfter] - find after cursor, default: false
             * @return {WrappedRange}
             */
          }, {
            key: "getWordsRange",
            value: function getWordsRange(findAfter) {
              var endPoint = this.getEndPoint();
              var isNotTextPoint = function isNotTextPoint2(point) {
                return !dom.isCharPoint(point) && !dom.isSpacePoint(point);
              };
              if (isNotTextPoint(endPoint)) {
                return this;
              }
              var startPoint = dom.prevPointUntil(endPoint, isNotTextPoint);
              if (findAfter) {
                endPoint = dom.nextPointUntil(endPoint, isNotTextPoint);
              }
              return new WrappedRange2(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * returns range for words before cursor that match with a Regex
             *
             * example:
             *  range: 'hi @Peter Pan'
             *  regex: '/@[a-z ]+/i'
             *  return range: '@Peter Pan'
             *
             * @param {RegExp} [regex]
             * @return {WrappedRange|null}
             */
          }, {
            key: "getWordsMatchRange",
            value: function getWordsMatchRange(regex) {
              var endPoint = this.getEndPoint();
              var startPoint = dom.prevPointUntil(endPoint, function(point) {
                if (!dom.isCharPoint(point) && !dom.isSpacePoint(point)) {
                  return true;
                }
                var rng2 = new WrappedRange2(point.node, point.offset, endPoint.node, endPoint.offset);
                var result2 = regex.exec(rng2.toString());
                return result2 && result2.index === 0;
              });
              var rng = new WrappedRange2(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
              var text2 = rng.toString();
              var result = regex.exec(text2);
              if (result && result[0].length === text2.length) {
                return rng;
              } else {
                return null;
              }
            }
            /**
             * create offsetPath bookmark
             *
             * @param {Node} editable
             */
          }, {
            key: "bookmark",
            value: function bookmark(editable2) {
              return {
                s: {
                  path: dom.makeOffsetPath(editable2, this.sc),
                  offset: this.so
                },
                e: {
                  path: dom.makeOffsetPath(editable2, this.ec),
                  offset: this.eo
                }
              };
            }
            /**
             * create offsetPath bookmark base on paragraph
             *
             * @param {Node[]} paras
             */
          }, {
            key: "paraBookmark",
            value: function paraBookmark(paras) {
              return {
                s: {
                  path: lists.tail(dom.makeOffsetPath(lists.head(paras), this.sc)),
                  offset: this.so
                },
                e: {
                  path: lists.tail(dom.makeOffsetPath(lists.last(paras), this.ec)),
                  offset: this.eo
                }
              };
            }
            /**
             * getClientRects
             * @return {Rect[]}
             */
          }, {
            key: "getClientRects",
            value: function getClientRects() {
              var nativeRng = this.nativeRange();
              return nativeRng.getClientRects();
            }
          }]);
        }();
        const range = {
          /**
           * create Range Object From arguments or Browser Selection
           *
           * @param {Node} sc - start container
           * @param {Number} so - start offset
           * @param {Node} ec - end container
           * @param {Number} eo - end offset
           * @return {WrappedRange}
           */
          create: function create3(sc, so, ec, eo) {
            if (arguments.length === 4) {
              return new WrappedRange(sc, so, ec, eo);
            } else if (arguments.length === 2) {
              ec = sc;
              eo = so;
              return new WrappedRange(sc, so, ec, eo);
            } else {
              var wrappedRange = this.createFromSelection();
              if (!wrappedRange && arguments.length === 1) {
                var bodyElement = arguments[0];
                if (dom.isEditable(bodyElement)) {
                  bodyElement = bodyElement.lastChild;
                }
                return this.createFromBodyElement(bodyElement, dom.emptyPara === arguments[0].innerHTML);
              }
              return wrappedRange;
            }
          },
          createFromBodyElement: function createFromBodyElement(bodyElement) {
            var isCollapseToStart = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
            var wrappedRange = this.createFromNode(bodyElement);
            return wrappedRange.collapse(isCollapseToStart);
          },
          createFromSelection: function createFromSelection() {
            var sc, so, ec, eo;
            if (env.isW3CRangeSupport) {
              var selection = document.getSelection();
              if (!selection || selection.rangeCount === 0) {
                return null;
              } else if (dom.isBody(selection.anchorNode)) {
                return null;
              }
              var nativeRng = selection.getRangeAt(0);
              sc = nativeRng.startContainer;
              so = nativeRng.startOffset;
              ec = nativeRng.endContainer;
              eo = nativeRng.endOffset;
            } else {
              var textRange = document.selection.createRange();
              var textRangeEnd = textRange.duplicate();
              textRangeEnd.collapse(false);
              var textRangeStart = textRange;
              textRangeStart.collapse(true);
              var startPoint = textRangeToPoint(textRangeStart, true);
              var endPoint = textRangeToPoint(textRangeEnd, false);
              if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) && dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) && endPoint.node.nextSibling === startPoint.node) {
                startPoint = endPoint;
              }
              sc = startPoint.cont;
              so = startPoint.offset;
              ec = endPoint.cont;
              eo = endPoint.offset;
            }
            return new WrappedRange(sc, so, ec, eo);
          },
          /**
           * @method
           *
           * create WrappedRange from node
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNode: function createFromNode(node) {
            var sc = node;
            var so = 0;
            var ec = node;
            var eo = dom.nodeLength(ec);
            if (dom.isVoid(sc)) {
              so = dom.listPrev(sc).length - 1;
              sc = sc.parentNode;
            }
            if (dom.isBR(ec)) {
              eo = dom.listPrev(ec).length - 1;
              ec = ec.parentNode;
            } else if (dom.isVoid(ec)) {
              eo = dom.listPrev(ec).length;
              ec = ec.parentNode;
            }
            return this.create(sc, so, ec, eo);
          },
          /**
           * create WrappedRange from node after position
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNodeBefore: function createFromNodeBefore(node) {
            return this.createFromNode(node).collapse(true);
          },
          /**
           * create WrappedRange from node after position
           *
           * @param {Node} node
           * @return {WrappedRange}
           */
          createFromNodeAfter: function createFromNodeAfter(node) {
            return this.createFromNode(node).collapse();
          },
          /**
           * @method
           *
           * create WrappedRange from bookmark
           *
           * @param {Node} editable
           * @param {Object} bookmark
           * @return {WrappedRange}
           */
          createFromBookmark: function createFromBookmark(editable2, bookmark) {
            var sc = dom.fromOffsetPath(editable2, bookmark.s.path);
            var so = bookmark.s.offset;
            var ec = dom.fromOffsetPath(editable2, bookmark.e.path);
            var eo = bookmark.e.offset;
            return new WrappedRange(sc, so, ec, eo);
          },
          /**
           * @method
           *
           * create WrappedRange from paraBookmark
           *
           * @param {Object} bookmark
           * @param {Node[]} paras
           * @return {WrappedRange}
           */
          createFromParaBookmark: function createFromParaBookmark(bookmark, paras) {
            var so = bookmark.s.offset;
            var eo = bookmark.e.offset;
            var sc = dom.fromOffsetPath(lists.head(paras), bookmark.s.path);
            var ec = dom.fromOffsetPath(lists.last(paras), bookmark.e.path);
            return new WrappedRange(sc, so, ec, eo);
          }
        };
        var KEY_MAP = {
          "BACKSPACE": 8,
          "TAB": 9,
          "ENTER": 13,
          "ESCAPE": 27,
          "SPACE": 32,
          "DELETE": 46,
          // Arrow
          "LEFT": 37,
          "UP": 38,
          "RIGHT": 39,
          "DOWN": 40,
          // Number: 0-9
          "NUM0": 48,
          "NUM1": 49,
          "NUM2": 50,
          "NUM3": 51,
          "NUM4": 52,
          "NUM5": 53,
          "NUM6": 54,
          "NUM7": 55,
          "NUM8": 56,
          // Alphabet: a-z
          "B": 66,
          "E": 69,
          "I": 73,
          "J": 74,
          "K": 75,
          "L": 76,
          "R": 82,
          "S": 83,
          "U": 85,
          "V": 86,
          "Y": 89,
          "Z": 90,
          "SLASH": 191,
          "LEFTBRACKET": 219,
          "BACKSLASH": 220,
          "RIGHTBRACKET": 221,
          // Navigation
          "HOME": 36,
          "END": 35,
          "PAGEUP": 33,
          "PAGEDOWN": 34
        };
        const key = {
          /**
           * @method isEdit
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isEdit: function isEdit(keyCode) {
            return lists.contains([KEY_MAP.BACKSPACE, KEY_MAP.TAB, KEY_MAP.ENTER, KEY_MAP.SPACE, KEY_MAP.DELETE], keyCode);
          },
          /**
           * @method isRemove
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isRemove: function isRemove(keyCode) {
            return lists.contains([KEY_MAP.BACKSPACE, KEY_MAP.DELETE], keyCode);
          },
          /**
           * @method isMove
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isMove: function isMove(keyCode) {
            return lists.contains([KEY_MAP.LEFT, KEY_MAP.UP, KEY_MAP.RIGHT, KEY_MAP.DOWN], keyCode);
          },
          /**
           * @method isNavigation
           *
           * @param {Number} keyCode
           * @return {Boolean}
           */
          isNavigation: function isNavigation(keyCode) {
            return lists.contains([KEY_MAP.HOME, KEY_MAP.END, KEY_MAP.PAGEUP, KEY_MAP.PAGEDOWN], keyCode);
          },
          /**
           * @property {Object} nameFromCode
           * @property {String} nameFromCode.8 "BACKSPACE"
           */
          nameFromCode: func.invertObject(KEY_MAP),
          code: KEY_MAP
        };
        function readFileAsDataURL(file2) {
          return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
            external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(new FileReader(), {
              onload: function onload(event) {
                var dataURL = event.target.result;
                deferred.resolve(dataURL);
              },
              onerror: function onerror(err) {
                deferred.reject(err);
              }
            }).readAsDataURL(file2);
          }).promise();
        }
        function createImage(url) {
          return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
            var $img = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<img>");
            $img.one("load", function() {
              $img.off("error abort");
              deferred.resolve($img);
            }).one("error abort", function() {
              $img.off("load").detach();
              deferred.reject($img);
            }).css({
              display: "none"
            }).appendTo(document.body).attr("src", url);
          }).promise();
        }
        function History_typeof(o2) {
          "@babel/helpers - typeof";
          return History_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, History_typeof(o2);
        }
        function History_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function History_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, History_toPropertyKey(o2.key), o2);
          }
        }
        function History_createClass(e2, r2, t2) {
          return r2 && History_defineProperties(e2.prototype, r2), t2 && History_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function History_toPropertyKey(t2) {
          var i = History_toPrimitive(t2, "string");
          return "symbol" == History_typeof(i) ? i : i + "";
        }
        function History_toPrimitive(t2, r2) {
          if ("object" != History_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != History_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var History = /* @__PURE__ */ function() {
          function History2(context) {
            History_classCallCheck(this, History2);
            this.stack = [];
            this.stackOffset = -1;
            this.context = context;
            this.$editable = context.layoutInfo.editable;
            this.editable = this.$editable[0];
          }
          return History_createClass(History2, [{
            key: "makeSnapshot",
            value: function makeSnapshot() {
              var rng = range.create(this.editable);
              var emptyBookmark = {
                s: {
                  path: [],
                  offset: 0
                },
                e: {
                  path: [],
                  offset: 0
                }
              };
              return {
                contents: this.$editable.html(),
                bookmark: rng && rng.isOnEditable() ? rng.bookmark(this.editable) : emptyBookmark
              };
            }
          }, {
            key: "applySnapshot",
            value: function applySnapshot(snapshot) {
              if (snapshot.contents !== null) {
                this.$editable.html(snapshot.contents);
              }
              if (snapshot.bookmark !== null) {
                range.createFromBookmark(this.editable, snapshot.bookmark).select();
              }
            }
            /**
            * @method rewind
            * Rewinds the history stack back to the first snapshot taken.
            * Leaves the stack intact, so that "Redo" can still be used.
            */
          }, {
            key: "rewind",
            value: function rewind() {
              if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
              }
              this.stackOffset = 0;
              this.applySnapshot(this.stack[this.stackOffset]);
            }
            /**
            *  @method commit
            *  Resets history stack, but keeps current editor's content.
            */
          }, {
            key: "commit",
            value: function commit() {
              this.stack = [];
              this.stackOffset = -1;
              this.recordUndo();
            }
            /**
            * @method reset
            * Resets the history stack completely; reverting to an empty editor.
            */
          }, {
            key: "reset",
            value: function reset() {
              this.stack = [];
              this.stackOffset = -1;
              this.$editable.html("");
              this.recordUndo();
            }
            /**
             * undo
             */
          }, {
            key: "undo",
            value: function undo() {
              if (this.$editable.html() !== this.stack[this.stackOffset].contents) {
                this.recordUndo();
              }
              if (this.stackOffset > 0) {
                this.stackOffset--;
                this.applySnapshot(this.stack[this.stackOffset]);
              }
            }
            /**
             * redo
             */
          }, {
            key: "redo",
            value: function redo() {
              if (this.stack.length - 1 > this.stackOffset) {
                this.stackOffset++;
                this.applySnapshot(this.stack[this.stackOffset]);
              }
            }
            /**
             * recorded undo
             */
          }, {
            key: "recordUndo",
            value: function recordUndo() {
              this.stackOffset++;
              if (this.stack.length > this.stackOffset) {
                this.stack = this.stack.slice(0, this.stackOffset);
              }
              this.stack.push(this.makeSnapshot());
              if (this.stack.length > this.context.options.historyLimit) {
                this.stack.shift();
                this.stackOffset -= 1;
              }
            }
          }]);
        }();
        function Style_typeof(o2) {
          "@babel/helpers - typeof";
          return Style_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Style_typeof(o2);
        }
        function Style_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Style_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Style_toPropertyKey(o2.key), o2);
          }
        }
        function Style_createClass(e2, r2, t2) {
          return r2 && Style_defineProperties(e2.prototype, r2), t2 && Style_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Style_toPropertyKey(t2) {
          var i = Style_toPrimitive(t2, "string");
          return "symbol" == Style_typeof(i) ? i : i + "";
        }
        function Style_toPrimitive(t2, r2) {
          if ("object" != Style_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Style_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Style = /* @__PURE__ */ function() {
          function Style2() {
            Style_classCallCheck(this, Style2);
          }
          return Style_createClass(Style2, [{
            key: "jQueryCSS",
            value: (
              /**
               * @method jQueryCSS
               *
               * [workaround] for old jQuery
               * passing an array of style properties to .css()
               * will result in an object of property-value pairs.
               * (compability with version < 1.9)
               *
               * @private
               * @param  {jQuery} $obj
               * @param  {Array} propertyNames - An array of one or more CSS properties.
               * @return {Object}
               */
              function jQueryCSS($obj, propertyNames) {
                var result = {};
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(propertyNames, function(idx, propertyName) {
                  result[propertyName] = $obj.css(propertyName);
                });
                return result;
              }
            )
            /**
             * returns style object from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */
          }, {
            key: "fromNode",
            value: function fromNode($node) {
              var properties = ["font-family", "font-size", "text-align", "list-style-type", "line-height"];
              var styleInfo = this.jQueryCSS($node, properties) || {};
              var fontSize = $node[0].style.fontSize || styleInfo["font-size"];
              styleInfo["font-size"] = parseInt(fontSize, 10);
              styleInfo["font-size-unit"] = fontSize.match(/[a-z%]+$/);
              return styleInfo;
            }
            /**
             * paragraph level style
             *
             * @param {WrappedRange} rng
             * @param {Object} styleInfo
             */
          }, {
            key: "stylePara",
            value: function stylePara(rng, styleInfo) {
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(rng.nodes(dom.isPara, {
                includeAncestor: true
              }), function(idx, para) {
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(para).css(styleInfo);
              });
            }
            /**
             * insert and returns styleNodes on range.
             *
             * @param {WrappedRange} rng
             * @param {Object} [options] - options for styleNodes
             * @param {String} [options.nodeName] - default: `SPAN`
             * @param {Boolean} [options.expandClosestSibling] - default: `false`
             * @param {Boolean} [options.onlyPartialContains] - default: `false`
             * @return {Node[]}
             */
          }, {
            key: "styleNodes",
            value: function styleNodes(rng, options) {
              rng = rng.splitText();
              var nodeName = options && options.nodeName || "SPAN";
              var expandClosestSibling = !!(options && options.expandClosestSibling);
              var onlyPartialContains = !!(options && options.onlyPartialContains);
              if (rng.isCollapsed()) {
                return [rng.insertNode(dom.create(nodeName))];
              }
              var pred = dom.makePredByNodeName(nodeName);
              var nodes = rng.nodes(dom.isText, {
                fullyContains: true
              }).map(function(text2) {
                return dom.singleChildAncestor(text2, pred) || dom.wrap(text2, nodeName);
              });
              if (expandClosestSibling) {
                if (onlyPartialContains) {
                  var nodesInRange = rng.nodes();
                  pred = func.and(pred, function(node) {
                    return lists.contains(nodesInRange, node);
                  });
                }
                return nodes.map(function(node) {
                  var siblings = dom.withClosestSiblings(node, pred);
                  var head2 = lists.head(siblings);
                  var tails = lists.tail(siblings);
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(tails, function(idx, elem) {
                    dom.appendChildNodes(head2, elem.childNodes);
                    dom.remove(elem);
                  });
                  return lists.head(siblings);
                });
              } else {
                return nodes;
              }
            }
            /**
             * get current style on cursor
             *
             * @param {WrappedRange} rng
             * @return {Object} - object contains style properties.
             */
          }, {
            key: "current",
            value: function current(rng) {
              var $cont = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);
              var styleInfo = this.fromNode($cont);
              try {
                styleInfo = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(styleInfo, {
                  "font-bold": document.queryCommandState("bold") ? "bold" : "normal",
                  "font-italic": document.queryCommandState("italic") ? "italic" : "normal",
                  "font-underline": document.queryCommandState("underline") ? "underline" : "normal",
                  "font-subscript": document.queryCommandState("subscript") ? "subscript" : "normal",
                  "font-superscript": document.queryCommandState("superscript") ? "superscript" : "normal",
                  "font-strikethrough": document.queryCommandState("strikethrough") ? "strikethrough" : "normal",
                  "font-family": document.queryCommandValue("fontname") || styleInfo["font-family"]
                });
              } catch (e2) {
              }
              if (!rng.isOnList()) {
                styleInfo["list-style"] = "none";
              } else {
                var orderedTypes = ["circle", "disc", "disc-leading-zero", "square"];
                var isUnordered = orderedTypes.indexOf(styleInfo["list-style-type"]) > -1;
                styleInfo["list-style"] = isUnordered ? "unordered" : "ordered";
              }
              var para = dom.ancestor(rng.sc, dom.isPara);
              if (para && para.style["line-height"]) {
                styleInfo["line-height"] = para.style.lineHeight;
              } else {
                var lineHeight = parseInt(styleInfo["line-height"], 10) / parseInt(styleInfo["font-size"], 10);
                styleInfo["line-height"] = lineHeight.toFixed(1);
              }
              styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);
              styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);
              styleInfo.range = rng;
              return styleInfo;
            }
          }]);
        }();
        function Bullet_typeof(o2) {
          "@babel/helpers - typeof";
          return Bullet_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Bullet_typeof(o2);
        }
        function Bullet_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Bullet_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Bullet_toPropertyKey(o2.key), o2);
          }
        }
        function Bullet_createClass(e2, r2, t2) {
          return r2 && Bullet_defineProperties(e2.prototype, r2), t2 && Bullet_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Bullet_toPropertyKey(t2) {
          var i = Bullet_toPrimitive(t2, "string");
          return "symbol" == Bullet_typeof(i) ? i : i + "";
        }
        function Bullet_toPrimitive(t2, r2) {
          if ("object" != Bullet_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Bullet_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Bullet = /* @__PURE__ */ function() {
          function Bullet2() {
            Bullet_classCallCheck(this, Bullet2);
          }
          return Bullet_createClass(Bullet2, [{
            key: "insertOrderedList",
            value: (
              /**
               * toggle ordered list
               */
              function insertOrderedList(editable2) {
                this.toggleList("OL", editable2);
              }
            )
            /**
             * toggle unordered list
             */
          }, {
            key: "insertUnorderedList",
            value: function insertUnorderedList(editable2) {
              this.toggleList("UL", editable2);
            }
            /**
             * indent
             */
          }, {
            key: "indent",
            value: function indent(editable2) {
              var _this = this;
              var rng = range.create(editable2).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var clustereds = lists.clusterBy(paras, func.peq2("parentNode"));
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(clustereds, function(idx, paras2) {
                var head2 = lists.head(paras2);
                if (dom.isLi(head2)) {
                  var previousList = _this.findList(head2.previousSibling);
                  if (previousList) {
                    paras2.map(function(para) {
                      return previousList.appendChild(para);
                    });
                  } else {
                    _this.wrapList(paras2, head2.parentNode.nodeName);
                    paras2.map(function(para) {
                      return para.parentNode;
                    }).map(function(para) {
                      return _this.appendToPrevious(para);
                    });
                  }
                } else {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(paras2, function(idx2, para) {
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(para).css("marginLeft", function(idx3, val) {
                      return (parseInt(val, 10) || 0) + 25;
                    });
                  });
                }
              });
              rng.select();
            }
            /**
             * outdent
             */
          }, {
            key: "outdent",
            value: function outdent(editable2) {
              var _this2 = this;
              var rng = range.create(editable2).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var clustereds = lists.clusterBy(paras, func.peq2("parentNode"));
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(clustereds, function(idx, paras2) {
                var head2 = lists.head(paras2);
                if (dom.isLi(head2)) {
                  _this2.releaseList([paras2]);
                } else {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(paras2, function(idx2, para) {
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(para).css("marginLeft", function(idx3, val) {
                      val = parseInt(val, 10) || 0;
                      return val > 25 ? val - 25 : "";
                    });
                  });
                }
              });
              rng.select();
            }
            /**
             * toggle list
             *
             * @param {String} listName - OL or UL
             */
          }, {
            key: "toggleList",
            value: function toggleList(listName, editable2) {
              var _this3 = this;
              var rng = range.create(editable2).wrapBodyInlineWithPara();
              var paras = rng.nodes(dom.isPara, {
                includeAncestor: true
              });
              var bookmark = rng.paraBookmark(paras);
              var clustereds = lists.clusterBy(paras, func.peq2("parentNode"));
              if (lists.find(paras, dom.isPurePara)) {
                var wrappedParas = [];
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(clustereds, function(idx, paras2) {
                  wrappedParas = wrappedParas.concat(_this3.wrapList(paras2, listName));
                });
                paras = wrappedParas;
              } else {
                var diffLists = rng.nodes(dom.isList, {
                  includeAncestor: true
                }).filter(function(listNode) {
                  return !external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().nodeName(listNode, listName);
                });
                if (diffLists.length) {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(diffLists, function(idx, listNode) {
                    dom.replace(listNode, listName);
                  });
                } else {
                  paras = this.releaseList(clustereds, true);
                }
              }
              range.createFromParaBookmark(bookmark, paras).select();
            }
            /**
             * @param {Node[]} paras
             * @param {String} listName
             * @return {Node[]}
             */
          }, {
            key: "wrapList",
            value: function wrapList(paras, listName) {
              var head2 = lists.head(paras);
              var last2 = lists.last(paras);
              var prevList = dom.isList(head2.previousSibling) && head2.previousSibling;
              var nextList = dom.isList(last2.nextSibling) && last2.nextSibling;
              var listNode = prevList || dom.insertAfter(dom.create(listName || "UL"), last2);
              paras = paras.map(function(para) {
                return dom.isPurePara(para) ? dom.replace(para, "LI") : para;
              });
              dom.appendChildNodes(listNode, paras, true);
              if (nextList) {
                dom.appendChildNodes(listNode, lists.from(nextList.childNodes), true);
                dom.remove(nextList);
              }
              return paras;
            }
            /**
             * @method releaseList
             *
             * @param {Array[]} clustereds
             * @param {Boolean} isEscapseToBody
             * @return {Node[]}
             */
          }, {
            key: "releaseList",
            value: function releaseList(clustereds, isEscapseToBody) {
              var _this4 = this;
              var releasedParas = [];
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(clustereds, function(idx, paras) {
                var head2 = lists.head(paras);
                var last2 = lists.last(paras);
                var headList = isEscapseToBody ? dom.lastAncestor(head2, dom.isList) : head2.parentNode;
                var parentItem = headList.parentNode;
                if (headList.parentNode.nodeName === "LI") {
                  paras.map(function(para) {
                    var newList = _this4.findNextSiblings(para);
                    if (parentItem.nextSibling) {
                      parentItem.parentNode.insertBefore(para, parentItem.nextSibling);
                    } else {
                      parentItem.parentNode.appendChild(para);
                    }
                    if (newList.length) {
                      _this4.wrapList(newList, headList.nodeName);
                      para.appendChild(newList[0].parentNode);
                    }
                  });
                  if (headList.children.length === 0) {
                    parentItem.removeChild(headList);
                  }
                  if (parentItem.childNodes.length === 0) {
                    parentItem.parentNode.removeChild(parentItem);
                  }
                } else {
                  var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {
                    node: last2.parentNode,
                    offset: dom.position(last2) + 1
                  }, {
                    isSkipPaddingBlankHTML: true
                  }) : null;
                  var middleList = dom.splitTree(headList, {
                    node: head2.parentNode,
                    offset: dom.position(head2)
                  }, {
                    isSkipPaddingBlankHTML: true
                  });
                  paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) : lists.from(middleList.childNodes).filter(dom.isLi);
                  if (isEscapseToBody || !dom.isList(headList.parentNode)) {
                    paras = paras.map(function(para) {
                      return dom.replace(para, "P");
                    });
                  }
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(lists.from(paras).reverse(), function(idx2, para) {
                    dom.insertAfter(para, headList);
                  });
                  var rootLists = lists.compact([headList, middleList, lastList]);
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(rootLists, function(idx2, rootList) {
                    var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(listNodes.reverse(), function(idx3, listNode) {
                      if (!dom.nodeLength(listNode)) {
                        dom.remove(listNode, true);
                      }
                    });
                  });
                }
                releasedParas = releasedParas.concat(paras);
              });
              return releasedParas;
            }
            /**
             * @method appendToPrevious
             *
             * Appends list to previous list item, if
             * none exist it wraps the list in a new list item.
             *
             * @param {HTMLNode} ListItem
             * @return {HTMLNode}
             */
          }, {
            key: "appendToPrevious",
            value: function appendToPrevious(node) {
              return node.previousSibling ? dom.appendChildNodes(node.previousSibling, [node]) : this.wrapList([node], "LI");
            }
            /**
             * @method findList
             *
             * Finds an existing list in list item
             *
             * @param {HTMLNode} ListItem
             * @return {Array[]}
             */
          }, {
            key: "findList",
            value: function findList(node) {
              return node ? lists.find(node.children, function(child) {
                return ["OL", "UL"].indexOf(child.nodeName) > -1;
              }) : null;
            }
            /**
             * @method findNextSiblings
             *
             * Finds all list item siblings that follow it
             *
             * @param {HTMLNode} ListItem
             * @return {HTMLNode}
             */
          }, {
            key: "findNextSiblings",
            value: function findNextSiblings(node) {
              var siblings = [];
              while (node.nextSibling) {
                siblings.push(node.nextSibling);
                node = node.nextSibling;
              }
              return siblings;
            }
          }]);
        }();
        function Typing_typeof(o2) {
          "@babel/helpers - typeof";
          return Typing_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Typing_typeof(o2);
        }
        function Typing_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Typing_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Typing_toPropertyKey(o2.key), o2);
          }
        }
        function Typing_createClass(e2, r2, t2) {
          return r2 && Typing_defineProperties(e2.prototype, r2), t2 && Typing_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Typing_toPropertyKey(t2) {
          var i = Typing_toPrimitive(t2, "string");
          return "symbol" == Typing_typeof(i) ? i : i + "";
        }
        function Typing_toPrimitive(t2, r2) {
          if ("object" != Typing_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Typing_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Typing = /* @__PURE__ */ function() {
          function Typing2(context) {
            Typing_classCallCheck(this, Typing2);
            this.bullet = new Bullet();
            this.options = context.options;
          }
          return Typing_createClass(Typing2, [{
            key: "insertTab",
            value: function insertTab(rng, tabsize) {
              var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));
              rng = rng.deleteContents();
              rng.insertNode(tab, true);
              rng = range.create(tab, tabsize);
              rng.select();
            }
            /**
             * insert paragraph
             *
             * @param {jQuery} $editable
             * @param {WrappedRange} rng Can be used in unit tests to "mock" the range
             *
             * blockquoteBreakingLevel
             *   0 - No break, the new paragraph remains inside the quote
             *   1 - Break the first blockquote in the ancestors list
             *   2 - Break all blockquotes, so that the new paragraph is not quoted (this is the default)
             */
          }, {
            key: "insertParagraph",
            value: function insertParagraph(editable2, rng) {
              rng = rng || range.create(editable2);
              rng = rng.deleteContents();
              rng = rng.wrapBodyInlineWithPara();
              var splitRoot = dom.ancestor(rng.sc, dom.isPara);
              var nextPara;
              if (splitRoot) {
                if (dom.isLi(splitRoot) && (dom.isEmpty(splitRoot) || dom.deepestChildIsEmpty(splitRoot))) {
                  this.bullet.toggleList(splitRoot.parentNode.nodeName);
                  return;
                } else {
                  var blockquote = null;
                  if (this.options.blockquoteBreakingLevel === 1) {
                    blockquote = dom.ancestor(splitRoot, dom.isBlockquote);
                  } else if (this.options.blockquoteBreakingLevel === 2) {
                    blockquote = dom.lastAncestor(splitRoot, dom.isBlockquote);
                  }
                  if (blockquote) {
                    nextPara = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(dom.emptyPara)[0];
                    if (dom.isRightEdgePoint(rng.getStartPoint()) && dom.isBR(rng.sc.nextSibling)) {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(rng.sc.nextSibling).remove();
                    }
                    var split = dom.splitTree(blockquote, rng.getStartPoint(), {
                      isDiscardEmptySplits: true
                    });
                    if (split) {
                      split.parentNode.insertBefore(nextPara, split);
                    } else {
                      dom.insertAfter(nextPara, blockquote);
                    }
                  } else {
                    nextPara = dom.splitTree(splitRoot, rng.getStartPoint());
                    var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);
                    emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(emptyAnchors, function(idx, anchor) {
                      dom.remove(anchor);
                    });
                    if ((dom.isHeading(nextPara) || dom.isPre(nextPara) || dom.isCustomStyleTag(nextPara)) && dom.isEmpty(nextPara)) {
                      nextPara = dom.replace(nextPara, "p");
                    }
                  }
                }
              } else {
                var next2 = rng.sc.childNodes[rng.so];
                nextPara = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(dom.emptyPara)[0];
                if (next2) {
                  rng.sc.insertBefore(nextPara, next2);
                } else {
                  rng.sc.appendChild(nextPara);
                }
              }
              range.create(nextPara, 0).normalize().select().scrollIntoView(editable2);
            }
          }]);
        }();
        function Table_typeof(o2) {
          "@babel/helpers - typeof";
          return Table_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Table_typeof(o2);
        }
        function Table_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Table_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Table_toPropertyKey(o2.key), o2);
          }
        }
        function Table_createClass(e2, r2, t2) {
          return r2 && Table_defineProperties(e2.prototype, r2), t2 && Table_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Table_toPropertyKey(t2) {
          var i = Table_toPrimitive(t2, "string");
          return "symbol" == Table_typeof(i) ? i : i + "";
        }
        function Table_toPrimitive(t2, r2) {
          if ("object" != Table_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Table_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var TableResultAction = function TableResultAction2(startPoint, where, action, domTable) {
          var _startPoint = {
            "colPos": 0,
            "rowPos": 0
          };
          var _virtualTable = [];
          var _actionCellList = [];
          function setStartPoint() {
            if (!startPoint || !startPoint.tagName || startPoint.tagName.toLowerCase() !== "td" && startPoint.tagName.toLowerCase() !== "th") {
              return;
            }
            _startPoint.colPos = startPoint.cellIndex;
            if (!startPoint.parentElement || !startPoint.parentElement.tagName || startPoint.parentElement.tagName.toLowerCase() !== "tr") {
              return;
            }
            _startPoint.rowPos = startPoint.parentElement.rowIndex;
          }
          function setVirtualTablePosition(rowIndex, cellIndex, baseRow, baseCell, isRowSpan, isColSpan, isVirtualCell) {
            var objPosition = {
              "baseRow": baseRow,
              "baseCell": baseCell,
              "isRowSpan": isRowSpan,
              "isColSpan": isColSpan,
              "isVirtual": isVirtualCell
            };
            if (!_virtualTable[rowIndex]) {
              _virtualTable[rowIndex] = [];
            }
            _virtualTable[rowIndex][cellIndex] = objPosition;
          }
          function getActionCell(virtualTableCellObj, resultAction, virtualRowPosition, virtualColPosition) {
            return {
              "baseCell": virtualTableCellObj.baseCell,
              "action": resultAction,
              "virtualTable": {
                "rowIndex": virtualRowPosition,
                "cellIndex": virtualColPosition
              }
            };
          }
          function recoverCellIndex(rowIndex, cellIndex) {
            if (!_virtualTable[rowIndex]) {
              return cellIndex;
            }
            if (!_virtualTable[rowIndex][cellIndex]) {
              return cellIndex;
            }
            var newCellIndex = cellIndex;
            while (_virtualTable[rowIndex][newCellIndex]) {
              newCellIndex++;
              if (!_virtualTable[rowIndex][newCellIndex]) {
                return newCellIndex;
              }
            }
          }
          function addCellInfoToVirtual(row, cell) {
            var cellIndex = recoverCellIndex(row.rowIndex, cell.cellIndex);
            var cellHasColspan = cell.colSpan > 1;
            var cellHasRowspan = cell.rowSpan > 1;
            var isThisSelectedCell = row.rowIndex === _startPoint.rowPos && cell.cellIndex === _startPoint.colPos;
            setVirtualTablePosition(row.rowIndex, cellIndex, row, cell, cellHasRowspan, cellHasColspan, false);
            var rowspanNumber = cell.attributes.rowSpan ? parseInt(cell.attributes.rowSpan.value, 10) : 0;
            if (rowspanNumber > 1) {
              for (var rp = 1; rp < rowspanNumber; rp++) {
                var rowspanIndex = row.rowIndex + rp;
                adjustStartPoint(rowspanIndex, cellIndex, cell, isThisSelectedCell);
                setVirtualTablePosition(rowspanIndex, cellIndex, row, cell, true, cellHasColspan, true);
              }
            }
            var colspanNumber = cell.attributes.colSpan ? parseInt(cell.attributes.colSpan.value, 10) : 0;
            if (colspanNumber > 1) {
              for (var cp = 1; cp < colspanNumber; cp++) {
                var cellspanIndex = recoverCellIndex(row.rowIndex, cellIndex + cp);
                adjustStartPoint(row.rowIndex, cellspanIndex, cell, isThisSelectedCell);
                setVirtualTablePosition(row.rowIndex, cellspanIndex, row, cell, cellHasRowspan, true, true);
              }
            }
          }
          function adjustStartPoint(rowIndex, cellIndex, cell, isSelectedCell) {
            if (rowIndex === _startPoint.rowPos && _startPoint.colPos >= cell.cellIndex && cell.cellIndex <= cellIndex && !isSelectedCell) {
              _startPoint.colPos++;
            }
          }
          function createVirtualTable() {
            var rows = domTable.rows;
            for (var rowIndex = 0; rowIndex < rows.length; rowIndex++) {
              var cells = rows[rowIndex].cells;
              for (var cellIndex = 0; cellIndex < cells.length; cellIndex++) {
                addCellInfoToVirtual(rows[rowIndex], cells[cellIndex]);
              }
            }
          }
          function getDeleteResultActionToCell(cell) {
            switch (where) {
              case TableResultAction2.where.Column:
                if (cell.isColSpan) {
                  return TableResultAction2.resultAction.SubtractSpanCount;
                }
                break;
              case TableResultAction2.where.Row:
                if (!cell.isVirtual && cell.isRowSpan) {
                  return TableResultAction2.resultAction.AddCell;
                } else if (cell.isRowSpan) {
                  return TableResultAction2.resultAction.SubtractSpanCount;
                }
                break;
            }
            return TableResultAction2.resultAction.RemoveCell;
          }
          function getAddResultActionToCell(cell) {
            switch (where) {
              case TableResultAction2.where.Column:
                if (cell.isColSpan) {
                  return TableResultAction2.resultAction.SumSpanCount;
                } else if (cell.isRowSpan && cell.isVirtual) {
                  return TableResultAction2.resultAction.Ignore;
                }
                break;
              case TableResultAction2.where.Row:
                if (cell.isRowSpan) {
                  return TableResultAction2.resultAction.SumSpanCount;
                } else if (cell.isColSpan && cell.isVirtual) {
                  return TableResultAction2.resultAction.Ignore;
                }
                break;
            }
            return TableResultAction2.resultAction.AddCell;
          }
          function init2() {
            setStartPoint();
            createVirtualTable();
          }
          this.getActionList = function() {
            var fixedRow = where === TableResultAction2.where.Row ? _startPoint.rowPos : -1;
            var fixedCol = where === TableResultAction2.where.Column ? _startPoint.colPos : -1;
            var actualPosition = 0;
            var canContinue = true;
            while (canContinue) {
              var rowPosition = fixedRow >= 0 ? fixedRow : actualPosition;
              var colPosition = fixedCol >= 0 ? fixedCol : actualPosition;
              var row = _virtualTable[rowPosition];
              if (!row) {
                canContinue = false;
                return _actionCellList;
              }
              var cell = row[colPosition];
              if (!cell) {
                canContinue = false;
                return _actionCellList;
              }
              var resultAction = TableResultAction2.resultAction.Ignore;
              switch (action) {
                case TableResultAction2.requestAction.Add:
                  resultAction = getAddResultActionToCell(cell);
                  break;
                case TableResultAction2.requestAction.Delete:
                  resultAction = getDeleteResultActionToCell(cell);
                  break;
              }
              _actionCellList.push(getActionCell(cell, resultAction, rowPosition, colPosition));
              actualPosition++;
            }
            return _actionCellList;
          };
          init2();
        };
        TableResultAction.where = {
          "Row": 0,
          "Column": 1
        };
        TableResultAction.requestAction = {
          "Add": 0,
          "Delete": 1
        };
        TableResultAction.resultAction = {
          "Ignore": 0,
          "SubtractSpanCount": 1,
          "RemoveCell": 2,
          "AddCell": 3,
          "SumSpanCount": 4
        };
        var Table = /* @__PURE__ */ function() {
          function Table2() {
            Table_classCallCheck(this, Table2);
          }
          return Table_createClass(Table2, [{
            key: "tab",
            value: (
              /**
               * handle tab key
               *
               * @param {WrappedRange} rng
               * @param {Boolean} isShift
               */
              function tab(rng, isShift) {
                var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
                var table = dom.ancestor(cell, dom.isTable);
                var cells = dom.listDescendant(table, dom.isCell);
                var nextCell = lists[isShift ? "prev" : "next"](cells, cell);
                if (nextCell) {
                  range.create(nextCell, 0).select();
                }
              }
            )
            /**
             * Add a new row
             *
             * @param {WrappedRange} rng
             * @param {String} position (top/bottom)
             * @return {Node}
             */
          }, {
            key: "addRow",
            value: function addRow(rng, position2) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var currentTr = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell).closest("tr");
              var trAttributes = this.recoverAttributes(currentTr);
              var html2 = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<tr" + trAttributes + "></tr>");
              var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Add, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(currentTr).closest("table")[0]);
              var actions2 = vTable.getActionList();
              for (var idCell = 0; idCell < actions2.length; idCell++) {
                var currentCell = actions2[idCell];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                switch (currentCell.action) {
                  case TableResultAction.resultAction.AddCell:
                    html2.append("<td" + tdAttributes + ">" + dom.blank + "</td>");
                    break;
                  case TableResultAction.resultAction.SumSpanCount:
                    {
                      if (position2 === "top") {
                        var baseCellTr = currentCell.baseCell.parent;
                        var isTopFromRowSpan = (!baseCellTr ? 0 : currentCell.baseCell.closest("tr").rowIndex) <= currentTr[0].rowIndex;
                        if (isTopFromRowSpan) {
                          var newTd = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<div></div>").append(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<td" + tdAttributes + ">" + dom.blank + "</td>").removeAttr("rowspan")).html();
                          html2.append(newTd);
                          break;
                        }
                      }
                      var rowspanNumber = parseInt(currentCell.baseCell.rowSpan, 10);
                      rowspanNumber++;
                      currentCell.baseCell.setAttribute("rowSpan", rowspanNumber);
                    }
                    break;
                }
              }
              if (position2 === "top") {
                currentTr.before(html2);
              } else {
                var cellHasRowspan = cell.rowSpan > 1;
                if (cellHasRowspan) {
                  var lastTrIndex = currentTr[0].rowIndex + (cell.rowSpan - 2);
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(currentTr).parent().find("tr")[lastTrIndex]).after(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(html2));
                  return;
                }
                currentTr.after(html2);
              }
            }
            /**
             * Add a new col
             *
             * @param {WrappedRange} rng
             * @param {String} position (left/right)
             * @return {Node}
             */
          }, {
            key: "addCol",
            value: function addCol(rng, position2) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell).closest("tr");
              var rowsGroup = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(row).siblings();
              rowsGroup.push(row);
              var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Add, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(row).closest("table")[0]);
              var actions2 = vTable.getActionList();
              for (var actionIndex = 0; actionIndex < actions2.length; actionIndex++) {
                var currentCell = actions2[actionIndex];
                var tdAttributes = this.recoverAttributes(currentCell.baseCell);
                switch (currentCell.action) {
                  case TableResultAction.resultAction.AddCell:
                    if (position2 === "right") {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(currentCell.baseCell).after("<td" + tdAttributes + ">" + dom.blank + "</td>");
                    } else {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(currentCell.baseCell).before("<td" + tdAttributes + ">" + dom.blank + "</td>");
                    }
                    break;
                  case TableResultAction.resultAction.SumSpanCount:
                    if (position2 === "right") {
                      var colspanNumber = parseInt(currentCell.baseCell.colSpan, 10);
                      colspanNumber++;
                      currentCell.baseCell.setAttribute("colSpan", colspanNumber);
                    } else {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(currentCell.baseCell).before("<td" + tdAttributes + ">" + dom.blank + "</td>");
                    }
                    break;
                }
              }
            }
            /*
            * Copy attributes from element.
            *
            * @param {object} Element to recover attributes.
            * @return {string} Copied string elements.
            */
          }, {
            key: "recoverAttributes",
            value: function recoverAttributes(el) {
              var resultStr = "";
              if (!el) {
                return resultStr;
              }
              var attrList = el.attributes || [];
              for (var i = 0; i < attrList.length; i++) {
                if (attrList[i].name.toLowerCase() === "id") {
                  continue;
                }
                if (attrList[i].specified) {
                  resultStr += " " + attrList[i].name + "='" + attrList[i].value + "'";
                }
              }
              return resultStr;
            }
            /**
             * Delete current row
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
          }, {
            key: "deleteRow",
            value: function deleteRow(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell).closest("tr");
              var cellPos = row.children("td, th").index(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell));
              var rowPos = row[0].rowIndex;
              var vTable = new TableResultAction(cell, TableResultAction.where.Row, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(row).closest("table")[0]);
              var actions2 = vTable.getActionList();
              for (var actionIndex = 0; actionIndex < actions2.length; actionIndex++) {
                if (!actions2[actionIndex]) {
                  continue;
                }
                var baseCell = actions2[actionIndex].baseCell;
                var virtualPosition = actions2[actionIndex].virtualTable;
                var hasRowspan = baseCell.rowSpan && baseCell.rowSpan > 1;
                var rowspanNumber = hasRowspan ? parseInt(baseCell.rowSpan, 10) : 0;
                switch (actions2[actionIndex].action) {
                  case TableResultAction.resultAction.Ignore:
                    continue;
                  case TableResultAction.resultAction.AddCell:
                    {
                      var nextRow = row.next("tr")[0];
                      if (!nextRow) {
                        continue;
                      }
                      var cloneRow = row[0].cells[cellPos];
                      if (hasRowspan) {
                        if (rowspanNumber > 2) {
                          rowspanNumber--;
                          nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                          nextRow.cells[cellPos].setAttribute("rowSpan", rowspanNumber);
                          nextRow.cells[cellPos].innerHTML = "";
                        } else if (rowspanNumber === 2) {
                          nextRow.insertBefore(cloneRow, nextRow.cells[cellPos]);
                          nextRow.cells[cellPos].removeAttribute("rowSpan");
                          nextRow.cells[cellPos].innerHTML = "";
                        }
                      }
                    }
                    continue;
                  case TableResultAction.resultAction.SubtractSpanCount:
                    if (hasRowspan) {
                      if (rowspanNumber > 2) {
                        rowspanNumber--;
                        baseCell.setAttribute("rowSpan", rowspanNumber);
                        if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                          baseCell.innerHTML = "";
                        }
                      } else if (rowspanNumber === 2) {
                        baseCell.removeAttribute("rowSpan");
                        if (virtualPosition.rowIndex !== rowPos && baseCell.cellIndex === cellPos) {
                          baseCell.innerHTML = "";
                        }
                      }
                    }
                    continue;
                  case TableResultAction.resultAction.RemoveCell:
                    continue;
                }
              }
              row.remove();
            }
            /**
             * Delete current col
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
          }, {
            key: "deleteCol",
            value: function deleteCol(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              var row = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell).closest("tr");
              var cellPos = row.children("td, th").index(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell));
              var vTable = new TableResultAction(cell, TableResultAction.where.Column, TableResultAction.requestAction.Delete, external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(row).closest("table")[0]);
              var actions2 = vTable.getActionList();
              for (var actionIndex = 0; actionIndex < actions2.length; actionIndex++) {
                if (!actions2[actionIndex]) {
                  continue;
                }
                switch (actions2[actionIndex].action) {
                  case TableResultAction.resultAction.Ignore:
                    continue;
                  case TableResultAction.resultAction.SubtractSpanCount:
                    {
                      var baseCell = actions2[actionIndex].baseCell;
                      var hasColspan = baseCell.colSpan && baseCell.colSpan > 1;
                      if (hasColspan) {
                        var colspanNumber = baseCell.colSpan ? parseInt(baseCell.colSpan, 10) : 0;
                        if (colspanNumber > 2) {
                          colspanNumber--;
                          baseCell.setAttribute("colSpan", colspanNumber);
                          if (baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = "";
                          }
                        } else if (colspanNumber === 2) {
                          baseCell.removeAttribute("colSpan");
                          if (baseCell.cellIndex === cellPos) {
                            baseCell.innerHTML = "";
                          }
                        }
                      }
                    }
                    continue;
                  case TableResultAction.resultAction.RemoveCell:
                    dom.remove(actions2[actionIndex].baseCell, true);
                    continue;
                }
              }
            }
            /**
             * create empty table element
             *
             * @param {Number} rowCount
             * @param {Number} colCount
             * @return {Node}
             */
          }, {
            key: "createTable",
            value: function createTable(colCount, rowCount, options) {
              var tds = [];
              var tdHTML;
              for (var idxCol = 0; idxCol < colCount; idxCol++) {
                tds.push("<td>" + dom.blank + "</td>");
              }
              tdHTML = tds.join("");
              var trs = [];
              var trHTML;
              for (var idxRow = 0; idxRow < rowCount; idxRow++) {
                trs.push("<tr>" + tdHTML + "</tr>");
              }
              trHTML = trs.join("");
              var $table = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<table>" + trHTML + "</table>");
              if (options && options.tableClassName) {
                $table.addClass(options.tableClassName);
              }
              return $table[0];
            }
            /**
             * Delete current table
             *
             * @param {WrappedRange} rng
             * @return {Node}
             */
          }, {
            key: "deleteTable",
            value: function deleteTable(rng) {
              var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(cell).closest("table").remove();
            }
          }]);
        }();
        function Editor_typeof(o2) {
          "@babel/helpers - typeof";
          return Editor_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Editor_typeof(o2);
        }
        function Editor_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Editor_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Editor_toPropertyKey(o2.key), o2);
          }
        }
        function Editor_createClass(e2, r2, t2) {
          return r2 && Editor_defineProperties(e2.prototype, r2), t2 && Editor_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Editor_toPropertyKey(t2) {
          var i = Editor_toPrimitive(t2, "string");
          return "symbol" == Editor_typeof(i) ? i : i + "";
        }
        function Editor_toPrimitive(t2, r2) {
          if ("object" != Editor_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Editor_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var KEY_BOGUS = "bogus";
        var MAILTO_PATTERN = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        var TEL_PATTERN = /^(\+?\d{1,3}[\s-]?)?(\d{1,4})[\s-]?(\d{1,4})[\s-]?(\d{1,4})$/;
        var URL_SCHEME_PATTERN = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/;
        var Editor = /* @__PURE__ */ function() {
          function Editor2(context) {
            var _this = this;
            Editor_classCallCheck(this, Editor2);
            this.context = context;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.editable = this.$editable[0];
            this.lastRange = null;
            this.snapshot = null;
            this.style = new Style();
            this.table = new Table();
            this.typing = new Typing(context);
            this.bullet = new Bullet();
            this.history = new History(context);
            this.context.memo("help.escape", this.lang.help.escape);
            this.context.memo("help.undo", this.lang.help.undo);
            this.context.memo("help.redo", this.lang.help.redo);
            this.context.memo("help.tab", this.lang.help.tab);
            this.context.memo("help.untab", this.lang.help.untab);
            this.context.memo("help.insertParagraph", this.lang.help.insertParagraph);
            this.context.memo("help.insertOrderedList", this.lang.help.insertOrderedList);
            this.context.memo("help.insertUnorderedList", this.lang.help.insertUnorderedList);
            this.context.memo("help.indent", this.lang.help.indent);
            this.context.memo("help.outdent", this.lang.help.outdent);
            this.context.memo("help.formatPara", this.lang.help.formatPara);
            this.context.memo("help.insertHorizontalRule", this.lang.help.insertHorizontalRule);
            this.context.memo("help.fontName", this.lang.help.fontName);
            var commands = ["bold", "italic", "underline", "strikethrough", "superscript", "subscript", "justifyLeft", "justifyCenter", "justifyRight", "justifyFull", "formatBlock", "removeFormat", "backColor"];
            for (var idx = 0, len = commands.length; idx < len; idx++) {
              this[commands[idx]] = function(sCmd) {
                return function(value2) {
                  _this.beforeCommand();
                  document.execCommand(sCmd, false, value2);
                  _this.afterCommand(true);
                };
              }(commands[idx]);
              this.context.memo("help." + commands[idx], this.lang.help[commands[idx]]);
            }
            this.fontName = this.wrapCommand(function(value2) {
              return _this.fontStyling("font-family", env.validFontName(value2));
            });
            this.fontSize = this.wrapCommand(function(value2) {
              var unit = _this.currentStyle()["font-size-unit"];
              return _this.fontStyling("font-size", value2 + unit);
            });
            this.fontSizeUnit = this.wrapCommand(function(value2) {
              var size = _this.currentStyle()["font-size"];
              return _this.fontStyling("font-size", size + value2);
            });
            for (var _idx = 1; _idx <= 6; _idx++) {
              this["formatH" + _idx] = function(idx2) {
                return function() {
                  _this.formatBlock("H" + idx2);
                };
              }(_idx);
              this.context.memo("help.formatH" + _idx, this.lang.help["formatH" + _idx]);
            }
            this.insertParagraph = this.wrapCommand(function() {
              _this.typing.insertParagraph(_this.editable);
            });
            this.insertOrderedList = this.wrapCommand(function() {
              _this.bullet.insertOrderedList(_this.editable);
            });
            this.insertUnorderedList = this.wrapCommand(function() {
              _this.bullet.insertUnorderedList(_this.editable);
            });
            this.indent = this.wrapCommand(function() {
              _this.bullet.indent(_this.editable);
            });
            this.outdent = this.wrapCommand(function() {
              _this.bullet.outdent(_this.editable);
            });
            this.insertNode = this.wrapCommand(function(node) {
              if (_this.isLimited(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(node).text().length)) {
                return;
              }
              var rng = _this.getLastRange();
              rng.insertNode(node);
              _this.setLastRange(range.createFromNodeAfter(node).select());
            });
            this.insertText = this.wrapCommand(function(text2) {
              if (_this.isLimited(text2.length)) {
                return;
              }
              var rng = _this.getLastRange();
              var textNode = rng.insertNode(dom.createText(text2));
              _this.setLastRange(range.create(textNode, dom.nodeLength(textNode)).select());
            });
            this.pasteHTML = this.wrapCommand(function(markup) {
              if (_this.isLimited(markup.length)) {
                return;
              }
              markup = _this.context.invoke("codeview.purify", markup);
              var contents = _this.getLastRange().pasteHTML(markup);
              _this.setLastRange(range.createFromNodeAfter(lists.last(contents)).select());
            });
            this.formatBlock = this.wrapCommand(function(tagName, $target) {
              var onApplyCustomStyle = _this.options.callbacks.onApplyCustomStyle;
              if (onApplyCustomStyle) {
                onApplyCustomStyle.call(_this, $target, _this.context, _this.onFormatBlock);
              } else {
                _this.onFormatBlock(tagName, $target);
              }
            });
            this.insertHorizontalRule = this.wrapCommand(function() {
              var hrNode = _this.getLastRange().insertNode(dom.create("HR"));
              if (hrNode.nextSibling) {
                _this.setLastRange(range.create(hrNode.nextSibling, 0).normalize().select());
              }
            });
            this.lineHeight = this.wrapCommand(function(value2) {
              _this.style.stylePara(_this.getLastRange(), {
                lineHeight: value2
              });
            });
            this.createLink = this.wrapCommand(function(linkInfo) {
              var rel = [];
              var linkUrl = linkInfo.url;
              var linkText = linkInfo.text;
              var isNewWindow = linkInfo.isNewWindow;
              var addNoReferrer = _this.options.linkAddNoReferrer;
              var addNoOpener = _this.options.linkAddNoOpener;
              var rng = linkInfo.range || _this.getLastRange();
              var additionalTextLength = linkText.length - rng.toString().length;
              if (additionalTextLength > 0 && _this.isLimited(additionalTextLength)) {
                return;
              }
              var isTextChanged = rng.toString() !== linkText;
              if (typeof linkUrl === "string") {
                linkUrl = linkUrl.trim();
              }
              if (_this.options.onCreateLink) {
                linkUrl = _this.options.onCreateLink(linkUrl);
              } else {
                linkUrl = _this.checkLinkUrl(linkUrl);
              }
              var anchors = [];
              if (isTextChanged) {
                rng = rng.deleteContents();
                var anchor = rng.insertNode(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<A></A>").text(linkText)[0]);
                anchors.push(anchor);
              } else {
                anchors = _this.style.styleNodes(rng, {
                  nodeName: "A",
                  expandClosestSibling: true,
                  onlyPartialContains: true
                });
              }
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(anchors, function(idx2, anchor2) {
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(anchor2).attr("href", linkUrl);
                if (isNewWindow) {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(anchor2).attr("target", "_blank");
                  if (addNoReferrer) {
                    rel.push("noreferrer");
                  }
                  if (addNoOpener) {
                    rel.push("noopener");
                  }
                  if (rel.length) {
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(anchor2).attr("rel", rel.join(" "));
                  }
                } else {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(anchor2).removeAttr("target");
                }
              });
              _this.setLastRange(_this.createRangeFromList(anchors).select());
            });
            this.color = this.wrapCommand(function(colorInfo) {
              var foreColor = colorInfo.foreColor;
              var backColor = colorInfo.backColor;
              if (foreColor) {
                document.execCommand("foreColor", false, foreColor);
              }
              if (backColor) {
                document.execCommand("backColor", false, backColor);
              }
            });
            this.foreColor = this.wrapCommand(function(colorInfo) {
              document.execCommand("foreColor", false, colorInfo);
            });
            this.insertTable = this.wrapCommand(function(dim) {
              var dimension = dim.split("x");
              var rng = _this.getLastRange().deleteContents();
              rng.insertNode(_this.table.createTable(dimension[0], dimension[1], _this.options));
            });
            this.removeMedia = this.wrapCommand(function() {
              var $target = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(_this.restoreTarget()).parent();
              if ($target.closest("figure").length) {
                $target.closest("figure").remove();
              } else {
                $target = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(_this.restoreTarget()).detach();
              }
              _this.setLastRange(range.createFromSelection($target).select());
              _this.context.triggerEvent("media.delete", $target, _this.$editable);
            });
            this.floatMe = this.wrapCommand(function(value2) {
              var $target = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(_this.restoreTarget());
              $target.toggleClass("note-float-left", value2 === "left");
              $target.toggleClass("note-float-right", value2 === "right");
              $target.css("float", value2 === "none" ? "" : value2);
            });
            this.resize = this.wrapCommand(function(value2) {
              var $target = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(_this.restoreTarget());
              value2 = parseFloat(value2);
              if (value2 === 0) {
                $target.css("width", "");
              } else {
                $target.css({
                  width: value2 * 100 + "%",
                  height: ""
                });
              }
            });
          }
          return Editor_createClass(Editor2, [{
            key: "initialize",
            value: function initialize2() {
              var _this2 = this;
              this.$editable.on("keydown", function(event) {
                if (event.keyCode === key.code.ENTER) {
                  _this2.context.triggerEvent("enter", event);
                }
                _this2.context.triggerEvent("keydown", event);
                _this2.snapshot = _this2.history.makeSnapshot();
                _this2.hasKeyShortCut = false;
                if (!event.isDefaultPrevented()) {
                  if (_this2.options.shortcuts) {
                    _this2.hasKeyShortCut = _this2.handleKeyMap(event);
                  } else {
                    _this2.preventDefaultEditableShortCuts(event);
                  }
                }
                if (_this2.isLimited(1, event)) {
                  var lastRange = _this2.getLastRange();
                  if (lastRange.eo - lastRange.so === 0) {
                    return false;
                  }
                }
                _this2.setLastRange();
                if (_this2.options.recordEveryKeystroke) {
                  if (_this2.hasKeyShortCut === false) {
                    _this2.history.recordUndo();
                  }
                }
              }).on("keyup", function(event) {
                _this2.setLastRange();
                _this2.context.triggerEvent("keyup", event);
              }).on("focus", function(event) {
                _this2.setLastRange();
                _this2.context.triggerEvent("focus", event);
              }).on("blur", function(event) {
                _this2.context.triggerEvent("blur", event);
              }).on("mousedown", function(event) {
                _this2.context.triggerEvent("mousedown", event);
              }).on("mouseup", function(event) {
                _this2.setLastRange();
                _this2.history.recordUndo();
                _this2.context.triggerEvent("mouseup", event);
              }).on("scroll", function(event) {
                _this2.context.triggerEvent("scroll", event);
              }).on("paste", function(event) {
                _this2.setLastRange();
                _this2.context.triggerEvent("paste", event);
              }).on("copy", function(event) {
                _this2.context.triggerEvent("copy", event);
              }).on("input", function() {
                if (_this2.isLimited(0) && _this2.snapshot) {
                  _this2.history.applySnapshot(_this2.snapshot);
                }
              });
              this.$editable.attr("spellcheck", this.options.spellCheck);
              this.$editable.attr("autocorrect", this.options.spellCheck);
              if (this.options.disableGrammar) {
                this.$editable.attr("data-gramm", false);
              }
              this.$editable.html(dom.html(this.$note) || dom.emptyPara);
              this.$editable.on(env.inputEventName, func.debounce(function() {
                _this2.context.triggerEvent("change", _this2.$editable.html(), _this2.$editable);
              }, 10));
              this.$editable.on("focusin", function(event) {
                _this2.context.triggerEvent("focusin", event);
              }).on("focusout", function(event) {
                _this2.context.triggerEvent("focusout", event);
              });
              if (this.options.airMode) {
                if (this.options.overrideContextMenu) {
                  this.$editor.on("contextmenu", function(event) {
                    _this2.context.triggerEvent("contextmenu", event);
                    return false;
                  });
                }
              } else {
                if (this.options.width) {
                  this.$editor.outerWidth(this.options.width);
                }
                if (this.options.height) {
                  this.$editable.outerHeight(this.options.height);
                }
                if (this.options.maxHeight) {
                  this.$editable.css("max-height", this.options.maxHeight);
                }
                if (this.options.minHeight) {
                  this.$editable.css("min-height", this.options.minHeight);
                }
              }
              this.history.recordUndo();
              this.setLastRange();
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$editable.off();
            }
          }, {
            key: "handleKeyMap",
            value: function handleKeyMap(event) {
              var keyMap = this.options.keyMap[env.isMac ? "mac" : "pc"];
              var keys = [];
              if (event.metaKey) {
                keys.push("CMD");
              }
              if (event.ctrlKey && !event.altKey) {
                keys.push("CTRL");
              }
              if (event.shiftKey) {
                keys.push("SHIFT");
              }
              var keyName = key.nameFromCode[event.keyCode];
              if (keyName) {
                keys.push(keyName);
              }
              var eventName = keyMap[keys.join("+")];
              if (keyName === "TAB" && !this.options.tabDisable) {
                this.afterCommand();
              } else if (eventName) {
                if (this.context.invoke(eventName) !== false) {
                  event.preventDefault();
                  return true;
                }
              } else if (key.isEdit(event.keyCode)) {
                if (key.isRemove(event.keyCode)) {
                  this.context.invoke("removed");
                }
                this.afterCommand();
              }
              return false;
            }
          }, {
            key: "preventDefaultEditableShortCuts",
            value: function preventDefaultEditableShortCuts(event) {
              if ((event.ctrlKey || event.metaKey) && lists.contains([66, 73, 85], event.keyCode)) {
                event.preventDefault();
              }
            }
          }, {
            key: "isLimited",
            value: function isLimited(pad, event) {
              pad = pad || 0;
              if (typeof event !== "undefined") {
                if (key.isMove(event.keyCode) || key.isNavigation(event.keyCode) || event.ctrlKey || event.metaKey || lists.contains([key.code.BACKSPACE, key.code.DELETE], event.keyCode)) {
                  return false;
                }
              }
              if (this.options.maxTextLength > 0) {
                if (this.$editable.text().length + pad > this.options.maxTextLength) {
                  return true;
                }
              }
              return false;
            }
          }, {
            key: "checkLinkUrl",
            value: function checkLinkUrl(linkUrl) {
              if (MAILTO_PATTERN.test(linkUrl)) {
                return "mailto://" + linkUrl;
              } else if (TEL_PATTERN.test(linkUrl)) {
                return "tel://" + linkUrl;
              } else if (!URL_SCHEME_PATTERN.test(linkUrl)) {
                return "http://" + linkUrl;
              }
              return linkUrl;
            }
            /**
             * create range
             * @return {WrappedRange}
             */
          }, {
            key: "createRange",
            value: function createRange() {
              this.focus();
              this.setLastRange();
              return this.getLastRange();
            }
            /**
             * create a new range from the list of elements
             *
             * @param {list} dom element list
             * @return {WrappedRange}
             */
          }, {
            key: "createRangeFromList",
            value: function createRangeFromList(lst) {
              var startRange = range.createFromNodeBefore(lists.head(lst));
              var startPoint = startRange.getStartPoint();
              var endRange = range.createFromNodeAfter(lists.last(lst));
              var endPoint = endRange.getEndPoint();
              return range.create(startPoint.node, startPoint.offset, endPoint.node, endPoint.offset);
            }
            /**
             * set the last range
             *
             * if given rng is exist, set rng as the last range
             * or create a new range at the end of the document
             *
             * @param {WrappedRange} rng
             */
          }, {
            key: "setLastRange",
            value: function setLastRange(rng) {
              if (rng) {
                this.lastRange = rng;
              } else {
                this.lastRange = range.create(this.editable);
                if (external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.lastRange.sc).closest(".note-editable").length === 0) {
                  this.lastRange = range.createFromBodyElement(this.editable);
                }
              }
            }
            /**
             * get the last range
             *
             * if there is a saved last range, return it
             * or create a new range and return it
             *
             * @return {WrappedRange}
             */
          }, {
            key: "getLastRange",
            value: function getLastRange() {
              if (!this.lastRange) {
                this.setLastRange();
              }
              return this.lastRange;
            }
            /**
             * saveRange
             *
             * save current range
             *
             * @param {Boolean} [thenCollapse=false]
             */
          }, {
            key: "saveRange",
            value: function saveRange(thenCollapse) {
              if (thenCollapse) {
                this.getLastRange().collapse().select();
              }
            }
            /**
             * restoreRange
             *
             * restore lately range
             */
          }, {
            key: "restoreRange",
            value: function restoreRange() {
              if (this.lastRange) {
                this.lastRange.select();
                this.focus();
              }
            }
          }, {
            key: "saveTarget",
            value: function saveTarget(node) {
              this.$editable.data("target", node);
            }
          }, {
            key: "clearTarget",
            value: function clearTarget() {
              this.$editable.removeData("target");
            }
          }, {
            key: "restoreTarget",
            value: function restoreTarget() {
              return this.$editable.data("target");
            }
            /**
             * currentStyle
             *
             * current style
             * @return {Object|Boolean} unfocus
             */
          }, {
            key: "currentStyle",
            value: function currentStyle() {
              var rng = range.create();
              if (rng) {
                rng = rng.normalize();
              }
              return rng ? this.style.current(rng) : this.style.fromNode(this.$editable);
            }
            /**
             * style from node
             *
             * @param {jQuery} $node
             * @return {Object}
             */
          }, {
            key: "styleFromNode",
            value: function styleFromNode($node) {
              return this.style.fromNode($node);
            }
            /**
             * undo
             */
          }, {
            key: "undo",
            value: function undo() {
              this.context.triggerEvent("before.command", this.$editable.html());
              this.history.undo();
              this.context.triggerEvent("change", this.$editable.html(), this.$editable);
            }
            /*
            * commit
            */
          }, {
            key: "commit",
            value: function commit() {
              this.context.triggerEvent("before.command", this.$editable.html());
              this.history.commit();
              this.context.triggerEvent("change", this.$editable.html(), this.$editable);
            }
            /**
             * redo
             */
          }, {
            key: "redo",
            value: function redo() {
              this.context.triggerEvent("before.command", this.$editable.html());
              this.history.redo();
              this.context.triggerEvent("change", this.$editable.html(), this.$editable);
            }
            /**
             * before command
             */
          }, {
            key: "beforeCommand",
            value: function beforeCommand() {
              this.context.triggerEvent("before.command", this.$editable.html());
              document.execCommand("styleWithCSS", false, this.options.styleWithCSS);
              this.focus();
            }
            /**
             * after command
             * @param {Boolean} isPreventTrigger
             */
          }, {
            key: "afterCommand",
            value: function afterCommand(isPreventTrigger) {
              this.normalizeContent();
              this.history.recordUndo();
              if (!isPreventTrigger) {
                this.context.triggerEvent("change", this.$editable.html(), this.$editable);
              }
            }
            /**
             * handle tab key
             */
          }, {
            key: "tab",
            value: function tab() {
              var rng = this.getLastRange();
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng);
              } else {
                if (this.options.tabSize === 0) {
                  return false;
                }
                if (!this.isLimited(this.options.tabSize)) {
                  this.beforeCommand();
                  this.typing.insertTab(rng, this.options.tabSize);
                  this.afterCommand();
                }
              }
            }
            /**
             * handle shift+tab key
             */
          }, {
            key: "untab",
            value: function untab() {
              var rng = this.getLastRange();
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.table.tab(rng, true);
              } else {
                if (this.options.tabSize === 0) {
                  return false;
                }
              }
            }
            /**
             * run given function between beforeCommand and afterCommand
             */
          }, {
            key: "wrapCommand",
            value: function wrapCommand(fn3) {
              return function() {
                this.beforeCommand();
                fn3.apply(this, arguments);
                this.afterCommand();
              };
            }
            /**
             * removed (function added by 1der1)
            */
          }, {
            key: "removed",
            value: function removed(rng, node, tagName) {
              rng = range.create();
              if (rng.isCollapsed() && rng.isOnCell()) {
                node = rng.ec;
                if ((tagName = node.tagName) && node.childElementCount === 1 && node.childNodes[0].tagName === "BR") {
                  if (tagName === "P") {
                    node.remove();
                  } else if (["TH", "TD"].indexOf(tagName) >= 0) {
                    node.firstChild.remove();
                  }
                }
              }
            }
            /**
             * insert image
             *
             * @param {String} src
             * @param {String|Function} param
             * @return {Promise}
             */
          }, {
            key: "insertImage",
            value: function insertImage(src, param) {
              var _this3 = this;
              return createImage(src).then(function($image) {
                _this3.beforeCommand();
                if (typeof param === "function") {
                  param($image);
                } else {
                  if (typeof param === "string") {
                    $image.attr("data-filename", param);
                  }
                  $image.css("width", Math.min(_this3.$editable.width(), $image.width()));
                }
                $image.show();
                _this3.getLastRange().insertNode($image[0]);
                _this3.setLastRange(range.createFromNodeAfter($image[0]).select());
                _this3.afterCommand();
              }).fail(function(e2) {
                _this3.context.triggerEvent("image.upload.error", e2);
              });
            }
            /**
             * insertImages
             * @param {File[]} files
             */
          }, {
            key: "insertImagesAsDataURL",
            value: function insertImagesAsDataURL(files) {
              var _this4 = this;
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(files, function(idx, file2) {
                var filename = file2.name;
                if (_this4.options.maximumImageFileSize && _this4.options.maximumImageFileSize < file2.size) {
                  _this4.context.triggerEvent("image.upload.error", _this4.lang.image.maximumFileSizeError);
                } else {
                  readFileAsDataURL(file2).then(function(dataURL) {
                    return _this4.insertImage(dataURL, filename);
                  }).fail(function() {
                    _this4.context.triggerEvent("image.upload.error");
                  });
                }
              });
            }
            /**
             * insertImagesOrCallback
             * @param {File[]} files
             */
          }, {
            key: "insertImagesOrCallback",
            value: function insertImagesOrCallback(files) {
              var callbacks = this.options.callbacks;
              if (callbacks.onImageUpload) {
                this.context.triggerEvent("image.upload", files);
              } else {
                this.insertImagesAsDataURL(files);
              }
            }
            /**
             * return selected plain text
             * @return {String} text
             */
          }, {
            key: "getSelectedText",
            value: function getSelectedText() {
              var rng = this.getLastRange();
              if (rng.isOnAnchor()) {
                rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));
              }
              return rng.toString();
            }
          }, {
            key: "onFormatBlock",
            value: function onFormatBlock(tagName, $target) {
              document.execCommand("FormatBlock", false, env.isMSIE ? "<" + tagName + ">" : tagName);
              if ($target && $target.length) {
                if ($target[0].tagName.toUpperCase() !== tagName.toUpperCase()) {
                  $target = $target.find(tagName);
                }
                if ($target && $target.length) {
                  var currentRange = this.createRange();
                  var $parent = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()([currentRange.sc, currentRange.ec]).closest(tagName);
                  $parent.removeClass();
                  var className = $target[0].className || "";
                  if (className) {
                    $parent.addClass(className);
                  }
                }
              }
            }
          }, {
            key: "formatPara",
            value: function formatPara() {
              this.formatBlock("P");
            }
          }, {
            key: "fontStyling",
            value: function fontStyling(target, value2) {
              var rng = this.getLastRange();
              if (rng !== "") {
                var spans = this.style.styleNodes(rng);
                this.$editor.find(".note-status-output").html("");
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(spans).css(target, value2);
                if (rng.isCollapsed()) {
                  var firstSpan = lists.head(spans);
                  if (firstSpan && !dom.nodeLength(firstSpan)) {
                    firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;
                    range.createFromNode(firstSpan.firstChild).select();
                    this.setLastRange();
                    this.$editable.data(KEY_BOGUS, firstSpan);
                  }
                } else {
                  rng.select();
                }
              } else {
                var noteStatusOutput = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().now();
                this.$editor.find(".note-status-output").html('<div id="note-status-output-' + noteStatusOutput + '" class="alert alert-info">' + this.lang.output.noSelection + "</div>");
                setTimeout(function() {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("#note-status-output-" + noteStatusOutput).remove();
                }, 5e3);
              }
            }
            /**
             * unlink
             *
             * @type command
             */
          }, {
            key: "unlink",
            value: function unlink() {
              var rng = this.getLastRange();
              if (rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                rng = range.createFromNode(anchor);
                rng.select();
                this.setLastRange();
                this.beforeCommand();
                document.execCommand("unlink");
                this.afterCommand();
              }
            }
            /**
             * returns link info
             *
             * @return {Object}
             * @return {WrappedRange} return.range
             * @return {String} return.text
             * @return {Boolean} [return.isNewWindow=true]
             * @return {String} [return.url=""]
             */
          }, {
            key: "getLinkInfo",
            value: function getLinkInfo() {
              if (!this.hasFocus()) {
                this.focus();
              }
              var rng = this.getLastRange().expand(dom.isAnchor);
              var $anchor = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(lists.head(rng.nodes(dom.isAnchor)));
              var linkInfo = {
                range: rng,
                text: rng.toString(),
                url: $anchor.length ? $anchor.attr("href") : ""
              };
              if ($anchor.length) {
                linkInfo.isNewWindow = $anchor.attr("target") === "_blank";
              }
              return linkInfo;
            }
          }, {
            key: "addRow",
            value: function addRow(position2) {
              var rng = this.getLastRange(this.$editable);
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addRow(rng, position2);
                this.afterCommand();
              }
            }
          }, {
            key: "addCol",
            value: function addCol(position2) {
              var rng = this.getLastRange(this.$editable);
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.addCol(rng, position2);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteRow",
            value: function deleteRow() {
              var rng = this.getLastRange(this.$editable);
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteRow(rng);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteCol",
            value: function deleteCol() {
              var rng = this.getLastRange(this.$editable);
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteCol(rng);
                this.afterCommand();
              }
            }
          }, {
            key: "deleteTable",
            value: function deleteTable() {
              var rng = this.getLastRange(this.$editable);
              if (rng.isCollapsed() && rng.isOnCell()) {
                this.beforeCommand();
                this.table.deleteTable(rng);
                this.afterCommand();
              }
            }
            /**
             * @param {Position} pos
             * @param {jQuery} $target - target element
             * @param {Boolean} [bKeepRatio] - keep ratio
             */
          }, {
            key: "resizeTo",
            value: function resizeTo(pos, $target, bKeepRatio) {
              var imageSize;
              if (bKeepRatio) {
                var newRatio = pos.y / pos.x;
                var ratio = $target.data("ratio");
                imageSize = {
                  width: ratio > newRatio ? pos.x : pos.y / ratio,
                  height: ratio > newRatio ? pos.x * ratio : pos.y
                };
              } else {
                imageSize = {
                  width: pos.x,
                  height: pos.y
                };
              }
              $target.css(imageSize);
            }
            /**
             * returns whether editable area has focus or not.
             */
          }, {
            key: "hasFocus",
            value: function hasFocus() {
              return this.$editable.is(":focus");
            }
            /**
             * set focus
             */
          }, {
            key: "focus",
            value: function focus() {
              if (!this.hasFocus()) {
                this.$editable.trigger("focus");
              }
            }
            /**
             * returns whether contents is empty or not.
             * @return {Boolean}
             */
          }, {
            key: "isEmpty",
            value: function isEmpty3() {
              return dom.isEmpty(this.$editable[0]) || dom.emptyPara === this.$editable.html();
            }
            /**
             * Removes all contents and restores the editable instance to an _emptyPara_.
             */
          }, {
            key: "empty",
            value: function empty() {
              this.context.invoke("code", dom.emptyPara);
            }
            /**
             * normalize content
             */
          }, {
            key: "normalizeContent",
            value: function normalizeContent() {
              this.$editable[0].normalize();
            }
          }]);
        }();
        function Clipboard_typeof(o2) {
          "@babel/helpers - typeof";
          return Clipboard_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Clipboard_typeof(o2);
        }
        function Clipboard_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Clipboard_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Clipboard_toPropertyKey(o2.key), o2);
          }
        }
        function Clipboard_createClass(e2, r2, t2) {
          return r2 && Clipboard_defineProperties(e2.prototype, r2), t2 && Clipboard_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Clipboard_toPropertyKey(t2) {
          var i = Clipboard_toPrimitive(t2, "string");
          return "symbol" == Clipboard_typeof(i) ? i : i + "";
        }
        function Clipboard_toPrimitive(t2, r2) {
          if ("object" != Clipboard_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Clipboard_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Clipboard = /* @__PURE__ */ function() {
          function Clipboard2(context) {
            Clipboard_classCallCheck(this, Clipboard2);
            this.context = context;
            this.options = context.options;
            this.$editable = context.layoutInfo.editable;
          }
          return Clipboard_createClass(Clipboard2, [{
            key: "initialize",
            value: function initialize2() {
              this.$editable.on("paste", this.pasteByEvent.bind(this));
            }
            /**
             * paste by clipboard event
             *
             * @param {Event} event
             */
          }, {
            key: "pasteByEvent",
            value: function pasteByEvent(event) {
              var _this = this;
              if (this.context.isDisabled()) {
                return;
              }
              var clipboardData = event.originalEvent.clipboardData;
              if (clipboardData && clipboardData.items && clipboardData.items.length) {
                var clipboardFiles = clipboardData.files;
                var clipboardText = clipboardData.getData("Text");
                if (clipboardFiles.length > 0 && this.options.allowClipboardImagePasting) {
                  this.context.invoke("editor.insertImagesOrCallback", clipboardFiles);
                  event.preventDefault();
                }
                if (clipboardText.length > 0 && this.context.invoke("editor.isLimited", clipboardText.length)) {
                  event.preventDefault();
                }
              } else if (window.clipboardData) {
                var text2 = window.clipboardData.getData("text");
                if (this.context.invoke("editor.isLimited", text2.length)) {
                  event.preventDefault();
                }
              }
              setTimeout(function() {
                _this.context.invoke("editor.afterCommand");
              }, 10);
            }
          }]);
        }();
        function Dropzone_typeof(o2) {
          "@babel/helpers - typeof";
          return Dropzone_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Dropzone_typeof(o2);
        }
        function Dropzone_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Dropzone_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Dropzone_toPropertyKey(o2.key), o2);
          }
        }
        function Dropzone_createClass(e2, r2, t2) {
          return r2 && Dropzone_defineProperties(e2.prototype, r2), t2 && Dropzone_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Dropzone_toPropertyKey(t2) {
          var i = Dropzone_toPrimitive(t2, "string");
          return "symbol" == Dropzone_typeof(i) ? i : i + "";
        }
        function Dropzone_toPrimitive(t2, r2) {
          if ("object" != Dropzone_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Dropzone_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Dropzone = /* @__PURE__ */ function() {
          function Dropzone2(context) {
            Dropzone_classCallCheck(this, Dropzone2);
            this.context = context;
            this.$eventListener = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document);
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.documentEventHandlers = {};
            this.$dropzone = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(['<div class="note-dropzone">', '<div class="note-dropzone-message"></div>', "</div>"].join("")).prependTo(this.$editor);
          }
          return Dropzone_createClass(Dropzone2, [{
            key: "initialize",
            value: function initialize2() {
              if (this.options.disableDragAndDrop) {
                this.documentEventHandlers.onDrop = function(e2) {
                  e2.preventDefault();
                };
                this.$eventListener = this.$dropzone;
                this.$eventListener.on("drop", this.documentEventHandlers.onDrop);
              } else {
                this.attachDragAndDropEvent();
              }
            }
            /**
             * attach Drag and Drop Events
             */
          }, {
            key: "attachDragAndDropEvent",
            value: function attachDragAndDropEvent() {
              var _this = this;
              var collection = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()();
              var $dropzoneMessage = this.$dropzone.find(".note-dropzone-message");
              this.documentEventHandlers.onDragenter = function(e2) {
                var isCodeview = _this.context.invoke("codeview.isActivated");
                var hasEditorSize = _this.$editor.width() > 0 && _this.$editor.height() > 0;
                if (!isCodeview && !collection.length && hasEditorSize) {
                  _this.$editor.addClass("dragover");
                  _this.$dropzone.width(_this.$editor.width());
                  _this.$dropzone.height(_this.$editor.height());
                  $dropzoneMessage.text(_this.lang.image.dragImageHere);
                }
                collection = collection.add(e2.target);
              };
              this.documentEventHandlers.onDragleave = function(e2) {
                collection = collection.not(e2.target);
                if (!collection.length || e2.target.nodeName === "BODY") {
                  collection = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()();
                  _this.$editor.removeClass("dragover");
                }
              };
              this.documentEventHandlers.onDrop = function() {
                collection = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()();
                _this.$editor.removeClass("dragover");
              };
              this.$eventListener.on("dragenter", this.documentEventHandlers.onDragenter).on("dragleave", this.documentEventHandlers.onDragleave).on("drop", this.documentEventHandlers.onDrop);
              this.$dropzone.on("dragenter", function() {
                _this.$dropzone.addClass("hover");
                $dropzoneMessage.text(_this.lang.image.dropImage);
              }).on("dragleave", function() {
                _this.$dropzone.removeClass("hover");
                $dropzoneMessage.text(_this.lang.image.dragImageHere);
              });
              this.$dropzone.on("drop", function(event) {
                var dataTransfer = event.originalEvent.dataTransfer;
                event.preventDefault();
                if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
                  _this.$editable.trigger("focus");
                  _this.context.invoke("editor.insertImagesOrCallback", dataTransfer.files);
                } else {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(dataTransfer.types, function(idx, type) {
                    if (type.toLowerCase().indexOf("_moz_") > -1) {
                      return;
                    }
                    var content = dataTransfer.getData(type);
                    if (type.toLowerCase().indexOf("text") > -1) {
                      _this.context.invoke("editor.pasteHTML", content);
                    } else {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(content).each(function(idx2, item2) {
                        _this.context.invoke("editor.insertNode", item2);
                      });
                    }
                  });
                }
              }).on("dragover", false);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              var _this2 = this;
              Object.keys(this.documentEventHandlers).forEach(function(key2) {
                _this2.$eventListener.off(key2.slice(2).toLowerCase(), _this2.documentEventHandlers[key2]);
              });
              this.documentEventHandlers = {};
            }
          }]);
        }();
        function Codeview_typeof(o2) {
          "@babel/helpers - typeof";
          return Codeview_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Codeview_typeof(o2);
        }
        function _createForOfIteratorHelper(r2, e2) {
          var t2 = "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
          if (!t2) {
            if (Array.isArray(r2) || (t2 = _unsupportedIterableToArray(r2)) || e2 && r2 && "number" == typeof r2.length) {
              t2 && (r2 = t2);
              var _n = 0, F2 = function F3() {
              };
              return { s: F2, n: function n2() {
                return _n >= r2.length ? { done: true } : { done: false, value: r2[_n++] };
              }, e: function e3(r3) {
                throw r3;
              }, f: F2 };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }
          var o2, a2 = true, u2 = false;
          return { s: function s2() {
            t2 = t2.call(r2);
          }, n: function n2() {
            var r3 = t2.next();
            return a2 = r3.done, r3;
          }, e: function e3(r3) {
            u2 = true, o2 = r3;
          }, f: function f2() {
            try {
              a2 || null == t2["return"] || t2["return"]();
            } finally {
              if (u2)
                throw o2;
            }
          } };
        }
        function _unsupportedIterableToArray(r2, a2) {
          if (r2) {
            if ("string" == typeof r2)
              return _arrayLikeToArray(r2, a2);
            var t2 = {}.toString.call(r2).slice(8, -1);
            return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
          }
        }
        function _arrayLikeToArray(r2, a2) {
          (null == a2 || a2 > r2.length) && (a2 = r2.length);
          for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++)
            n2[e2] = r2[e2];
          return n2;
        }
        function Codeview_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Codeview_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Codeview_toPropertyKey(o2.key), o2);
          }
        }
        function Codeview_createClass(e2, r2, t2) {
          return r2 && Codeview_defineProperties(e2.prototype, r2), t2 && Codeview_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Codeview_toPropertyKey(t2) {
          var i = Codeview_toPrimitive(t2, "string");
          return "symbol" == Codeview_typeof(i) ? i : i + "";
        }
        function Codeview_toPrimitive(t2, r2) {
          if ("object" != Codeview_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Codeview_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var CodeView = /* @__PURE__ */ function() {
          function CodeView2(context) {
            Codeview_classCallCheck(this, CodeView2);
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.options = context.options;
            this.CodeMirrorConstructor = window.CodeMirror;
            if (this.options.codemirror.CodeMirrorConstructor) {
              this.CodeMirrorConstructor = this.options.codemirror.CodeMirrorConstructor;
            }
          }
          return Codeview_createClass(CodeView2, [{
            key: "sync",
            value: function sync(html2) {
              var isCodeview = this.isActivated();
              var CodeMirror = this.CodeMirrorConstructor;
              if (isCodeview) {
                if (html2) {
                  if (CodeMirror) {
                    this.$codable.data("cmEditor").getDoc().setValue(html2);
                  } else {
                    this.$codable.val(html2);
                  }
                } else {
                  if (CodeMirror) {
                    this.$codable.data("cmEditor").save();
                  }
                }
              }
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              var _this = this;
              this.$codable.on("keyup", function(event) {
                if (event.keyCode === key.code.ESCAPE) {
                  _this.deactivate();
                }
              });
            }
            /**
             * @return {Boolean}
             */
          }, {
            key: "isActivated",
            value: function isActivated() {
              return this.$editor.hasClass("codeview");
            }
            /**
             * toggle codeview
             */
          }, {
            key: "toggle",
            value: function toggle2() {
              if (this.isActivated()) {
                this.deactivate();
              } else {
                this.activate();
              }
              this.context.triggerEvent("codeview.toggled");
            }
            /**
             * purify input value
             * @param value
             * @returns {*}
             */
          }, {
            key: "purify",
            value: function purify(value2) {
              if (this.options.codeviewFilter) {
                value2 = value2.replace(this.options.codeviewFilterRegex, "");
                if (this.options.codeviewIframeFilter) {
                  var whitelist = this.options.codeviewIframeWhitelistSrc.concat(this.options.codeviewIframeWhitelistSrcBase);
                  value2 = value2.replace(/(<iframe.*?>.*?(?:<\/iframe>)?)/gi, function(tag) {
                    if (/<.+src(?==?('|"|\s)?)[\s\S]+src(?=('|"|\s)?)[^>]*?>/i.test(tag)) {
                      return "";
                    }
                    var _iterator = _createForOfIteratorHelper(whitelist), _step;
                    try {
                      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
                        var src = _step.value;
                        if (new RegExp('src="(https?:)?//' + src.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&") + '/(.+)"').test(tag)) {
                          return tag;
                        }
                      }
                    } catch (err) {
                      _iterator.e(err);
                    } finally {
                      _iterator.f();
                    }
                    return "";
                  });
                }
              }
              return value2;
            }
            /**
             * activate code view
             */
          }, {
            key: "activate",
            value: function activate() {
              var _this2 = this;
              var CodeMirror = this.CodeMirrorConstructor;
              this.$codable.val(dom.html(this.$editable, this.options.prettifyHtml));
              this.$codable.height(this.$editable.height());
              this.context.invoke("toolbar.updateCodeview", true);
              this.context.invoke("airPopover.updateCodeview", true);
              this.$editor.addClass("codeview");
              this.$codable.trigger("focus");
              if (CodeMirror) {
                var cmEditor = CodeMirror.fromTextArea(this.$codable[0], this.options.codemirror);
                if (this.options.codemirror.tern) {
                  var server = new CodeMirror.TernServer(this.options.codemirror.tern);
                  cmEditor.ternServer = server;
                  cmEditor.on("cursorActivity", function(cm) {
                    server.updateArgHints(cm);
                  });
                }
                cmEditor.on("blur", function(event) {
                  _this2.context.triggerEvent("blur.codeview", cmEditor.getValue(), event);
                });
                cmEditor.on("change", function() {
                  _this2.context.triggerEvent("change.codeview", cmEditor.getValue(), cmEditor);
                });
                cmEditor.setSize(null, this.$editable.outerHeight());
                this.$codable.data("cmEditor", cmEditor);
              } else {
                this.$codable.on("blur", function(event) {
                  _this2.context.triggerEvent("blur.codeview", _this2.$codable.val(), event);
                });
                this.$codable.on("input", function() {
                  _this2.context.triggerEvent("change.codeview", _this2.$codable.val(), _this2.$codable);
                });
              }
            }
            /**
             * deactivate code view
             */
          }, {
            key: "deactivate",
            value: function deactivate() {
              var CodeMirror = this.CodeMirrorConstructor;
              if (CodeMirror) {
                var cmEditor = this.$codable.data("cmEditor");
                this.$codable.val(cmEditor.getValue());
                cmEditor.toTextArea();
              }
              var value2 = this.purify(dom.value(this.$codable, this.options.prettifyHtml) || dom.emptyPara);
              var isChange = this.$editable.html() !== value2;
              this.$editable.html(value2);
              this.$editable.height(this.options.height ? this.$codable.height() : "auto");
              this.$editor.removeClass("codeview");
              if (isChange) {
                this.context.triggerEvent("change", this.$editable.html(), this.$editable);
              }
              this.$editable.trigger("focus");
              this.context.invoke("toolbar.updateCodeview", false);
              this.context.invoke("airPopover.updateCodeview", false);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              if (this.isActivated()) {
                this.deactivate();
              }
            }
          }]);
        }();
        function Statusbar_typeof(o2) {
          "@babel/helpers - typeof";
          return Statusbar_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Statusbar_typeof(o2);
        }
        function Statusbar_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Statusbar_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Statusbar_toPropertyKey(o2.key), o2);
          }
        }
        function Statusbar_createClass(e2, r2, t2) {
          return r2 && Statusbar_defineProperties(e2.prototype, r2), t2 && Statusbar_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Statusbar_toPropertyKey(t2) {
          var i = Statusbar_toPrimitive(t2, "string");
          return "symbol" == Statusbar_typeof(i) ? i : i + "";
        }
        function Statusbar_toPrimitive(t2, r2) {
          if ("object" != Statusbar_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Statusbar_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var EDITABLE_PADDING = 24;
        var Statusbar = /* @__PURE__ */ function() {
          function Statusbar2(context) {
            Statusbar_classCallCheck(this, Statusbar2);
            this.$document = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document);
            this.$statusbar = context.layoutInfo.statusbar;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.options = context.options;
          }
          return Statusbar_createClass(Statusbar2, [{
            key: "initialize",
            value: function initialize2() {
              var _this = this;
              if (this.options.airMode || this.options.disableResizeEditor) {
                this.destroy();
                return;
              }
              this.$statusbar.on("mousedown touchstart", function(event) {
                event.preventDefault();
                event.stopPropagation();
                var editableTop = _this.$editable.offset().top - _this.$document.scrollTop();
                var editableCodeTop = _this.$codable.offset().top - _this.$document.scrollTop();
                var onStatusbarMove = function onStatusbarMove2(event2) {
                  var originalEvent = event2.type == "mousemove" ? event2 : event2.originalEvent.touches[0];
                  var height = originalEvent.clientY - (editableTop + EDITABLE_PADDING);
                  var heightCode = originalEvent.clientY - (editableCodeTop + EDITABLE_PADDING);
                  height = _this.options.minheight > 0 ? Math.max(height, _this.options.minheight) : height;
                  height = _this.options.maxHeight > 0 ? Math.min(height, _this.options.maxHeight) : height;
                  heightCode = _this.options.minheight > 0 ? Math.max(heightCode, _this.options.minheight) : heightCode;
                  heightCode = _this.options.maxHeight > 0 ? Math.min(heightCode, _this.options.maxHeight) : heightCode;
                  _this.$editable.height(height);
                  _this.$codable.height(heightCode);
                };
                _this.$document.on("mousemove touchmove", onStatusbarMove).one("mouseup touchend", function() {
                  _this.$document.off("mousemove touchmove", onStatusbarMove);
                });
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$statusbar.off();
              this.$statusbar.addClass("locked");
            }
          }]);
        }();
        function Fullscreen_typeof(o2) {
          "@babel/helpers - typeof";
          return Fullscreen_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Fullscreen_typeof(o2);
        }
        function Fullscreen_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Fullscreen_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Fullscreen_toPropertyKey(o2.key), o2);
          }
        }
        function Fullscreen_createClass(e2, r2, t2) {
          return r2 && Fullscreen_defineProperties(e2.prototype, r2), t2 && Fullscreen_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Fullscreen_toPropertyKey(t2) {
          var i = Fullscreen_toPrimitive(t2, "string");
          return "symbol" == Fullscreen_typeof(i) ? i : i + "";
        }
        function Fullscreen_toPrimitive(t2, r2) {
          if ("object" != Fullscreen_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Fullscreen_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Fullscreen = /* @__PURE__ */ function() {
          function Fullscreen2(context) {
            var _this = this;
            Fullscreen_classCallCheck(this, Fullscreen2);
            this.context = context;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.$editable = context.layoutInfo.editable;
            this.$codable = context.layoutInfo.codable;
            this.$window = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(window);
            this.$scrollbar = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("html, body");
            this.scrollbarClassName = "note-fullscreen-body";
            this.onResize = function() {
              _this.resizeTo({
                h: _this.$window.height() - _this.$toolbar.outerHeight()
              });
            };
          }
          return Fullscreen_createClass(Fullscreen2, [{
            key: "resizeTo",
            value: function resizeTo(size) {
              this.$editable.css("height", size.h);
              this.$codable.css("height", size.h);
              if (this.$codable.data("cmeditor")) {
                this.$codable.data("cmeditor").setsize(null, size.h);
              }
            }
            /**
             * toggle fullscreen
             */
          }, {
            key: "toggle",
            value: function toggle2() {
              this.$editor.toggleClass("fullscreen");
              var isFullscreen = this.isFullscreen();
              this.$scrollbar.toggleClass(this.scrollbarClassName, isFullscreen);
              if (isFullscreen) {
                this.$editable.data("orgHeight", this.$editable.css("height"));
                this.$editable.data("orgMaxHeight", this.$editable.css("maxHeight"));
                this.$editable.css("maxHeight", "");
                this.$window.on("resize", this.onResize).trigger("resize");
              } else {
                this.$window.off("resize", this.onResize);
                this.resizeTo({
                  h: this.$editable.data("orgHeight")
                });
                this.$editable.css("maxHeight", this.$editable.css("orgMaxHeight"));
              }
              this.context.invoke("toolbar.updateFullscreen", isFullscreen);
            }
          }, {
            key: "isFullscreen",
            value: function isFullscreen() {
              return this.$editor.hasClass("fullscreen");
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$scrollbar.removeClass(this.scrollbarClassName);
            }
          }]);
        }();
        function Handle_typeof(o2) {
          "@babel/helpers - typeof";
          return Handle_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Handle_typeof(o2);
        }
        function Handle_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Handle_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Handle_toPropertyKey(o2.key), o2);
          }
        }
        function Handle_createClass(e2, r2, t2) {
          return r2 && Handle_defineProperties(e2.prototype, r2), t2 && Handle_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Handle_toPropertyKey(t2) {
          var i = Handle_toPrimitive(t2, "string");
          return "symbol" == Handle_typeof(i) ? i : i + "";
        }
        function Handle_toPrimitive(t2, r2) {
          if ("object" != Handle_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Handle_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Handle = /* @__PURE__ */ function() {
          function Handle2(context) {
            var _this = this;
            Handle_classCallCheck(this, Handle2);
            this.context = context;
            this.$document = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document);
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.events = {
              "summernote.mousedown": function summernoteMousedown(we2, e2) {
                if (_this.update(e2.target, e2)) {
                  e2.preventDefault();
                }
              },
              "summernote.keyup summernote.scroll summernote.change summernote.dialog.shown": function summernoteKeyupSummernoteScrollSummernoteChangeSummernoteDialogShown() {
                _this.update();
              },
              "summernote.disable summernote.blur": function summernoteDisableSummernoteBlur() {
                _this.hide();
              },
              "summernote.codeview.toggled": function summernoteCodeviewToggled() {
                _this.update();
              }
            };
          }
          return Handle_createClass(Handle2, [{
            key: "initialize",
            value: function initialize2() {
              var _this2 = this;
              this.$handle = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(['<div class="note-handle">', '<div class="note-control-selection">', '<div class="note-control-selection-bg"></div>', '<div class="note-control-holder note-control-nw"></div>', '<div class="note-control-holder note-control-ne"></div>', '<div class="note-control-holder note-control-sw"></div>', '<div class="', this.options.disableResizeImage ? "note-control-holder" : "note-control-sizing", ' note-control-se"></div>', this.options.disableResizeImage ? "" : '<div class="note-control-selection-info"></div>', "</div>", "</div>"].join("")).prependTo(this.$editingArea);
              this.$handle.on("mousedown", function(event) {
                if (dom.isControlSizing(event.target)) {
                  event.preventDefault();
                  event.stopPropagation();
                  var $target = _this2.$handle.find(".note-control-selection").data("target");
                  var posStart = $target.offset();
                  var scrollTop = _this2.$document.scrollTop();
                  var onMouseMove = function onMouseMove2(event2) {
                    _this2.context.invoke("editor.resizeTo", {
                      x: event2.clientX - posStart.left,
                      y: event2.clientY - (posStart.top - scrollTop)
                    }, $target, !event2.shiftKey);
                    _this2.update($target[0], event2);
                  };
                  _this2.$document.on("mousemove", onMouseMove).one("mouseup", function(e2) {
                    e2.preventDefault();
                    _this2.$document.off("mousemove", onMouseMove);
                    _this2.context.invoke("editor.afterCommand");
                  });
                  if (!$target.data("ratio")) {
                    $target.data("ratio", $target.height() / $target.width());
                  }
                }
              });
              this.$handle.on("wheel", function(event) {
                event.preventDefault();
                _this2.update();
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$handle.remove();
            }
          }, {
            key: "update",
            value: function update2(target, event) {
              if (this.context.isDisabled()) {
                return false;
              }
              var isImage = dom.isImg(target);
              var $selection = this.$handle.find(".note-control-selection");
              this.context.invoke("imagePopover.update", target, event);
              if (isImage) {
                var $image = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(target);
                var areaRect = this.$editingArea[0].getBoundingClientRect();
                var imageRect = target.getBoundingClientRect();
                $selection.css({
                  display: "block",
                  left: imageRect.left - areaRect.left,
                  top: imageRect.top - areaRect.top,
                  width: imageRect.width,
                  height: imageRect.height
                }).data("target", $image);
                var origImageObj = new Image();
                origImageObj.src = $image.attr("src");
                var sizingText = imageRect.width + "x" + imageRect.height + " (" + this.lang.image.original + ": " + origImageObj.width + "x" + origImageObj.height + ")";
                $selection.find(".note-control-selection-info").text(sizingText);
                this.context.invoke("editor.saveTarget", target);
              } else {
                this.hide();
              }
              return isImage;
            }
            /**
             * hide
             *
             * @param {jQuery} $handle
             */
          }, {
            key: "hide",
            value: function hide2() {
              this.context.invoke("editor.clearTarget");
              this.$handle.children().hide();
            }
          }]);
        }();
        function AutoLink_typeof(o2) {
          "@babel/helpers - typeof";
          return AutoLink_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, AutoLink_typeof(o2);
        }
        function AutoLink_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function AutoLink_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, AutoLink_toPropertyKey(o2.key), o2);
          }
        }
        function AutoLink_createClass(e2, r2, t2) {
          return r2 && AutoLink_defineProperties(e2.prototype, r2), t2 && AutoLink_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function AutoLink_toPropertyKey(t2) {
          var i = AutoLink_toPrimitive(t2, "string");
          return "symbol" == AutoLink_typeof(i) ? i : i + "";
        }
        function AutoLink_toPrimitive(t2, r2) {
          if ("object" != AutoLink_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != AutoLink_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var defaultScheme = "http://";
        var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\:[\/]{2}|tel:|mailto:[A-Z0-9._%+-]+@|xmpp:[A-Z0-9._%+-]+@)?(www\.)?(.+)$/i;
        var AutoLink = /* @__PURE__ */ function() {
          function AutoLink2(context) {
            var _this = this;
            AutoLink_classCallCheck(this, AutoLink2);
            this.context = context;
            this.options = context.options;
            this.$editable = context.layoutInfo.editable;
            this.events = {
              "summernote.keyup": function summernoteKeyup(we2, event) {
                if (!event.isDefaultPrevented()) {
                  _this.handleKeyup(event);
                }
              },
              "summernote.keydown": function summernoteKeydown(we2, event) {
                _this.handleKeydown(event);
              }
            };
          }
          return AutoLink_createClass(AutoLink2, [{
            key: "initialize",
            value: function initialize2() {
              this.lastWordRange = null;
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.lastWordRange = null;
            }
          }, {
            key: "replace",
            value: function replace2() {
              if (!this.lastWordRange) {
                return;
              }
              var keyword = this.lastWordRange.toString();
              var match = keyword.match(linkPattern);
              if (match && (match[1] || match[2])) {
                var link = match[1] ? keyword : defaultScheme + keyword;
                var urlText = this.options.showDomainOnlyForAutolink ? keyword.replace(/^(?:https?:\/\/)?(?:tel?:?)?(?:mailto?:?)?(?:xmpp?:?)?(?:www\.)?/i, "").split("/")[0] : keyword;
                var node = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<a></a>").html(urlText).attr("href", link)[0];
                if (this.context.options.linkTargetBlank) {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(node).attr("target", "_blank");
                }
                this.lastWordRange.insertNode(node);
                this.lastWordRange = null;
                this.context.invoke("editor.focus");
                this.context.triggerEvent("change", this.$editable.html(), this.$editable);
              }
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(event) {
              if (lists.contains([key.code.ENTER, key.code.SPACE], event.keyCode)) {
                var wordRange = this.context.invoke("editor.createRange").getWordRange();
                this.lastWordRange = wordRange;
              }
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(event) {
              if (key.code.SPACE === event.keyCode || key.code.ENTER === event.keyCode && !event.shiftKey) {
                this.replace();
              }
            }
          }]);
        }();
        function AutoSync_typeof(o2) {
          "@babel/helpers - typeof";
          return AutoSync_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, AutoSync_typeof(o2);
        }
        function AutoSync_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function AutoSync_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, AutoSync_toPropertyKey(o2.key), o2);
          }
        }
        function AutoSync_createClass(e2, r2, t2) {
          return r2 && AutoSync_defineProperties(e2.prototype, r2), t2 && AutoSync_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function AutoSync_toPropertyKey(t2) {
          var i = AutoSync_toPrimitive(t2, "string");
          return "symbol" == AutoSync_typeof(i) ? i : i + "";
        }
        function AutoSync_toPrimitive(t2, r2) {
          if ("object" != AutoSync_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != AutoSync_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var AutoSync = /* @__PURE__ */ function() {
          function AutoSync2(context) {
            var _this = this;
            AutoSync_classCallCheck(this, AutoSync2);
            this.$note = context.layoutInfo.note;
            this.events = {
              "summernote.change": function summernoteChange() {
                _this.$note.val(context.invoke("code"));
              }
            };
          }
          return AutoSync_createClass(AutoSync2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return dom.isTextarea(this.$note[0]);
            }
          }]);
        }();
        function AutoReplace_typeof(o2) {
          "@babel/helpers - typeof";
          return AutoReplace_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, AutoReplace_typeof(o2);
        }
        function AutoReplace_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function AutoReplace_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, AutoReplace_toPropertyKey(o2.key), o2);
          }
        }
        function AutoReplace_createClass(e2, r2, t2) {
          return r2 && AutoReplace_defineProperties(e2.prototype, r2), t2 && AutoReplace_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function AutoReplace_toPropertyKey(t2) {
          var i = AutoReplace_toPrimitive(t2, "string");
          return "symbol" == AutoReplace_typeof(i) ? i : i + "";
        }
        function AutoReplace_toPrimitive(t2, r2) {
          if ("object" != AutoReplace_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != AutoReplace_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var AutoReplace = /* @__PURE__ */ function() {
          function AutoReplace2(context) {
            var _this = this;
            AutoReplace_classCallCheck(this, AutoReplace2);
            this.context = context;
            this.options = context.options.replace || {};
            this.keys = [key.code.ENTER, key.code.SPACE, key.code.PERIOD, key.code.COMMA, key.code.SEMICOLON, key.code.SLASH];
            this.previousKeydownCode = null;
            this.events = {
              "summernote.keyup": function summernoteKeyup(we2, event) {
                if (!event.isDefaultPrevented()) {
                  _this.handleKeyup(event);
                }
              },
              "summernote.keydown": function summernoteKeydown(we2, event) {
                _this.handleKeydown(event);
              }
            };
          }
          return AutoReplace_createClass(AutoReplace2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !!this.options.match;
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              this.lastWord = null;
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.lastWord = null;
            }
          }, {
            key: "replace",
            value: function replace2() {
              if (!this.lastWord) {
                return;
              }
              var self2 = this;
              var keyword = this.lastWord.toString();
              this.options.match(keyword, function(match) {
                if (match) {
                  var node = "";
                  if (typeof match === "string") {
                    node = dom.createText(match);
                  } else if (match instanceof jQuery) {
                    node = match[0];
                  } else if (match instanceof Node) {
                    node = match;
                  }
                  if (!node)
                    return;
                  self2.lastWord.insertNode(node);
                  self2.lastWord = null;
                  self2.context.invoke("editor.focus");
                }
              });
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(event) {
              if (this.previousKeydownCode && lists.contains(this.keys, this.previousKeydownCode)) {
                this.previousKeydownCode = event.keyCode;
                return;
              }
              if (lists.contains(this.keys, event.keyCode)) {
                var wordRange = this.context.invoke("editor.createRange").getWordRange();
                this.lastWord = wordRange;
              }
              this.previousKeydownCode = event.keyCode;
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(event) {
              if (lists.contains(this.keys, event.keyCode)) {
                this.replace();
              }
            }
          }]);
        }();
        function Placeholder_typeof(o2) {
          "@babel/helpers - typeof";
          return Placeholder_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Placeholder_typeof(o2);
        }
        function Placeholder_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Placeholder_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Placeholder_toPropertyKey(o2.key), o2);
          }
        }
        function Placeholder_createClass(e2, r2, t2) {
          return r2 && Placeholder_defineProperties(e2.prototype, r2), t2 && Placeholder_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Placeholder_toPropertyKey(t2) {
          var i = Placeholder_toPrimitive(t2, "string");
          return "symbol" == Placeholder_typeof(i) ? i : i + "";
        }
        function Placeholder_toPrimitive(t2, r2) {
          if ("object" != Placeholder_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Placeholder_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Placeholder = /* @__PURE__ */ function() {
          function Placeholder2(context) {
            var _this = this;
            Placeholder_classCallCheck(this, Placeholder2);
            this.context = context;
            this.$editingArea = context.layoutInfo.editingArea;
            this.options = context.options;
            if (this.options.inheritPlaceholder === true) {
              this.options.placeholder = this.context.$note.attr("placeholder") || this.options.placeholder;
            }
            this.events = {
              "summernote.init summernote.change": function summernoteInitSummernoteChange() {
                _this.update();
              },
              "summernote.codeview.toggled": function summernoteCodeviewToggled() {
                _this.update();
              }
            };
          }
          return Placeholder_createClass(Placeholder2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !!this.options.placeholder;
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              var _this2 = this;
              this.$placeholder = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()('<div class="note-placeholder"></div>');
              this.$placeholder.on("click", function() {
                _this2.context.invoke("focus");
              }).html(this.options.placeholder).prependTo(this.$editingArea);
              this.update();
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$placeholder.remove();
            }
          }, {
            key: "update",
            value: function update2() {
              var isShow = !this.context.invoke("codeview.isActivated") && this.context.invoke("editor.isEmpty");
              this.$placeholder.toggle(isShow);
            }
          }]);
        }();
        function Buttons_typeof(o2) {
          "@babel/helpers - typeof";
          return Buttons_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Buttons_typeof(o2);
        }
        function Buttons_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Buttons_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Buttons_toPropertyKey(o2.key), o2);
          }
        }
        function Buttons_createClass(e2, r2, t2) {
          return r2 && Buttons_defineProperties(e2.prototype, r2), t2 && Buttons_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Buttons_toPropertyKey(t2) {
          var i = Buttons_toPrimitive(t2, "string");
          return "symbol" == Buttons_typeof(i) ? i : i + "";
        }
        function Buttons_toPrimitive(t2, r2) {
          if ("object" != Buttons_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Buttons_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Buttons2 = /* @__PURE__ */ function() {
          function Buttons3(context) {
            Buttons_classCallCheck(this, Buttons3);
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.context = context;
            this.$toolbar = context.layoutInfo.toolbar;
            this.options = context.options;
            this.lang = this.options.langInfo;
            this.invertedKeyMap = func.invertObject(this.options.keyMap[env.isMac ? "mac" : "pc"]);
          }
          return Buttons_createClass(Buttons3, [{
            key: "representShortcut",
            value: function representShortcut(editorMethod) {
              var shortcut = this.invertedKeyMap[editorMethod];
              if (!this.options.shortcuts || !shortcut) {
                return "";
              }
              if (env.isMac) {
                shortcut = shortcut.replace("CMD", "⌘").replace("SHIFT", "⇧");
              }
              shortcut = shortcut.replace("BACKSLASH", "\\").replace("SLASH", "/").replace("LEFTBRACKET", "[").replace("RIGHTBRACKET", "]");
              return " (" + shortcut + ")";
            }
          }, {
            key: "button",
            value: function button(o2) {
              if (!this.options.tooltip && o2.tooltip) {
                delete o2.tooltip;
              }
              o2.container = this.options.container;
              return this.ui.button(o2);
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              this.addToolbarButtons();
              this.addImagePopoverButtons();
              this.addLinkPopoverButtons();
              this.addTablePopoverButtons();
              this.fontInstalledMap = {};
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              delete this.fontInstalledMap;
            }
          }, {
            key: "isFontInstalled",
            value: function isFontInstalled(name2) {
              if (!Object.prototype.hasOwnProperty.call(this.fontInstalledMap, name2)) {
                this.fontInstalledMap[name2] = env.isFontInstalled(name2) || lists.contains(this.options.fontNamesIgnoreCheck, name2);
              }
              return this.fontInstalledMap[name2];
            }
          }, {
            key: "isFontDeservedToAdd",
            value: function isFontDeservedToAdd(name2) {
              name2 = name2.toLowerCase();
              return name2 !== "" && this.isFontInstalled(name2) && env.genericFontFamilies.indexOf(name2) === -1;
            }
          }, {
            key: "colorPalette",
            value: function colorPalette(className, tooltip, backColor, foreColor) {
              var _this = this;
              return this.ui.buttonGroup({
                className: "note-color " + className,
                children: [this.button({
                  className: "note-current-color-button",
                  contents: this.ui.icon(this.options.icons.font + " note-recent-color"),
                  tooltip,
                  click: function click(event) {
                    var $button = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.currentTarget);
                    if (backColor && foreColor) {
                      _this.context.invoke("editor.color", {
                        backColor: $button.attr("data-backColor"),
                        foreColor: $button.attr("data-foreColor")
                      });
                    } else if (backColor) {
                      _this.context.invoke("editor.color", {
                        backColor: $button.attr("data-backColor")
                      });
                    } else if (foreColor) {
                      _this.context.invoke("editor.color", {
                        foreColor: $button.attr("data-foreColor")
                      });
                    }
                  },
                  callback: function callback($button) {
                    var $recentColor = $button.find(".note-recent-color");
                    if (backColor) {
                      $recentColor.css("background-color", _this.options.colorButton.backColor);
                      $button.attr("data-backColor", _this.options.colorButton.backColor);
                    }
                    if (foreColor) {
                      $recentColor.css("color", _this.options.colorButton.foreColor);
                      $button.attr("data-foreColor", _this.options.colorButton.foreColor);
                    } else {
                      $recentColor.css("color", "transparent");
                    }
                  }
                }), this.button({
                  className: "dropdown-toggle",
                  contents: this.ui.dropdownButtonContents("", this.options),
                  tooltip: this.lang.color.more,
                  data: {
                    toggle: "dropdown"
                  }
                }), this.ui.dropdown({
                  items: (backColor ? ['<div class="note-palette">', '<div class="note-palette-title">' + this.lang.color.background + "</div>", "<div>", '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="backColor" data-value="transparent">', this.lang.color.transparent, "</button>", "</div>", '<div class="note-holder" data-event="backColor"><!-- back colors --></div>', "<div>", '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="backColorPicker-' + this.options.id + '">', this.lang.color.cpSelect, "</button>", '<input type="color" id="backColorPicker-' + this.options.id + '" class="note-btn note-color-select-btn" value="' + this.options.colorButton.backColor + '" data-event="backColorPalette-' + this.options.id + '">', "</div>", '<div class="note-holder-custom" id="backColorPalette-' + this.options.id + '" data-event="backColor"></div>', "</div>"].join("") : "") + (foreColor ? [
                    '<div class="note-palette">',
                    '<div class="note-palette-title">' + this.lang.color.foreground + "</div>",
                    "<div>",
                    '<button type="button" class="note-color-reset btn btn-light btn-default" data-event="removeFormat" data-value="foreColor">',
                    this.lang.color.resetToDefault,
                    "</button>",
                    "</div>",
                    '<div class="note-holder" data-event="foreColor"><!-- fore colors --></div>',
                    "<div>",
                    '<button type="button" class="note-color-select btn btn-light btn-default" data-event="openPalette" data-value="foreColorPicker-' + this.options.id + '">',
                    this.lang.color.cpSelect,
                    "</button>",
                    '<input type="color" id="foreColorPicker-' + this.options.id + '" class="note-btn note-color-select-btn" value="' + this.options.colorButton.foreColor + '" data-event="foreColorPalette-' + this.options.id + '">',
                    "</div>",
                    // Fix missing Div, Commented to find easily if it's wrong
                    '<div class="note-holder-custom" id="foreColorPalette-' + this.options.id + '" data-event="foreColor"></div>',
                    "</div>"
                  ].join("") : ""),
                  callback: function callback($dropdown) {
                    $dropdown.find(".note-holder").each(function(idx, item2) {
                      var $holder = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                      $holder.append(_this.ui.palette({
                        colors: _this.options.colors,
                        colorsName: _this.options.colorsName,
                        eventName: $holder.data("event"),
                        container: _this.options.container,
                        tooltip: _this.options.tooltip
                      }).render());
                    });
                    var customColors = [["#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF", "#FFFFFF"]];
                    $dropdown.find(".note-holder-custom").each(function(idx, item2) {
                      var $holder = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                      $holder.append(_this.ui.palette({
                        colors: customColors,
                        colorsName: customColors,
                        eventName: $holder.data("event"),
                        container: _this.options.container,
                        tooltip: _this.options.tooltip
                      }).render());
                    });
                    $dropdown.find("input[type=color]").each(function(idx, item2) {
                      external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2).on("change", function() {
                        var $chip = $dropdown.find("#" + external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this).data("event")).find(".note-color-btn").first();
                        var color = this.value.toUpperCase();
                        $chip.css("background-color", color).attr("aria-label", color).attr("data-value", color).attr("data-original-title", color);
                        $chip.trigger("click");
                      });
                    });
                  },
                  click: function click(event) {
                    event.stopPropagation();
                    var $parent = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("." + className).find(".note-dropdown-menu");
                    var $button = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.target);
                    var eventName = $button.data("event");
                    var value2 = $button.attr("data-value");
                    if (eventName === "openPalette") {
                      var $picker = $parent.find("#" + value2);
                      var $palette = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()($parent.find("#" + $picker.data("event")).find(".note-color-row")[0]);
                      var $chip = $palette.find(".note-color-btn").last().detach();
                      var color = $picker.val();
                      $chip.css("background-color", color).attr("aria-label", color).attr("data-value", color).attr("data-original-title", color);
                      $palette.prepend($chip);
                      $picker.trigger("click");
                    } else {
                      if (lists.contains(["backColor", "foreColor"], eventName)) {
                        var key2 = eventName === "backColor" ? "background-color" : "color";
                        var $color = $button.closest(".note-color").find(".note-recent-color");
                        var $currentButton = $button.closest(".note-color").find(".note-current-color-button");
                        $color.css(key2, value2);
                        $currentButton.attr("data-" + eventName, value2);
                      }
                      _this.context.invoke("editor." + eventName, value2);
                    }
                  }
                })]
              }).render();
            }
          }, {
            key: "addToolbarButtons",
            value: function addToolbarButtons() {
              var _this2 = this;
              this.context.memo("button.style", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.magic), _this2.options),
                  tooltip: _this2.lang.style.style,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdown({
                  className: "dropdown-style",
                  items: _this2.options.styleTags,
                  title: _this2.lang.style.style,
                  template: function template(item2) {
                    if (typeof item2 === "string") {
                      item2 = {
                        tag: item2,
                        title: Object.prototype.hasOwnProperty.call(_this2.lang.style, item2) ? _this2.lang.style[item2] : item2
                      };
                    }
                    var tag = item2.tag;
                    var title = item2.title;
                    var style = item2.style ? ' style="' + item2.style + '" ' : "";
                    var className = item2.className ? ' class="' + item2.className + '"' : "";
                    return "<" + tag + style + className + ">" + title + "</" + tag + ">";
                  },
                  click: _this2.context.createInvokeHandler("editor.formatBlock")
                })]).render();
              });
              var _loop = function _loop2() {
                var item2 = _this2.options.styleTags[styleIdx];
                _this2.context.memo("button.style." + item2, function() {
                  return _this2.button({
                    className: "note-btn-style-" + item2,
                    contents: '<div data-value="' + item2 + '">' + item2.toUpperCase() + "</div>",
                    tooltip: _this2.lang.style[item2],
                    click: _this2.context.createInvokeHandler("editor.formatBlock")
                  }).render();
                });
              };
              for (var styleIdx = 0, styleLen = this.options.styleTags.length; styleIdx < styleLen; styleIdx++) {
                _loop();
              }
              this.context.memo("button.bold", function() {
                return _this2.button({
                  className: "note-btn-bold",
                  contents: _this2.ui.icon(_this2.options.icons.bold),
                  tooltip: _this2.lang.font.bold + _this2.representShortcut("bold"),
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.bold")
                }).render();
              });
              this.context.memo("button.italic", function() {
                return _this2.button({
                  className: "note-btn-italic",
                  contents: _this2.ui.icon(_this2.options.icons.italic),
                  tooltip: _this2.lang.font.italic + _this2.representShortcut("italic"),
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.italic")
                }).render();
              });
              this.context.memo("button.underline", function() {
                return _this2.button({
                  className: "note-btn-underline",
                  contents: _this2.ui.icon(_this2.options.icons.underline),
                  tooltip: _this2.lang.font.underline + _this2.representShortcut("underline"),
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.underline")
                }).render();
              });
              this.context.memo("button.clear", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.eraser),
                  tooltip: _this2.lang.font.clear + _this2.representShortcut("removeFormat"),
                  click: _this2.context.createInvokeHandler("editor.removeFormat")
                }).render();
              });
              this.context.memo("button.strikethrough", function() {
                return _this2.button({
                  className: "note-btn-strikethrough",
                  contents: _this2.ui.icon(_this2.options.icons.strikethrough),
                  tooltip: _this2.lang.font.strikethrough + _this2.representShortcut("strikethrough"),
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.strikethrough")
                }).render();
              });
              this.context.memo("button.superscript", function() {
                return _this2.button({
                  className: "note-btn-superscript",
                  contents: _this2.ui.icon(_this2.options.icons.superscript),
                  tooltip: _this2.lang.font.superscript,
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.superscript")
                }).render();
              });
              this.context.memo("button.subscript", function() {
                return _this2.button({
                  className: "note-btn-subscript",
                  contents: _this2.ui.icon(_this2.options.icons.subscript),
                  tooltip: _this2.lang.font.subscript,
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.subscript")
                }).render();
              });
              this.context.memo("button.fontname", function() {
                var styleInfo = _this2.context.invoke("editor.currentStyle");
                if (_this2.options.addDefaultFonts) {
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(styleInfo["font-family"].split(","), function(idx, fontname) {
                    fontname = fontname.trim().replace(/['"]+/g, "");
                    if (_this2.isFontDeservedToAdd(fontname)) {
                      if (_this2.options.fontNames.indexOf(fontname) === -1) {
                        _this2.options.fontNames.push(fontname);
                      }
                    }
                  });
                }
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontname"></span>', _this2.options),
                  tooltip: _this2.lang.font.name,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdownCheck({
                  className: "dropdown-fontname",
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontNames.filter(_this2.isFontInstalled.bind(_this2)),
                  title: _this2.lang.font.name,
                  template: function template(item2) {
                    return '<span style="font-family: ' + env.validFontName(item2) + '">' + item2 + "</span>";
                  },
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.fontName")
                })]).render();
              });
              this.context.memo("button.fontsize", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsize"></span>', _this2.options),
                  tooltip: _this2.lang.font.size,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdownCheck({
                  className: "dropdown-fontsize",
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontSizes,
                  title: _this2.lang.font.size,
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.fontSize")
                })]).render();
              });
              this.context.memo("button.fontsizeunit", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents('<span class="note-current-fontsizeunit"></span>', _this2.options),
                  tooltip: _this2.lang.font.sizeunit,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdownCheck({
                  className: "dropdown-fontsizeunit",
                  checkClassName: _this2.options.icons.menuCheck,
                  items: _this2.options.fontSizeUnits,
                  title: _this2.lang.font.sizeunit,
                  click: _this2.context.createInvokeHandlerAndUpdateState("editor.fontSizeUnit")
                })]).render();
              });
              this.context.memo("button.color", function() {
                return _this2.colorPalette("note-color-all", _this2.lang.color.recent, true, true);
              });
              this.context.memo("button.forecolor", function() {
                return _this2.colorPalette("note-color-fore", _this2.lang.color.foreground, false, true);
              });
              this.context.memo("button.backcolor", function() {
                return _this2.colorPalette("note-color-back", _this2.lang.color.background, true, false);
              });
              this.context.memo("button.ul", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.unorderedlist),
                  tooltip: _this2.lang.lists.unordered + _this2.representShortcut("insertUnorderedList"),
                  click: _this2.context.createInvokeHandler("editor.insertUnorderedList")
                }).render();
              });
              this.context.memo("button.ol", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.orderedlist),
                  tooltip: _this2.lang.lists.ordered + _this2.representShortcut("insertOrderedList"),
                  click: _this2.context.createInvokeHandler("editor.insertOrderedList")
                }).render();
              });
              var justifyLeft = this.button({
                contents: this.ui.icon(this.options.icons.alignLeft),
                tooltip: this.lang.paragraph.left + this.representShortcut("justifyLeft"),
                click: this.context.createInvokeHandler("editor.justifyLeft")
              });
              var justifyCenter = this.button({
                contents: this.ui.icon(this.options.icons.alignCenter),
                tooltip: this.lang.paragraph.center + this.representShortcut("justifyCenter"),
                click: this.context.createInvokeHandler("editor.justifyCenter")
              });
              var justifyRight = this.button({
                contents: this.ui.icon(this.options.icons.alignRight),
                tooltip: this.lang.paragraph.right + this.representShortcut("justifyRight"),
                click: this.context.createInvokeHandler("editor.justifyRight")
              });
              var justifyFull = this.button({
                contents: this.ui.icon(this.options.icons.alignJustify),
                tooltip: this.lang.paragraph.justify + this.representShortcut("justifyFull"),
                click: this.context.createInvokeHandler("editor.justifyFull")
              });
              var outdent = this.button({
                contents: this.ui.icon(this.options.icons.outdent),
                tooltip: this.lang.paragraph.outdent + this.representShortcut("outdent"),
                click: this.context.createInvokeHandler("editor.outdent")
              });
              var indent = this.button({
                contents: this.ui.icon(this.options.icons.indent),
                tooltip: this.lang.paragraph.indent + this.representShortcut("indent"),
                click: this.context.createInvokeHandler("editor.indent")
              });
              this.context.memo("button.justifyLeft", func.invoke(justifyLeft, "render"));
              this.context.memo("button.justifyCenter", func.invoke(justifyCenter, "render"));
              this.context.memo("button.justifyRight", func.invoke(justifyRight, "render"));
              this.context.memo("button.justifyFull", func.invoke(justifyFull, "render"));
              this.context.memo("button.outdent", func.invoke(outdent, "render"));
              this.context.memo("button.indent", func.invoke(indent, "render"));
              this.context.memo("button.paragraph", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.alignLeft), _this2.options),
                  tooltip: _this2.lang.paragraph.paragraph,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdown([_this2.ui.buttonGroup({
                  className: "note-align",
                  children: [justifyLeft, justifyCenter, justifyRight, justifyFull]
                }), _this2.ui.buttonGroup({
                  className: "note-list",
                  children: [outdent, indent]
                })])]).render();
              });
              this.context.memo("button.height", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.textHeight), _this2.options),
                  tooltip: _this2.lang.font.height,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdownCheck({
                  items: _this2.options.lineHeights,
                  checkClassName: _this2.options.icons.menuCheck,
                  className: "dropdown-line-height",
                  title: _this2.lang.font.height,
                  click: _this2.context.createInvokeHandler("editor.lineHeight")
                })]).render();
              });
              this.context.memo("button.table", function() {
                return _this2.ui.buttonGroup([_this2.button({
                  className: "dropdown-toggle",
                  contents: _this2.ui.dropdownButtonContents(_this2.ui.icon(_this2.options.icons.table), _this2.options),
                  tooltip: _this2.lang.table.table,
                  data: {
                    toggle: "dropdown"
                  }
                }), _this2.ui.dropdown({
                  title: _this2.lang.table.table,
                  className: "note-table",
                  items: ['<div class="note-dimension-picker">', '<div class="note-dimension-picker-mousecatcher" data-event="insertTable" data-value="1x1"></div>', '<div class="note-dimension-picker-highlighted"></div>', '<div class="note-dimension-picker-unhighlighted"></div>', "</div>", '<div class="note-dimension-display">1 x 1</div>'].join("")
                })], {
                  callback: function callback($node) {
                    var $catcher = $node.find(".note-dimension-picker-mousecatcher");
                    $catcher.css({
                      width: _this2.options.insertTableMaxSize.col + "em",
                      height: _this2.options.insertTableMaxSize.row + "em"
                    }).on("mousedown", _this2.context.createInvokeHandler("editor.insertTable")).on("mousemove", _this2.tableMoveHandler.bind(_this2));
                  }
                }).render();
              });
              this.context.memo("button.link", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.link),
                  tooltip: _this2.lang.link.link + _this2.representShortcut("linkDialog.show"),
                  click: _this2.context.createInvokeHandler("linkDialog.show")
                }).render();
              });
              this.context.memo("button.picture", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.picture),
                  tooltip: _this2.lang.image.image,
                  click: _this2.context.createInvokeHandler("imageDialog.show")
                }).render();
              });
              this.context.memo("button.video", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.video),
                  tooltip: _this2.lang.video.video,
                  click: _this2.context.createInvokeHandler("videoDialog.show")
                }).render();
              });
              this.context.memo("button.hr", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.minus),
                  tooltip: _this2.lang.hr.insert + _this2.representShortcut("insertHorizontalRule"),
                  click: _this2.context.createInvokeHandler("editor.insertHorizontalRule")
                }).render();
              });
              this.context.memo("button.fullscreen", function() {
                return _this2.button({
                  className: "btn-fullscreen note-codeview-keep",
                  contents: _this2.ui.icon(_this2.options.icons.arrowsAlt),
                  tooltip: _this2.lang.options.fullscreen,
                  click: _this2.context.createInvokeHandler("fullscreen.toggle")
                }).render();
              });
              this.context.memo("button.codeview", function() {
                return _this2.button({
                  className: "btn-codeview note-codeview-keep",
                  contents: _this2.ui.icon(_this2.options.icons.code),
                  tooltip: _this2.lang.options.codeview,
                  click: _this2.context.createInvokeHandler("codeview.toggle")
                }).render();
              });
              this.context.memo("button.redo", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.redo),
                  tooltip: _this2.lang.history.redo + _this2.representShortcut("redo"),
                  click: _this2.context.createInvokeHandler("editor.redo")
                }).render();
              });
              this.context.memo("button.undo", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.undo),
                  tooltip: _this2.lang.history.undo + _this2.representShortcut("undo"),
                  click: _this2.context.createInvokeHandler("editor.undo")
                }).render();
              });
              this.context.memo("button.help", function() {
                return _this2.button({
                  contents: _this2.ui.icon(_this2.options.icons.question),
                  tooltip: _this2.lang.options.help,
                  click: _this2.context.createInvokeHandler("helpDialog.show")
                }).render();
              });
            }
            /**
             * image: [
             *   ['imageResize', ['resizeFull', 'resizeHalf', 'resizeQuarter', 'resizeNone']],
             *   ['float', ['floatLeft', 'floatRight', 'floatNone']],
             *   ['remove', ['removeMedia']],
             * ],
             */
          }, {
            key: "addImagePopoverButtons",
            value: function addImagePopoverButtons() {
              var _this3 = this;
              this.context.memo("button.resizeFull", function() {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">100%</span>',
                  tooltip: _this3.lang.image.resizeFull,
                  click: _this3.context.createInvokeHandler("editor.resize", "1")
                }).render();
              });
              this.context.memo("button.resizeHalf", function() {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">50%</span>',
                  tooltip: _this3.lang.image.resizeHalf,
                  click: _this3.context.createInvokeHandler("editor.resize", "0.5")
                }).render();
              });
              this.context.memo("button.resizeQuarter", function() {
                return _this3.button({
                  contents: '<span class="note-fontsize-10">25%</span>',
                  tooltip: _this3.lang.image.resizeQuarter,
                  click: _this3.context.createInvokeHandler("editor.resize", "0.25")
                }).render();
              });
              this.context.memo("button.resizeNone", function() {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.rollback),
                  tooltip: _this3.lang.image.resizeNone,
                  click: _this3.context.createInvokeHandler("editor.resize", "0")
                }).render();
              });
              this.context.memo("button.floatLeft", function() {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.floatLeft),
                  tooltip: _this3.lang.image.floatLeft,
                  click: _this3.context.createInvokeHandler("editor.floatMe", "left")
                }).render();
              });
              this.context.memo("button.floatRight", function() {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.floatRight),
                  tooltip: _this3.lang.image.floatRight,
                  click: _this3.context.createInvokeHandler("editor.floatMe", "right")
                }).render();
              });
              this.context.memo("button.floatNone", function() {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.rollback),
                  tooltip: _this3.lang.image.floatNone,
                  click: _this3.context.createInvokeHandler("editor.floatMe", "none")
                }).render();
              });
              this.context.memo("button.removeMedia", function() {
                return _this3.button({
                  contents: _this3.ui.icon(_this3.options.icons.trash),
                  tooltip: _this3.lang.image.remove,
                  click: _this3.context.createInvokeHandler("editor.removeMedia")
                }).render();
              });
            }
          }, {
            key: "addLinkPopoverButtons",
            value: function addLinkPopoverButtons() {
              var _this4 = this;
              this.context.memo("button.linkDialogShow", function() {
                return _this4.button({
                  contents: _this4.ui.icon(_this4.options.icons.link),
                  tooltip: _this4.lang.link.edit,
                  click: _this4.context.createInvokeHandler("linkDialog.show")
                }).render();
              });
              this.context.memo("button.unlink", function() {
                return _this4.button({
                  contents: _this4.ui.icon(_this4.options.icons.unlink),
                  tooltip: _this4.lang.link.unlink,
                  click: _this4.context.createInvokeHandler("editor.unlink")
                }).render();
              });
            }
            /**
             * table : [
             *  ['add', ['addRowDown', 'addRowUp', 'addColLeft', 'addColRight']],
             *  ['delete', ['deleteRow', 'deleteCol', 'deleteTable']]
             * ],
             */
          }, {
            key: "addTablePopoverButtons",
            value: function addTablePopoverButtons() {
              var _this5 = this;
              this.context.memo("button.addRowUp", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.rowAbove),
                  tooltip: _this5.lang.table.addRowAbove,
                  click: _this5.context.createInvokeHandler("editor.addRow", "top")
                }).render();
              });
              this.context.memo("button.addRowDown", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.rowBelow),
                  tooltip: _this5.lang.table.addRowBelow,
                  click: _this5.context.createInvokeHandler("editor.addRow", "bottom")
                }).render();
              });
              this.context.memo("button.addColLeft", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.colBefore),
                  tooltip: _this5.lang.table.addColLeft,
                  click: _this5.context.createInvokeHandler("editor.addCol", "left")
                }).render();
              });
              this.context.memo("button.addColRight", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.colAfter),
                  tooltip: _this5.lang.table.addColRight,
                  click: _this5.context.createInvokeHandler("editor.addCol", "right")
                }).render();
              });
              this.context.memo("button.deleteRow", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.rowRemove),
                  tooltip: _this5.lang.table.delRow,
                  click: _this5.context.createInvokeHandler("editor.deleteRow")
                }).render();
              });
              this.context.memo("button.deleteCol", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.colRemove),
                  tooltip: _this5.lang.table.delCol,
                  click: _this5.context.createInvokeHandler("editor.deleteCol")
                }).render();
              });
              this.context.memo("button.deleteTable", function() {
                return _this5.button({
                  className: "btn-md",
                  contents: _this5.ui.icon(_this5.options.icons.trash),
                  tooltip: _this5.lang.table.delTable,
                  click: _this5.context.createInvokeHandler("editor.deleteTable")
                }).render();
              });
            }
          }, {
            key: "build",
            value: function build($container, groups) {
              for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {
                var group = groups[groupIdx];
                var groupName = Array.isArray(group) ? group[0] : group;
                var buttons = Array.isArray(group) ? group.length === 1 ? [group[0]] : group[1] : [group];
                var $group = this.ui.buttonGroup({
                  className: "note-" + groupName
                }).render();
                for (var idx = 0, len = buttons.length; idx < len; idx++) {
                  var btn = this.context.memo("button." + buttons[idx]);
                  if (btn) {
                    $group.append(typeof btn === "function" ? btn(this.context) : btn);
                  }
                }
                $group.appendTo($container);
              }
            }
            /**
             * @param {jQuery} [$container]
             */
          }, {
            key: "updateCurrentStyle",
            value: function updateCurrentStyle($container) {
              var $cont = $container || this.$toolbar;
              var styleInfo = this.context.invoke("editor.currentStyle");
              this.updateBtnStates($cont, {
                ".note-btn-bold": function noteBtnBold() {
                  return styleInfo["font-bold"] === "bold";
                },
                ".note-btn-italic": function noteBtnItalic() {
                  return styleInfo["font-italic"] === "italic";
                },
                ".note-btn-underline": function noteBtnUnderline() {
                  return styleInfo["font-underline"] === "underline";
                },
                ".note-btn-subscript": function noteBtnSubscript() {
                  return styleInfo["font-subscript"] === "subscript";
                },
                ".note-btn-superscript": function noteBtnSuperscript() {
                  return styleInfo["font-superscript"] === "superscript";
                },
                ".note-btn-strikethrough": function noteBtnStrikethrough() {
                  return styleInfo["font-strikethrough"] === "strikethrough";
                }
              });
              if (styleInfo["font-family"]) {
                var fontNames = styleInfo["font-family"].split(",").map(function(name2) {
                  return name2.replace(/[\'\"]/g, "").replace(/\s+$/, "").replace(/^\s+/, "");
                });
                var fontName = lists.find(fontNames, this.isFontInstalled.bind(this));
                $cont.find(".dropdown-fontname a").each(function(idx, item2) {
                  var $item = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                  var isChecked = $item.data("value") + "" === fontName + "";
                  $item.toggleClass("checked", isChecked);
                });
                $cont.find(".note-current-fontname").text(fontName).css("font-family", fontName);
              }
              if (styleInfo["font-size"]) {
                var fontSize = styleInfo["font-size"];
                $cont.find(".dropdown-fontsize a").each(function(idx, item2) {
                  var $item = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                  var isChecked = $item.data("value") + "" === fontSize + "";
                  $item.toggleClass("checked", isChecked);
                });
                $cont.find(".note-current-fontsize").text(fontSize);
                var fontSizeUnit = styleInfo["font-size-unit"];
                $cont.find(".dropdown-fontsizeunit a").each(function(idx, item2) {
                  var $item = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                  var isChecked = $item.data("value") + "" === fontSizeUnit + "";
                  $item.toggleClass("checked", isChecked);
                });
                $cont.find(".note-current-fontsizeunit").text(fontSizeUnit);
              }
              if (styleInfo["line-height"]) {
                var lineHeight = styleInfo["line-height"];
                $cont.find(".dropdown-line-height a").each(function(idx, item2) {
                  var $item = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2);
                  var isChecked = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(item2).data("value") + "" === lineHeight + "";
                  $item.toggleClass("checked", isChecked);
                });
                $cont.find(".note-current-line-height").text(lineHeight);
              }
            }
          }, {
            key: "updateBtnStates",
            value: function updateBtnStates($container, infos) {
              var _this6 = this;
              external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(infos, function(selector, pred) {
                _this6.ui.toggleBtnActive($container.find(selector), pred());
              });
            }
          }, {
            key: "tableMoveHandler",
            value: function tableMoveHandler(event) {
              var PX_PER_EM = 18;
              var $picker = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.target.parentNode);
              var $dimensionDisplay = $picker.next();
              var $catcher = $picker.find(".note-dimension-picker-mousecatcher");
              var $highlighted = $picker.find(".note-dimension-picker-highlighted");
              var $unhighlighted = $picker.find(".note-dimension-picker-unhighlighted");
              var posOffset;
              if (event.offsetX === void 0) {
                var posCatcher = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.target).offset();
                posOffset = {
                  x: event.pageX - posCatcher.left,
                  y: event.pageY - posCatcher.top
                };
              } else {
                posOffset = {
                  x: event.offsetX,
                  y: event.offsetY
                };
              }
              var dim = {
                c: Math.ceil(posOffset.x / PX_PER_EM) || 1,
                r: Math.ceil(posOffset.y / PX_PER_EM) || 1
              };
              $highlighted.css({
                width: dim.c + "em",
                height: dim.r + "em"
              });
              $catcher.data("value", dim.c + "x" + dim.r);
              if (dim.c > 3 && dim.c < this.options.insertTableMaxSize.col) {
                $unhighlighted.css({
                  width: dim.c + 1 + "em"
                });
              }
              if (dim.r > 3 && dim.r < this.options.insertTableMaxSize.row) {
                $unhighlighted.css({
                  height: dim.r + 1 + "em"
                });
              }
              $dimensionDisplay.html(dim.c + " x " + dim.r);
            }
          }]);
        }();
        function Toolbar_typeof(o2) {
          "@babel/helpers - typeof";
          return Toolbar_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, Toolbar_typeof(o2);
        }
        function Toolbar_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function Toolbar_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, Toolbar_toPropertyKey(o2.key), o2);
          }
        }
        function Toolbar_createClass(e2, r2, t2) {
          return r2 && Toolbar_defineProperties(e2.prototype, r2), t2 && Toolbar_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function Toolbar_toPropertyKey(t2) {
          var i = Toolbar_toPrimitive(t2, "string");
          return "symbol" == Toolbar_typeof(i) ? i : i + "";
        }
        function Toolbar_toPrimitive(t2, r2) {
          if ("object" != Toolbar_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != Toolbar_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Toolbar = /* @__PURE__ */ function() {
          function Toolbar2(context) {
            Toolbar_classCallCheck(this, Toolbar2);
            this.context = context;
            this.$window = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(window);
            this.$document = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document);
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$note = context.layoutInfo.note;
            this.$editor = context.layoutInfo.editor;
            this.$toolbar = context.layoutInfo.toolbar;
            this.$editable = context.layoutInfo.editable;
            this.$statusbar = context.layoutInfo.statusbar;
            this.options = context.options;
            this.isFollowing = false;
            this.followScroll = this.followScroll.bind(this);
          }
          return Toolbar_createClass(Toolbar2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !this.options.airMode;
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              var _this = this;
              this.options.toolbar = this.options.toolbar || [];
              if (!this.options.toolbar.length) {
                this.$toolbar.hide();
              } else {
                this.context.invoke("buttons.build", this.$toolbar, this.options.toolbar);
              }
              if (this.options.toolbarContainer) {
                this.$toolbar.appendTo(this.options.toolbarContainer);
              }
              this.changeContainer(false);
              this.$note.on("summernote.keyup summernote.mouseup summernote.change", function() {
                _this.context.invoke("buttons.updateCurrentStyle");
              });
              this.context.invoke("buttons.updateCurrentStyle");
              if (this.options.followingToolbar) {
                this.$window.on("scroll resize", this.followScroll);
              }
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$toolbar.children().remove();
              if (this.options.followingToolbar) {
                this.$window.off("scroll resize", this.followScroll);
              }
            }
          }, {
            key: "followScroll",
            value: function followScroll() {
              if (this.$editor.hasClass("fullscreen")) {
                return false;
              }
              var editorHeight = this.$editor.outerHeight();
              var editorWidth = this.$editor.width();
              var toolbarHeight = this.$toolbar.height();
              var statusbarHeight = this.$statusbar.height();
              var otherBarHeight = 0;
              if (this.options.otherStaticBar) {
                otherBarHeight = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.otherStaticBar).outerHeight();
              }
              var currentOffset = this.$document.scrollTop();
              var editorOffsetTop = this.$editor.offset().top;
              var editorOffsetBottom = editorOffsetTop + editorHeight;
              var activateOffset = editorOffsetTop - otherBarHeight;
              var deactivateOffsetBottom = editorOffsetBottom - otherBarHeight - toolbarHeight - statusbarHeight;
              if (!this.isFollowing && currentOffset > activateOffset && currentOffset < deactivateOffsetBottom - toolbarHeight) {
                this.isFollowing = true;
                this.$editable.css({
                  marginTop: this.$toolbar.outerHeight()
                });
                this.$toolbar.css({
                  position: "fixed",
                  top: otherBarHeight,
                  width: editorWidth,
                  zIndex: 1e3
                });
              } else if (this.isFollowing && (currentOffset < activateOffset || currentOffset > deactivateOffsetBottom)) {
                this.isFollowing = false;
                this.$toolbar.css({
                  position: "relative",
                  top: 0,
                  width: "100%",
                  zIndex: "auto"
                });
                this.$editable.css({
                  marginTop: ""
                });
              }
            }
          }, {
            key: "changeContainer",
            value: function changeContainer(isFullscreen) {
              if (isFullscreen) {
                this.$toolbar.prependTo(this.$editor);
              } else {
                if (this.options.toolbarContainer) {
                  this.$toolbar.appendTo(this.options.toolbarContainer);
                }
              }
              if (this.options.followingToolbar) {
                this.followScroll();
              }
            }
          }, {
            key: "updateFullscreen",
            value: function updateFullscreen(isFullscreen) {
              this.ui.toggleBtnActive(this.$toolbar.find(".btn-fullscreen"), isFullscreen);
              this.changeContainer(isFullscreen);
            }
          }, {
            key: "updateCodeview",
            value: function updateCodeview(isCodeview) {
              this.ui.toggleBtnActive(this.$toolbar.find(".btn-codeview"), isCodeview);
              if (isCodeview) {
                this.deactivate();
              } else {
                this.activate();
              }
            }
          }, {
            key: "activate",
            value: function activate(isIncludeCodeview) {
              var $btn = this.$toolbar.find("button");
              if (!isIncludeCodeview) {
                $btn = $btn.not(".note-codeview-keep");
              }
              this.ui.toggleBtn($btn, true);
            }
          }, {
            key: "deactivate",
            value: function deactivate(isIncludeCodeview) {
              var $btn = this.$toolbar.find("button");
              if (!isIncludeCodeview) {
                $btn = $btn.not(".note-codeview-keep");
              }
              this.ui.toggleBtn($btn, false);
            }
          }]);
        }();
        function LinkDialog_typeof(o2) {
          "@babel/helpers - typeof";
          return LinkDialog_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, LinkDialog_typeof(o2);
        }
        function LinkDialog_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function LinkDialog_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, LinkDialog_toPropertyKey(o2.key), o2);
          }
        }
        function LinkDialog_createClass(e2, r2, t2) {
          return r2 && LinkDialog_defineProperties(e2.prototype, r2), t2 && LinkDialog_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function LinkDialog_toPropertyKey(t2) {
          var i = LinkDialog_toPrimitive(t2, "string");
          return "symbol" == LinkDialog_typeof(i) ? i : i + "";
        }
        function LinkDialog_toPrimitive(t2, r2) {
          if ("object" != LinkDialog_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != LinkDialog_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var LinkDialog_MAILTO_PATTERN = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        var LinkDialog_TEL_PATTERN = /^(\+?\d{1,3}[\s-]?)?(\d{1,4})[\s-]?(\d{1,4})[\s-]?(\d{1,4})$/;
        var LinkDialog_URL_SCHEME_PATTERN = /^([A-Za-z][A-Za-z0-9+-.]*\:|#|\/)/;
        var LinkDialog = /* @__PURE__ */ function() {
          function LinkDialog2(context) {
            LinkDialog_classCallCheck(this, LinkDialog2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$body = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
            context.memo("help.linkDialog.show", this.options.langInfo.help["linkDialog.show"]);
          }
          return LinkDialog_createClass(LinkDialog2, [{
            key: "initialize",
            value: function initialize2() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group">', '<label for="note-dialog-link-txt-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.link.textToDisplay, "</label>"), '<input id="note-dialog-link-txt-'.concat(this.options.id, '" class="note-link-text form-control note-form-control note-input" type="text"/>'), "</div>", '<div class="form-group note-form-group">', '<label for="note-dialog-link-url-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.link.url, "</label>"), '<input id="note-dialog-link-url-'.concat(this.options.id, '" class="note-link-url form-control note-form-control note-input" type="text" value="http://"/>'), "</div>", !this.options.disableLinkTarget ? external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<div></div>").append(this.ui.checkbox({
                className: "sn-checkbox-open-in-new-window",
                text: this.lang.link.openInNewWindow,
                checked: true
              }).render()).html() : ""].join("");
              var buttonClass = "btn btn-primary note-btn note-btn-primary note-link-btn";
              var footer = '<input type="button" href="#" class="'.concat(buttonClass, '" value="').concat(this.lang.link.insert, '" disabled>');
              this.$dialog = this.ui.dialog({
                className: "link-dialog",
                title: this.lang.link.insert,
                fade: this.options.dialogsFade,
                body,
                footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on("keypress", function(event) {
                if (event.keyCode === key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger("click");
                }
              });
            }
          }, {
            key: "checkLinkUrl",
            value: function checkLinkUrl(linkUrl) {
              if (LinkDialog_MAILTO_PATTERN.test(linkUrl)) {
                return "mailto://" + linkUrl;
              } else if (LinkDialog_TEL_PATTERN.test(linkUrl)) {
                return "tel://" + linkUrl;
              } else if (!LinkDialog_URL_SCHEME_PATTERN.test(linkUrl)) {
                return "http://" + linkUrl;
              }
              return linkUrl;
            }
          }, {
            key: "onCheckLinkUrl",
            value: function onCheckLinkUrl($input) {
              var _this = this;
              $input.on("blur", function(event) {
                event.target.value = event.target.value == "" ? "" : _this.checkLinkUrl(event.target.value);
              });
            }
            /**
             * toggle update button
             */
          }, {
            key: "toggleLinkBtn",
            value: function toggleLinkBtn($linkBtn, $linkText, $linkUrl) {
              this.ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());
            }
            /**
             * Show link dialog and set event handlers on dialog controls.
             *
             * @param {Object} linkInfo
             * @return {Promise}
             */
          }, {
            key: "showLinkDialog",
            value: function showLinkDialog(linkInfo) {
              var _this2 = this;
              return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
                var $linkText = _this2.$dialog.find(".note-link-text");
                var $linkUrl = _this2.$dialog.find(".note-link-url");
                var $linkBtn = _this2.$dialog.find(".note-link-btn");
                var $openInNewWindow = _this2.$dialog.find(".sn-checkbox-open-in-new-window input[type=checkbox]");
                _this2.ui.onDialogShown(_this2.$dialog, function() {
                  _this2.context.triggerEvent("dialog.shown");
                  if (!linkInfo.url && func.isValidUrl(linkInfo.text)) {
                    linkInfo.url = _this2.checkLinkUrl(linkInfo.text);
                  }
                  $linkText.on("input paste propertychange", function() {
                    var text2 = $linkText.val();
                    var div = document.createElement("div");
                    div.innerText = text2;
                    text2 = div.innerHTML;
                    linkInfo.text = text2;
                    _this2.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                  }).val(linkInfo.text);
                  $linkUrl.on("input paste propertychange", function() {
                    if (!linkInfo.text) {
                      $linkText.val($linkUrl.val());
                    }
                    _this2.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                  }).val(linkInfo.url);
                  if (!env.isSupportTouch) {
                    $linkUrl.trigger("focus");
                  }
                  _this2.toggleLinkBtn($linkBtn, $linkText, $linkUrl);
                  _this2.bindEnterKey($linkUrl, $linkBtn);
                  _this2.bindEnterKey($linkText, $linkBtn);
                  _this2.onCheckLinkUrl($linkUrl);
                  var isNewWindowChecked = linkInfo.isNewWindow !== void 0 ? linkInfo.isNewWindow : _this2.context.options.linkTargetBlank;
                  $openInNewWindow.prop("checked", isNewWindowChecked);
                  $linkBtn.one("click", function(event) {
                    event.preventDefault();
                    deferred.resolve({
                      range: linkInfo.range,
                      url: $linkUrl.val(),
                      text: $linkText.val(),
                      isNewWindow: $openInNewWindow.is(":checked")
                    });
                    _this2.ui.hideDialog(_this2.$dialog);
                  });
                });
                _this2.ui.onDialogHidden(_this2.$dialog, function() {
                  $linkText.off();
                  $linkUrl.off();
                  $linkBtn.off();
                  if (deferred.state() === "pending") {
                    deferred.reject();
                  }
                });
                _this2.ui.showDialog(_this2.$dialog);
              }).promise();
            }
            /**
             * @param {Object} layoutInfo
             */
          }, {
            key: "show",
            value: function show2() {
              var _this3 = this;
              var linkInfo = this.context.invoke("editor.getLinkInfo");
              this.context.invoke("editor.saveRange");
              this.showLinkDialog(linkInfo).then(function(linkInfo2) {
                _this3.context.invoke("editor.restoreRange");
                _this3.context.invoke("editor.createLink", linkInfo2);
              }).fail(function() {
                _this3.context.invoke("editor.restoreRange");
              });
            }
          }]);
        }();
        function LinkPopover_typeof(o2) {
          "@babel/helpers - typeof";
          return LinkPopover_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, LinkPopover_typeof(o2);
        }
        function LinkPopover_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function LinkPopover_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, LinkPopover_toPropertyKey(o2.key), o2);
          }
        }
        function LinkPopover_createClass(e2, r2, t2) {
          return r2 && LinkPopover_defineProperties(e2.prototype, r2), t2 && LinkPopover_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function LinkPopover_toPropertyKey(t2) {
          var i = LinkPopover_toPrimitive(t2, "string");
          return "symbol" == LinkPopover_typeof(i) ? i : i + "";
        }
        function LinkPopover_toPrimitive(t2, r2) {
          if ("object" != LinkPopover_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != LinkPopover_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var LinkPopover = /* @__PURE__ */ function() {
          function LinkPopover2(context) {
            var _this = this;
            LinkPopover_classCallCheck(this, LinkPopover2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.options = context.options;
            this.events = {
              "summernote.keyup summernote.mouseup summernote.change summernote.scroll": function summernoteKeyupSummernoteMouseupSummernoteChangeSummernoteScroll() {
                _this.update();
              },
              "summernote.disable summernote.dialog.shown": function summernoteDisableSummernoteDialogShown() {
                _this.hide();
              },
              "summernote.blur": function summernoteBlur(we2, event) {
                if (event.originalEvent && event.originalEvent.relatedTarget) {
                  if (!_this.$popover[0].contains(event.originalEvent.relatedTarget)) {
                    _this.hide();
                  }
                } else {
                  _this.hide();
                }
              }
            };
          }
          return LinkPopover_createClass(LinkPopover2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.link);
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              this.$popover = this.ui.popover({
                className: "note-link-popover",
                callback: function callback($node) {
                  var $content2 = $node.find(".popover-content,.note-popover-content");
                  $content2.prepend('<span><a target="_blank"></a>&nbsp;</span>');
                }
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find(".popover-content,.note-popover-content");
              this.context.invoke("buttons.build", $content, this.options.popover.link);
              this.$popover.on("mousedown", function(event) {
                event.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update2() {
              if (!this.context.invoke("editor.hasFocus")) {
                this.hide();
                return;
              }
              var rng = this.context.invoke("editor.getLastRange");
              if (rng.isCollapsed() && rng.isOnAnchor()) {
                var anchor = dom.ancestor(rng.sc, dom.isAnchor);
                var href = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(anchor).attr("href");
                this.$popover.find("a").attr("href", href).text(href);
                var pos = dom.posFromPlaceholder(anchor);
                var containerOffset = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.container).offset();
                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: "block",
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide2() {
              this.$popover.hide();
            }
          }]);
        }();
        function ImageDialog_typeof(o2) {
          "@babel/helpers - typeof";
          return ImageDialog_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, ImageDialog_typeof(o2);
        }
        function ImageDialog_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function ImageDialog_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, ImageDialog_toPropertyKey(o2.key), o2);
          }
        }
        function ImageDialog_createClass(e2, r2, t2) {
          return r2 && ImageDialog_defineProperties(e2.prototype, r2), t2 && ImageDialog_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function ImageDialog_toPropertyKey(t2) {
          var i = ImageDialog_toPrimitive(t2, "string");
          return "symbol" == ImageDialog_typeof(i) ? i : i + "";
        }
        function ImageDialog_toPrimitive(t2, r2) {
          if ("object" != ImageDialog_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != ImageDialog_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var ImageDialog = /* @__PURE__ */ function() {
          function ImageDialog2(context) {
            ImageDialog_classCallCheck(this, ImageDialog2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$body = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }
          return ImageDialog_createClass(ImageDialog2, [{
            key: "initialize",
            value: function initialize2() {
              var imageLimitation = "";
              if (this.options.maximumImageFileSize) {
                var unit = Math.floor(Math.log(this.options.maximumImageFileSize) / Math.log(1024));
                var readableSize = (this.options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 + " " + " KMGTP"[unit] + "B";
                imageLimitation = "<small>".concat(this.lang.image.maximumFileSize + " : " + readableSize, "</small>");
              }
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group note-group-select-from-files">', '<label for="note-dialog-image-file-' + this.options.id + '" class="note-form-label">' + this.lang.image.selectFromFiles + "</label>", '<input id="note-dialog-image-file-' + this.options.id + '" class="note-image-input form-control-file note-form-control note-input" ', ' type="file" name="files" accept="' + this.options.acceptImageFileTypes + '" multiple="multiple"/>', imageLimitation, "</div>", '<div class="form-group note-group-image-url">', '<label for="note-dialog-image-url-' + this.options.id + '" class="note-form-label">' + this.lang.image.url + "</label>", '<input id="note-dialog-image-url-' + this.options.id + '" class="note-image-url form-control note-form-control note-input" type="text"/>', "</div>"].join("");
              var buttonClass = "btn btn-primary note-btn note-btn-primary note-image-btn";
              var footer = '<input type="button" href="#" class="'.concat(buttonClass, '" value="').concat(this.lang.image.insert, '" disabled>');
              this.$dialog = this.ui.dialog({
                title: this.lang.image.insert,
                fade: this.options.dialogsFade,
                body,
                footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on("keypress", function(event) {
                if (event.keyCode === key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger("click");
                }
              });
            }
          }, {
            key: "show",
            value: function show2() {
              var _this = this;
              this.context.invoke("editor.saveRange");
              this.showImageDialog().then(function(data2) {
                _this.ui.hideDialog(_this.$dialog);
                _this.context.invoke("editor.restoreRange");
                if (typeof data2 === "string") {
                  if (_this.options.callbacks.onImageLinkInsert) {
                    _this.context.triggerEvent("image.link.insert", data2);
                  } else {
                    _this.context.invoke("editor.insertImage", data2);
                  }
                } else {
                  _this.context.invoke("editor.insertImagesOrCallback", data2);
                }
              }).fail(function() {
                _this.context.invoke("editor.restoreRange");
              });
            }
            /**
             * show image dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */
          }, {
            key: "showImageDialog",
            value: function showImageDialog() {
              var _this2 = this;
              return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
                var $imageInput = _this2.$dialog.find(".note-image-input");
                var $imageUrl = _this2.$dialog.find(".note-image-url");
                var $imageBtn = _this2.$dialog.find(".note-image-btn");
                _this2.ui.onDialogShown(_this2.$dialog, function() {
                  _this2.context.triggerEvent("dialog.shown");
                  $imageInput.replaceWith($imageInput.clone().on("change", function(event) {
                    deferred.resolve(event.target.files || event.target.value);
                  }).val(""));
                  $imageUrl.on("input paste propertychange", function() {
                    _this2.ui.toggleBtn($imageBtn, $imageUrl.val());
                  }).val("");
                  if (!env.isSupportTouch) {
                    $imageUrl.trigger("focus");
                  }
                  $imageBtn.on("click", function(event) {
                    event.preventDefault();
                    deferred.resolve($imageUrl.val());
                  });
                  _this2.bindEnterKey($imageUrl, $imageBtn);
                });
                _this2.ui.onDialogHidden(_this2.$dialog, function() {
                  $imageInput.off();
                  $imageUrl.off();
                  $imageBtn.off();
                  if (deferred.state() === "pending") {
                    deferred.reject();
                  }
                });
                _this2.ui.showDialog(_this2.$dialog);
              });
            }
          }]);
        }();
        function ImagePopover_typeof(o2) {
          "@babel/helpers - typeof";
          return ImagePopover_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, ImagePopover_typeof(o2);
        }
        function ImagePopover_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function ImagePopover_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, ImagePopover_toPropertyKey(o2.key), o2);
          }
        }
        function ImagePopover_createClass(e2, r2, t2) {
          return r2 && ImagePopover_defineProperties(e2.prototype, r2), t2 && ImagePopover_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function ImagePopover_toPropertyKey(t2) {
          var i = ImagePopover_toPrimitive(t2, "string");
          return "symbol" == ImagePopover_typeof(i) ? i : i + "";
        }
        function ImagePopover_toPrimitive(t2, r2) {
          if ("object" != ImagePopover_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != ImagePopover_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var ImagePopover = /* @__PURE__ */ function() {
          function ImagePopover2(context) {
            var _this = this;
            ImagePopover_classCallCheck(this, ImagePopover2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.editable = context.layoutInfo.editable[0];
            this.options = context.options;
            this.events = {
              "summernote.disable summernote.dialog.shown": function summernoteDisableSummernoteDialogShown() {
                _this.hide();
              },
              "summernote.blur": function summernoteBlur(we2, event) {
                if (event.originalEvent && event.originalEvent.relatedTarget) {
                  if (!_this.$popover[0].contains(event.originalEvent.relatedTarget)) {
                    _this.hide();
                  }
                } else {
                  _this.hide();
                }
              }
            };
          }
          return ImagePopover_createClass(ImagePopover2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.image);
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              this.$popover = this.ui.popover({
                className: "note-image-popover"
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find(".popover-content,.note-popover-content");
              this.context.invoke("buttons.build", $content, this.options.popover.image);
              this.$popover.on("mousedown", function(event) {
                event.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update2(target, event) {
              if (dom.isImg(target)) {
                var position2 = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(target).offset();
                var containerOffset = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.container).offset();
                var pos = {};
                if (this.options.popatmouse) {
                  pos.left = event.pageX - 20;
                  pos.top = event.pageY;
                } else {
                  pos = position2;
                }
                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: "block",
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide2() {
              this.$popover.hide();
            }
          }]);
        }();
        function TablePopover_typeof(o2) {
          "@babel/helpers - typeof";
          return TablePopover_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, TablePopover_typeof(o2);
        }
        function TablePopover_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function TablePopover_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, TablePopover_toPropertyKey(o2.key), o2);
          }
        }
        function TablePopover_createClass(e2, r2, t2) {
          return r2 && TablePopover_defineProperties(e2.prototype, r2), t2 && TablePopover_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function TablePopover_toPropertyKey(t2) {
          var i = TablePopover_toPrimitive(t2, "string");
          return "symbol" == TablePopover_typeof(i) ? i : i + "";
        }
        function TablePopover_toPrimitive(t2, r2) {
          if ("object" != TablePopover_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != TablePopover_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var TablePopover = /* @__PURE__ */ function() {
          function TablePopover2(context) {
            var _this = this;
            TablePopover_classCallCheck(this, TablePopover2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.options = context.options;
            this.events = {
              "summernote.mousedown": function summernoteMousedown(we2, event) {
                _this.update(event.target);
              },
              "summernote.keyup summernote.scroll summernote.change": function summernoteKeyupSummernoteScrollSummernoteChange() {
                _this.update();
              },
              "summernote.disable summernote.dialog.shown": function summernoteDisableSummernoteDialogShown() {
                _this.hide();
              },
              "summernote.blur": function summernoteBlur(we2, event) {
                if (event.originalEvent && event.originalEvent.relatedTarget) {
                  if (!_this.$popover[0].contains(event.originalEvent.relatedTarget)) {
                    _this.hide();
                  }
                } else {
                  _this.hide();
                }
              }
            };
          }
          return TablePopover_createClass(TablePopover2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return !lists.isEmpty(this.options.popover.table);
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              this.$popover = this.ui.popover({
                className: "note-table-popover"
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find(".popover-content,.note-popover-content");
              this.context.invoke("buttons.build", $content, this.options.popover.table);
              if (env.isFF) {
                document.execCommand("enableInlineTableEditing", false, false);
              }
              this.$popover.on("mousedown", function(event) {
                event.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update2(target) {
              if (this.context.isDisabled()) {
                return false;
              }
              var isCell2 = dom.isCell(target) || dom.isCell(target === null || target === void 0 ? void 0 : target.parentElement);
              if (isCell2) {
                var pos = dom.posFromPlaceholder(target);
                var containerOffset = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.container).offset();
                pos.top -= containerOffset.top;
                pos.left -= containerOffset.left;
                this.$popover.css({
                  display: "block",
                  left: pos.left,
                  top: pos.top
                });
              } else {
                this.hide();
              }
              return isCell2;
            }
          }, {
            key: "hide",
            value: function hide2() {
              this.$popover.hide();
            }
          }]);
        }();
        function VideoDialog_typeof(o2) {
          "@babel/helpers - typeof";
          return VideoDialog_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, VideoDialog_typeof(o2);
        }
        function VideoDialog_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function VideoDialog_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, VideoDialog_toPropertyKey(o2.key), o2);
          }
        }
        function VideoDialog_createClass(e2, r2, t2) {
          return r2 && VideoDialog_defineProperties(e2.prototype, r2), t2 && VideoDialog_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function VideoDialog_toPropertyKey(t2) {
          var i = VideoDialog_toPrimitive(t2, "string");
          return "symbol" == VideoDialog_typeof(i) ? i : i + "";
        }
        function VideoDialog_toPrimitive(t2, r2) {
          if ("object" != VideoDialog_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != VideoDialog_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var VideoDialog = /* @__PURE__ */ function() {
          function VideoDialog2(context) {
            VideoDialog_classCallCheck(this, VideoDialog2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$body = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }
          return VideoDialog_createClass(VideoDialog2, [{
            key: "initialize",
            value: function initialize2() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<div class="form-group note-form-group row-fluid">', '<label for="note-dialog-video-url-'.concat(this.options.id, '" class="note-form-label">').concat(this.lang.video.url, ' <small class="text-muted">').concat(this.lang.video.providers, "</small></label>"), '<input id="note-dialog-video-url-'.concat(this.options.id, '" class="note-video-url form-control note-form-control note-input" type="text"/>'), "</div>"].join("");
              var buttonClass = "btn btn-primary note-btn note-btn-primary note-video-btn";
              var footer = '<input type="button" href="#" class="'.concat(buttonClass, '" value="').concat(this.lang.video.insert, '" disabled>');
              this.$dialog = this.ui.dialog({
                title: this.lang.video.insert,
                fade: this.options.dialogsFade,
                body,
                footer
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "bindEnterKey",
            value: function bindEnterKey($input, $btn) {
              $input.on("keypress", function(event) {
                if (event.keyCode === key.code.ENTER) {
                  event.preventDefault();
                  $btn.trigger("click");
                }
              });
            }
          }, {
            key: "createVideoNode",
            value: function createVideoNode(url) {
              var ytRegExp = /(?:youtu\.be\/|youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=|shorts\/|live\/))([^&\n?]+)(?:.*[?&]t=([^&\n]+))?.*/;
              var ytRegExpForStart = /^(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/;
              var ytMatch = url.match(ytRegExp);
              var gdRegExp = /(?:\.|\/\/)drive\.google\.com\/file\/d\/(.[a-zA-Z0-9_-]*)\/view/;
              var gdMatch = url.match(gdRegExp);
              var igRegExp = /(?:www\.|\/\/)instagram\.com\/(reel|p)\/(.[a-zA-Z0-9_-]*)/;
              var igMatch = url.match(igRegExp);
              var vRegExp = /\/\/vine\.co\/v\/([a-zA-Z0-9]+)/;
              var vMatch = url.match(vRegExp);
              var vimRegExp = /\/\/(player\.)?vimeo\.com\/([a-z]*\/)*(\d+)[?]?.*/;
              var vimMatch = url.match(vimRegExp);
              var dmRegExp = /.+dailymotion.com\/(video|hub)\/([^_]+)[^#]*(#video=([^_&]+))?/;
              var dmMatch = url.match(dmRegExp);
              var youkuRegExp = /\/\/v\.youku\.com\/v_show\/id_(\w+)=*\.html/;
              var youkuMatch = url.match(youkuRegExp);
              var peerTubeRegExp = /\/\/(.*)\/videos\/watch\/([^?]*)(?:\?(?:start=(\w*))?(?:&stop=(\w*))?(?:&loop=([10]))?(?:&autoplay=([10]))?(?:&muted=([10]))?)?/;
              var peerTubeMatch = url.match(peerTubeRegExp);
              var qqRegExp = /\/\/v\.qq\.com.*?vid=(.+)/;
              var qqMatch = url.match(qqRegExp);
              var qqRegExp2 = /\/\/v\.qq\.com\/x?\/?(page|cover).*?\/([^\/]+)\.html\??.*/;
              var qqMatch2 = url.match(qqRegExp2);
              var mp4RegExp = /^.+.(mp4|m4v)$/;
              var mp4Match = url.match(mp4RegExp);
              var oggRegExp = /^.+.(ogg|ogv)$/;
              var oggMatch = url.match(oggRegExp);
              var webmRegExp = /^.+.(webm)$/;
              var webmMatch = url.match(webmRegExp);
              var fbRegExp = /(?:www\.|\/\/)facebook\.com\/([^\/]+)\/videos\/([0-9]+)/;
              var fbMatch = url.match(fbRegExp);
              var $video;
              if (ytMatch && ytMatch[1].length === 11) {
                var youtubeId = ytMatch[1];
                var start2 = 0;
                if (typeof ytMatch[2] !== "undefined") {
                  var ytMatchForStart = ytMatch[2].match(ytRegExpForStart);
                  if (ytMatchForStart) {
                    for (var n2 = [3600, 60, 1], i = 0, r2 = n2.length; i < r2; i++) {
                      start2 += typeof ytMatchForStart[i + 1] !== "undefined" ? n2[i] * parseInt(ytMatchForStart[i + 1], 10) : 0;
                    }
                  } else {
                    start2 = parseInt(ytMatch[2], 10);
                  }
                }
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", "//www.youtube.com/embed/" + youtubeId + (start2 > 0 ? "?start=" + start2 : "")).attr("width", "640").attr("height", "360");
              } else if (gdMatch && gdMatch[0].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", "https://drive.google.com/file/d/" + gdMatch[1] + "/preview").attr("width", "640").attr("height", "480");
              } else if (igMatch && igMatch[0].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", "https://instagram.com/p/" + igMatch[2] + "/embed/").attr("width", "612").attr("height", "710").attr("scrolling", "no").attr("allowtransparency", "true");
              } else if (vMatch && vMatch[0].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", vMatch[0] + "/embed/simple").attr("width", "600").attr("height", "600").attr("class", "vine-embed");
              } else if (vimMatch && vimMatch[3].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("src", "//player.vimeo.com/video/" + vimMatch[3]).attr("width", "640").attr("height", "360");
              } else if (dmMatch && dmMatch[2].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", "//www.dailymotion.com/embed/video/" + dmMatch[2]).attr("width", "640").attr("height", "360");
              } else if (youkuMatch && youkuMatch[1].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "498").attr("width", "510").attr("src", "//player.youku.com/embed/" + youkuMatch[1]);
              } else if (peerTubeMatch && peerTubeMatch[0].length) {
                var begin = 0;
                if (peerTubeMatch[2] !== "undefined")
                  begin = peerTubeMatch[2];
                var end2 = 0;
                if (peerTubeMatch[3] !== "undefined")
                  end2 = peerTubeMatch[3];
                var loop = 0;
                if (peerTubeMatch[4] !== "undefined")
                  loop = peerTubeMatch[4];
                var autoplay = 0;
                if (peerTubeMatch[5] !== "undefined")
                  autoplay = peerTubeMatch[5];
                var muted = 0;
                if (peerTubeMatch[6] !== "undefined")
                  muted = peerTubeMatch[6];
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()('<iframe allowfullscreen sandbox="allow-same-origin allow-scripts allow-popups">').attr("frameborder", 0).attr("src", "//" + peerTubeMatch[1] + "/videos/embed/" + peerTubeMatch[2] + "?loop=" + loop + "&autoplay=" + autoplay + "&muted=" + muted + (begin > 0 ? "&start=" + begin : "") + (end2 > 0 ? "&end=" + start2 : "")).attr("width", "560").attr("height", "315");
              } else if (qqMatch && qqMatch[1].length || qqMatch2 && qqMatch2[2].length) {
                var vid = qqMatch && qqMatch[1].length ? qqMatch[1] : qqMatch2[2];
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>").attr("frameborder", 0).attr("height", "310").attr("width", "500").attr("src", "https://v.qq.com/txp/iframe/player.html?vid=" + vid + "&amp;auto=0");
              } else if (mp4Match || oggMatch || webmMatch) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<video controls>").attr("src", url).attr("width", "640").attr("height", "360");
              } else if (fbMatch && fbMatch[0].length) {
                $video = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<iframe>").attr("frameborder", 0).attr("src", "https://www.facebook.com/plugins/video.php?href=" + encodeURIComponent(fbMatch[0]) + "&show_text=0&width=560").attr("width", "560").attr("height", "301").attr("scrolling", "no").attr("allowtransparency", "true");
              } else {
                return false;
              }
              $video.addClass("note-video-clip");
              return $video[0];
            }
          }, {
            key: "show",
            value: function show2() {
              var _this = this;
              var text2 = this.context.invoke("editor.getSelectedText");
              this.context.invoke("editor.saveRange");
              this.showVideoDialog(text2).then(function(url) {
                _this.ui.hideDialog(_this.$dialog);
                _this.context.invoke("editor.restoreRange");
                var $node = _this.createVideoNode(url);
                if ($node) {
                  _this.context.invoke("editor.insertNode", $node);
                }
              }).fail(function() {
                _this.context.invoke("editor.restoreRange");
              });
            }
            /**
             * show video dialog
             *
             * @param {jQuery} $dialog
             * @return {Promise}
             */
          }, {
            key: "showVideoDialog",
            value: function showVideoDialog() {
              var _this2 = this;
              return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
                var $videoUrl = _this2.$dialog.find(".note-video-url");
                var $videoBtn = _this2.$dialog.find(".note-video-btn");
                _this2.ui.onDialogShown(_this2.$dialog, function() {
                  _this2.context.triggerEvent("dialog.shown");
                  $videoUrl.on("input paste propertychange", function() {
                    _this2.ui.toggleBtn($videoBtn, $videoUrl.val());
                  });
                  if (!env.isSupportTouch) {
                    $videoUrl.trigger("focus");
                  }
                  $videoBtn.on("click", function(event) {
                    event.preventDefault();
                    deferred.resolve($videoUrl.val());
                  });
                  _this2.bindEnterKey($videoUrl, $videoBtn);
                });
                _this2.ui.onDialogHidden(_this2.$dialog, function() {
                  $videoUrl.off();
                  $videoBtn.off();
                  if (deferred.state() === "pending") {
                    deferred.reject();
                  }
                });
                _this2.ui.showDialog(_this2.$dialog);
              });
            }
          }]);
        }();
        function HelpDialog_typeof(o2) {
          "@babel/helpers - typeof";
          return HelpDialog_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, HelpDialog_typeof(o2);
        }
        function HelpDialog_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function HelpDialog_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, HelpDialog_toPropertyKey(o2.key), o2);
          }
        }
        function HelpDialog_createClass(e2, r2, t2) {
          return r2 && HelpDialog_defineProperties(e2.prototype, r2), t2 && HelpDialog_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function HelpDialog_toPropertyKey(t2) {
          var i = HelpDialog_toPrimitive(t2, "string");
          return "symbol" == HelpDialog_typeof(i) ? i : i + "";
        }
        function HelpDialog_toPrimitive(t2, r2) {
          if ("object" != HelpDialog_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != HelpDialog_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var HelpDialog = /* @__PURE__ */ function() {
          function HelpDialog2(context) {
            HelpDialog_classCallCheck(this, HelpDialog2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$body = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(document.body);
            this.$editor = context.layoutInfo.editor;
            this.options = context.options;
            this.lang = this.options.langInfo;
          }
          return HelpDialog_createClass(HelpDialog2, [{
            key: "initialize",
            value: function initialize2() {
              var $container = this.options.dialogsInBody ? this.$body : this.options.container;
              var body = ['<p class="text-center">', '<a href="http://summernote.org/" target="_blank" rel="noopener noreferrer">Summernote 0.9.1</a> · ', '<a href="https://github.com/summernote/summernote" target="_blank" rel="noopener noreferrer">Project</a> · ', '<a href="https://github.com/summernote/summernote/issues" target="_blank" rel="noopener noreferrer">Issues</a>', "</p>"].join("");
              this.$dialog = this.ui.dialog({
                title: this.lang.options.help,
                fade: this.options.dialogsFade,
                body: this.createShortcutList(),
                footer: body,
                callback: function callback($node) {
                  $node.find(".modal-body,.note-modal-body").css({
                    "max-height": 300,
                    "overflow": "scroll"
                  });
                }
              }).render().appendTo($container);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.ui.hideDialog(this.$dialog);
              this.$dialog.remove();
            }
          }, {
            key: "createShortcutList",
            value: function createShortcutList() {
              var _this = this;
              var keyMap = this.options.keyMap[env.isMac ? "mac" : "pc"];
              return Object.keys(keyMap).map(function(key2) {
                var command = keyMap[key2];
                var $row = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()('<div><div class="help-list-item"></div></div>');
                $row.append(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<label><kbd>" + key2 + "</kdb></label>").css({
                  "width": 180,
                  "margin-right": 10
                })).append(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()("<span></span>").html(_this.context.memo("help." + command) || command));
                return $row.html();
              }).join("");
            }
            /**
             * show help dialog
             *
             * @return {Promise}
             */
          }, {
            key: "showHelpDialog",
            value: function showHelpDialog() {
              var _this2 = this;
              return external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().Deferred(function(deferred) {
                _this2.ui.onDialogShown(_this2.$dialog, function() {
                  _this2.context.triggerEvent("dialog.shown");
                  deferred.resolve();
                });
                _this2.ui.showDialog(_this2.$dialog);
              }).promise();
            }
          }, {
            key: "show",
            value: function show2() {
              var _this3 = this;
              this.context.invoke("editor.saveRange");
              this.showHelpDialog().then(function() {
                _this3.context.invoke("editor.restoreRange");
              });
            }
          }]);
        }();
        function AirPopover_typeof(o2) {
          "@babel/helpers - typeof";
          return AirPopover_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, AirPopover_typeof(o2);
        }
        function AirPopover_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function AirPopover_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, AirPopover_toPropertyKey(o2.key), o2);
          }
        }
        function AirPopover_createClass(e2, r2, t2) {
          return r2 && AirPopover_defineProperties(e2.prototype, r2), t2 && AirPopover_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function AirPopover_toPropertyKey(t2) {
          var i = AirPopover_toPrimitive(t2, "string");
          return "symbol" == AirPopover_typeof(i) ? i : i + "";
        }
        function AirPopover_toPrimitive(t2, r2) {
          if ("object" != AirPopover_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != AirPopover_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var AIRMODE_POPOVER_X_OFFSET = -5;
        var AIRMODE_POPOVER_Y_OFFSET = 5;
        var AirPopover = /* @__PURE__ */ function() {
          function AirPopover2(context) {
            var _this = this;
            AirPopover_classCallCheck(this, AirPopover2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.options = context.options;
            this.hidable = true;
            this.onContextmenu = false;
            this.pageX = null;
            this.pageY = null;
            this.events = {
              "summernote.contextmenu": function summernoteContextmenu(event) {
                if (_this.options.editing) {
                  event.preventDefault();
                  event.stopPropagation();
                  _this.onContextmenu = true;
                  _this.update(true);
                }
              },
              "summernote.mousedown": function summernoteMousedown(we2, event) {
                _this.pageX = event.pageX;
                _this.pageY = event.pageY;
              },
              "summernote.keyup summernote.mouseup summernote.scroll": function summernoteKeyupSummernoteMouseupSummernoteScroll(we2, event) {
                if (_this.options.editing && !_this.onContextmenu) {
                  if (event.type == "keyup") {
                    var range2 = _this.context.invoke("editor.getLastRange");
                    var wordRange = range2.getWordRange();
                    var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                    _this.pageX = bnd.left;
                    _this.pageY = bnd.top;
                  } else {
                    _this.pageX = event.pageX;
                    _this.pageY = event.pageY;
                  }
                  _this.update();
                }
                _this.onContextmenu = false;
              },
              "summernote.disable summernote.change summernote.dialog.shown summernote.blur": function summernoteDisableSummernoteChangeSummernoteDialogShownSummernoteBlur() {
                _this.hide();
              },
              "summernote.focusout": function summernoteFocusout() {
                if (!_this.$popover.is(":active,:focus")) {
                  _this.hide();
                }
              }
            };
          }
          return AirPopover_createClass(AirPopover2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return this.options.airMode && !lists.isEmpty(this.options.popover.air);
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              var _this2 = this;
              this.$popover = this.ui.popover({
                className: "note-air-popover"
              }).render().appendTo(this.options.container);
              var $content = this.$popover.find(".popover-content");
              this.context.invoke("buttons.build", $content, this.options.popover.air);
              this.$popover.on("mousedown", function() {
                _this2.hidable = false;
              });
              this.$popover.on("mouseup", function() {
                _this2.hidable = true;
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$popover.remove();
            }
          }, {
            key: "update",
            value: function update2(forcelyOpen) {
              var styleInfo = this.context.invoke("editor.currentStyle");
              if (styleInfo.range && (!styleInfo.range.isCollapsed() || forcelyOpen)) {
                var rect = {
                  left: this.pageX,
                  top: this.pageY
                };
                var containerOffset = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.container).offset();
                rect.top -= containerOffset.top;
                rect.left -= containerOffset.left;
                this.$popover.css({
                  display: "block",
                  left: Math.max(rect.left, 0) + AIRMODE_POPOVER_X_OFFSET,
                  top: rect.top + AIRMODE_POPOVER_Y_OFFSET
                });
                this.context.invoke("buttons.updateCurrentStyle", this.$popover);
              } else {
                this.hide();
              }
            }
          }, {
            key: "updateCodeview",
            value: function updateCodeview(isCodeview) {
              this.ui.toggleBtnActive(this.$popover.find(".btn-codeview"), isCodeview);
              if (isCodeview) {
                this.hide();
              }
            }
          }, {
            key: "hide",
            value: function hide2() {
              if (this.hidable) {
                this.$popover.hide();
              }
            }
          }]);
        }();
        function HintPopover_typeof(o2) {
          "@babel/helpers - typeof";
          return HintPopover_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, HintPopover_typeof(o2);
        }
        function HintPopover_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function HintPopover_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, HintPopover_toPropertyKey(o2.key), o2);
          }
        }
        function HintPopover_createClass(e2, r2, t2) {
          return r2 && HintPopover_defineProperties(e2.prototype, r2), t2 && HintPopover_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function HintPopover_toPropertyKey(t2) {
          var i = HintPopover_toPrimitive(t2, "string");
          return "symbol" == HintPopover_typeof(i) ? i : i + "";
        }
        function HintPopover_toPrimitive(t2, r2) {
          if ("object" != HintPopover_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != HintPopover_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var POPOVER_DIST = 5;
        var HintPopover = /* @__PURE__ */ function() {
          function HintPopover2(context) {
            var _this = this;
            HintPopover_classCallCheck(this, HintPopover2);
            this.context = context;
            this.ui = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.ui;
            this.$editable = context.layoutInfo.editable;
            this.options = context.options;
            this.hint = this.options.hint || [];
            this.direction = this.options.hintDirection || "bottom";
            this.hints = Array.isArray(this.hint) ? this.hint : [this.hint];
            this.events = {
              "summernote.keyup": function summernoteKeyup(we2, event) {
                if (!event.isDefaultPrevented()) {
                  _this.handleKeyup(event);
                }
              },
              "summernote.keydown": function summernoteKeydown(we2, event) {
                _this.handleKeydown(event);
              },
              "summernote.disable summernote.dialog.shown summernote.blur": function summernoteDisableSummernoteDialogShownSummernoteBlur() {
                _this.hide();
              }
            };
          }
          return HintPopover_createClass(HintPopover2, [{
            key: "shouldInitialize",
            value: function shouldInitialize() {
              return this.hints.length > 0;
            }
          }, {
            key: "initialize",
            value: function initialize2() {
              var _this2 = this;
              this.lastWordRange = null;
              this.matchingWord = null;
              this.$popover = this.ui.popover({
                className: "note-hint-popover",
                hideArrow: true,
                direction: ""
              }).render().appendTo(this.options.container);
              this.$popover.hide();
              this.$content = this.$popover.find(".popover-content,.note-popover-content");
              this.$content.on("click", ".note-hint-item", function(event) {
                _this2.$content.find(".active").removeClass("active");
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(event.currentTarget).addClass("active");
                _this2.replace();
              });
              this.$popover.on("mousedown", function(event) {
                event.preventDefault();
              });
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.$popover.remove();
            }
          }, {
            key: "selectItem",
            value: function selectItem($item) {
              this.$content.find(".active").removeClass("active");
              $item.addClass("active");
              this.$content[0].scrollTop = $item[0].offsetTop - this.$content.innerHeight() / 2;
            }
          }, {
            key: "moveDown",
            value: function moveDown() {
              var $current = this.$content.find(".note-hint-item.active");
              var $next = $current.next();
              if ($next.length) {
                this.selectItem($next);
              } else {
                var $nextGroup = $current.parent().next();
                if (!$nextGroup.length) {
                  $nextGroup = this.$content.find(".note-hint-group").first();
                }
                this.selectItem($nextGroup.find(".note-hint-item").first());
              }
            }
          }, {
            key: "moveUp",
            value: function moveUp() {
              var $current = this.$content.find(".note-hint-item.active");
              var $prev = $current.prev();
              if ($prev.length) {
                this.selectItem($prev);
              } else {
                var $prevGroup = $current.parent().prev();
                if (!$prevGroup.length) {
                  $prevGroup = this.$content.find(".note-hint-group").last();
                }
                this.selectItem($prevGroup.find(".note-hint-item").last());
              }
            }
          }, {
            key: "replace",
            value: function replace2() {
              var $item = this.$content.find(".note-hint-item.active");
              if ($item.length) {
                var node = this.nodeFromItem($item);
                if (this.matchingWord !== null && this.matchingWord.length === 0) {
                  this.lastWordRange.so = this.lastWordRange.eo;
                } else if (this.matchingWord !== null && this.matchingWord.length > 0 && !this.lastWordRange.isCollapsed()) {
                  var rangeCompute = this.lastWordRange.eo - this.lastWordRange.so - this.matchingWord.length;
                  if (rangeCompute > 0) {
                    this.lastWordRange.so += rangeCompute;
                  }
                }
                this.lastWordRange.insertNode(node);
                if (this.options.hintSelect === "next") {
                  var blank = document.createTextNode("");
                  external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(node).after(blank);
                  range.createFromNodeBefore(blank).select();
                } else {
                  range.createFromNodeAfter(node).select();
                }
                this.lastWordRange = null;
                this.hide();
                this.context.invoke("editor.focus");
                this.context.triggerEvent("change", this.$editable.html(), this.$editable);
              }
            }
          }, {
            key: "nodeFromItem",
            value: function nodeFromItem($item) {
              var hint = this.hints[$item.data("index")];
              var item2 = $item.data("item");
              var node = hint.content ? hint.content(item2) : item2;
              if (typeof node === "string") {
                node = dom.createText(node);
              }
              return node;
            }
          }, {
            key: "createItemTemplates",
            value: function createItemTemplates(hintIdx, items) {
              var hint = this.hints[hintIdx];
              return items.map(function(item2, idx) {
                var $item = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()('<div class="note-hint-item"></div>');
                $item.append(hint.template ? hint.template(item2) : item2 + "");
                $item.data({
                  "index": hintIdx,
                  "item": item2
                });
                if (hintIdx === 0 && idx === 0) {
                  $item.addClass("active");
                }
                return $item;
              });
            }
          }, {
            key: "handleKeydown",
            value: function handleKeydown(event) {
              if (!this.$popover.is(":visible")) {
                return;
              }
              if (event.keyCode === key.code.ENTER) {
                event.preventDefault();
                this.replace();
              } else if (event.keyCode === key.code.UP) {
                event.preventDefault();
                this.moveUp();
              } else if (event.keyCode === key.code.DOWN) {
                event.preventDefault();
                this.moveDown();
              }
            }
          }, {
            key: "searchKeyword",
            value: function searchKeyword(index, keyword, callback) {
              var hint = this.hints[index];
              if (hint && hint.match.test(keyword) && hint.search) {
                var matches2 = hint.match.exec(keyword);
                this.matchingWord = matches2[0];
                hint.search(matches2[1], callback);
              } else {
                callback();
              }
            }
          }, {
            key: "createGroup",
            value: function createGroup(idx, keyword) {
              var _this3 = this;
              var $group = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()('<div class="note-hint-group note-hint-group-' + idx + '"></div>');
              this.searchKeyword(idx, keyword, function(items) {
                items = items || [];
                if (items.length) {
                  $group.html(_this3.createItemTemplates(idx, items));
                  _this3.show();
                }
              });
              return $group;
            }
          }, {
            key: "handleKeyup",
            value: function handleKeyup(event) {
              var _this4 = this;
              if (!lists.contains([key.code.ENTER, key.code.UP, key.code.DOWN], event.keyCode)) {
                var _range2 = this.context.invoke("editor.getLastRange");
                var wordRange, keyword;
                if (this.options.hintMode === "words") {
                  wordRange = _range2.getWordsRange(_range2);
                  keyword = wordRange.toString();
                  this.hints.forEach(function(hint) {
                    if (hint.match.test(keyword)) {
                      wordRange = _range2.getWordsMatchRange(hint.match);
                      return false;
                    }
                  });
                  if (!wordRange) {
                    this.hide();
                    return;
                  }
                  keyword = wordRange.toString();
                } else {
                  wordRange = _range2.getWordRange();
                  keyword = wordRange.toString();
                }
                if (this.hints.length && keyword) {
                  this.$content.empty();
                  var bnd = func.rect2bnd(lists.last(wordRange.getClientRects()));
                  var containerOffset = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.options.container).offset();
                  if (bnd) {
                    bnd.top -= containerOffset.top;
                    bnd.left -= containerOffset.left;
                    this.$popover.hide();
                    this.lastWordRange = wordRange;
                    this.hints.forEach(function(hint, idx) {
                      if (hint.match.test(keyword)) {
                        _this4.createGroup(idx, keyword).appendTo(_this4.$content);
                      }
                    });
                    this.$content.find(".note-hint-item").first().addClass("active");
                    if (this.direction === "top") {
                      this.$popover.css({
                        left: bnd.left,
                        top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST
                      });
                    } else {
                      this.$popover.css({
                        left: bnd.left,
                        top: bnd.top + bnd.height + POPOVER_DIST
                      });
                    }
                  }
                } else {
                  this.hide();
                }
              }
            }
          }, {
            key: "show",
            value: function show2() {
              this.$popover.show();
            }
          }, {
            key: "hide",
            value: function hide2() {
              this.$popover.hide();
            }
          }]);
        }();
        external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote, {
          version: "0.9.1",
          plugins: {},
          dom,
          range,
          lists,
          options: {
            langInfo: external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote.lang["en-US"],
            editing: true,
            modules: {
              "editor": Editor,
              "clipboard": Clipboard,
              "dropzone": Dropzone,
              "codeview": CodeView,
              "statusbar": Statusbar,
              "fullscreen": Fullscreen,
              "handle": Handle,
              // FIXME: HintPopover must be front of autolink
              //  - Script error about range when Enter key is pressed on hint popover
              "hintPopover": HintPopover,
              "autoLink": AutoLink,
              "autoSync": AutoSync,
              "autoReplace": AutoReplace,
              "placeholder": Placeholder,
              "buttons": Buttons2,
              "toolbar": Toolbar,
              "linkDialog": LinkDialog,
              "linkPopover": LinkPopover,
              "imageDialog": ImageDialog,
              "imagePopover": ImagePopover,
              "tablePopover": TablePopover,
              "videoDialog": VideoDialog,
              "helpDialog": HelpDialog,
              "airPopover": AirPopover
            },
            buttons: {},
            lang: "en-US",
            followingToolbar: false,
            toolbarPosition: "top",
            otherStaticBar: "",
            // toolbar
            codeviewKeepButton: false,
            toolbar: [["style", ["style"]], ["font", ["bold", "underline", "clear"]], ["fontname", ["fontname"]], ["color", ["color"]], ["para", ["ul", "ol", "paragraph"]], ["table", ["table"]], ["insert", ["link", "picture", "video"]], ["view", ["fullscreen", "codeview", "help"]]],
            // popover
            popatmouse: true,
            popover: {
              image: [["resize", ["resizeFull", "resizeHalf", "resizeQuarter", "resizeNone"]], ["float", ["floatLeft", "floatRight", "floatNone"]], ["remove", ["removeMedia"]]],
              link: [["link", ["linkDialogShow", "unlink"]]],
              table: [["add", ["addRowDown", "addRowUp", "addColLeft", "addColRight"]], ["delete", ["deleteRow", "deleteCol", "deleteTable"]]],
              air: [["color", ["color"]], ["font", ["bold", "underline", "clear"]], ["para", ["ul", "paragraph"]], ["table", ["table"]], ["insert", ["link", "picture"]], ["view", ["fullscreen", "codeview"]]]
            },
            // link options
            linkAddNoReferrer: false,
            addLinkNoOpener: false,
            // air mode: inline editor
            airMode: false,
            overrideContextMenu: false,
            // TBD
            width: null,
            height: null,
            linkTargetBlank: true,
            focus: false,
            tabDisable: false,
            tabSize: 4,
            styleWithCSS: false,
            shortcuts: true,
            textareaAutoSync: true,
            tooltip: "auto",
            container: null,
            maxTextLength: 0,
            blockquoteBreakingLevel: 2,
            spellCheck: true,
            disableGrammar: false,
            placeholder: null,
            inheritPlaceholder: false,
            // TODO: need to be documented
            recordEveryKeystroke: false,
            historyLimit: 200,
            // TODO: need to be documented
            showDomainOnlyForAutolink: false,
            // TODO: need to be documented
            hintMode: "word",
            hintSelect: "after",
            hintDirection: "bottom",
            styleTags: ["p", "blockquote", "pre", "h1", "h2", "h3", "h4", "h5", "h6"],
            fontNames: ["Arial", "Arial Black", "Comic Sans MS", "Courier New", "Helvetica Neue", "Helvetica", "Impact", "Lucida Grande", "Tahoma", "Times New Roman", "Verdana"],
            fontNamesIgnoreCheck: [],
            addDefaultFonts: true,
            fontSizes: ["8", "9", "10", "11", "12", "14", "18", "24", "36"],
            fontSizeUnits: ["px", "pt"],
            // pallete colors(n x n)
            colors: [["#000000", "#424242", "#636363", "#9C9C94", "#CEC6CE", "#EFEFEF", "#F7F7F7", "#FFFFFF"], ["#FF0000", "#FF9C00", "#FFFF00", "#00FF00", "#00FFFF", "#0000FF", "#9C00FF", "#FF00FF"], ["#F7C6CE", "#FFE7CE", "#FFEFC6", "#D6EFD6", "#CEDEE7", "#CEE7F7", "#D6D6E7", "#E7D6DE"], ["#E79C9C", "#FFC69C", "#FFE79C", "#B5D6A5", "#A5C6CE", "#9CC6EF", "#B5A5D6", "#D6A5BD"], ["#E76363", "#F7AD6B", "#FFD663", "#94BD7B", "#73A5AD", "#6BADDE", "#8C7BC6", "#C67BA5"], ["#CE0000", "#E79439", "#EFC631", "#6BA54A", "#4A7B8C", "#3984C6", "#634AA5", "#A54A7B"], ["#9C0000", "#B56308", "#BD9400", "#397B21", "#104A5A", "#085294", "#311873", "#731842"], ["#630000", "#7B3900", "#846300", "#295218", "#083139", "#003163", "#21104A", "#4A1031"]],
            // http://chir.ag/projects/name-that-color/
            colorsName: [["Black", "Tundora", "Dove Gray", "Star Dust", "Pale Slate", "Gallery", "Alabaster", "White"], ["Red", "Orange Peel", "Yellow", "Green", "Cyan", "Blue", "Electric Violet", "Magenta"], ["Azalea", "Karry", "Egg White", "Zanah", "Botticelli", "Tropical Blue", "Mischka", "Twilight"], ["Tonys Pink", "Peach Orange", "Cream Brulee", "Sprout", "Casper", "Perano", "Cold Purple", "Careys Pink"], ["Mandy", "Rajah", "Dandelion", "Olivine", "Gulf Stream", "Viking", "Blue Marguerite", "Puce"], ["Guardsman Red", "Fire Bush", "Golden Dream", "Chelsea Cucumber", "Smalt Blue", "Boston Blue", "Butterfly Bush", "Cadillac"], ["Sangria", "Mai Tai", "Buddha Gold", "Forest Green", "Eden", "Venice Blue", "Meteorite", "Claret"], ["Rosewood", "Cinnamon", "Olive", "Parsley", "Tiber", "Midnight Blue", "Valentino", "Loulou"]],
            colorButton: {
              foreColor: "#000000",
              backColor: "#FFFF00"
            },
            lineHeights: ["1.0", "1.2", "1.4", "1.5", "1.6", "1.8", "2.0", "3.0"],
            tableClassName: "table table-bordered",
            insertTableMaxSize: {
              col: 10,
              row: 10
            },
            // By default, dialogs are attached in container.
            dialogsInBody: false,
            dialogsFade: false,
            maximumImageFileSize: null,
            acceptImageFileTypes: "image/*",
            allowClipboardImagePasting: true,
            callbacks: {
              onBeforeCommand: null,
              onBlur: null,
              onBlurCodeview: null,
              onChange: null,
              onChangeCodeview: null,
              onDialogShown: null,
              onEnter: null,
              onFocus: null,
              onImageLinkInsert: null,
              onImageUpload: null,
              onImageUploadError: null,
              onInit: null,
              onKeydown: null,
              onKeyup: null,
              onMousedown: null,
              onMouseup: null,
              onPaste: null,
              onScroll: null
            },
            codemirror: {
              mode: "text/html",
              htmlMode: true,
              lineNumbers: true
            },
            codeviewFilter: true,
            codeviewFilterRegex: /<\/*(?:applet|b(?:ase|gsound|link)|embed|frame(?:set)?|ilayer|l(?:ayer|ink)|meta|object|s(?:cript|tyle)|t(?:itle|extarea)|xml)[^>]*?>/gi,
            codeviewIframeFilter: true,
            codeviewIframeWhitelistSrc: [],
            codeviewIframeWhitelistSrcBase: ["www.youtube.com", "www.youtube-nocookie.com", "www.facebook.com", "vine.co", "instagram.com", "player.vimeo.com", "www.dailymotion.com", "player.youku.com", "jumpingbean.tv", "v.qq.com"],
            keyMap: {
              pc: {
                "ESC": "escape",
                "ENTER": "insertParagraph",
                "CTRL+Z": "undo",
                "CTRL+Y": "redo",
                "TAB": "tab",
                "SHIFT+TAB": "untab",
                "CTRL+B": "bold",
                "CTRL+I": "italic",
                "CTRL+U": "underline",
                "CTRL+SHIFT+S": "strikethrough",
                "CTRL+BACKSLASH": "removeFormat",
                "CTRL+SHIFT+L": "justifyLeft",
                "CTRL+SHIFT+E": "justifyCenter",
                "CTRL+SHIFT+R": "justifyRight",
                "CTRL+SHIFT+J": "justifyFull",
                "CTRL+SHIFT+NUM7": "insertUnorderedList",
                "CTRL+SHIFT+NUM8": "insertOrderedList",
                "CTRL+LEFTBRACKET": "outdent",
                "CTRL+RIGHTBRACKET": "indent",
                "CTRL+NUM0": "formatPara",
                "CTRL+NUM1": "formatH1",
                "CTRL+NUM2": "formatH2",
                "CTRL+NUM3": "formatH3",
                "CTRL+NUM4": "formatH4",
                "CTRL+NUM5": "formatH5",
                "CTRL+NUM6": "formatH6",
                "CTRL+ENTER": "insertHorizontalRule",
                "CTRL+K": "linkDialog.show"
              },
              mac: {
                "ESC": "escape",
                "ENTER": "insertParagraph",
                "CMD+Z": "undo",
                "CMD+SHIFT+Z": "redo",
                "TAB": "tab",
                "SHIFT+TAB": "untab",
                "CMD+B": "bold",
                "CMD+I": "italic",
                "CMD+U": "underline",
                "CMD+SHIFT+S": "strikethrough",
                "CMD+BACKSLASH": "removeFormat",
                "CMD+SHIFT+L": "justifyLeft",
                "CMD+SHIFT+E": "justifyCenter",
                "CMD+SHIFT+R": "justifyRight",
                "CMD+SHIFT+J": "justifyFull",
                "CMD+SHIFT+NUM7": "insertUnorderedList",
                "CMD+SHIFT+NUM8": "insertOrderedList",
                "CMD+LEFTBRACKET": "outdent",
                "CMD+RIGHTBRACKET": "indent",
                "CMD+NUM0": "formatPara",
                "CMD+NUM1": "formatH1",
                "CMD+NUM2": "formatH2",
                "CMD+NUM3": "formatH3",
                "CMD+NUM4": "formatH4",
                "CMD+NUM5": "formatH5",
                "CMD+NUM6": "formatH6",
                "CMD+ENTER": "insertHorizontalRule",
                "CMD+K": "linkDialog.show"
              }
            },
            icons: {
              "align": "note-icon-align",
              "alignCenter": "note-icon-align-center",
              "alignJustify": "note-icon-align-justify",
              "alignLeft": "note-icon-align-left",
              "alignRight": "note-icon-align-right",
              "rowBelow": "note-icon-row-below",
              "colBefore": "note-icon-col-before",
              "colAfter": "note-icon-col-after",
              "rowAbove": "note-icon-row-above",
              "rowRemove": "note-icon-row-remove",
              "colRemove": "note-icon-col-remove",
              "indent": "note-icon-align-indent",
              "outdent": "note-icon-align-outdent",
              "arrowsAlt": "note-icon-arrows-alt",
              "bold": "note-icon-bold",
              "caret": "note-icon-caret",
              "circle": "note-icon-circle",
              "close": "note-icon-close",
              "code": "note-icon-code",
              "eraser": "note-icon-eraser",
              "floatLeft": "note-icon-float-left",
              "floatRight": "note-icon-float-right",
              "font": "note-icon-font",
              "frame": "note-icon-frame",
              "italic": "note-icon-italic",
              "link": "note-icon-link",
              "unlink": "note-icon-chain-broken",
              "magic": "note-icon-magic",
              "menuCheck": "note-icon-menu-check",
              "minus": "note-icon-minus",
              "orderedlist": "note-icon-orderedlist",
              "pencil": "note-icon-pencil",
              "picture": "note-icon-picture",
              "question": "note-icon-question",
              "redo": "note-icon-redo",
              "rollback": "note-icon-rollback",
              "square": "note-icon-square",
              "strikethrough": "note-icon-strikethrough",
              "subscript": "note-icon-subscript",
              "superscript": "note-icon-superscript",
              "table": "note-icon-table",
              "textHeight": "note-icon-text-height",
              "trash": "note-icon-trash",
              "underline": "note-icon-underline",
              "undo": "note-icon-undo",
              "unorderedlist": "note-icon-unorderedlist",
              "video": "note-icon-video"
            }
          }
        });
        function renderer_typeof(o2) {
          "@babel/helpers - typeof";
          return renderer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, renderer_typeof(o2);
        }
        function renderer_classCallCheck(a2, n2) {
          if (!(a2 instanceof n2))
            throw new TypeError("Cannot call a class as a function");
        }
        function renderer_defineProperties(e2, r2) {
          for (var t2 = 0; t2 < r2.length; t2++) {
            var o2 = r2[t2];
            o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, renderer_toPropertyKey(o2.key), o2);
          }
        }
        function renderer_createClass(e2, r2, t2) {
          return r2 && renderer_defineProperties(e2.prototype, r2), t2 && renderer_defineProperties(e2, t2), Object.defineProperty(e2, "prototype", { writable: false }), e2;
        }
        function renderer_toPropertyKey(t2) {
          var i = renderer_toPrimitive(t2, "string");
          return "symbol" == renderer_typeof(i) ? i : i + "";
        }
        function renderer_toPrimitive(t2, r2) {
          if ("object" != renderer_typeof(t2) || !t2)
            return t2;
          var e2 = t2[Symbol.toPrimitive];
          if (void 0 !== e2) {
            var i = e2.call(t2, r2 || "default");
            if ("object" != renderer_typeof(i))
              return i;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return ("string" === r2 ? String : Number)(t2);
        }
        var Renderer = /* @__PURE__ */ function() {
          function Renderer2(markup, children, options, callback) {
            renderer_classCallCheck(this, Renderer2);
            this.markup = markup;
            this.children = children;
            this.options = options;
            this.callback = callback;
          }
          return renderer_createClass(Renderer2, [{
            key: "render",
            value: function render2($parent) {
              var $node = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(this.markup);
              if (this.options && this.options.contents) {
                $node.html(this.options.contents);
              }
              if (this.options && this.options.className) {
                $node.addClass(this.options.className);
              }
              if (this.options && this.options.data) {
                external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().each(this.options.data, function(k2, v2) {
                  $node.attr("data-" + k2, v2);
                });
              }
              if (this.options && this.options.click) {
                $node.on("click", this.options.click);
              }
              if (this.children) {
                var $container = $node.find(".note-children-container");
                this.children.forEach(function(child) {
                  child.render($container.length ? $container : $node);
                });
              }
              if (this.callback) {
                this.callback($node, this.options);
              }
              if (this.options && this.options.callback) {
                this.options.callback($node);
              }
              if ($parent) {
                $parent.append($node);
              }
              return $node;
            }
          }]);
        }();
        const renderer = {
          create: function create3(markup, callback) {
            return function() {
              var options = renderer_typeof(arguments[1]) === "object" ? arguments[1] : arguments[0];
              var children = Array.isArray(arguments[0]) ? arguments[0] : [];
              if (options && options.children) {
                children = options.children;
              }
              return new Renderer(markup, children, options, callback);
            };
          }
        };
        function summernote_bs3_typeof(o2) {
          "@babel/helpers - typeof";
          return summernote_bs3_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
            return typeof o3;
          } : function(o3) {
            return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
          }, summernote_bs3_typeof(o2);
        }
        var editor = renderer.create('<div class="note-editor note-frame panel panel-default"></div>');
        var toolbar = renderer.create('<div class="panel-heading note-toolbar" role="toolbar"></div>');
        var editingArea = renderer.create('<div class="note-editing-area"></div>');
        var codable = renderer.create('<textarea class="note-codable" aria-multiline="true"></textarea>');
        var editable = renderer.create('<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>');
        var statusbar = renderer.create(['<output class="note-status-output" role="status" aria-live="polite"></output>', '<div class="note-statusbar" role="status">', '<div class="note-resizebar" aria-label="Resize">', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', '<div class="note-icon-bar"></div>', "</div>", "</div>"].join(""));
        var airEditor = renderer.create('<div class="note-editor note-airframe"></div>');
        var airEditable = renderer.create(['<div class="note-editable" contentEditable="true" role="textbox" aria-multiline="true"></div>', '<output class="note-status-output" role="status" aria-live="polite"></output>'].join(""));
        var buttonGroup = renderer.create('<div class="note-btn-group btn-group"></div>');
        var dropdown = renderer.create('<ul class="note-dropdown-menu dropdown-menu"></ul>', function($node, options) {
          var markup = Array.isArray(options.items) ? options.items.map(function(item2) {
            var value2 = typeof item2 === "string" ? item2 : item2.value || "";
            var content = options.template ? options.template(item2) : item2;
            var option2 = summernote_bs3_typeof(item2) === "object" ? item2.option : void 0;
            var dataValue = 'data-value="' + value2 + '"';
            var dataOption = option2 !== void 0 ? ' data-option="' + option2 + '"' : "";
            return '<li aria-label="' + value2 + '"><a href="#" ' + (dataValue + dataOption) + ">" + content + "</a></li>";
          }).join("") : options.items;
          $node.html(markup).attr({
            "aria-label": options.title
          });
          if (options && options.codeviewKeepButton) {
            $node.addClass("note-codeview-keep");
          }
        });
        var dropdownButtonContents = function dropdownButtonContents2(contents, options) {
          return contents + " " + icon(options.icons.caret, "span");
        };
        var dropdownCheck = renderer.create('<ul class="note-dropdown-menu dropdown-menu note-check"></ul>', function($node, options) {
          var markup = Array.isArray(options.items) ? options.items.map(function(item2) {
            var value2 = typeof item2 === "string" ? item2 : item2.value || "";
            var content = options.template ? options.template(item2) : item2;
            return '<li aria-label="' + item2 + '"><a href="#" data-value="' + value2 + '">' + icon(options.checkClassName) + " " + content + "</a></li>";
          }).join("") : options.items;
          $node.html(markup).attr({
            "aria-label": options.title
          });
          if (options && options.codeviewKeepButton) {
            $node.addClass("note-codeview-keep");
          }
        });
        var dialog = renderer.create('<div class="modal note-modal" aria-hidden="false" tabindex="-1" role="dialog"></div>', function($node, options) {
          if (options.fade) {
            $node.addClass("fade");
          }
          $node.attr({
            "aria-label": options.title
          });
          $node.html(['<div class="modal-dialog">', '<div class="modal-content">', options.title ? '<div class="modal-header"><button type="button" class="close" data-dismiss="modal" aria-label="Close" aria-hidden="true">&times;</button><h4 class="modal-title">' + options.title + "</h4></div>" : "", '<div class="modal-body">' + options.body + "</div>", options.footer ? '<div class="modal-footer">' + options.footer + "</div>" : "", "</div>", "</div>"].join(""));
        });
        var popover = renderer.create(['<div class="note-popover popover in">', '<div class="arrow"></div>', '<div class="popover-content note-children-container"></div>', "</div>"].join(""), function($node, options) {
          var direction = typeof options.direction !== "undefined" ? options.direction : "bottom";
          $node.addClass(direction);
          if (options.hideArrow) {
            $node.find(".arrow").hide();
          }
        });
        var summernote_bs3_checkbox = renderer.create('<div class="checkbox"></div>', function($node, options) {
          $node.html(["<label" + (options.id ? ' for="note-' + options.id + '"' : "") + ">", '<input type="checkbox"' + (options.id ? ' id="note-' + options.id + '"' : ""), options.checked ? " checked" : "", ' aria-checked="' + (options.checked ? "true" : "false") + '"/>', options.text ? options.text : "", "</label>"].join(""));
        });
        var icon = function icon2(iconClassName, tagName) {
          if (iconClassName.match(/^</)) {
            return iconClassName;
          }
          tagName = tagName || "i";
          return "<" + tagName + ' class="' + iconClassName + '"></' + tagName + ">";
        };
        var ui2 = function ui3(editorOptions) {
          return {
            editor,
            toolbar,
            editingArea,
            codable,
            editable,
            statusbar,
            airEditor,
            airEditable,
            buttonGroup,
            dropdown,
            dropdownButtonContents,
            dropdownCheck,
            dialog,
            popover,
            checkbox: summernote_bs3_checkbox,
            icon,
            options: editorOptions,
            palette: function palette($node, options) {
              return renderer.create('<div class="note-color-palette"></div>', function($node2, options2) {
                var contents = [];
                for (var row = 0, rowSize = options2.colors.length; row < rowSize; row++) {
                  var eventName = options2.eventName;
                  var colors = options2.colors[row];
                  var colorsName = options2.colorsName[row];
                  var buttons = [];
                  for (var col = 0, colSize = colors.length; col < colSize; col++) {
                    var color = colors[col];
                    var colorName = colorsName[col];
                    buttons.push(['<button type="button" class="note-color-btn"', 'style="background-color:', color, '" ', 'data-event="', eventName, '" ', 'data-value="', color, '" ', 'title="', colorName, '" ', 'aria-label="', colorName, '" ', 'data-toggle="button" tabindex="-1"></button>'].join(""));
                  }
                  contents.push('<div class="note-color-row">' + buttons.join("") + "</div>");
                }
                $node2.html(contents.join(""));
                if (options2.tooltip) {
                  $node2.find(".note-color-btn").tooltip({
                    container: options2.container || editorOptions.container,
                    trigger: "hover",
                    placement: "bottom"
                  });
                }
              })($node, options);
            },
            button: function button($node, options) {
              return renderer.create('<button type="button" class="note-btn btn btn-default btn-sm" tabindex="-1"></button>', function($node2, options2) {
                if (options2 && options2.tooltip) {
                  $node2.attr({
                    title: options2.tooltip,
                    "aria-label": options2.tooltip
                  }).tooltip({
                    container: options2.container || editorOptions.container,
                    trigger: "hover",
                    placement: "bottom"
                  }).on("click", function(e2) {
                    external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default()(e2.currentTarget).tooltip("hide");
                  });
                }
                if (options2 && options2.codeviewButton) {
                  $node2.addClass("note-codeview-keep");
                }
              })($node, options);
            },
            toggleBtn: function toggleBtn($btn, isEnable) {
              $btn.toggleClass("disabled", !isEnable);
              $btn.attr("disabled", !isEnable);
            },
            toggleBtnActive: function toggleBtnActive($btn, isActive) {
              $btn.toggleClass("active", isActive);
            },
            onDialogShown: function onDialogShown($dialog, handler) {
              $dialog.one("shown.bs.modal", handler);
            },
            onDialogHidden: function onDialogHidden($dialog, handler) {
              $dialog.one("hidden.bs.modal", handler);
            },
            showDialog: function showDialog($dialog) {
              $dialog.modal("show");
            },
            hideDialog: function hideDialog($dialog) {
              $dialog.modal("hide");
            },
            createLayout: function createLayout($note) {
              var $editor = (editorOptions.airMode ? airEditor([editingArea([codable(), airEditable()])]) : editorOptions.toolbarPosition === "bottom" ? editor([editingArea([codable(), editable()]), toolbar(), statusbar()]) : editor([toolbar(), editingArea([codable(), editable()]), statusbar()])).render();
              $editor.insertAfter($note);
              return {
                note: $note,
                editor: $editor,
                toolbar: $editor.find(".note-toolbar"),
                editingArea: $editor.find(".note-editing-area"),
                editable: $editor.find(".note-editable"),
                codable: $editor.find(".note-codable"),
                statusbar: $editor.find(".note-statusbar")
              };
            },
            removeLayout: function removeLayout($note, layoutInfo) {
              $note.html(layoutInfo.editable.html());
              layoutInfo.editor.remove();
              $note.show();
            }
          };
        };
        external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote = external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().extend(external_root_jQuery_commonjs_jquery_commonjs2_jquery_amd_jquery_default().summernote, {
          ui_template: ui2,
          "interface": "bs3"
        });
        return __webpack_exports__;
      })()
    );
  });
})(summernote);
/*! Loading Overlay - v1.0.2 - 2014-02-19
* http://jgerigmeyer.github.io/jquery-loading-overlay/
* Copyright (c) 2014 Jonny Gerig Meyer; Licensed MIT */
(function($2) {
  var methods2 = {
    init: function(options) {
      var opts = $2.extend({}, $2.fn.loadingOverlay.defaults, options);
      var target = $2(this).addClass(opts.loadingClass);
      var overlay = '<div class="' + opts.overlayClass + '"><p class="' + opts.spinnerClass + '"><span class="' + opts.iconClass + '"></span><span class="' + opts.textClass + '">' + opts.loadingText + "</span></p></div>";
      if (!target.data("loading-overlay")) {
        target.prepend($2(overlay)).data("loading-overlay", true);
      }
      return target;
    },
    remove: function(options) {
      var opts = $2.extend({}, $2.fn.loadingOverlay.defaults, options);
      var target = $2(this).data("loading-overlay", false);
      target.find("." + opts.overlayClass).detach();
      if (target.hasClass(opts.loadingClass)) {
        target.removeClass(opts.loadingClass);
      } else {
        target.find("." + opts.loadingClass).removeClass(opts.loadingClass);
      }
      return target;
    },
    // Expose internal methods to allow stubbing in tests
    exposeMethods: function() {
      return methods2;
    }
  };
  $2.fn.loadingOverlay = function(method) {
    if (methods2[method]) {
      return methods2[method].apply(
        this,
        Array.prototype.slice.call(arguments, 1)
      );
    } else if (typeof method === "object" || !method) {
      return methods2.init.apply(this, arguments);
    } else {
      $2.error("Method " + method + " does not exist on jQuery.loadingOverlay");
    }
  };
  $2.fn.loadingOverlay.defaults = {
    loadingClass: "loading",
    // Class added to target while loading
    overlayClass: "loading-overlay",
    // Class added to overlay (style with CSS)
    spinnerClass: "loading-spinner",
    // Class added to loading overlay spinner
    iconClass: "loading-icon",
    // Class added to loading overlay spinner
    textClass: "loading-text",
    // Class added to loading overlay spinner
    loadingText: "loading"
    // Text within loading overlay
  };
})(jQuery);
var inputmask = { exports: {} };
/*!
 * dist/inputmask
 * https://github.com/RobinHerbots/Inputmask
 * Copyright (c) 2010 - 2024 Robin Herbots
 * Licensed under the MIT license
 * Version: 5.0.9
 */
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }("undefined" != typeof self ? self : commonjsGlobal, function() {
    return function() {
      var e2 = {
        3976: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = void 0;
          t3.default = {
            _maxTestPos: 500,
            placeholder: "_",
            optionalmarker: ["[", "]"],
            quantifiermarker: ["{", "}"],
            groupmarker: ["(", ")"],
            alternatormarker: "|",
            escapeChar: "\\",
            mask: null,
            regex: null,
            oncomplete: function() {
            },
            onincomplete: function() {
            },
            oncleared: function() {
            },
            repeat: 0,
            greedy: false,
            autoUnmask: false,
            removeMaskOnSubmit: false,
            clearMaskOnLostFocus: true,
            insertMode: true,
            insertModeVisual: true,
            clearIncomplete: false,
            alias: null,
            onKeyDown: function() {
            },
            onBeforeMask: null,
            onBeforePaste: function(e4, t4) {
              return "function" == typeof t4.onBeforeMask ? t4.onBeforeMask.call(this, e4, t4) : e4;
            },
            onBeforeWrite: null,
            onUnMask: null,
            showMaskOnFocus: true,
            showMaskOnHover: true,
            onKeyValidation: function() {
            },
            skipOptionalPartCharacter: " ",
            numericInput: false,
            rightAlign: false,
            undoOnEscape: true,
            radixPoint: "",
            _radixDance: false,
            groupSeparator: "",
            keepStatic: null,
            positionCaretOnTab: true,
            tabThrough: false,
            supportsInputType: ["text", "tel", "url", "password", "search"],
            isComplete: null,
            preValidation: null,
            postValidation: null,
            staticDefinitionSymbol: void 0,
            jitMasking: false,
            nullable: true,
            inputEventOnly: false,
            noValuePatching: false,
            positionCaretOnClick: "lvp",
            casing: null,
            inputmode: "text",
            importDataAttributes: true,
            shiftPositions: true,
            usePrototypeDefinitions: true,
            validationEventTimeOut: 3e3,
            substitutes: {}
          };
        },
        7392: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = void 0;
          t3.default = {
            9: {
              validator: "[0-9０-９]",
              definitionSymbol: "*"
            },
            a: {
              validator: "[A-Za-zА-яЁёÀ-ÿµ]",
              definitionSymbol: "*"
            },
            "*": {
              validator: "[0-9０-９A-Za-zА-яЁёÀ-ÿµ]"
            }
          };
        },
        253: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = function(e4, t4, n3) {
            if (void 0 === n3)
              return e4.__data ? e4.__data[t4] : null;
            e4.__data = e4.__data || {}, e4.__data[t4] = n3;
          };
        },
        3776: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.Event = void 0, t3.off = function(e4, t4) {
            var n4, i3;
            u2(this[0]) && e4 && (n4 = this[0].eventRegistry, i3 = this[0], e4.split(" ").forEach(function(e5) {
              var a3 = o2(e5.split("."), 2);
              (function(e6, i4) {
                var a4, r3, o3 = [];
                if (e6.length > 0)
                  if (void 0 === t4)
                    for (a4 = 0, r3 = n4[e6][i4].length; a4 < r3; a4++)
                      o3.push({
                        ev: e6,
                        namespace: i4 && i4.length > 0 ? i4 : "global",
                        handler: n4[e6][i4][a4]
                      });
                  else
                    o3.push({
                      ev: e6,
                      namespace: i4 && i4.length > 0 ? i4 : "global",
                      handler: t4
                    });
                else if (i4.length > 0) {
                  for (var l3 in n4)
                    for (var s3 in n4[l3])
                      if (s3 === i4)
                        if (void 0 === t4)
                          for (a4 = 0, r3 = n4[l3][s3].length; a4 < r3; a4++)
                            o3.push({
                              ev: l3,
                              namespace: s3,
                              handler: n4[l3][s3][a4]
                            });
                        else
                          o3.push({
                            ev: l3,
                            namespace: s3,
                            handler: t4
                          });
                }
                return o3;
              })(a3[0], a3[1]).forEach(function(e6) {
                var t5 = e6.ev, a4 = e6.handler;
                !function(e7, t6, a5) {
                  if (e7 in n4 == 1)
                    if (i3.removeEventListener ? i3.removeEventListener(e7, a5, false) : i3.detachEvent && i3.detachEvent("on".concat(e7), a5), "global" === t6)
                      for (var r3 in n4[e7])
                        n4[e7][r3].splice(n4[e7][r3].indexOf(a5), 1);
                    else
                      n4[e7][t6].splice(n4[e7][t6].indexOf(a5), 1);
                }(t5, e6.namespace, a4);
              });
            }));
            return this;
          }, t3.on = function(e4, t4) {
            if (u2(this[0])) {
              var n4 = this[0].eventRegistry, i3 = this[0];
              e4.split(" ").forEach(function(e5) {
                var a3 = o2(e5.split("."), 2), r3 = a3[0], l3 = a3[1];
                !function(e6, a4) {
                  i3.addEventListener ? i3.addEventListener(e6, t4, false) : i3.attachEvent && i3.attachEvent("on".concat(e6), t4), n4[e6] = n4[e6] || {}, n4[e6][a4] = n4[e6][a4] || [], n4[e6][a4].push(t4);
                }(r3, void 0 === l3 ? "global" : l3);
              });
            }
            return this;
          }, t3.trigger = function(e4) {
            var t4 = arguments;
            if (u2(this[0]))
              for (var n4 = this[0].eventRegistry, i3 = this[0], o3 = "string" == typeof e4 ? e4.split(" ") : [e4.type], l3 = 0; l3 < o3.length; l3++) {
                var s3 = o3[l3].split("."), f3 = s3[0], p2 = s3[1] || "global";
                if (void 0 !== c2 && "global" === p2) {
                  var d2, h2 = {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    detail: arguments[1]
                  };
                  if (c2.createEvent) {
                    try {
                      if ("input" === f3)
                        h2.inputType = "insertText", d2 = new InputEvent(f3, h2);
                      else
                        d2 = new CustomEvent(f3, h2);
                    } catch (e5) {
                      (d2 = c2.createEvent("CustomEvent")).initCustomEvent(f3, h2.bubbles, h2.cancelable, h2.detail);
                    }
                    e4.type && (0, a2.default)(d2, e4), i3.dispatchEvent(d2);
                  } else
                    (d2 = c2.createEventObject()).eventType = f3, d2.detail = arguments[1], e4.type && (0, a2.default)(d2, e4), i3.fireEvent("on" + d2.eventType, d2);
                } else if (void 0 !== n4[f3]) {
                  arguments[0] = arguments[0].type ? arguments[0] : r2.default.Event(arguments[0]), arguments[0].detail = arguments.slice(1);
                  var v2 = n4[f3];
                  ("global" === p2 ? Object.values(v2).flat() : v2[p2]).forEach(function(e5) {
                    return e5.apply(i3, t4);
                  });
                }
              }
            return this;
          };
          var i2 = s2(n3(9380)), a2 = s2(n3(600)), r2 = s2(n3(4963));
          function o2(e4, t4) {
            return function(e5) {
              if (Array.isArray(e5))
                return e5;
            }(e4) || function(e5, t5) {
              var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
              if (null != n4) {
                var i3, a3, r3, o3, l3 = [], s3 = true, c3 = false;
                try {
                  if (r3 = (n4 = n4.call(e5)).next, 0 === t5) {
                    if (Object(n4) !== n4)
                      return;
                    s3 = false;
                  } else
                    for (; !(s3 = (i3 = r3.call(n4)).done) && (l3.push(i3.value), l3.length !== t5); s3 = true)
                      ;
                } catch (e6) {
                  c3 = true, a3 = e6;
                } finally {
                  try {
                    if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3))
                      return;
                  } finally {
                    if (c3)
                      throw a3;
                  }
                }
                return l3;
              }
            }(e4, t4) || function(e5, t5) {
              if (!e5)
                return;
              if ("string" == typeof e5)
                return l2(e5, t5);
              var n4 = Object.prototype.toString.call(e5).slice(8, -1);
              "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
              if ("Map" === n4 || "Set" === n4)
                return Array.from(e5);
              if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
                return l2(e5, t5);
            }(e4, t4) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function l2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          function s2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          var c2 = i2.default.document;
          function u2(e4) {
            return e4 instanceof Element;
          }
          var f2 = t3.Event = void 0;
          "function" == typeof i2.default.CustomEvent ? t3.Event = f2 = i2.default.CustomEvent : i2.default.Event && c2 && c2.createEvent ? (t3.Event = f2 = function(e4, t4) {
            t4 = t4 || {
              bubbles: false,
              cancelable: false,
              composed: true,
              detail: void 0
            };
            var n4 = c2.createEvent("CustomEvent");
            return n4.initCustomEvent(e4, t4.bubbles, t4.cancelable, t4.detail), n4;
          }, f2.prototype = i2.default.Event.prototype) : "undefined" != typeof Event && (t3.Event = f2 = Event);
        },
        600: function(e3, t3) {
          function n3(e4) {
            return n3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, n3(e4);
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = function e4() {
            var t4, i2, a2, r2, o2, l2, s2 = arguments[0] || {}, c2 = 1, u2 = arguments.length, f2 = false;
            "boolean" == typeof s2 && (f2 = s2, s2 = arguments[c2] || {}, c2++);
            "object" !== n3(s2) && "function" != typeof s2 && (s2 = {});
            for (; c2 < u2; c2++)
              if (null != (t4 = arguments[c2]))
                for (i2 in t4)
                  a2 = s2[i2], s2 !== (r2 = t4[i2]) && (f2 && r2 && ("[object Object]" === Object.prototype.toString.call(r2) || (o2 = Array.isArray(r2))) ? (o2 ? (o2 = false, l2 = a2 && Array.isArray(a2) ? a2 : []) : l2 = a2 && "[object Object]" === Object.prototype.toString.call(a2) ? a2 : {}, s2[i2] = e4(f2, l2, r2)) : void 0 !== r2 && (s2[i2] = r2));
            return s2;
          };
        },
        4963: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = void 0;
          var i2 = l2(n3(9380)), a2 = l2(n3(253)), r2 = n3(3776), o2 = l2(n3(600));
          function l2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          var s2 = i2.default.document;
          function c2(e4) {
            return e4 instanceof c2 ? e4 : this instanceof c2 ? void (null != e4 && e4 !== i2.default && (this[0] = e4.nodeName ? e4 : void 0 !== e4[0] && e4[0].nodeName ? e4[0] : s2.querySelector(e4), void 0 !== this[0] && null !== this[0] && (this[0].eventRegistry = this[0].eventRegistry || {}))) : new c2(e4);
          }
          c2.prototype = {
            on: r2.on,
            off: r2.off,
            trigger: r2.trigger
          }, c2.extend = o2.default, c2.data = a2.default, c2.Event = r2.Event;
          t3.default = c2;
        },
        9845: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.mobile = t3.iphone = t3.ie = void 0;
          var i2, a2 = (i2 = n3(9380)) && i2.__esModule ? i2 : {
            default: i2
          };
          var r2 = a2.default.navigator && a2.default.navigator.userAgent || "";
          t3.ie = r2.indexOf("MSIE ") > 0 || r2.indexOf("Trident/") > 0, t3.mobile = a2.default.navigator && a2.default.navigator.userAgentData && a2.default.navigator.userAgentData.mobile || a2.default.navigator && a2.default.navigator.maxTouchPoints || "ontouchstart" in a2.default, t3.iphone = /iphone/i.test(r2);
        },
        7184: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = function(e4) {
            return e4.replace(n3, "\\$1");
          };
          var n3 = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^"].join("|\\") + ")", "gim");
        },
        6030: function(e3, t3, n3) {
          function i2(e4) {
            return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, i2(e4);
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.EventHandlers = void 0;
          var a2, r2 = n3(9845), o2 = (a2 = n3(9380)) && a2.__esModule ? a2 : {
            default: a2
          }, l2 = n3(7760), s2 = n3(2839), c2 = n3(8711), u2 = n3(7215), f2 = n3(4713);
          function p2() {
            /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
            p2 = function() {
              return t4;
            };
            var e4, t4 = {}, n4 = Object.prototype, a3 = n4.hasOwnProperty, r3 = Object.defineProperty || function(e5, t5, n5) {
              e5[t5] = n5.value;
            }, o3 = "function" == typeof Symbol ? Symbol : {}, l3 = o3.iterator || "@@iterator", s3 = o3.asyncIterator || "@@asyncIterator", c3 = o3.toStringTag || "@@toStringTag";
            function u3(e5, t5, n5) {
              return Object.defineProperty(e5, t5, {
                value: n5,
                enumerable: true,
                configurable: true,
                writable: true
              }), e5[t5];
            }
            try {
              u3({}, "");
            } catch (e5) {
              u3 = function(e6, t5, n5) {
                return e6[t5] = n5;
              };
            }
            function f3(e5, t5, n5, i3) {
              var a4 = t5 && t5.prototype instanceof k2 ? t5 : k2, o4 = Object.create(a4.prototype), l4 = new D2(i3 || []);
              return r3(o4, "_invoke", {
                value: E2(e5, n5, l4)
              }), o4;
            }
            function d3(e5, t5, n5) {
              try {
                return {
                  type: "normal",
                  arg: e5.call(t5, n5)
                };
              } catch (e6) {
                return {
                  type: "throw",
                  arg: e6
                };
              }
            }
            t4.wrap = f3;
            var h3 = "suspendedStart", v3 = "suspendedYield", m3 = "executing", g3 = "completed", y3 = {};
            function k2() {
            }
            function b2() {
            }
            function x2() {
            }
            var w2 = {};
            u3(w2, l3, function() {
              return this;
            });
            var P2 = Object.getPrototypeOf, S2 = P2 && P2(P2(L2([])));
            S2 && S2 !== n4 && a3.call(S2, l3) && (w2 = S2);
            var O2 = x2.prototype = k2.prototype = Object.create(w2);
            function _2(e5) {
              ["next", "throw", "return"].forEach(function(t5) {
                u3(e5, t5, function(e6) {
                  return this._invoke(t5, e6);
                });
              });
            }
            function M2(e5, t5) {
              function n5(r4, o5, l4, s4) {
                var c4 = d3(e5[r4], e5, o5);
                if ("throw" !== c4.type) {
                  var u4 = c4.arg, f4 = u4.value;
                  return f4 && "object" == i2(f4) && a3.call(f4, "__await") ? t5.resolve(f4.__await).then(function(e6) {
                    n5("next", e6, l4, s4);
                  }, function(e6) {
                    n5("throw", e6, l4, s4);
                  }) : t5.resolve(f4).then(function(e6) {
                    u4.value = e6, l4(u4);
                  }, function(e6) {
                    return n5("throw", e6, l4, s4);
                  });
                }
                s4(c4.arg);
              }
              var o4;
              r3(this, "_invoke", {
                value: function(e6, i3) {
                  function a4() {
                    return new t5(function(t6, a5) {
                      n5(e6, i3, t6, a5);
                    });
                  }
                  return o4 = o4 ? o4.then(a4, a4) : a4();
                }
              });
            }
            function E2(t5, n5, i3) {
              var a4 = h3;
              return function(r4, o4) {
                if (a4 === m3)
                  throw new Error("Generator is already running");
                if (a4 === g3) {
                  if ("throw" === r4)
                    throw o4;
                  return {
                    value: e4,
                    done: true
                  };
                }
                for (i3.method = r4, i3.arg = o4; ; ) {
                  var l4 = i3.delegate;
                  if (l4) {
                    var s4 = j2(l4, i3);
                    if (s4) {
                      if (s4 === y3)
                        continue;
                      return s4;
                    }
                  }
                  if ("next" === i3.method)
                    i3.sent = i3._sent = i3.arg;
                  else if ("throw" === i3.method) {
                    if (a4 === h3)
                      throw a4 = g3, i3.arg;
                    i3.dispatchException(i3.arg);
                  } else
                    "return" === i3.method && i3.abrupt("return", i3.arg);
                  a4 = m3;
                  var c4 = d3(t5, n5, i3);
                  if ("normal" === c4.type) {
                    if (a4 = i3.done ? g3 : v3, c4.arg === y3)
                      continue;
                    return {
                      value: c4.arg,
                      done: i3.done
                    };
                  }
                  "throw" === c4.type && (a4 = g3, i3.method = "throw", i3.arg = c4.arg);
                }
              };
            }
            function j2(t5, n5) {
              var i3 = n5.method, a4 = t5.iterator[i3];
              if (a4 === e4)
                return n5.delegate = null, "throw" === i3 && t5.iterator.return && (n5.method = "return", n5.arg = e4, j2(t5, n5), "throw" === n5.method) || "return" !== i3 && (n5.method = "throw", n5.arg = new TypeError("The iterator does not provide a '" + i3 + "' method")), y3;
              var r4 = d3(a4, t5.iterator, n5.arg);
              if ("throw" === r4.type)
                return n5.method = "throw", n5.arg = r4.arg, n5.delegate = null, y3;
              var o4 = r4.arg;
              return o4 ? o4.done ? (n5[t5.resultName] = o4.value, n5.next = t5.nextLoc, "return" !== n5.method && (n5.method = "next", n5.arg = e4), n5.delegate = null, y3) : o4 : (n5.method = "throw", n5.arg = new TypeError("iterator result is not an object"), n5.delegate = null, y3);
            }
            function T2(e5) {
              var t5 = {
                tryLoc: e5[0]
              };
              1 in e5 && (t5.catchLoc = e5[1]), 2 in e5 && (t5.finallyLoc = e5[2], t5.afterLoc = e5[3]), this.tryEntries.push(t5);
            }
            function A2(e5) {
              var t5 = e5.completion || {};
              t5.type = "normal", delete t5.arg, e5.completion = t5;
            }
            function D2(e5) {
              this.tryEntries = [{
                tryLoc: "root"
              }], e5.forEach(T2, this), this.reset(true);
            }
            function L2(t5) {
              if (t5 || "" === t5) {
                var n5 = t5[l3];
                if (n5)
                  return n5.call(t5);
                if ("function" == typeof t5.next)
                  return t5;
                if (!isNaN(t5.length)) {
                  var r4 = -1, o4 = function n6() {
                    for (; ++r4 < t5.length; )
                      if (a3.call(t5, r4))
                        return n6.value = t5[r4], n6.done = false, n6;
                    return n6.value = e4, n6.done = true, n6;
                  };
                  return o4.next = o4;
                }
              }
              throw new TypeError(i2(t5) + " is not iterable");
            }
            return b2.prototype = x2, r3(O2, "constructor", {
              value: x2,
              configurable: true
            }), r3(x2, "constructor", {
              value: b2,
              configurable: true
            }), b2.displayName = u3(x2, c3, "GeneratorFunction"), t4.isGeneratorFunction = function(e5) {
              var t5 = "function" == typeof e5 && e5.constructor;
              return !!t5 && (t5 === b2 || "GeneratorFunction" === (t5.displayName || t5.name));
            }, t4.mark = function(e5) {
              return Object.setPrototypeOf ? Object.setPrototypeOf(e5, x2) : (e5.__proto__ = x2, u3(e5, c3, "GeneratorFunction")), e5.prototype = Object.create(O2), e5;
            }, t4.awrap = function(e5) {
              return {
                __await: e5
              };
            }, _2(M2.prototype), u3(M2.prototype, s3, function() {
              return this;
            }), t4.AsyncIterator = M2, t4.async = function(e5, n5, i3, a4, r4) {
              void 0 === r4 && (r4 = Promise);
              var o4 = new M2(f3(e5, n5, i3, a4), r4);
              return t4.isGeneratorFunction(n5) ? o4 : o4.next().then(function(e6) {
                return e6.done ? e6.value : o4.next();
              });
            }, _2(O2), u3(O2, c3, "Generator"), u3(O2, l3, function() {
              return this;
            }), u3(O2, "toString", function() {
              return "[object Generator]";
            }), t4.keys = function(e5) {
              var t5 = Object(e5), n5 = [];
              for (var i3 in t5)
                n5.push(i3);
              return n5.reverse(), function e6() {
                for (; n5.length; ) {
                  var i4 = n5.pop();
                  if (i4 in t5)
                    return e6.value = i4, e6.done = false, e6;
                }
                return e6.done = true, e6;
              };
            }, t4.values = L2, D2.prototype = {
              constructor: D2,
              reset: function(t5) {
                if (this.prev = 0, this.next = 0, this.sent = this._sent = e4, this.done = false, this.delegate = null, this.method = "next", this.arg = e4, this.tryEntries.forEach(A2), !t5)
                  for (var n5 in this)
                    "t" === n5.charAt(0) && a3.call(this, n5) && !isNaN(+n5.slice(1)) && (this[n5] = e4);
              },
              stop: function() {
                this.done = true;
                var e5 = this.tryEntries[0].completion;
                if ("throw" === e5.type)
                  throw e5.arg;
                return this.rval;
              },
              dispatchException: function(t5) {
                if (this.done)
                  throw t5;
                var n5 = this;
                function i3(i4, a4) {
                  return l4.type = "throw", l4.arg = t5, n5.next = i4, a4 && (n5.method = "next", n5.arg = e4), !!a4;
                }
                for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
                  var o4 = this.tryEntries[r4], l4 = o4.completion;
                  if ("root" === o4.tryLoc)
                    return i3("end");
                  if (o4.tryLoc <= this.prev) {
                    var s4 = a3.call(o4, "catchLoc"), c4 = a3.call(o4, "finallyLoc");
                    if (s4 && c4) {
                      if (this.prev < o4.catchLoc)
                        return i3(o4.catchLoc, true);
                      if (this.prev < o4.finallyLoc)
                        return i3(o4.finallyLoc);
                    } else if (s4) {
                      if (this.prev < o4.catchLoc)
                        return i3(o4.catchLoc, true);
                    } else {
                      if (!c4)
                        throw new Error("try statement without catch or finally");
                      if (this.prev < o4.finallyLoc)
                        return i3(o4.finallyLoc);
                    }
                  }
                }
              },
              abrupt: function(e5, t5) {
                for (var n5 = this.tryEntries.length - 1; n5 >= 0; --n5) {
                  var i3 = this.tryEntries[n5];
                  if (i3.tryLoc <= this.prev && a3.call(i3, "finallyLoc") && this.prev < i3.finallyLoc) {
                    var r4 = i3;
                    break;
                  }
                }
                r4 && ("break" === e5 || "continue" === e5) && r4.tryLoc <= t5 && t5 <= r4.finallyLoc && (r4 = null);
                var o4 = r4 ? r4.completion : {};
                return o4.type = e5, o4.arg = t5, r4 ? (this.method = "next", this.next = r4.finallyLoc, y3) : this.complete(o4);
              },
              complete: function(e5, t5) {
                if ("throw" === e5.type)
                  throw e5.arg;
                return "break" === e5.type || "continue" === e5.type ? this.next = e5.arg : "return" === e5.type ? (this.rval = this.arg = e5.arg, this.method = "return", this.next = "end") : "normal" === e5.type && t5 && (this.next = t5), y3;
              },
              finish: function(e5) {
                for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                  var n5 = this.tryEntries[t5];
                  if (n5.finallyLoc === e5)
                    return this.complete(n5.completion, n5.afterLoc), A2(n5), y3;
                }
              },
              catch: function(e5) {
                for (var t5 = this.tryEntries.length - 1; t5 >= 0; --t5) {
                  var n5 = this.tryEntries[t5];
                  if (n5.tryLoc === e5) {
                    var i3 = n5.completion;
                    if ("throw" === i3.type) {
                      var a4 = i3.arg;
                      A2(n5);
                    }
                    return a4;
                  }
                }
                throw new Error("illegal catch attempt");
              },
              delegateYield: function(t5, n5, i3) {
                return this.delegate = {
                  iterator: L2(t5),
                  resultName: n5,
                  nextLoc: i3
                }, "next" === this.method && (this.arg = e4), y3;
              }
            }, t4;
          }
          function d2(e4, t4) {
            var n4 = "undefined" != typeof Symbol && e4[Symbol.iterator] || e4["@@iterator"];
            if (!n4) {
              if (Array.isArray(e4) || (n4 = function(e5, t5) {
                if (!e5)
                  return;
                if ("string" == typeof e5)
                  return h2(e5, t5);
                var n5 = Object.prototype.toString.call(e5).slice(8, -1);
                "Object" === n5 && e5.constructor && (n5 = e5.constructor.name);
                if ("Map" === n5 || "Set" === n5)
                  return Array.from(e5);
                if ("Arguments" === n5 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n5))
                  return h2(e5, t5);
              }(e4)) || t4 && e4 && "number" == typeof e4.length) {
                n4 && (e4 = n4);
                var i3 = 0, a3 = function() {
                };
                return {
                  s: a3,
                  n: function() {
                    return i3 >= e4.length ? {
                      done: true
                    } : {
                      done: false,
                      value: e4[i3++]
                    };
                  },
                  e: function(e5) {
                    throw e5;
                  },
                  f: a3
                };
              }
              throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }
            var r3, o3 = true, l3 = false;
            return {
              s: function() {
                n4 = n4.call(e4);
              },
              n: function() {
                var e5 = n4.next();
                return o3 = e5.done, e5;
              },
              e: function(e5) {
                l3 = true, r3 = e5;
              },
              f: function() {
                try {
                  o3 || null == n4.return || n4.return();
                } finally {
                  if (l3)
                    throw r3;
                }
              }
            };
          }
          function h2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          function v2(e4, t4, n4, i3, a3, r3, o3) {
            try {
              var l3 = e4[r3](o3), s3 = l3.value;
            } catch (e5) {
              return void n4(e5);
            }
            l3.done ? t4(s3) : Promise.resolve(s3).then(i3, a3);
          }
          var m2, g2, y2 = t3.EventHandlers = {
            keyEvent: function(e4, t4, n4, i3, a3) {
              var o3 = this.inputmask, p3 = o3.opts, d3 = o3.dependencyLib, h3 = o3.maskset, v3 = this, m3 = d3(v3), g3 = e4.key, k2 = c2.caret.call(o3, v3), b2 = p3.onKeyDown.call(this, e4, c2.getBuffer.call(o3), k2, p3);
              if (void 0 !== b2)
                return b2;
              if (g3 === s2.keys.Backspace || g3 === s2.keys.Delete || r2.iphone && g3 === s2.keys.BACKSPACE_SAFARI || e4.ctrlKey && g3 === s2.keys.x && !("oncut" in v3))
                e4.preventDefault(), u2.handleRemove.call(o3, v3, g3, k2), (0, l2.writeBuffer)(v3, c2.getBuffer.call(o3, true), h3.p, e4, v3.inputmask._valueGet() !== c2.getBuffer.call(o3).join(""));
              else if (g3 === s2.keys.End || g3 === s2.keys.PageDown) {
                e4.preventDefault();
                var x2 = c2.seekNext.call(o3, c2.getLastValidPosition.call(o3));
                c2.caret.call(o3, v3, e4.shiftKey ? k2.begin : x2, x2, true);
              } else
                g3 === s2.keys.Home && !e4.shiftKey || g3 === s2.keys.PageUp ? (e4.preventDefault(), c2.caret.call(o3, v3, 0, e4.shiftKey ? k2.begin : 0, true)) : p3.undoOnEscape && g3 === s2.keys.Escape && true !== e4.altKey ? ((0, l2.checkVal)(v3, true, false, o3.undoValue.split("")), m3.trigger("click")) : g3 !== s2.keys.Insert || e4.shiftKey || e4.ctrlKey || void 0 !== o3.userOptions.insertMode ? true === p3.tabThrough && g3 === s2.keys.Tab ? true === e4.shiftKey ? (k2.end = c2.seekPrevious.call(o3, k2.end, true), true === f2.getTest.call(o3, k2.end - 1).match.static && k2.end--, k2.begin = c2.seekPrevious.call(o3, k2.end, true), k2.begin >= 0 && k2.end > 0 && (e4.preventDefault(), c2.caret.call(o3, v3, k2.begin, k2.end))) : (k2.begin = c2.seekNext.call(o3, k2.begin, true), k2.end = c2.seekNext.call(o3, k2.begin, true), k2.end < h3.maskLength && k2.end--, k2.begin <= h3.maskLength && (e4.preventDefault(), c2.caret.call(o3, v3, k2.begin, k2.end))) : e4.shiftKey || (p3.insertModeVisual && false === p3.insertMode ? g3 === s2.keys.ArrowRight ? setTimeout(function() {
                  var e5 = c2.caret.call(o3, v3);
                  c2.caret.call(o3, v3, e5.begin);
                }, 0) : g3 === s2.keys.ArrowLeft && setTimeout(function() {
                  var e5 = c2.translatePosition.call(o3, v3.inputmask.caretPos.begin);
                  c2.translatePosition.call(o3, v3.inputmask.caretPos.end);
                  o3.isRTL ? c2.caret.call(o3, v3, e5 + (e5 === h3.maskLength ? 0 : 1)) : c2.caret.call(o3, v3, e5 - (0 === e5 ? 0 : 1));
                }, 0) : void 0 === o3.keyEventHook || o3.keyEventHook(e4)) : u2.isSelection.call(o3, k2) ? p3.insertMode = !p3.insertMode : (p3.insertMode = !p3.insertMode, c2.caret.call(o3, v3, k2.begin, k2.begin));
              return o3.isComposing = g3 == s2.keys.Process || g3 == s2.keys.Unidentified, o3.ignorable = g3.length > 1 && !("textarea" === v3.tagName.toLowerCase() && g3 == s2.keys.Enter), y2.keypressEvent.call(this, e4, t4, n4, i3, a3);
            },
            keypressEvent: function(e4, t4, n4, i3, a3) {
              var r3 = this.inputmask || this, o3 = r3.opts, f3 = r3.dependencyLib, p3 = r3.maskset, d3 = r3.el, h3 = f3(d3), v3 = e4.key;
              if (true === t4 || e4.ctrlKey && e4.altKey && !r3.ignorable || !(e4.ctrlKey || e4.metaKey || r3.ignorable)) {
                if (v3) {
                  var m3, g3 = t4 ? {
                    begin: a3,
                    end: a3
                  } : c2.caret.call(r3, d3);
                  t4 || (v3 = o3.substitutes[v3] || v3), p3.writeOutBuffer = true;
                  var y3 = u2.isValid.call(r3, g3, v3, i3, void 0, void 0, void 0, t4);
                  if (false !== y3 && (c2.resetMaskSet.call(r3, true), m3 = void 0 !== y3.caret ? y3.caret : c2.seekNext.call(r3, y3.pos.begin ? y3.pos.begin : y3.pos), p3.p = m3), m3 = o3.numericInput && void 0 === y3.caret ? c2.seekPrevious.call(r3, m3) : m3, false !== n4 && (setTimeout(function() {
                    o3.onKeyValidation.call(d3, v3, y3);
                  }, 0), p3.writeOutBuffer && false !== y3)) {
                    var k2 = c2.getBuffer.call(r3);
                    (0, l2.writeBuffer)(d3, k2, m3, e4, true !== t4);
                  }
                  if (e4.preventDefault(), t4)
                    return false !== y3 && (y3.forwardPosition = m3), y3;
                }
              } else
                v3 === s2.keys.Enter && r3.undoValue !== r3._valueGet(true) && (r3.undoValue = r3._valueGet(true), setTimeout(function() {
                  h3.trigger("change");
                }, 0));
            },
            pasteEvent: (m2 = p2().mark(function e4(t4) {
              var n4, i3, a3, r3, s3, u3;
              return p2().wrap(function(e5) {
                for (; ; )
                  switch (e5.prev = e5.next) {
                    case 0:
                      n4 = function(e6, n5, i4, a4, o3) {
                        var s4 = c2.caret.call(e6, n5, void 0, void 0, true), u4 = i4.substr(0, s4.begin), f3 = i4.substr(s4.end, i4.length);
                        if (u4 == (e6.isRTL ? c2.getBufferTemplate.call(e6).slice().reverse() : c2.getBufferTemplate.call(e6)).slice(0, s4.begin).join("") && (u4 = ""), f3 == (e6.isRTL ? c2.getBufferTemplate.call(e6).slice().reverse() : c2.getBufferTemplate.call(e6)).slice(s4.end).join("") && (f3 = ""), a4 = u4 + a4 + f3, e6.isRTL && true !== r3.numericInput) {
                          a4 = a4.split("");
                          var p3, h3 = d2(c2.getBufferTemplate.call(e6));
                          try {
                            for (h3.s(); !(p3 = h3.n()).done; ) {
                              var v3 = p3.value;
                              a4[0] === v3 && a4.shift();
                            }
                          } catch (e7) {
                            h3.e(e7);
                          } finally {
                            h3.f();
                          }
                          a4 = a4.reverse().join("");
                        }
                        var m3 = a4;
                        if ("function" == typeof o3) {
                          if (false === (m3 = o3.call(e6, m3, r3)))
                            return false;
                          m3 || (m3 = i4);
                        }
                        (0, l2.checkVal)(n5, true, false, m3.toString().split(""), t4);
                      }, i3 = this, a3 = this.inputmask, r3 = a3.opts, s3 = a3._valueGet(true), a3.skipInputEvent = true, t4.clipboardData && t4.clipboardData.getData ? u3 = t4.clipboardData.getData("text/plain") : o2.default.clipboardData && o2.default.clipboardData.getData && (u3 = o2.default.clipboardData.getData("Text")), n4(a3, i3, s3, u3, r3.onBeforePaste), t4.preventDefault();
                    case 7:
                    case "end":
                      return e5.stop();
                  }
              }, e4, this);
            }), g2 = function() {
              var e4 = this, t4 = arguments;
              return new Promise(function(n4, i3) {
                var a3 = m2.apply(e4, t4);
                function r3(e5) {
                  v2(a3, n4, i3, r3, o3, "next", e5);
                }
                function o3(e5) {
                  v2(a3, n4, i3, r3, o3, "throw", e5);
                }
                r3(void 0);
              });
            }, function(e4) {
              return g2.apply(this, arguments);
            }),
            inputFallBackEvent: function(e4) {
              var t4 = this.inputmask, n4 = t4.opts, i3 = t4.dependencyLib;
              var a3, o3 = this, u3 = o3.inputmask._valueGet(true), p3 = (t4.isRTL ? c2.getBuffer.call(t4).slice().reverse() : c2.getBuffer.call(t4)).join(""), d3 = c2.caret.call(t4, o3, void 0, void 0, true);
              if (p3 !== u3) {
                if (a3 = function(e5, i4, a4) {
                  for (var r3, o4, l3, s3 = e5.substr(0, a4.begin).split(""), u4 = e5.substr(a4.begin).split(""), p4 = i4.substr(0, a4.begin).split(""), d4 = i4.substr(a4.begin).split(""), h4 = s3.length >= p4.length ? s3.length : p4.length, v3 = u4.length >= d4.length ? u4.length : d4.length, m3 = "", g3 = [], y3 = "~"; s3.length < h4; )
                    s3.push(y3);
                  for (; p4.length < h4; )
                    p4.push(y3);
                  for (; u4.length < v3; )
                    u4.unshift(y3);
                  for (; d4.length < v3; )
                    d4.unshift(y3);
                  var k2 = s3.concat(u4), b2 = p4.concat(d4);
                  for (o4 = 0, r3 = k2.length; o4 < r3; o4++)
                    switch (l3 = f2.getPlaceholder.call(t4, c2.translatePosition.call(t4, o4)), m3) {
                      case "insertText":
                        b2[o4 - 1] === k2[o4] && a4.begin == k2.length - 1 && g3.push(k2[o4]), o4 = r3;
                        break;
                      case "insertReplacementText":
                      case "deleteContentBackward":
                        k2[o4] === y3 ? a4.end++ : o4 = r3;
                        break;
                      default:
                        k2[o4] !== b2[o4] && (k2[o4 + 1] !== y3 && k2[o4 + 1] !== l3 && void 0 !== k2[o4 + 1] || (b2[o4] !== l3 || b2[o4 + 1] !== y3) && b2[o4] !== y3 ? b2[o4 + 1] === y3 && b2[o4] === k2[o4 + 1] ? (m3 = "insertText", g3.push(k2[o4]), a4.begin--, a4.end--) : k2[o4] !== l3 && k2[o4] !== y3 && (k2[o4 + 1] === y3 || b2[o4] !== k2[o4] && b2[o4 + 1] === k2[o4 + 1]) ? (m3 = "insertReplacementText", g3.push(k2[o4]), a4.begin--) : k2[o4] === y3 ? (m3 = "deleteContentBackward", (c2.isMask.call(t4, c2.translatePosition.call(t4, o4), true) || b2[o4] === n4.radixPoint) && a4.end++) : o4 = r3 : (m3 = "insertText", g3.push(k2[o4]), a4.begin--, a4.end--));
                    }
                  return {
                    action: m3,
                    data: g3,
                    caret: a4
                  };
                }(u3, p3, d3), (o3.inputmask.shadowRoot || o3.ownerDocument).activeElement !== o3 && o3.focus(), (0, l2.writeBuffer)(o3, c2.getBuffer.call(t4)), c2.caret.call(t4, o3, d3.begin, d3.end, true), !r2.mobile && t4.skipNextInsert && "insertText" === e4.inputType && "insertText" === a3.action && t4.isComposing)
                  return false;
                switch ("insertCompositionText" === e4.inputType && "insertText" === a3.action && t4.isComposing ? t4.skipNextInsert = true : t4.skipNextInsert = false, a3.action) {
                  case "insertText":
                  case "insertReplacementText":
                    a3.data.forEach(function(e5, n5) {
                      var a4 = new i3.Event("keypress");
                      a4.key = e5, t4.ignorable = false, y2.keypressEvent.call(o3, a4);
                    }), setTimeout(function() {
                      t4.$el.trigger("keyup");
                    }, 0);
                    break;
                  case "deleteContentBackward":
                    var h3 = new i3.Event("keydown");
                    h3.key = s2.keys.Backspace, y2.keyEvent.call(o3, h3);
                    break;
                  default:
                    (0, l2.applyInputValue)(o3, u3), c2.caret.call(t4, o3, d3.begin, d3.end, true);
                }
                e4.preventDefault();
              }
            },
            setValueEvent: function(e4) {
              var t4 = this.inputmask, n4 = t4.dependencyLib, i3 = this, a3 = e4 && e4.detail ? e4.detail[0] : arguments[1];
              void 0 === a3 && (a3 = i3.inputmask._valueGet(true)), (0, l2.applyInputValue)(i3, a3, new n4.Event("input")), (e4.detail && void 0 !== e4.detail[1] || void 0 !== arguments[2]) && c2.caret.call(t4, i3, e4.detail ? e4.detail[1] : arguments[2]);
            },
            focusEvent: function(e4) {
              var t4 = this.inputmask, n4 = t4.opts, i3 = t4 && t4._valueGet();
              n4.showMaskOnFocus && i3 !== c2.getBuffer.call(t4).join("") && (0, l2.writeBuffer)(this, c2.getBuffer.call(t4), c2.seekNext.call(t4, c2.getLastValidPosition.call(t4))), true !== n4.positionCaretOnTab || false !== t4.mouseEnter || u2.isComplete.call(t4, c2.getBuffer.call(t4)) && -1 !== c2.getLastValidPosition.call(t4) || y2.clickEvent.apply(this, [e4, true]), t4.undoValue = t4 && t4._valueGet(true);
            },
            invalidEvent: function(e4) {
              this.inputmask.validationEvent = true;
            },
            mouseleaveEvent: function() {
              var e4 = this.inputmask, t4 = e4.opts, n4 = this;
              e4.mouseEnter = false, t4.clearMaskOnLostFocus && (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement !== n4 && (0, l2.HandleNativePlaceholder)(n4, e4.originalPlaceholder);
            },
            clickEvent: function(e4, t4) {
              var n4 = this.inputmask;
              n4.clicked++;
              var i3 = this;
              if ((i3.inputmask.shadowRoot || i3.ownerDocument).activeElement === i3) {
                var a3 = c2.determineNewCaretPosition.call(n4, c2.caret.call(n4, i3), t4);
                void 0 !== a3 && c2.caret.call(n4, i3, a3);
              }
            },
            cutEvent: function(e4) {
              var t4 = this.inputmask, n4 = t4.maskset, i3 = this, a3 = c2.caret.call(t4, i3), r3 = t4.isRTL ? c2.getBuffer.call(t4).slice(a3.end, a3.begin) : c2.getBuffer.call(t4).slice(a3.begin, a3.end), f3 = t4.isRTL ? r3.reverse().join("") : r3.join("");
              o2.default.navigator && o2.default.navigator.clipboard ? o2.default.navigator.clipboard.writeText(f3) : o2.default.clipboardData && o2.default.clipboardData.getData && o2.default.clipboardData.setData("Text", f3), u2.handleRemove.call(t4, i3, s2.keys.Delete, a3), (0, l2.writeBuffer)(i3, c2.getBuffer.call(t4), n4.p, e4, t4.undoValue !== t4._valueGet(true));
            },
            blurEvent: function(e4) {
              var t4 = this.inputmask, n4 = t4.opts, i3 = t4.dependencyLib;
              t4.clicked = 0;
              var a3 = i3(this), r3 = this;
              if (r3.inputmask) {
                (0, l2.HandleNativePlaceholder)(r3, t4.originalPlaceholder);
                var o3 = r3.inputmask._valueGet(), s3 = c2.getBuffer.call(t4).slice();
                "" !== o3 && (n4.clearMaskOnLostFocus && (-1 === c2.getLastValidPosition.call(t4) && o3 === c2.getBufferTemplate.call(t4).join("") ? s3 = [] : l2.clearOptionalTail.call(t4, s3)), false === u2.isComplete.call(t4, s3) && (setTimeout(function() {
                  a3.trigger("incomplete");
                }, 0), n4.clearIncomplete && (c2.resetMaskSet.call(t4, false), s3 = n4.clearMaskOnLostFocus ? [] : c2.getBufferTemplate.call(t4).slice())), (0, l2.writeBuffer)(r3, s3, void 0, e4)), o3 = t4._valueGet(true), t4.undoValue !== o3 && ("" != o3 || t4.undoValue != c2.getBufferTemplate.call(t4).join("") || t4.undoValue == c2.getBufferTemplate.call(t4).join("") && t4.maskset.validPositions.length > 0) && (t4.undoValue = o3, a3.trigger("change"));
              }
            },
            mouseenterEvent: function() {
              var e4 = this.inputmask, t4 = e4.opts.showMaskOnHover, n4 = this;
              if (e4.mouseEnter = true, (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement !== n4) {
                var i3 = (e4.isRTL ? c2.getBufferTemplate.call(e4).slice().reverse() : c2.getBufferTemplate.call(e4)).join("");
                t4 && (0, l2.HandleNativePlaceholder)(n4, i3);
              }
            },
            submitEvent: function() {
              var e4 = this.inputmask, t4 = e4.opts;
              e4.undoValue !== e4._valueGet(true) && e4.$el.trigger("change"), -1 === c2.getLastValidPosition.call(e4) && e4._valueGet && e4._valueGet() === c2.getBufferTemplate.call(e4).join("") && e4._valueSet(""), t4.clearIncomplete && false === u2.isComplete.call(e4, c2.getBuffer.call(e4)) && e4._valueSet(""), t4.removeMaskOnSubmit && (e4._valueSet(e4.unmaskedvalue(), true), setTimeout(function() {
                (0, l2.writeBuffer)(e4.el, c2.getBuffer.call(e4));
              }, 0));
            },
            resetEvent: function() {
              var e4 = this.inputmask;
              e4.refreshValue = true, setTimeout(function() {
                (0, l2.applyInputValue)(e4.el, e4._valueGet(true));
              }, 0);
            }
          };
        },
        9716: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.EventRuler = void 0;
          var i2, a2 = n3(7760), r2 = (i2 = n3(2394)) && i2.__esModule ? i2 : {
            default: i2
          }, o2 = n3(2839), l2 = n3(8711);
          t3.EventRuler = {
            on: function(e4, t4, n4) {
              var i3 = e4.inputmask.dependencyLib, s2 = function(t5) {
                t5.originalEvent && (t5 = t5.originalEvent || t5, arguments[0] = t5);
                var s3, c2 = this, u2 = c2.inputmask, f2 = u2 ? u2.opts : void 0;
                if (void 0 === u2 && "FORM" !== this.nodeName) {
                  var p2 = i3.data(c2, "_inputmask_opts");
                  i3(c2).off(), p2 && new r2.default(p2).mask(c2);
                } else {
                  if (["submit", "reset", "setvalue"].includes(t5.type) || "FORM" === this.nodeName || !(c2.disabled || c2.readOnly && !("keydown" === t5.type && t5.ctrlKey && t5.key === o2.keys.c || false === f2.tabThrough && t5.key === o2.keys.Tab))) {
                    switch (t5.type) {
                      case "input":
                        if (true === u2.skipInputEvent)
                          return u2.skipInputEvent = false, t5.preventDefault();
                        break;
                      case "click":
                      case "focus":
                        return u2.validationEvent ? (u2.validationEvent = false, e4.blur(), (0, a2.HandleNativePlaceholder)(e4, (u2.isRTL ? l2.getBufferTemplate.call(u2).slice().reverse() : l2.getBufferTemplate.call(u2)).join("")), setTimeout(function() {
                          e4.focus();
                        }, f2.validationEventTimeOut), false) : (s3 = arguments, void setTimeout(function() {
                          e4.inputmask && n4.apply(c2, s3);
                        }, 0));
                    }
                    var d2 = n4.apply(c2, arguments);
                    return false === d2 && (t5.preventDefault(), t5.stopPropagation()), d2;
                  }
                  t5.preventDefault();
                }
              };
              ["submit", "reset"].includes(t4) ? (s2 = s2.bind(e4), null !== e4.form && i3(e4.form).on(t4, s2)) : i3(e4).on(t4, s2), e4.inputmask.events[t4] = e4.inputmask.events[t4] || [], e4.inputmask.events[t4].push(s2);
            },
            off: function(e4, t4) {
              if (e4.inputmask && e4.inputmask.events) {
                var n4 = e4.inputmask.dependencyLib, i3 = e4.inputmask.events;
                for (var a3 in t4 && ((i3 = [])[t4] = e4.inputmask.events[t4]), i3) {
                  for (var r3 = i3[a3]; r3.length > 0; ) {
                    var o3 = r3.pop();
                    ["submit", "reset"].includes(a3) ? null !== e4.form && n4(e4.form).off(a3, o3) : n4(e4).off(a3, o3);
                  }
                  delete e4.inputmask.events[a3];
                }
              }
            }
          };
        },
        219: function(e3, t3, n3) {
          var i2 = p2(n3(7184)), a2 = p2(n3(2394)), r2 = n3(2839), o2 = n3(8711), l2 = n3(4713);
          function s2(e4, t4) {
            return function(e5) {
              if (Array.isArray(e5))
                return e5;
            }(e4) || function(e5, t5) {
              var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
              if (null != n4) {
                var i3, a3, r3, o3, l3 = [], s3 = true, c3 = false;
                try {
                  if (r3 = (n4 = n4.call(e5)).next, 0 === t5) {
                    if (Object(n4) !== n4)
                      return;
                    s3 = false;
                  } else
                    for (; !(s3 = (i3 = r3.call(n4)).done) && (l3.push(i3.value), l3.length !== t5); s3 = true)
                      ;
                } catch (e6) {
                  c3 = true, a3 = e6;
                } finally {
                  try {
                    if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3))
                      return;
                  } finally {
                    if (c3)
                      throw a3;
                  }
                }
                return l3;
              }
            }(e4, t4) || function(e5, t5) {
              if (!e5)
                return;
              if ("string" == typeof e5)
                return c2(e5, t5);
              var n4 = Object.prototype.toString.call(e5).slice(8, -1);
              "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
              if ("Map" === n4 || "Set" === n4)
                return Array.from(e5);
              if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
                return c2(e5, t5);
            }(e4, t4) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function c2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          function u2(e4) {
            return u2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, u2(e4);
          }
          function f2(e4, t4) {
            for (var n4 = 0; n4 < t4.length; n4++) {
              var i3 = t4[n4];
              i3.enumerable = i3.enumerable || false, i3.configurable = true, "value" in i3 && (i3.writable = true), Object.defineProperty(e4, (a3 = i3.key, r3 = void 0, r3 = function(e5, t5) {
                if ("object" !== u2(e5) || null === e5)
                  return e5;
                var n5 = e5[Symbol.toPrimitive];
                if (void 0 !== n5) {
                  var i4 = n5.call(e5, t5 || "default");
                  if ("object" !== u2(i4))
                    return i4;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t5 ? String : Number)(e5);
              }(a3, "string"), "symbol" === u2(r3) ? r3 : String(r3)), i3);
            }
            var a3, r3;
          }
          function p2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          n3(1313);
          var d2 = a2.default.dependencyLib, h2 = function() {
            function e4(t5, n5, i3, a3) {
              !function(e5, t6) {
                if (!(e5 instanceof t6))
                  throw new TypeError("Cannot call a class as a function");
              }(this, e4), this.mask = t5, this.format = n5, this.opts = i3, this.inputmask = a3, this._date = new Date(1, 0, 1), this.initDateObject(t5, this.opts, this.inputmask);
            }
            var t4, n4;
            return t4 = e4, (n4 = [{
              key: "date",
              get: function() {
                return void 0 === this._date && (this._date = new Date(1, 0, 1), this.initDateObject(void 0, this.opts, this.inputmask)), this._date;
              }
            }, {
              key: "initDateObject",
              value: function(e5, t5, n5) {
                var i3;
                for (P2(t5).lastIndex = 0; i3 = P2(t5).exec(this.format); ) {
                  var a3 = /\d+$/.exec(i3[0]), r3 = a3 ? i3[0][0] + "x" : i3[0], o3 = void 0;
                  if (void 0 !== e5) {
                    if (a3) {
                      var s3 = P2(t5).lastIndex, c3 = j2.call(n5, i3.index, t5, n5 && n5.maskset);
                      P2(t5).lastIndex = s3, o3 = e5.slice(0, e5.indexOf(c3.nextMatch[0]));
                    } else {
                      for (var u3 = i3[0][0], f3 = i3.index; n5 && (t5.placeholder[l2.getTest.call(n5, f3).match.placeholder] || l2.getTest.call(n5, f3).match.placeholder) === u3; )
                        f3++;
                      var p3 = f3 - i3.index;
                      o3 = e5.slice(0, p3 || y2[r3] && y2[r3][4] || r3.length);
                    }
                    e5 = e5.slice(o3.length);
                  }
                  Object.prototype.hasOwnProperty.call(y2, r3) && this.setValue(this, o3, r3, y2[r3][2], y2[r3][1]);
                }
              }
            }, {
              key: "setValue",
              value: function(e5, t5, n5, i3, a3) {
                if (void 0 !== t5)
                  switch (i3) {
                    case "ampm":
                      e5[i3] = t5, e5["raw" + i3] = t5.replace(/\s/g, "_");
                      break;
                    case "month":
                      if ("mmm" === n5 || "mmmm" === n5) {
                        e5[i3] = _2("mmm" === n5 ? m2.monthNames.slice(0, 12).findIndex(function(e6) {
                          return t5.toLowerCase() === e6.toLowerCase();
                        }) + 1 : m2.monthNames.slice(12, 24).findIndex(function(e6) {
                          return t5.toLowerCase() === e6.toLowerCase();
                        }) + 1, 2), e5[i3] = "00" === e5[i3] ? "" : e5[i3].toString(), e5["raw" + i3] = e5[i3];
                        break;
                      }
                    default:
                      e5[i3] = t5.replace(/[^0-9]/g, "0"), e5["raw" + i3] = t5.replace(/\s/g, "_");
                  }
                if (void 0 !== a3) {
                  var r3 = e5[i3];
                  ("day" === i3 && 29 === parseInt(r3) || "month" === i3 && 2 === parseInt(r3)) && (29 !== parseInt(e5.day) || 2 !== parseInt(e5.month) || "" !== e5.year && void 0 !== e5.year || e5._date.setFullYear(2012, 1, 29)), "day" === i3 && (g2 = true, 0 === parseInt(r3) && (r3 = 1)), "month" === i3 && (g2 = true), "year" === i3 && (g2 = true, r3.length < y2[n5][4] && (r3 = _2(r3, y2[n5][4], true))), ("" !== r3 && !isNaN(r3) || "ampm" === i3) && a3.call(e5._date, r3);
                }
              }
            }, {
              key: "reset",
              value: function() {
                this._date = new Date(1, 0, 1);
              }
            }, {
              key: "reInit",
              value: function() {
                this._date = void 0, this.date;
              }
            }]) && f2(t4.prototype, n4), Object.defineProperty(t4, "prototype", {
              writable: false
            }), e4;
          }(), v2 = (/* @__PURE__ */ new Date()).getFullYear(), m2 = a2.default.prototype.i18n, g2 = false, y2 = {
            d: ["[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", Date.prototype.getDate],
            dd: ["0[1-9]|[12][0-9]|3[01]", Date.prototype.setDate, "day", function() {
              return _2(Date.prototype.getDate.call(this), 2);
            }],
            ddd: [""],
            dddd: [""],
            m: ["[1-9]|1[012]", function(e4) {
              var t4 = e4 ? parseInt(e4) : 0;
              return t4 > 0 && t4--, Date.prototype.setMonth.call(this, t4);
            }, "month", function() {
              return Date.prototype.getMonth.call(this) + 1;
            }],
            mm: ["0[1-9]|1[012]", function(e4) {
              var t4 = e4 ? parseInt(e4) : 0;
              return t4 > 0 && t4--, Date.prototype.setMonth.call(this, t4);
            }, "month", function() {
              return _2(Date.prototype.getMonth.call(this) + 1, 2);
            }],
            mmm: [m2.monthNames.slice(0, 12).join("|"), function(e4) {
              var t4 = m2.monthNames.slice(0, 12).findIndex(function(t5) {
                return e4.toLowerCase() === t5.toLowerCase();
              });
              return -1 !== t4 && Date.prototype.setMonth.call(this, t4);
            }, "month", function() {
              return m2.monthNames.slice(0, 12)[Date.prototype.getMonth.call(this)];
            }],
            mmmm: [m2.monthNames.slice(12, 24).join("|"), function(e4) {
              var t4 = m2.monthNames.slice(12, 24).findIndex(function(t5) {
                return e4.toLowerCase() === t5.toLowerCase();
              });
              return -1 !== t4 && Date.prototype.setMonth.call(this, t4);
            }, "month", function() {
              return m2.monthNames.slice(12, 24)[Date.prototype.getMonth.call(this)];
            }],
            yy: ["[0-9]{2}", function(e4) {
              var t4 = (/* @__PURE__ */ new Date()).getFullYear().toString().slice(0, 2);
              Date.prototype.setFullYear.call(this, "".concat(t4).concat(e4));
            }, "year", function() {
              return _2(Date.prototype.getFullYear.call(this), 2);
            }, 2],
            yyyy: ["[0-9]{4}", Date.prototype.setFullYear, "year", function() {
              return _2(Date.prototype.getFullYear.call(this), 4);
            }, 4],
            h: ["[1-9]|1[0-2]", Date.prototype.setHours, "hours", Date.prototype.getHours],
            hh: ["0[1-9]|1[0-2]", Date.prototype.setHours, "hours", function() {
              return _2(Date.prototype.getHours.call(this), 2);
            }],
            hx: [function(e4) {
              return "[0-9]{".concat(e4, "}");
            }, Date.prototype.setHours, "hours", function(e4) {
              return Date.prototype.getHours;
            }],
            H: ["1?[0-9]|2[0-3]", Date.prototype.setHours, "hours", Date.prototype.getHours],
            HH: ["0[0-9]|1[0-9]|2[0-3]", Date.prototype.setHours, "hours", function() {
              return _2(Date.prototype.getHours.call(this), 2);
            }],
            Hx: [function(e4) {
              return "[0-9]{".concat(e4, "}");
            }, Date.prototype.setHours, "hours", function(e4) {
              return function() {
                return _2(Date.prototype.getHours.call(this), e4);
              };
            }],
            M: ["[1-5]?[0-9]", Date.prototype.setMinutes, "minutes", Date.prototype.getMinutes],
            MM: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setMinutes, "minutes", function() {
              return _2(Date.prototype.getMinutes.call(this), 2);
            }],
            s: ["[1-5]?[0-9]", Date.prototype.setSeconds, "seconds", Date.prototype.getSeconds],
            ss: ["0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]", Date.prototype.setSeconds, "seconds", function() {
              return _2(Date.prototype.getSeconds.call(this), 2);
            }],
            l: ["[0-9]{3}", Date.prototype.setMilliseconds, "milliseconds", function() {
              return _2(Date.prototype.getMilliseconds.call(this), 3);
            }, 3],
            L: ["[0-9]{2}", Date.prototype.setMilliseconds, "milliseconds", function() {
              return _2(Date.prototype.getMilliseconds.call(this), 2);
            }, 2],
            t: ["[ap]", b2, "ampm", x2, 1],
            tt: ["[ap]m", b2, "ampm", x2, 2],
            T: ["[AP]", b2, "ampm", x2, 1],
            TT: ["[AP]M", b2, "ampm", x2, 2],
            Z: [".*", void 0, "Z", function() {
              var e4 = this.toString().match(/\((.+)\)/)[1];
              e4.includes(" ") && (e4 = (e4 = e4.replace("-", " ").toUpperCase()).split(" ").map(function(e5) {
                return s2(e5, 1)[0];
              }).join(""));
              return e4;
            }],
            o: [""],
            S: [""]
          }, k2 = {
            isoDate: "yyyy-mm-dd",
            isoTime: "HH:MM:ss",
            isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
            isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
          };
          function b2(e4) {
            var t4 = this.getHours();
            e4.toLowerCase().includes("p") ? this.setHours(t4 + 12) : e4.toLowerCase().includes("a") && t4 >= 12 && this.setHours(t4 - 12);
          }
          function x2() {
            var e4 = this.getHours();
            return (e4 = e4 || 12) >= 12 ? "PM" : "AM";
          }
          function w2(e4) {
            var t4 = /\d+$/.exec(e4[0]);
            if (t4 && void 0 !== t4[0]) {
              var n4 = y2[e4[0][0] + "x"].slice("");
              return n4[0] = n4[0](t4[0]), n4[3] = n4[3](t4[0]), n4;
            }
            if (y2[e4[0]])
              return y2[e4[0]];
          }
          function P2(e4) {
            if (!e4.tokenizer) {
              var t4 = [], n4 = [];
              for (var i3 in y2)
                if (/\.*x$/.test(i3)) {
                  var a3 = i3[0] + "\\d+";
                  -1 === n4.indexOf(a3) && n4.push(a3);
                } else
                  -1 === t4.indexOf(i3[0]) && t4.push(i3[0]);
              e4.tokenizer = "(" + (n4.length > 0 ? n4.join("|") + "|" : "") + t4.join("+|") + ")+?|.", e4.tokenizer = new RegExp(e4.tokenizer, "g");
            }
            return e4.tokenizer;
          }
          function S2(e4, t4, n4) {
            if (!g2)
              return true;
            if (void 0 === e4.rawday || !isFinite(e4.rawday) && new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day || "29" == e4.day && (!isFinite(e4.rawyear) || void 0 === e4.rawyear || "" === e4.rawyear) || new Date(e4.date.getFullYear(), isFinite(e4.rawmonth) ? e4.month : e4.date.getMonth() + 1, 0).getDate() >= e4.day)
              return t4;
            if ("29" == e4.day) {
              var i3 = j2.call(this, t4.pos, n4, this.maskset);
              if (i3.targetMatch && "yyyy" === i3.targetMatch[0] && t4.pos - i3.targetMatchIndex == 2)
                return t4.remove = t4.pos + 1, t4;
            } else if (2 == e4.date.getMonth() && "30" == e4.day && void 0 !== t4.c)
              return e4.day = "03", e4.date.setDate(3), e4.date.setMonth(1), t4.insert = [{
                pos: t4.pos,
                c: "0"
              }, {
                pos: t4.pos + 1,
                c: t4.c
              }], t4.caret = o2.seekNext.call(this, t4.pos + 1), t4;
            return false;
          }
          function O2(e4, t4, n4, a3) {
            var r3, o3, l3 = "", s3 = 0, c3 = {};
            for (P2(n4).lastIndex = 0; r3 = P2(n4).exec(e4); ) {
              if (void 0 === t4)
                if (o3 = w2(r3))
                  l3 += "(" + o3[0] + ")", n4.placeholder && "" !== n4.placeholder ? (c3[s3] = n4.placeholder[r3.index % n4.placeholder.length], c3[n4.placeholder[r3.index % n4.placeholder.length]] = r3[0].charAt(0)) : c3[s3] = r3[0].charAt(0);
                else
                  switch (r3[0]) {
                    case "[":
                      l3 += "(";
                      break;
                    case "]":
                      l3 += ")?";
                      break;
                    default:
                      l3 += (0, i2.default)(r3[0]), c3[s3] = r3[0].charAt(0);
                  }
              else if (o3 = w2(r3))
                if (true !== a3 && o3[3])
                  l3 += o3[3].call(t4.date);
                else
                  o3[2] ? l3 += t4["raw" + o3[2]] : l3 += r3[0];
              else
                l3 += r3[0];
              s3++;
            }
            return void 0 === t4 && (n4.placeholder = c3), l3;
          }
          function _2(e4, t4, n4) {
            for (e4 = String(e4), t4 = t4 || 2; e4.length < t4; )
              e4 = n4 ? e4 + "0" : "0" + e4;
            return e4;
          }
          function M2(e4, t4, n4) {
            return "string" == typeof e4 ? new h2(e4, t4, n4, this) : e4 && "object" === u2(e4) && Object.prototype.hasOwnProperty.call(e4, "date") ? e4 : void 0;
          }
          function E2(e4, t4) {
            return O2(t4.inputFormat, {
              date: e4
            }, t4);
          }
          function j2(e4, t4, n4) {
            var i3, a3, r3 = this, o3 = n4 && n4.tests[e4] ? t4.placeholder[n4.tests[e4][0].match.placeholder] || n4.tests[e4][0].match.placeholder : "", s3 = 0, c3 = 0;
            for (P2(t4).lastIndex = 0; a3 = P2(t4).exec(t4.inputFormat); ) {
              var u3 = /\d+$/.exec(a3[0]);
              if (u3)
                c3 = parseInt(u3[0]);
              else {
                for (var f3 = a3[0][0], p3 = s3; r3 && (t4.placeholder[l2.getTest.call(r3, p3).match.placeholder] || l2.getTest.call(r3, p3).match.placeholder) === f3; )
                  p3++;
                0 === (c3 = p3 - s3) && (c3 = a3[0].length);
              }
              if (s3 += c3, -1 != a3[0].indexOf(o3) || s3 >= e4 + 1) {
                i3 = a3, a3 = P2(t4).exec(t4.inputFormat);
                break;
              }
            }
            return {
              targetMatchIndex: s3 - c3,
              nextMatch: a3,
              targetMatch: i3
            };
          }
          a2.default.extendAliases({
            datetime: {
              mask: function(e4) {
                return e4.numericInput = false, y2.S = m2.ordinalSuffix.join("|"), e4.inputFormat = k2[e4.inputFormat] || e4.inputFormat, e4.displayFormat = k2[e4.displayFormat] || e4.displayFormat || e4.inputFormat, e4.outputFormat = k2[e4.outputFormat] || e4.outputFormat || e4.inputFormat, e4.regex = O2(e4.inputFormat, void 0, e4), e4.min = M2(e4.min, e4.inputFormat, e4), e4.max = M2(e4.max, e4.inputFormat, e4), null;
              },
              placeholder: "",
              inputFormat: "isoDateTime",
              displayFormat: null,
              outputFormat: null,
              min: null,
              max: null,
              skipOptionalPartCharacter: "",
              preValidation: function(e4, t4, n4, i3, a3, r3, o3, l3) {
                if (l3)
                  return true;
                if (isNaN(n4) && e4[t4] !== n4) {
                  var s3 = j2.call(this, t4, a3, r3);
                  if (s3.nextMatch && s3.nextMatch[0] === n4 && s3.targetMatch[0].length > 1) {
                    var c3 = w2(s3.targetMatch)[0];
                    if (new RegExp(c3).test("0" + e4[t4 - 1]))
                      return e4[t4] = e4[t4 - 1], e4[t4 - 1] = "0", {
                        fuzzy: true,
                        buffer: e4,
                        refreshFromBuffer: {
                          start: t4 - 1,
                          end: t4 + 1
                        },
                        pos: t4 + 1
                      };
                  }
                }
                return true;
              },
              postValidation: function(e4, t4, n4, i3, a3, r3, o3, s3) {
                var c3, u3, f3 = this;
                if (o3)
                  return true;
                if (false === i3 && (((c3 = j2.call(f3, t4 + 1, a3, r3)).targetMatch && c3.targetMatchIndex === t4 && c3.targetMatch[0].length > 1 && void 0 !== y2[c3.targetMatch[0]] || (c3 = j2.call(f3, t4 + 2, a3, r3)).targetMatch && c3.targetMatchIndex === t4 + 1 && c3.targetMatch[0].length > 1 && void 0 !== y2[c3.targetMatch[0]]) && (u3 = w2(c3.targetMatch)[0]), void 0 !== u3 && (void 0 !== r3.validPositions[t4 + 1] && new RegExp(u3).test(n4 + "0") ? (e4[t4] = n4, e4[t4 + 1] = "0", i3 = {
                  pos: t4 + 2,
                  caret: t4
                }) : new RegExp(u3).test("0" + n4) && (e4[t4] = "0", e4[t4 + 1] = n4, i3 = {
                  pos: t4 + 2
                })), false === i3))
                  return i3;
                if (i3.fuzzy && (e4 = i3.buffer, t4 = i3.pos), (c3 = j2.call(f3, t4, a3, r3)).targetMatch && c3.targetMatch[0] && void 0 !== y2[c3.targetMatch[0]]) {
                  var p3 = w2(c3.targetMatch);
                  u3 = p3[0];
                  var d3 = e4.slice(c3.targetMatchIndex, c3.targetMatchIndex + c3.targetMatch[0].length);
                  if (false === new RegExp(u3).test(d3.join("")) && 2 === c3.targetMatch[0].length && r3.validPositions[c3.targetMatchIndex] && r3.validPositions[c3.targetMatchIndex + 1] && (r3.validPositions[c3.targetMatchIndex + 1].input = "0"), "year" == p3[2])
                    for (var h3 = l2.getMaskTemplate.call(f3, false, 1, void 0, true), m3 = t4 + 1; m3 < e4.length; m3++)
                      e4[m3] = h3[m3], r3.validPositions.splice(t4 + 1, 1);
                }
                var g3 = i3, k3 = M2.call(f3, e4.join(""), a3.inputFormat, a3);
                return g3 && !isNaN(k3.date.getTime()) && (a3.prefillYear && (g3 = function(e5, t5, n5) {
                  if (e5.year !== e5.rawyear) {
                    var i4 = v2.toString(), a4 = e5.rawyear.replace(/[^0-9]/g, ""), r4 = i4.slice(0, a4.length), o4 = i4.slice(a4.length);
                    if (2 === a4.length && a4 === r4) {
                      var l3 = new Date(v2, e5.month - 1, e5.day);
                      e5.day == l3.getDate() && (!n5.max || n5.max.date.getTime() >= l3.getTime()) && (e5.date.setFullYear(v2), e5.year = i4, t5.insert = [{
                        pos: t5.pos + 1,
                        c: o4[0]
                      }, {
                        pos: t5.pos + 2,
                        c: o4[1]
                      }]);
                    }
                  }
                  return t5;
                }(k3, g3, a3)), g3 = function(e5, t5, n5, i4, a4) {
                  if (!t5)
                    return t5;
                  if (t5 && n5.min && !isNaN(n5.min.date.getTime())) {
                    var r4;
                    for (e5.reset(), P2(n5).lastIndex = 0; r4 = P2(n5).exec(n5.inputFormat); ) {
                      var o4;
                      if ((o4 = w2(r4)) && o4[3]) {
                        for (var l3 = o4[1], s4 = e5[o4[2]], c4 = n5.min[o4[2]], u4 = n5.max ? n5.max[o4[2]] : c4 + 1, f4 = [], p4 = false, d4 = 0; d4 < c4.length; d4++)
                          void 0 !== i4.validPositions[d4 + r4.index] || p4 ? (f4[d4] = s4[d4], p4 = p4 || s4[d4] > c4[d4]) : (d4 + r4.index == 0 && s4[d4] < c4[d4] ? (f4[d4] = s4[d4], p4 = true) : f4[d4] = c4[d4], "year" === o4[2] && s4.length - 1 == d4 && c4 != u4 && (f4 = (parseInt(f4.join("")) + 1).toString().split("")), "ampm" === o4[2] && c4 != u4 && n5.min.date.getTime() > e5.date.getTime() && (f4[d4] = u4[d4]));
                        l3.call(e5._date, f4.join(""));
                      }
                    }
                    t5 = n5.min.date.getTime() <= e5.date.getTime(), e5.reInit();
                  }
                  return t5 && n5.max && (isNaN(n5.max.date.getTime()) || (t5 = n5.max.date.getTime() >= e5.date.getTime())), t5;
                }(k3, g3 = S2.call(f3, k3, g3, a3), a3, r3)), void 0 !== t4 && g3 && i3.pos !== t4 ? {
                  buffer: O2(a3.inputFormat, k3, a3).split(""),
                  refreshFromBuffer: {
                    start: t4,
                    end: i3.pos
                  },
                  pos: i3.caret || i3.pos
                } : g3;
              },
              onKeyDown: function(e4, t4, n4, i3) {
                e4.ctrlKey && e4.key === r2.keys.ArrowRight && (this.inputmask._valueSet(E2(/* @__PURE__ */ new Date(), i3)), d2(this).trigger("setvalue"));
              },
              onUnMask: function(e4, t4, n4) {
                return t4 ? O2(n4.outputFormat, M2.call(this, e4, n4.inputFormat, n4), n4, true) : t4;
              },
              casing: function(e4, t4, n4, i3) {
                if (0 == t4.nativeDef.indexOf("[ap]"))
                  return e4.toLowerCase();
                if (0 == t4.nativeDef.indexOf("[AP]"))
                  return e4.toUpperCase();
                var a3 = l2.getTest.call(this, [n4 - 1]);
                return 0 == a3.match.def.indexOf("[AP]") || 0 === n4 || a3 && a3.input === String.fromCharCode(r2.keyCode.Space) || a3 && a3.match.def === String.fromCharCode(r2.keyCode.Space) ? e4.toUpperCase() : e4.toLowerCase();
              },
              onBeforeMask: function(e4, t4) {
                return "[object Date]" === Object.prototype.toString.call(e4) && (e4 = E2(e4, t4)), e4;
              },
              insertMode: false,
              insertModeVisual: false,
              shiftPositions: false,
              keepStatic: false,
              inputmode: "numeric",
              prefillYear: true
            }
          });
        },
        1313: function(e3, t3, n3) {
          var i2, a2 = (i2 = n3(2394)) && i2.__esModule ? i2 : {
            default: i2
          };
          a2.default.dependencyLib.extend(true, a2.default.prototype.i18n, {
            dayNames: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
            monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
            ordinalSuffix: ["st", "nd", "rd", "th"]
          });
        },
        3851: function(e3, t3, n3) {
          var i2, a2 = (i2 = n3(2394)) && i2.__esModule ? i2 : {
            default: i2
          }, r2 = n3(8711), o2 = n3(4713);
          function l2(e4) {
            return function(e5) {
              if (Array.isArray(e5))
                return s2(e5);
            }(e4) || function(e5) {
              if ("undefined" != typeof Symbol && null != e5[Symbol.iterator] || null != e5["@@iterator"])
                return Array.from(e5);
            }(e4) || function(e5, t4) {
              if (!e5)
                return;
              if ("string" == typeof e5)
                return s2(e5, t4);
              var n4 = Object.prototype.toString.call(e5).slice(8, -1);
              "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
              if ("Map" === n4 || "Set" === n4)
                return Array.from(e5);
              if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
                return s2(e5, t4);
            }(e4) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function s2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          a2.default.extendDefinitions({
            A: {
              validator: "[A-Za-zА-яЁёÀ-ÿµ]",
              casing: "upper"
            },
            "&": {
              validator: "[0-9A-Za-zА-яЁёÀ-ÿµ]",
              casing: "upper"
            },
            "#": {
              validator: "[0-9A-Fa-f]",
              casing: "upper"
            }
          });
          var c2 = /25[0-5]|2[0-4][0-9]|[01][0-9][0-9]/;
          function u2(e4, t4, n4, i3, a3) {
            if (n4 - 1 > -1 && "." !== t4.buffer[n4 - 1] ? (e4 = t4.buffer[n4 - 1] + e4, e4 = n4 - 2 > -1 && "." !== t4.buffer[n4 - 2] ? t4.buffer[n4 - 2] + e4 : "0" + e4) : e4 = "00" + e4, a3.greedy && parseInt(e4) > 255 && c2.test("00" + e4.charAt(2))) {
              var r3 = [].concat(l2(t4.buffer.slice(0, n4)), [".", e4.charAt(2)]);
              if (r3.join("").match(/\./g).length < 4)
                return {
                  refreshFromBuffer: true,
                  buffer: r3,
                  caret: n4 + 2
                };
            }
            return c2.test(e4);
          }
          a2.default.extendAliases({
            cssunit: {
              regex: "[+-]?[0-9]+\\.?([0-9]+)?(px|em|rem|ex|%|in|cm|mm|pt|pc)"
            },
            url: {
              regex: "(https?|ftp)://.*",
              autoUnmask: false,
              keepStatic: false,
              tabThrough: true
            },
            ip: {
              mask: "i{1,3}.j{1,3}.k{1,3}.l{1,3}",
              definitions: {
                i: {
                  validator: u2
                },
                j: {
                  validator: u2
                },
                k: {
                  validator: u2
                },
                l: {
                  validator: u2
                }
              },
              onUnMask: function(e4, t4, n4) {
                return e4;
              },
              inputmode: "decimal",
              substitutes: {
                ",": "."
              }
            },
            email: {
              mask: function(e4) {
                var t4 = e4.separator, n4 = e4.quantifier, i3 = "*{1,64}[.*{1,64}][.*{1,64}][.*{1,63}]@-{1,63}.-{1,63}[.-{1,63}][.-{1,63}]", a3 = i3;
                if (t4)
                  for (var r3 = 0; r3 < n4; r3++)
                    a3 += "[".concat(t4).concat(i3, "]");
                return a3;
              },
              greedy: false,
              casing: "lower",
              separator: null,
              quantifier: 5,
              skipOptionalPartCharacter: "",
              onBeforePaste: function(e4, t4) {
                return (e4 = e4.toLowerCase()).replace("mailto:", "");
              },
              definitions: {
                "*": {
                  validator: "[0-9１-９A-Za-zА-яЁёÀ-ÿµ!#$%&'*+/=?^_`{|}~-]"
                },
                "-": {
                  validator: "[0-9A-Za-z-]"
                }
              },
              onUnMask: function(e4, t4, n4) {
                return e4;
              },
              inputmode: "email"
            },
            mac: {
              mask: "##:##:##:##:##:##"
            },
            vin: {
              mask: "V{13}9{4}",
              definitions: {
                V: {
                  validator: "[A-HJ-NPR-Za-hj-npr-z\\d]",
                  casing: "upper"
                }
              },
              clearIncomplete: true,
              autoUnmask: true
            },
            ssn: {
              mask: "999-99-9999",
              postValidation: function(e4, t4, n4, i3, a3, l3, s3) {
                var c3 = o2.getMaskTemplate.call(this, true, r2.getLastValidPosition.call(this), true, true);
                return /^(?!219-09-9999|078-05-1120)(?!666|000|9.{2}).{3}-(?!00).{2}-(?!0{4}).{4}$/.test(c3.join(""));
              }
            }
          });
        },
        207: function(e3, t3, n3) {
          var i2 = l2(n3(7184)), a2 = l2(n3(2394)), r2 = n3(2839), o2 = n3(8711);
          function l2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          var s2 = a2.default.dependencyLib;
          function c2(e4, t4) {
            for (var n4 = "", i3 = 0; i3 < e4.length; i3++)
              a2.default.prototype.definitions[e4.charAt(i3)] || t4.definitions[e4.charAt(i3)] || t4.optionalmarker[0] === e4.charAt(i3) || t4.optionalmarker[1] === e4.charAt(i3) || t4.quantifiermarker[0] === e4.charAt(i3) || t4.quantifiermarker[1] === e4.charAt(i3) || t4.groupmarker[0] === e4.charAt(i3) || t4.groupmarker[1] === e4.charAt(i3) || t4.alternatormarker === e4.charAt(i3) ? n4 += "\\" + e4.charAt(i3) : n4 += e4.charAt(i3);
            return n4;
          }
          function u2(e4, t4, n4, i3) {
            if (e4.length > 0 && t4 > 0 && (!n4.digitsOptional || i3)) {
              var a3 = e4.indexOf(n4.radixPoint), r3 = false;
              n4.negationSymbol.back === e4[e4.length - 1] && (r3 = true, e4.length--), -1 === a3 && (e4.push(n4.radixPoint), a3 = e4.length - 1);
              for (var o3 = 1; o3 <= t4; o3++)
                isFinite(e4[a3 + o3]) || (e4[a3 + o3] = "0");
            }
            return r3 && e4.push(n4.negationSymbol.back), e4;
          }
          function f2(e4, t4) {
            var n4 = 0;
            for (var i3 in "+" === e4 && (n4 = o2.seekNext.call(this, t4.validPositions.length - 1)), t4.tests)
              if ((i3 = parseInt(i3)) >= n4) {
                for (var a3 = 0, r3 = t4.tests[i3].length; a3 < r3; a3++)
                  if ((void 0 === t4.validPositions[i3] || "-" === e4) && t4.tests[i3][a3].match.def === e4)
                    return i3 + (void 0 !== t4.validPositions[i3] && "-" !== e4 ? 1 : 0);
              }
            return n4;
          }
          function p2(e4, t4) {
            for (var n4 = -1, i3 = 0, a3 = t4.validPositions.length; i3 < a3; i3++) {
              var r3 = t4.validPositions[i3];
              if (r3 && r3.match.def === e4) {
                n4 = i3;
                break;
              }
            }
            return n4;
          }
          function d2(e4, t4, n4, i3, a3) {
            var r3 = t4.buffer ? t4.buffer.indexOf(a3.radixPoint) : -1, o3 = (-1 !== r3 || i3 && a3.jitMasking) && new RegExp(a3.definitions[9].validator).test(e4);
            return !i3 && a3._radixDance && -1 !== r3 && o3 && null == t4.validPositions[r3] ? {
              insert: {
                pos: r3 === n4 ? r3 + 1 : r3,
                c: a3.radixPoint
              },
              pos: n4
            } : o3;
          }
          a2.default.extendAliases({
            numeric: {
              mask: function(e4) {
                e4.repeat = 0, e4.groupSeparator === e4.radixPoint && e4.digits && "0" !== e4.digits && ("." === e4.radixPoint ? e4.groupSeparator = "," : "," === e4.radixPoint ? e4.groupSeparator = "." : e4.groupSeparator = ""), " " === e4.groupSeparator && (e4.skipOptionalPartCharacter = void 0), e4.placeholder.length > 1 && (e4.placeholder = e4.placeholder.charAt(0)), "radixFocus" === e4.positionCaretOnClick && "" === e4.placeholder && (e4.positionCaretOnClick = "lvp");
                var t4 = "0", n4 = e4.radixPoint;
                true === e4.numericInput && void 0 === e4.__financeInput ? (t4 = "1", e4.positionCaretOnClick = "radixFocus" === e4.positionCaretOnClick ? "lvp" : e4.positionCaretOnClick, e4.digitsOptional = false, isNaN(e4.digits) && (e4.digits = 2), e4._radixDance = false, n4 = "," === e4.radixPoint ? "?" : "!", "" !== e4.radixPoint && void 0 === e4.definitions[n4] && (e4.definitions[n4] = {}, e4.definitions[n4].validator = "[" + e4.radixPoint + "]", e4.definitions[n4].placeholder = e4.radixPoint, e4.definitions[n4].static = true, e4.definitions[n4].generated = true)) : (e4.__financeInput = false, e4.numericInput = true);
                var a3, r3 = "[+]";
                if (r3 += c2(e4.prefix, e4), "" !== e4.groupSeparator ? (void 0 === e4.definitions[e4.groupSeparator] && (e4.definitions[e4.groupSeparator] = {}, e4.definitions[e4.groupSeparator].validator = "[" + e4.groupSeparator + "]", e4.definitions[e4.groupSeparator].placeholder = e4.groupSeparator, e4.definitions[e4.groupSeparator].static = true, e4.definitions[e4.groupSeparator].generated = true), r3 += e4._mask(e4)) : r3 += "9{+}", void 0 !== e4.digits && 0 !== e4.digits) {
                  var o3 = e4.digits.toString().split(",");
                  isFinite(o3[0]) && o3[1] && isFinite(o3[1]) ? r3 += n4 + t4 + "{" + e4.digits + "}" : (isNaN(e4.digits) || parseInt(e4.digits) > 0) && (e4.digitsOptional || e4.jitMasking ? (a3 = r3 + n4 + t4 + "{0," + e4.digits + "}", e4.keepStatic = true) : r3 += n4 + t4 + "{" + e4.digits + "}");
                } else
                  e4.inputmode = "numeric";
                return r3 += c2(e4.suffix, e4), r3 += "[-]", a3 && (r3 = [a3 + c2(e4.suffix, e4) + "[-]", r3]), e4.greedy = false, function(e5) {
                  void 0 === e5.parseMinMaxOptions && (null !== e5.min && (e5.min = e5.min.toString().replace(new RegExp((0, i2.default)(e5.groupSeparator), "g"), ""), "," === e5.radixPoint && (e5.min = e5.min.replace(e5.radixPoint, ".")), e5.min = isFinite(e5.min) ? parseFloat(e5.min) : NaN, isNaN(e5.min) && (e5.min = Number.MIN_VALUE)), null !== e5.max && (e5.max = e5.max.toString().replace(new RegExp((0, i2.default)(e5.groupSeparator), "g"), ""), "," === e5.radixPoint && (e5.max = e5.max.replace(e5.radixPoint, ".")), e5.max = isFinite(e5.max) ? parseFloat(e5.max) : NaN, isNaN(e5.max) && (e5.max = Number.MAX_VALUE)), e5.parseMinMaxOptions = "done");
                }(e4), "" !== e4.radixPoint && e4.substituteRadixPoint && (e4.substitutes["." == e4.radixPoint ? "," : "."] = e4.radixPoint), r3;
              },
              _mask: function(e4) {
                return "(" + e4.groupSeparator + "999){+|1}";
              },
              digits: "*",
              digitsOptional: true,
              enforceDigitsOnBlur: false,
              radixPoint: ".",
              positionCaretOnClick: "radixFocus",
              _radixDance: true,
              groupSeparator: "",
              allowMinus: true,
              negationSymbol: {
                front: "-",
                back: ""
              },
              prefix: "",
              suffix: "",
              min: null,
              max: null,
              SetMaxOnOverflow: false,
              step: 1,
              inputType: "text",
              unmaskAsNumber: false,
              roundingFN: Math.round,
              inputmode: "decimal",
              shortcuts: {
                k: "1000",
                m: "1000000"
              },
              placeholder: "0",
              greedy: false,
              rightAlign: true,
              insertMode: true,
              autoUnmask: false,
              skipOptionalPartCharacter: "",
              usePrototypeDefinitions: false,
              stripLeadingZeroes: true,
              substituteRadixPoint: true,
              definitions: {
                0: {
                  validator: d2
                },
                1: {
                  validator: d2,
                  definitionSymbol: "9"
                },
                9: {
                  validator: "[0-9０-９٠-٩۰-۹]",
                  definitionSymbol: "*"
                },
                "+": {
                  validator: function(e4, t4, n4, i3, a3) {
                    return a3.allowMinus && ("-" === e4 || e4 === a3.negationSymbol.front);
                  }
                },
                "-": {
                  validator: function(e4, t4, n4, i3, a3) {
                    return a3.allowMinus && e4 === a3.negationSymbol.back;
                  }
                }
              },
              preValidation: function(e4, t4, n4, i3, a3, r3, o3, l3) {
                var s3 = this;
                if (false !== a3.__financeInput && n4 === a3.radixPoint)
                  return false;
                var c3 = e4.indexOf(a3.radixPoint), u3 = t4;
                if (t4 = function(e5, t5, n5, i4, a4) {
                  return a4._radixDance && a4.numericInput && t5 !== a4.negationSymbol.back && e5 <= n5 && (n5 > 0 || t5 == a4.radixPoint) && (void 0 === i4.validPositions[e5 - 1] || i4.validPositions[e5 - 1].input !== a4.negationSymbol.back) && (e5 -= 1), e5;
                }(t4, n4, c3, r3, a3), "-" === n4 || n4 === a3.negationSymbol.front) {
                  if (true !== a3.allowMinus)
                    return false;
                  var d3 = false, h2 = p2("+", r3), v2 = p2("-", r3);
                  return -1 !== h2 && (d3 = [h2], -1 !== v2 && d3.push(v2)), false !== d3 ? {
                    remove: d3,
                    caret: u3 - a3.negationSymbol.back.length
                  } : {
                    insert: [{
                      pos: f2.call(s3, "+", r3),
                      c: a3.negationSymbol.front,
                      fromIsValid: true
                    }, {
                      pos: f2.call(s3, "-", r3),
                      c: a3.negationSymbol.back,
                      fromIsValid: void 0
                    }],
                    caret: u3 + a3.negationSymbol.back.length
                  };
                }
                if (n4 === a3.groupSeparator)
                  return {
                    caret: u3
                  };
                if (l3)
                  return true;
                if (-1 !== c3 && true === a3._radixDance && false === i3 && n4 === a3.radixPoint && void 0 !== a3.digits && (isNaN(a3.digits) || parseInt(a3.digits) > 0) && c3 !== t4) {
                  var m2 = f2.call(s3, a3.radixPoint, r3);
                  return r3.validPositions[m2] && (r3.validPositions[m2].generatedInput = r3.validPositions[m2].generated || false), {
                    caret: a3._radixDance && t4 === c3 - 1 ? c3 + 1 : c3
                  };
                }
                if (false === a3.__financeInput) {
                  if (i3) {
                    if (a3.digitsOptional)
                      return {
                        rewritePosition: o3.end
                      };
                    if (!a3.digitsOptional) {
                      if (o3.begin > c3 && o3.end <= c3)
                        return n4 === a3.radixPoint ? {
                          insert: {
                            pos: c3 + 1,
                            c: "0",
                            fromIsValid: true
                          },
                          rewritePosition: c3
                        } : {
                          rewritePosition: c3 + 1
                        };
                      if (o3.begin < c3)
                        return {
                          rewritePosition: o3.begin - 1
                        };
                    }
                  } else if (!a3.showMaskOnHover && !a3.showMaskOnFocus && !a3.digitsOptional && a3.digits > 0 && "" === this.__valueGet.call(this.el))
                    return {
                      rewritePosition: c3
                    };
                }
                return {
                  rewritePosition: t4
                };
              },
              postValidation: function(e4, t4, n4, i3, a3, r3, o3) {
                if (false === i3)
                  return i3;
                if (o3)
                  return true;
                if (null !== a3.min || null !== a3.max) {
                  var l3 = a3.onUnMask(e4.slice().reverse().join(""), void 0, s2.extend({}, a3, {
                    unmaskAsNumber: true
                  }));
                  if (null !== a3.min && l3 < a3.min && (l3.toString().length > a3.min.toString().length || l3 < 0))
                    return false;
                  if (null !== a3.max && l3 > a3.max)
                    return !!a3.SetMaxOnOverflow && {
                      refreshFromBuffer: true,
                      buffer: u2(a3.max.toString().replace(".", a3.radixPoint).split(""), a3.digits, a3).reverse()
                    };
                }
                return i3;
              },
              onUnMask: function(e4, t4, n4) {
                if ("" === t4 && true === n4.nullable)
                  return t4;
                var a3 = e4.replace(n4.prefix, "");
                return a3 = (a3 = a3.replace(n4.suffix, "")).replace(new RegExp((0, i2.default)(n4.groupSeparator), "g"), ""), "" !== n4.placeholder.charAt(0) && (a3 = a3.replace(new RegExp(n4.placeholder.charAt(0), "g"), "0")), n4.unmaskAsNumber ? ("" !== n4.radixPoint && -1 !== a3.indexOf(n4.radixPoint) && (a3 = a3.replace(i2.default.call(this, n4.radixPoint), ".")), a3 = (a3 = a3.replace(new RegExp("^" + (0, i2.default)(n4.negationSymbol.front)), "-")).replace(new RegExp((0, i2.default)(n4.negationSymbol.back) + "$"), ""), Number(a3)) : a3;
              },
              isComplete: function(e4, t4) {
                var n4 = (t4.numericInput ? e4.slice().reverse() : e4).join("");
                return n4 = (n4 = (n4 = (n4 = (n4 = n4.replace(new RegExp("^" + (0, i2.default)(t4.negationSymbol.front)), "-")).replace(new RegExp((0, i2.default)(t4.negationSymbol.back) + "$"), "")).replace(t4.prefix, "")).replace(t4.suffix, "")).replace(new RegExp((0, i2.default)(t4.groupSeparator) + "([0-9]{3})", "g"), "$1"), "," === t4.radixPoint && (n4 = n4.replace((0, i2.default)(t4.radixPoint), ".")), isFinite(n4);
              },
              onBeforeMask: function(e4, t4) {
                var n4;
                e4 = null !== (n4 = e4) && void 0 !== n4 ? n4 : "";
                var a3 = t4.radixPoint || ",";
                isFinite(t4.digits) && (t4.digits = parseInt(t4.digits)), "number" != typeof e4 && "number" !== t4.inputType || "" === a3 || (e4 = e4.toString().replace(".", a3));
                var r3 = "-" === e4.charAt(0) || e4.charAt(0) === t4.negationSymbol.front, o3 = e4.split(a3), l3 = o3[0].replace(/[^\-0-9]/g, ""), s3 = o3.length > 1 ? o3[1].replace(/[^0-9]/g, "") : "", c3 = o3.length > 1;
                e4 = l3 + ("" !== s3 ? a3 + s3 : s3);
                var f3 = 0;
                if ("" !== a3 && (f3 = t4.digitsOptional ? t4.digits < s3.length ? t4.digits : s3.length : t4.digits, "" !== s3 || !t4.digitsOptional)) {
                  var p3 = Math.pow(10, f3 || 1);
                  e4 = e4.replace((0, i2.default)(a3), "."), isNaN(parseFloat(e4)) || (e4 = (t4.roundingFN(parseFloat(e4) * p3) / p3).toFixed(f3)), e4 = e4.toString().replace(".", a3);
                }
                if (0 === t4.digits && -1 !== e4.indexOf(a3) && (e4 = e4.substring(0, e4.indexOf(a3))), null !== t4.min || null !== t4.max) {
                  var d3 = e4.toString().replace(a3, ".");
                  null !== t4.min && d3 < t4.min ? e4 = t4.min.toString().replace(".", a3) : null !== t4.max && d3 > t4.max && (e4 = t4.max.toString().replace(".", a3));
                }
                return r3 && "-" !== e4.charAt(0) && (e4 = "-" + e4), u2(e4.toString().split(""), f3, t4, c3).join("");
              },
              onBeforeWrite: function(e4, t4, n4, a3) {
                function r3(e5, t5) {
                  if (false !== a3.__financeInput || t5) {
                    var n5 = e5.indexOf(a3.radixPoint);
                    -1 !== n5 && e5.splice(n5, 1);
                  }
                  if ("" !== a3.groupSeparator)
                    for (; -1 !== (n5 = e5.indexOf(a3.groupSeparator)); )
                      e5.splice(n5, 1);
                  return e5;
                }
                var o3, l3;
                if (a3.stripLeadingZeroes && (l3 = function(e5, t5) {
                  var n5 = new RegExp("(^" + ("" !== t5.negationSymbol.front ? (0, i2.default)(t5.negationSymbol.front) + "?" : "") + (0, i2.default)(t5.prefix) + ")(.*)(" + (0, i2.default)(t5.suffix) + ("" != t5.negationSymbol.back ? (0, i2.default)(t5.negationSymbol.back) + "?" : "") + "$)").exec(e5.slice().reverse().join("")), a4 = n5 ? n5[2] : "", r4 = false;
                  return a4 && (a4 = a4.split(t5.radixPoint.charAt(0))[0], r4 = new RegExp("^[0" + t5.groupSeparator + "]*").exec(a4)), !(!r4 || !(r4[0].length > 1 || r4[0].length > 0 && r4[0].length < a4.length)) && r4;
                }(t4, a3)))
                  for (var c3 = t4.join("").lastIndexOf(l3[0].split("").reverse().join("")) - (l3[0] == l3.input ? 0 : 1), f3 = l3[0] == l3.input ? 1 : 0, p3 = l3[0].length - f3; p3 > 0; p3--)
                    this.maskset.validPositions.splice(c3 + p3, 1), delete t4[c3 + p3];
                if (e4)
                  switch (e4.type) {
                    case "blur":
                    case "checkval":
                      if (null !== a3.min) {
                        var d3 = a3.onUnMask(t4.slice().reverse().join(""), void 0, s2.extend({}, a3, {
                          unmaskAsNumber: true
                        }));
                        if (null !== a3.min && d3 < a3.min)
                          return {
                            refreshFromBuffer: true,
                            buffer: u2(a3.min.toString().replace(".", a3.radixPoint).split(""), a3.digits, a3).reverse()
                          };
                      }
                      if (t4[t4.length - 1] === a3.negationSymbol.front) {
                        var h2 = new RegExp("(^" + ("" != a3.negationSymbol.front ? (0, i2.default)(a3.negationSymbol.front) + "?" : "") + (0, i2.default)(a3.prefix) + ")(.*)(" + (0, i2.default)(a3.suffix) + ("" != a3.negationSymbol.back ? (0, i2.default)(a3.negationSymbol.back) + "?" : "") + "$)").exec(r3(t4.slice(), true).reverse().join(""));
                        0 == (h2 ? h2[2] : "") && (o3 = {
                          refreshFromBuffer: true,
                          buffer: [0]
                        });
                      } else if ("" !== a3.radixPoint) {
                        t4.indexOf(a3.radixPoint) === a3.suffix.length && (o3 && o3.buffer ? o3.buffer.splice(0, 1 + a3.suffix.length) : (t4.splice(0, 1 + a3.suffix.length), o3 = {
                          refreshFromBuffer: true,
                          buffer: r3(t4)
                        }));
                      }
                      if (a3.enforceDigitsOnBlur) {
                        var v2 = (o3 = o3 || {}) && o3.buffer || t4.slice().reverse();
                        o3.refreshFromBuffer = true, o3.buffer = u2(v2, a3.digits, a3, true).reverse();
                      }
                  }
                return o3;
              },
              onKeyDown: function(e4, t4, n4, i3) {
                var a3, o3 = s2(this);
                if (3 != e4.location) {
                  var l3, c3 = e4.key;
                  if ((l3 = i3.shortcuts && i3.shortcuts[c3]) && l3.length > 1)
                    return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) * parseInt(l3)), o3.trigger("setvalue"), false;
                }
                if (e4.ctrlKey)
                  switch (e4.key) {
                    case r2.keys.ArrowUp:
                      return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) + parseInt(i3.step)), o3.trigger("setvalue"), false;
                    case r2.keys.ArrowDown:
                      return this.inputmask.__valueSet.call(this, parseFloat(this.inputmask.unmaskedvalue()) - parseInt(i3.step)), o3.trigger("setvalue"), false;
                  }
                if (!e4.shiftKey && (e4.key === r2.keys.Delete || e4.key === r2.keys.Backspace || e4.key === r2.keys.BACKSPACE_SAFARI) && n4.begin !== t4.length) {
                  if (t4[e4.key === r2.keys.Delete ? n4.begin - 1 : n4.end] === i3.negationSymbol.front)
                    return a3 = t4.slice().reverse(), "" !== i3.negationSymbol.front && a3.shift(), "" !== i3.negationSymbol.back && a3.pop(), o3.trigger("setvalue", [a3.join(""), n4.begin]), false;
                  if (true === i3._radixDance) {
                    var f3, p3 = t4.indexOf(i3.radixPoint);
                    if (i3.digitsOptional) {
                      if (0 === p3)
                        return (a3 = t4.slice().reverse()).pop(), o3.trigger("setvalue", [a3.join(""), n4.begin >= a3.length ? a3.length : n4.begin]), false;
                    } else if (-1 !== p3 && (n4.begin < p3 || n4.end < p3 || e4.key === r2.keys.Delete && (n4.begin === p3 || n4.begin - 1 === p3)))
                      return n4.begin === n4.end && (e4.key === r2.keys.Backspace || e4.key === r2.keys.BACKSPACE_SAFARI ? n4.begin++ : e4.key === r2.keys.Delete && n4.begin - 1 === p3 && (f3 = s2.extend({}, n4), n4.begin--, n4.end--)), (a3 = t4.slice().reverse()).splice(a3.length - n4.begin, n4.begin - n4.end + 1), a3 = u2(a3, i3.digits, i3).join(""), f3 && (n4 = f3), o3.trigger("setvalue", [a3, n4.begin >= a3.length ? p3 + 1 : n4.begin]), false;
                  }
                }
              }
            },
            currency: {
              prefix: "",
              groupSeparator: ",",
              alias: "numeric",
              digits: 2,
              digitsOptional: false
            },
            decimal: {
              alias: "numeric"
            },
            integer: {
              alias: "numeric",
              inputmode: "numeric",
              digits: 0
            },
            percentage: {
              alias: "numeric",
              min: 0,
              max: 100,
              suffix: " %",
              digits: 0,
              allowMinus: false
            },
            indianns: {
              alias: "numeric",
              _mask: function(e4) {
                return "(" + e4.groupSeparator + "99){*|1}(" + e4.groupSeparator + "999){1|1}";
              },
              groupSeparator: ",",
              radixPoint: ".",
              placeholder: "0",
              digits: 2,
              digitsOptional: false
            }
          });
        },
        9380: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = void 0;
          var n3 = !("undefined" == typeof window || !window.document || !window.document.createElement);
          t3.default = n3 ? window : {};
        },
        7760: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.HandleNativePlaceholder = function(e4, t4) {
            var n4 = e4 ? e4.inputmask : this;
            if (i2.ie) {
              if (e4.inputmask._valueGet() !== t4 && (e4.placeholder !== t4 || "" === e4.placeholder)) {
                var a3 = o2.getBuffer.call(n4).slice(), r3 = e4.inputmask._valueGet();
                if (r3 !== t4) {
                  var l3 = o2.getLastValidPosition.call(n4);
                  -1 === l3 && r3 === o2.getBufferTemplate.call(n4).join("") ? a3 = [] : -1 !== l3 && u2.call(n4, a3), p2(e4, a3);
                }
              }
            } else
              e4.placeholder !== t4 && (e4.placeholder = t4, "" === e4.placeholder && e4.removeAttribute("placeholder"));
          }, t3.applyInputValue = c2, t3.checkVal = f2, t3.clearOptionalTail = u2, t3.unmaskedvalue = function(e4) {
            var t4 = e4 ? e4.inputmask : this, n4 = t4.opts, i3 = t4.maskset;
            if (e4) {
              if (void 0 === e4.inputmask)
                return e4.value;
              e4.inputmask && e4.inputmask.refreshValue && c2(e4, e4.inputmask._valueGet(true));
            }
            for (var a3 = [], r3 = i3.validPositions, l3 = 0, s3 = r3.length; l3 < s3; l3++)
              r3[l3] && r3[l3].match && (1 != r3[l3].match.static || Array.isArray(i3.metadata) && true !== r3[l3].generatedInput) && a3.push(r3[l3].input);
            var u3 = 0 === a3.length ? "" : (t4.isRTL ? a3.reverse() : a3).join("");
            if ("function" == typeof n4.onUnMask) {
              var f3 = (t4.isRTL ? o2.getBuffer.call(t4).slice().reverse() : o2.getBuffer.call(t4)).join("");
              u3 = n4.onUnMask.call(t4, f3, u3, n4);
            }
            return u3;
          }, t3.writeBuffer = p2;
          var i2 = n3(9845), a2 = n3(6030), r2 = n3(2839), o2 = n3(8711), l2 = n3(7215), s2 = n3(4713);
          function c2(e4, t4, n4) {
            var i3 = e4 ? e4.inputmask : this, a3 = i3.opts;
            e4.inputmask.refreshValue = false, "function" == typeof a3.onBeforeMask && (t4 = a3.onBeforeMask.call(i3, t4, a3) || t4), f2(e4, true, false, t4 = (t4 || "").toString().split(""), n4), i3.undoValue = i3._valueGet(true), (a3.clearMaskOnLostFocus || a3.clearIncomplete) && e4.inputmask._valueGet() === o2.getBufferTemplate.call(i3).join("") && -1 === o2.getLastValidPosition.call(i3) && e4.inputmask._valueSet("");
          }
          function u2(e4) {
            e4.length = 0;
            for (var t4, n4 = s2.getMaskTemplate.call(this, true, 0, true, void 0, true); void 0 !== (t4 = n4.shift()); )
              e4.push(t4);
            return e4;
          }
          function f2(e4, t4, n4, i3, r3) {
            var c3, u3 = e4 ? e4.inputmask : this, f3 = u3.maskset, d2 = u3.opts, h2 = u3.dependencyLib, v2 = i3.slice(), m2 = "", g2 = -1, y2 = d2.skipOptionalPartCharacter;
            d2.skipOptionalPartCharacter = "", o2.resetMaskSet.call(u3, false), u3.clicked = 0, g2 = d2.radixPoint ? o2.determineNewCaretPosition.call(u3, {
              begin: 0,
              end: 0
            }, false, false === d2.__financeInput ? "radixFocus" : void 0).begin : 0, f3.p = g2, u3.caretPos = {
              begin: g2
            };
            var k2 = [], b2 = u3.caretPos;
            if (v2.forEach(function(e5, t5) {
              if (void 0 !== e5) {
                var i4 = new h2.Event("_checkval");
                i4.key = e5, m2 += e5;
                var r4 = o2.getLastValidPosition.call(u3, void 0, true);
                !function(e6, t6) {
                  for (var n5 = s2.getMaskTemplate.call(u3, true, 0).slice(e6, o2.seekNext.call(u3, e6, false, false)).join("").replace(/'/g, ""), i5 = n5.indexOf(t6); i5 > 0 && " " === n5[i5 - 1]; )
                    i5--;
                  var a3 = 0 === i5 && !o2.isMask.call(u3, e6) && (s2.getTest.call(u3, e6).match.nativeDef === t6.charAt(0) || true === s2.getTest.call(u3, e6).match.static && s2.getTest.call(u3, e6).match.nativeDef === "'" + t6.charAt(0) || " " === s2.getTest.call(u3, e6).match.nativeDef && (s2.getTest.call(u3, e6 + 1).match.nativeDef === t6.charAt(0) || true === s2.getTest.call(u3, e6 + 1).match.static && s2.getTest.call(u3, e6 + 1).match.nativeDef === "'" + t6.charAt(0)));
                  if (!a3 && i5 > 0 && !o2.isMask.call(u3, e6, false, true)) {
                    var r5 = o2.seekNext.call(u3, e6);
                    u3.caretPos.begin < r5 && (u3.caretPos = {
                      begin: r5
                    });
                  }
                  return a3;
                }(g2, m2) ? (c3 = a2.EventHandlers.keypressEvent.call(u3, i4, true, false, n4, u3.caretPos.begin)) && (g2 = u3.caretPos.begin + 1, m2 = "") : c3 = a2.EventHandlers.keypressEvent.call(u3, i4, true, false, n4, r4 + 1), c3 ? (void 0 !== c3.pos && f3.validPositions[c3.pos] && true === f3.validPositions[c3.pos].match.static && void 0 === f3.validPositions[c3.pos].alternation && (k2.push(c3.pos), u3.isRTL || (c3.forwardPosition = c3.pos + 1)), p2.call(u3, void 0, o2.getBuffer.call(u3), c3.forwardPosition, i4, false), u3.caretPos = {
                  begin: c3.forwardPosition,
                  end: c3.forwardPosition
                }, b2 = u3.caretPos) : void 0 === f3.validPositions[t5] && v2[t5] === s2.getPlaceholder.call(u3, t5) && o2.isMask.call(u3, t5, true) ? u3.caretPos.begin++ : u3.caretPos = b2;
              }
            }), k2.length > 0) {
              var x2, w2, P2 = o2.seekNext.call(u3, -1, void 0, false);
              if (!l2.isComplete.call(u3, o2.getBuffer.call(u3)) && k2.length <= P2 || l2.isComplete.call(u3, o2.getBuffer.call(u3)) && k2.length > 0 && k2.length !== P2 && 0 === k2[0]) {
                for (var S2 = P2; void 0 !== (x2 = k2.shift()); )
                  if (x2 < S2) {
                    var O2 = new h2.Event("_checkval");
                    if ((w2 = f3.validPositions[x2]).generatedInput = true, O2.key = w2.input, (c3 = a2.EventHandlers.keypressEvent.call(u3, O2, true, false, n4, S2)) && void 0 !== c3.pos && c3.pos !== x2 && f3.validPositions[c3.pos] && true === f3.validPositions[c3.pos].match.static)
                      k2.push(c3.pos);
                    else if (!c3)
                      break;
                    S2++;
                  }
              }
            }
            t4 && p2.call(u3, e4, o2.getBuffer.call(u3), c3 ? c3.forwardPosition : u3.caretPos.begin, r3 || new h2.Event("checkval"), r3 && ("input" === r3.type && u3.undoValue !== o2.getBuffer.call(u3).join("") || "paste" === r3.type)), d2.skipOptionalPartCharacter = y2;
          }
          function p2(e4, t4, n4, i3, a3) {
            var s3 = e4 ? e4.inputmask : this, c3 = s3.opts, u3 = s3.dependencyLib;
            if (i3 && "function" == typeof c3.onBeforeWrite) {
              var f3 = c3.onBeforeWrite.call(s3, i3, t4, n4, c3);
              if (f3) {
                if (f3.refreshFromBuffer) {
                  var p3 = f3.refreshFromBuffer;
                  l2.refreshFromBuffer.call(s3, true === p3 ? p3 : p3.start, p3.end, f3.buffer || t4), t4 = o2.getBuffer.call(s3, true);
                }
                void 0 !== n4 && (n4 = void 0 !== f3.caret ? f3.caret : n4);
              }
            }
            if (void 0 !== e4 && (e4.inputmask._valueSet(t4.join("")), void 0 === n4 || void 0 !== i3 && "blur" === i3.type || o2.caret.call(s3, e4, n4, void 0, void 0, void 0 !== i3 && "keydown" === i3.type && (i3.key === r2.keys.Delete || i3.key === r2.keys.Backspace)), void 0 === e4.inputmask.writeBufferHook || e4.inputmask.writeBufferHook(n4), true === a3)) {
              var d2 = u3(e4), h2 = e4.inputmask._valueGet();
              e4.inputmask.skipInputEvent = true, d2.trigger("input"), setTimeout(function() {
                h2 === o2.getBufferTemplate.call(s3).join("") ? d2.trigger("cleared") : true === l2.isComplete.call(s3, t4) && d2.trigger("complete");
              }, 0);
            }
          }
        },
        2394: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = void 0;
          var i2 = v2(n3(3976)), a2 = v2(n3(7392)), r2 = v2(n3(4963)), o2 = n3(9716), l2 = v2(n3(9380)), s2 = n3(7760), c2 = n3(157), u2 = n3(2391), f2 = n3(8711), p2 = n3(7215), d2 = n3(4713);
          function h2(e4) {
            return h2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, h2(e4);
          }
          function v2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          var m2 = l2.default.document, g2 = "_inputmask_opts";
          function y2(e4, t4, n4) {
            if (!(this instanceof y2))
              return new y2(e4, t4, n4);
            this.dependencyLib = r2.default, this.el = void 0, this.events = {}, this.maskset = void 0, true !== n4 && ("[object Object]" === Object.prototype.toString.call(e4) ? t4 = e4 : (t4 = t4 || {}, e4 && (t4.alias = e4)), this.opts = r2.default.extend(true, {}, this.defaults, t4), this.noMasksCache = t4 && void 0 !== t4.definitions, this.userOptions = t4 || {}, k2(this.opts.alias, t4, this.opts)), this.refreshValue = false, this.undoValue = void 0, this.$el = void 0, this.skipInputEvent = false, this.validationEvent = false, this.ignorable = false, this.maxLength, this.mouseEnter = false, this.clicked = 0, this.originalPlaceholder = void 0, this.isComposing = false, this.hasAlternator = false;
          }
          function k2(e4, t4, n4) {
            var i3 = y2.prototype.aliases[e4];
            return i3 ? (i3.alias && k2(i3.alias, void 0, n4), r2.default.extend(true, n4, i3), r2.default.extend(true, n4, t4), true) : (null === n4.mask && (n4.mask = e4), false);
          }
          y2.prototype = {
            dataAttribute: "data-inputmask",
            defaults: i2.default,
            definitions: a2.default,
            aliases: {},
            masksCache: {},
            i18n: {},
            get isRTL() {
              return this.opts.isRTL || this.opts.numericInput;
            },
            mask: function(e4) {
              var t4 = this;
              return "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : Array.isArray(e4) ? e4 : [].slice.call(e4)).forEach(function(e5, n4) {
                var i3 = r2.default.extend(true, {}, t4.opts);
                if (function(e6, t5, n5, i4) {
                  function a4(t6, a5) {
                    var r3 = "" === i4 ? t6 : i4 + "-" + t6;
                    null !== (a5 = void 0 !== a5 ? a5 : e6.getAttribute(r3)) && ("string" == typeof a5 && (0 === t6.indexOf("on") ? a5 = l2.default[a5] : "false" === a5 ? a5 = false : "true" === a5 && (a5 = true)), n5[t6] = a5);
                  }
                  if (true === t5.importDataAttributes) {
                    var o3, s3, c3, u3, f3 = e6.getAttribute(i4);
                    if (f3 && "" !== f3 && (f3 = f3.replace(/'/g, '"'), s3 = JSON.parse("{" + f3 + "}")), s3) {
                      for (u3 in c3 = void 0, s3)
                        if ("alias" === u3.toLowerCase()) {
                          c3 = s3[u3];
                          break;
                        }
                    }
                    for (o3 in a4("alias", c3), n5.alias && k2(n5.alias, n5, t5), t5) {
                      if (s3) {
                        for (u3 in c3 = void 0, s3)
                          if (u3.toLowerCase() === o3.toLowerCase()) {
                            c3 = s3[u3];
                            break;
                          }
                      }
                      a4(o3, c3);
                    }
                  }
                  r2.default.extend(true, t5, n5), ("rtl" === e6.dir || t5.rightAlign) && (e6.style.textAlign = "right");
                  ("rtl" === e6.dir || t5.numericInput) && (e6.dir = "ltr", e6.removeAttribute("dir"), t5.isRTL = true);
                  return Object.keys(n5).length;
                }(e5, i3, r2.default.extend(true, {}, t4.userOptions), t4.dataAttribute)) {
                  var a3 = (0, u2.generateMaskSet)(i3, t4.noMasksCache);
                  void 0 !== a3 && (void 0 !== e5.inputmask && (e5.inputmask.opts.autoUnmask = true, e5.inputmask.remove()), e5.inputmask = new y2(void 0, void 0, true), e5.inputmask.opts = i3, e5.inputmask.noMasksCache = t4.noMasksCache, e5.inputmask.userOptions = r2.default.extend(true, {}, t4.userOptions), e5.inputmask.el = e5, e5.inputmask.$el = (0, r2.default)(e5), e5.inputmask.maskset = a3, r2.default.data(e5, g2, t4.userOptions), c2.mask.call(e5.inputmask));
                }
              }), e4 && e4[0] && e4[0].inputmask || this;
            },
            option: function(e4, t4) {
              return "string" == typeof e4 ? this.opts[e4] : "object" === h2(e4) ? (r2.default.extend(this.userOptions, e4), this.el && true !== t4 && this.mask(this.el), this) : void 0;
            },
            unmaskedvalue: function(e4) {
              if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), void 0 === this.el || void 0 !== e4) {
                var t4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                s2.checkVal.call(this, void 0, false, false, t4), "function" == typeof this.opts.onBeforeWrite && this.opts.onBeforeWrite.call(this, void 0, f2.getBuffer.call(this), 0, this.opts);
              }
              return s2.unmaskedvalue.call(this, this.el);
            },
            remove: function() {
              if (this.el) {
                r2.default.data(this.el, g2, null);
                var e4 = this.opts.autoUnmask ? (0, s2.unmaskedvalue)(this.el) : this._valueGet(this.opts.autoUnmask);
                e4 !== f2.getBufferTemplate.call(this).join("") ? this._valueSet(e4, this.opts.autoUnmask) : this._valueSet(""), o2.EventRuler.off(this.el), Object.getOwnPropertyDescriptor && Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(this.el), "value") && this.__valueGet && Object.defineProperty(this.el, "value", {
                  get: this.__valueGet,
                  set: this.__valueSet,
                  configurable: true
                }) : m2.__lookupGetter__ && this.el.__lookupGetter__("value") && this.__valueGet && (this.el.__defineGetter__("value", this.__valueGet), this.el.__defineSetter__("value", this.__valueSet)), this.el.inputmask = void 0;
              }
              return this.el;
            },
            getemptymask: function() {
              return this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), (this.isRTL ? f2.getBufferTemplate.call(this).reverse() : f2.getBufferTemplate.call(this)).join("");
            },
            hasMaskedValue: function() {
              return !this.opts.autoUnmask;
            },
            isComplete: function() {
              return this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), p2.isComplete.call(this, f2.getBuffer.call(this));
            },
            getmetadata: function() {
              if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), Array.isArray(this.maskset.metadata)) {
                var e4 = d2.getMaskTemplate.call(this, true, 0, false).join("");
                return this.maskset.metadata.forEach(function(t4) {
                  return t4.mask !== e4 || (e4 = t4, false);
                }), e4;
              }
              return this.maskset.metadata;
            },
            isValid: function(e4) {
              if (this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache), e4) {
                var t4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
                s2.checkVal.call(this, void 0, true, false, t4);
              } else
                e4 = this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join("");
              for (var n4 = f2.getBuffer.call(this), i3 = f2.determineLastRequiredPosition.call(this), a3 = n4.length - 1; a3 > i3 && !f2.isMask.call(this, a3); a3--)
                ;
              return n4.splice(i3, a3 + 1 - i3), p2.isComplete.call(this, n4) && e4 === (this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join(""));
            },
            format: function(e4, t4) {
              this.maskset = this.maskset || (0, u2.generateMaskSet)(this.opts, this.noMasksCache);
              var n4 = ("function" == typeof this.opts.onBeforeMask && this.opts.onBeforeMask.call(this, e4, this.opts) || e4).split("");
              s2.checkVal.call(this, void 0, true, false, n4);
              var i3 = this.isRTL ? f2.getBuffer.call(this).slice().reverse().join("") : f2.getBuffer.call(this).join("");
              return t4 ? {
                value: i3,
                metadata: this.getmetadata()
              } : i3;
            },
            setValue: function(e4) {
              this.el && (0, r2.default)(this.el).trigger("setvalue", [e4]);
            },
            analyseMask: u2.analyseMask
          }, y2.extendDefaults = function(e4) {
            r2.default.extend(true, y2.prototype.defaults, e4);
          }, y2.extendDefinitions = function(e4) {
            r2.default.extend(true, y2.prototype.definitions, e4);
          }, y2.extendAliases = function(e4) {
            r2.default.extend(true, y2.prototype.aliases, e4);
          }, y2.format = function(e4, t4, n4) {
            return y2(t4).format(e4, n4);
          }, y2.unmask = function(e4, t4) {
            return y2(t4).unmaskedvalue(e4);
          }, y2.isValid = function(e4, t4) {
            return y2(t4).isValid(e4);
          }, y2.remove = function(e4) {
            "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : e4).forEach(function(e5) {
              e5.inputmask && e5.inputmask.remove();
            });
          }, y2.setValue = function(e4, t4) {
            "string" == typeof e4 && (e4 = m2.getElementById(e4) || m2.querySelectorAll(e4)), (e4 = e4.nodeName ? [e4] : e4).forEach(function(e5) {
              e5.inputmask ? e5.inputmask.setValue(t4) : (0, r2.default)(e5).trigger("setvalue", [t4]);
            });
          }, y2.dependencyLib = r2.default, l2.default.Inputmask = y2;
          t3.default = y2;
        },
        5296: function(e3, t3, n3) {
          function i2(e4) {
            return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, i2(e4);
          }
          var a2 = d2(n3(9380)), r2 = d2(n3(2394));
          function o2(e4, t4) {
            for (var n4 = 0; n4 < t4.length; n4++) {
              var a3 = t4[n4];
              a3.enumerable = a3.enumerable || false, a3.configurable = true, "value" in a3 && (a3.writable = true), Object.defineProperty(e4, (r3 = a3.key, o3 = void 0, o3 = function(e5, t5) {
                if ("object" !== i2(e5) || null === e5)
                  return e5;
                var n5 = e5[Symbol.toPrimitive];
                if (void 0 !== n5) {
                  var a4 = n5.call(e5, t5 || "default");
                  if ("object" !== i2(a4))
                    return a4;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t5 ? String : Number)(e5);
              }(r3, "string"), "symbol" === i2(o3) ? o3 : String(o3)), a3);
            }
            var r3, o3;
          }
          function l2(e4) {
            var t4 = u2();
            return function() {
              var n4, a3 = p2(e4);
              if (t4) {
                var r3 = p2(this).constructor;
                n4 = Reflect.construct(a3, arguments, r3);
              } else
                n4 = a3.apply(this, arguments);
              return function(e5, t5) {
                if (t5 && ("object" === i2(t5) || "function" == typeof t5))
                  return t5;
                if (void 0 !== t5)
                  throw new TypeError("Derived constructors may only return object or undefined");
                return function(e6) {
                  if (void 0 === e6)
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                  return e6;
                }(e5);
              }(this, n4);
            };
          }
          function s2(e4) {
            var t4 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
            return s2 = function(e5) {
              if (null === e5 || !function(e6) {
                try {
                  return -1 !== Function.toString.call(e6).indexOf("[native code]");
                } catch (t5) {
                  return "function" == typeof e6;
                }
              }(e5))
                return e5;
              if ("function" != typeof e5)
                throw new TypeError("Super expression must either be null or a function");
              if (void 0 !== t4) {
                if (t4.has(e5))
                  return t4.get(e5);
                t4.set(e5, n4);
              }
              function n4() {
                return c2(e5, arguments, p2(this).constructor);
              }
              return n4.prototype = Object.create(e5.prototype, {
                constructor: {
                  value: n4,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              }), f2(n4, e5);
            }, s2(e4);
          }
          function c2(e4, t4, n4) {
            return c2 = u2() ? Reflect.construct.bind() : function(e5, t5, n5) {
              var i3 = [null];
              i3.push.apply(i3, t5);
              var a3 = new (Function.bind.apply(e5, i3))();
              return n5 && f2(a3, n5.prototype), a3;
            }, c2.apply(null, arguments);
          }
          function u2() {
            if ("undefined" == typeof Reflect || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if ("function" == typeof Proxy)
              return true;
            try {
              return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              })), true;
            } catch (e4) {
              return false;
            }
          }
          function f2(e4, t4) {
            return f2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e5, t5) {
              return e5.__proto__ = t5, e5;
            }, f2(e4, t4);
          }
          function p2(e4) {
            return p2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(e5) {
              return e5.__proto__ || Object.getPrototypeOf(e5);
            }, p2(e4);
          }
          function d2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
          var h2 = a2.default.document;
          if (h2 && h2.head && h2.head.attachShadow && a2.default.customElements && void 0 === a2.default.customElements.get("input-mask")) {
            var v2 = function(e4) {
              !function(e5, t5) {
                if ("function" != typeof t5 && null !== t5)
                  throw new TypeError("Super expression must either be null or a function");
                e5.prototype = Object.create(t5 && t5.prototype, {
                  constructor: {
                    value: e5,
                    writable: true,
                    configurable: true
                  }
                }), Object.defineProperty(e5, "prototype", {
                  writable: false
                }), t5 && f2(e5, t5);
              }(s3, e4);
              var t4, n4, a3 = l2(s3);
              function s3() {
                var e5;
                !function(e6, t6) {
                  if (!(e6 instanceof t6))
                    throw new TypeError("Cannot call a class as a function");
                }(this, s3);
                var t5 = (e5 = a3.call(this)).getAttributeNames(), n5 = e5.attachShadow({
                  mode: "closed"
                });
                for (var i3 in e5.input = h2.createElement("input"), e5.input.type = "text", n5.appendChild(e5.input), t5)
                  Object.prototype.hasOwnProperty.call(t5, i3) && e5.input.setAttribute(t5[i3], e5.getAttribute(t5[i3]));
                var o3 = new r2.default();
                return o3.dataAttribute = "", o3.mask(e5.input), e5.input.inputmask.shadowRoot = n5, e5;
              }
              return t4 = s3, (n4 = [{
                key: "attributeChangedCallback",
                value: function(e5, t5, n5) {
                  this.input.setAttribute(e5, n5);
                }
              }, {
                key: "value",
                get: function() {
                  return this.input.value;
                },
                set: function(e5) {
                  this.input.value = e5;
                }
              }]) && o2(t4.prototype, n4), Object.defineProperty(t4, "prototype", {
                writable: false
              }), s3;
            }(s2(HTMLElement));
            a2.default.customElements.define("input-mask", v2);
          }
        },
        2839: function(e3, t3) {
          function n3(e4) {
            return n3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, n3(e4);
          }
          function i2(e4, t4) {
            return function(e5) {
              if (Array.isArray(e5))
                return e5;
            }(e4) || function(e5, t5) {
              var n4 = null == e5 ? null : "undefined" != typeof Symbol && e5[Symbol.iterator] || e5["@@iterator"];
              if (null != n4) {
                var i3, a3, r3, o3, l3 = [], s3 = true, c2 = false;
                try {
                  if (r3 = (n4 = n4.call(e5)).next, 0 === t5) {
                    if (Object(n4) !== n4)
                      return;
                    s3 = false;
                  } else
                    for (; !(s3 = (i3 = r3.call(n4)).done) && (l3.push(i3.value), l3.length !== t5); s3 = true)
                      ;
                } catch (e6) {
                  c2 = true, a3 = e6;
                } finally {
                  try {
                    if (!s3 && null != n4.return && (o3 = n4.return(), Object(o3) !== o3))
                      return;
                  } finally {
                    if (c2)
                      throw a3;
                  }
                }
                return l3;
              }
            }(e4, t4) || function(e5, t5) {
              if (!e5)
                return;
              if ("string" == typeof e5)
                return a2(e5, t5);
              var n4 = Object.prototype.toString.call(e5).slice(8, -1);
              "Object" === n4 && e5.constructor && (n4 = e5.constructor.name);
              if ("Map" === n4 || "Set" === n4)
                return Array.from(e5);
              if ("Arguments" === n4 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n4))
                return a2(e5, t5);
            }(e4, t4) || function() {
              throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function a2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          function r2(e4, t4) {
            var n4 = Object.keys(e4);
            if (Object.getOwnPropertySymbols) {
              var i3 = Object.getOwnPropertySymbols(e4);
              t4 && (i3 = i3.filter(function(t5) {
                return Object.getOwnPropertyDescriptor(e4, t5).enumerable;
              })), n4.push.apply(n4, i3);
            }
            return n4;
          }
          function o2(e4, t4, i3) {
            return (t4 = function(e5) {
              var t5 = function(e6, t6) {
                if ("object" !== n3(e6) || null === e6)
                  return e6;
                var i4 = e6[Symbol.toPrimitive];
                if (void 0 !== i4) {
                  var a3 = i4.call(e6, t6 || "default");
                  if ("object" !== n3(a3))
                    return a3;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return ("string" === t6 ? String : Number)(e6);
              }(e5, "string");
              return "symbol" === n3(t5) ? t5 : String(t5);
            }(t4)) in e4 ? Object.defineProperty(e4, t4, {
              value: i3,
              enumerable: true,
              configurable: true,
              writable: true
            }) : e4[t4] = i3, e4;
          }
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.keys = t3.keyCode = void 0, t3.toKey = function(e4, t4) {
            return s2[e4] || (t4 ? String.fromCharCode(e4) : String.fromCharCode(e4).toLowerCase());
          }, t3.toKeyCode = function(e4) {
            return l2[e4];
          };
          var l2 = t3.keyCode = function(e4) {
            for (var t4 = 1; t4 < arguments.length; t4++) {
              var n4 = null != arguments[t4] ? arguments[t4] : {};
              t4 % 2 ? r2(Object(n4), true).forEach(function(t5) {
                o2(e4, t5, n4[t5]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e4, Object.getOwnPropertyDescriptors(n4)) : r2(Object(n4)).forEach(function(t5) {
                Object.defineProperty(e4, t5, Object.getOwnPropertyDescriptor(n4, t5));
              });
            }
            return e4;
          }({
            c: 67,
            x: 88,
            z: 90,
            BACKSPACE_SAFARI: 127,
            Enter: 13,
            Meta_LEFT: 91,
            Meta_RIGHT: 92,
            Space: 32
          }, {
            Alt: 18,
            AltGraph: 18,
            ArrowDown: 40,
            ArrowLeft: 37,
            ArrowRight: 39,
            ArrowUp: 38,
            Backspace: 8,
            CapsLock: 20,
            Control: 17,
            ContextMenu: 93,
            Dead: 221,
            Delete: 46,
            End: 35,
            Escape: 27,
            F1: 112,
            F2: 113,
            F3: 114,
            F4: 115,
            F5: 116,
            F6: 117,
            F7: 118,
            F8: 119,
            F9: 120,
            F10: 121,
            F11: 122,
            F12: 123,
            Home: 36,
            Insert: 45,
            NumLock: 144,
            PageDown: 34,
            PageUp: 33,
            Pause: 19,
            PrintScreen: 44,
            Process: 229,
            Shift: 16,
            ScrollLock: 145,
            Tab: 9,
            Unidentified: 229
          }), s2 = Object.entries(l2).reduce(function(e4, t4) {
            var n4 = i2(t4, 2), a3 = n4[0], r3 = n4[1];
            return e4[r3] = void 0 === e4[r3] ? a3 : e4[r3], e4;
          }, {});
          t3.keys = Object.entries(l2).reduce(function(e4, t4) {
            var n4 = i2(t4, 2), a3 = n4[0];
            n4[1];
            return e4[a3] = "Space" === a3 ? " " : a3, e4;
          }, {});
        },
        2391: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.analyseMask = function(e4, t4, n4) {
            var i3, a3, s3, c3, u2, f2, p2 = /(?:[?*+]|\{[0-9+*]+(?:,[0-9+*]*)?(?:\|[0-9+*]*)?\})|[^.?*+^${[]()|\\]+|./g, d2 = /\[\^?]?(?:[^\\\]]+|\\[\S\s]?)*]?|\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9][0-9]*|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|c[A-Za-z]|[\S\s]?)|\((?:\?[:=!]?)?|(?:[?*+]|\{[0-9]+(?:,[0-9]*)?\})\??|[^.?*+^${[()|\\]+|./g, h2 = false, v2 = new o2.default(), m2 = [], g2 = [], y2 = false;
            function k2(e5, i4, a4) {
              a4 = void 0 !== a4 ? a4 : e5.matches.length;
              var o3 = e5.matches[a4 - 1];
              if (t4) {
                if (0 === i4.indexOf("[") || h2 && /\\d|\\s|\\w|\\p/i.test(i4) || "." === i4) {
                  var s4 = n4.casing ? "i" : "";
                  /\\p\{.*}/i.test(i4) && (s4 += "u"), e5.matches.splice(a4++, 0, {
                    fn: new RegExp(i4, s4),
                    static: false,
                    optionality: false,
                    newBlockMarker: void 0 === o3 ? "master" : o3.def !== i4,
                    casing: null,
                    def: i4,
                    placeholder: "object" === l2(n4.placeholder) ? n4.placeholder[v2.matches.length] : void 0,
                    nativeDef: i4
                  });
                } else
                  h2 && (i4 = i4[i4.length - 1]), i4.split("").forEach(function(t5, i5) {
                    o3 = e5.matches[a4 - 1], e5.matches.splice(a4++, 0, {
                      fn: /[a-z]/i.test(n4.staticDefinitionSymbol || t5) ? new RegExp("[" + (n4.staticDefinitionSymbol || t5) + "]", n4.casing ? "i" : "") : null,
                      static: true,
                      optionality: false,
                      newBlockMarker: void 0 === o3 ? "master" : o3.def !== t5 && true !== o3.static,
                      casing: null,
                      def: n4.staticDefinitionSymbol || t5,
                      placeholder: void 0 !== n4.staticDefinitionSymbol ? t5 : "object" === l2(n4.placeholder) ? n4.placeholder[v2.matches.length] : void 0,
                      nativeDef: (h2 ? "'" : "") + t5
                    });
                  });
                h2 = false;
              } else {
                var c4 = n4.definitions && n4.definitions[i4] || n4.usePrototypeDefinitions && r2.default.prototype.definitions[i4];
                c4 && !h2 ? e5.matches.splice(a4++, 0, {
                  fn: c4.validator ? "string" == typeof c4.validator ? new RegExp(c4.validator, n4.casing ? "i" : "") : new function() {
                    this.test = c4.validator;
                  }() : /./,
                  static: c4.static || false,
                  optionality: c4.optional || false,
                  defOptionality: c4.optional || false,
                  newBlockMarker: void 0 === o3 || c4.optional ? "master" : o3.def !== (c4.definitionSymbol || i4),
                  casing: c4.casing,
                  def: c4.definitionSymbol || i4,
                  placeholder: c4.placeholder,
                  nativeDef: i4,
                  generated: c4.generated
                }) : (e5.matches.splice(a4++, 0, {
                  fn: /[a-z]/i.test(n4.staticDefinitionSymbol || i4) ? new RegExp("[" + (n4.staticDefinitionSymbol || i4) + "]", n4.casing ? "i" : "") : null,
                  static: true,
                  optionality: false,
                  newBlockMarker: void 0 === o3 ? "master" : o3.def !== i4 && true !== o3.static,
                  casing: null,
                  def: n4.staticDefinitionSymbol || i4,
                  placeholder: void 0 !== n4.staticDefinitionSymbol ? i4 : void 0,
                  nativeDef: (h2 ? "'" : "") + i4
                }), h2 = false);
              }
            }
            function b2() {
              if (m2.length > 0) {
                if (k2(c3 = m2[m2.length - 1], a3), c3.isAlternator) {
                  u2 = m2.pop();
                  for (var e5 = 0; e5 < u2.matches.length; e5++)
                    u2.matches[e5].isGroup && (u2.matches[e5].isGroup = false);
                  m2.length > 0 ? (c3 = m2[m2.length - 1]).matches.push(u2) : v2.matches.push(u2);
                }
              } else
                k2(v2, a3);
            }
            function x2(e5) {
              var t5 = new o2.default(true);
              return t5.openGroup = false, t5.matches = e5, t5;
            }
            function w2() {
              if ((s3 = m2.pop()).openGroup = false, void 0 !== s3)
                if (m2.length > 0) {
                  if ((c3 = m2[m2.length - 1]).matches.push(s3), c3.isAlternator) {
                    u2 = m2.pop();
                    for (var e5 = 0; e5 < u2.matches.length; e5++)
                      u2.matches[e5].isGroup = false, u2.matches[e5].alternatorGroup = false;
                    m2.length > 0 ? (c3 = m2[m2.length - 1]).matches.push(u2) : v2.matches.push(u2);
                  }
                } else
                  v2.matches.push(s3);
              else
                b2();
            }
            function P2(e5) {
              var t5 = e5.pop();
              return t5.isQuantifier && (t5 = x2([e5.pop(), t5])), t5;
            }
            t4 && (n4.optionalmarker[0] = void 0, n4.optionalmarker[1] = void 0);
            for (; i3 = t4 ? d2.exec(e4) : p2.exec(e4); ) {
              if (a3 = i3[0], t4) {
                switch (a3.charAt(0)) {
                  case "?":
                    a3 = "{0,1}";
                    break;
                  case "+":
                  case "*":
                    a3 = "{" + a3 + "}";
                    break;
                  case "|":
                    if (0 === m2.length) {
                      var S2 = x2(v2.matches);
                      S2.openGroup = true, m2.push(S2), v2.matches = [], y2 = true;
                    }
                }
                switch (a3) {
                  case "\\d":
                    a3 = "[0-9]";
                    break;
                  case "\\p":
                    a3 += d2.exec(e4)[0], a3 += d2.exec(e4)[0];
                }
              }
              if (h2)
                b2();
              else
                switch (a3.charAt(0)) {
                  case "$":
                  case "^":
                    t4 || b2();
                    break;
                  case n4.escapeChar:
                    h2 = true, t4 && b2();
                    break;
                  case n4.optionalmarker[1]:
                  case n4.groupmarker[1]:
                    w2();
                    break;
                  case n4.optionalmarker[0]:
                    m2.push(new o2.default(false, true));
                    break;
                  case n4.groupmarker[0]:
                    m2.push(new o2.default(true));
                    break;
                  case n4.quantifiermarker[0]:
                    var O2 = new o2.default(false, false, true), _2 = (a3 = a3.replace(/[{}?]/g, "")).split("|"), M2 = _2[0].split(","), E2 = isNaN(M2[0]) ? M2[0] : parseInt(M2[0]), j2 = 1 === M2.length ? E2 : isNaN(M2[1]) ? M2[1] : parseInt(M2[1]), T2 = isNaN(_2[1]) ? _2[1] : parseInt(_2[1]);
                    "*" !== E2 && "+" !== E2 || (E2 = "*" === j2 ? 0 : 1), O2.quantifier = {
                      min: E2,
                      max: j2,
                      jit: T2
                    };
                    var A2 = m2.length > 0 ? m2[m2.length - 1].matches : v2.matches;
                    (i3 = A2.pop()).isGroup || (i3 = x2([i3])), A2.push(i3), A2.push(O2);
                    break;
                  case n4.alternatormarker:
                    if (m2.length > 0) {
                      var D2 = (c3 = m2[m2.length - 1]).matches[c3.matches.length - 1];
                      f2 = c3.openGroup && (void 0 === D2.matches || false === D2.isGroup && false === D2.isAlternator) ? m2.pop() : P2(c3.matches);
                    } else
                      f2 = P2(v2.matches);
                    if (f2.isAlternator)
                      m2.push(f2);
                    else if (f2.alternatorGroup ? (u2 = m2.pop(), f2.alternatorGroup = false) : u2 = new o2.default(false, false, false, true), u2.matches.push(f2), m2.push(u2), f2.openGroup) {
                      f2.openGroup = false;
                      var L2 = new o2.default(true);
                      L2.alternatorGroup = true, m2.push(L2);
                    }
                    break;
                  default:
                    b2();
                }
            }
            y2 && w2();
            for (; m2.length > 0; )
              s3 = m2.pop(), v2.matches.push(s3);
            v2.matches.length > 0 && (!function e5(i4) {
              i4 && i4.matches && i4.matches.forEach(function(a4, r3) {
                var o3 = i4.matches[r3 + 1];
                (void 0 === o3 || void 0 === o3.matches || false === o3.isQuantifier) && a4 && a4.isGroup && (a4.isGroup = false, t4 || (k2(a4, n4.groupmarker[0], 0), true !== a4.openGroup && k2(a4, n4.groupmarker[1]))), e5(a4);
              });
            }(v2), g2.push(v2));
            (n4.numericInput || n4.isRTL) && function e5(t5) {
              for (var i4 in t5.matches = t5.matches.reverse(), t5.matches)
                if (Object.prototype.hasOwnProperty.call(t5.matches, i4)) {
                  var a4 = parseInt(i4);
                  if (t5.matches[i4].isQuantifier && t5.matches[a4 + 1] && t5.matches[a4 + 1].isGroup) {
                    var r3 = t5.matches[i4];
                    t5.matches.splice(i4, 1), t5.matches.splice(a4 + 1, 0, r3);
                  }
                  void 0 !== t5.matches[i4].matches ? t5.matches[i4] = e5(t5.matches[i4]) : t5.matches[i4] = ((o3 = t5.matches[i4]) === n4.optionalmarker[0] ? o3 = n4.optionalmarker[1] : o3 === n4.optionalmarker[1] ? o3 = n4.optionalmarker[0] : o3 === n4.groupmarker[0] ? o3 = n4.groupmarker[1] : o3 === n4.groupmarker[1] && (o3 = n4.groupmarker[0]), o3);
                }
              var o3;
              return t5;
            }(g2[0]);
            return g2;
          }, t3.generateMaskSet = function(e4, t4) {
            var n4;
            function o3(e5, t5) {
              var n5 = t5.repeat, i3 = t5.groupmarker, r3 = t5.quantifiermarker, o4 = t5.keepStatic;
              if (n5 > 0 || "*" === n5 || "+" === n5) {
                var l3 = "*" === n5 ? 0 : "+" === n5 ? 1 : n5;
                if (l3 != n5)
                  e5 = i3[0] + e5 + i3[1] + r3[0] + l3 + "," + n5 + r3[1];
                else
                  for (var c4 = e5, u3 = 1; u3 < l3; u3++)
                    e5 += c4;
              }
              if (true === o4) {
                var f2 = e5.match(new RegExp("(.)\\[([^\\]]*)\\]", "g"));
                f2 && f2.forEach(function(t6, n6) {
                  var i4 = function(e6, t7) {
                    return function(e7) {
                      if (Array.isArray(e7))
                        return e7;
                    }(e6) || function(e7, t8) {
                      var n7 = null == e7 ? null : "undefined" != typeof Symbol && e7[Symbol.iterator] || e7["@@iterator"];
                      if (null != n7) {
                        var i5, a3, r5, o6, l4 = [], s3 = true, c5 = false;
                        try {
                          if (r5 = (n7 = n7.call(e7)).next, 0 === t8) {
                            if (Object(n7) !== n7)
                              return;
                            s3 = false;
                          } else
                            for (; !(s3 = (i5 = r5.call(n7)).done) && (l4.push(i5.value), l4.length !== t8); s3 = true)
                              ;
                        } catch (e8) {
                          c5 = true, a3 = e8;
                        } finally {
                          try {
                            if (!s3 && null != n7.return && (o6 = n7.return(), Object(o6) !== o6))
                              return;
                          } finally {
                            if (c5)
                              throw a3;
                          }
                        }
                        return l4;
                      }
                    }(e6, t7) || function(e7, t8) {
                      if (!e7)
                        return;
                      if ("string" == typeof e7)
                        return s2(e7, t8);
                      var n7 = Object.prototype.toString.call(e7).slice(8, -1);
                      "Object" === n7 && e7.constructor && (n7 = e7.constructor.name);
                      if ("Map" === n7 || "Set" === n7)
                        return Array.from(e7);
                      if ("Arguments" === n7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n7))
                        return s2(e7, t8);
                    }(e6, t7) || function() {
                      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
                    }();
                  }(t6.split("["), 2), r4 = i4[0], o5 = i4[1];
                  o5 = o5.replace("]", ""), e5 = e5.replace(new RegExp("".concat((0, a2.default)(r4), "\\[").concat((0, a2.default)(o5), "\\]")), r4.charAt(0) === o5.charAt(0) ? "(".concat(r4, "|").concat(r4).concat(o5, ")") : "".concat(r4, "[").concat(o5, "]"));
                });
              }
              return e5;
            }
            function c3(e5, n5, a3) {
              var s3, c4, u3 = false;
              return null !== e5 && "" !== e5 || ((u3 = null !== a3.regex) ? e5 = (e5 = a3.regex).replace(/^(\^)(.*)(\$)$/, "$2") : (u3 = true, e5 = ".*")), 1 === e5.length && false === a3.greedy && 0 !== a3.repeat && (a3.placeholder = ""), e5 = o3(e5, a3), c4 = u3 ? "regex_" + a3.regex : a3.numericInput ? e5.split("").reverse().join("") : e5, null !== a3.keepStatic && (c4 = "ks_" + a3.keepStatic + c4), "object" === l2(a3.placeholder) && (c4 = "ph_" + JSON.stringify(a3.placeholder) + c4), void 0 === r2.default.prototype.masksCache[c4] || true === t4 ? (s3 = {
                mask: e5,
                maskToken: r2.default.prototype.analyseMask(e5, u3, a3),
                validPositions: [],
                _buffer: void 0,
                buffer: void 0,
                tests: {},
                excludes: {},
                metadata: n5,
                maskLength: void 0,
                jitOffset: {}
              }, true !== t4 && (r2.default.prototype.masksCache[c4] = s3, s3 = i2.default.extend(true, {}, r2.default.prototype.masksCache[c4]))) : s3 = i2.default.extend(true, {}, r2.default.prototype.masksCache[c4]), s3;
            }
            "function" == typeof e4.mask && (e4.mask = e4.mask(e4));
            if (Array.isArray(e4.mask)) {
              if (e4.mask.length > 1) {
                null === e4.keepStatic && (e4.keepStatic = true);
                var u2 = e4.groupmarker[0];
                return (e4.isRTL ? e4.mask.reverse() : e4.mask).forEach(function(t5) {
                  u2.length > 1 && (u2 += e4.alternatormarker), void 0 !== t5.mask && "function" != typeof t5.mask ? u2 += t5.mask : u2 += t5;
                }), c3(u2 += e4.groupmarker[1], e4.mask, e4);
              }
              e4.mask = e4.mask.pop();
            }
            n4 = e4.mask && void 0 !== e4.mask.mask && "function" != typeof e4.mask.mask ? c3(e4.mask.mask, e4.mask, e4) : c3(e4.mask, e4.mask, e4);
            null === e4.keepStatic && (e4.keepStatic = false);
            return n4;
          };
          var i2 = c2(n3(4963)), a2 = c2(n3(7184)), r2 = c2(n3(2394)), o2 = c2(n3(9695));
          function l2(e4) {
            return l2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, l2(e4);
          }
          function s2(e4, t4) {
            (null == t4 || t4 > e4.length) && (t4 = e4.length);
            for (var n4 = 0, i3 = new Array(t4); n4 < t4; n4++)
              i3[n4] = e4[n4];
            return i3;
          }
          function c2(e4) {
            return e4 && e4.__esModule ? e4 : {
              default: e4
            };
          }
        },
        157: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.mask = function() {
            var e4 = this, t4 = this.opts, n4 = this.el, c2 = this.dependencyLib;
            r2.EventRuler.off(n4);
            var u2 = function(t5, n5) {
              var i3 = t5.getAttribute("type"), a3 = "input" === t5.tagName.toLowerCase() && n5.supportsInputType.includes(i3) || t5.isContentEditable || "textarea" === t5.tagName.toLowerCase();
              if (!a3)
                if ("input" === t5.tagName.toLowerCase()) {
                  var s3 = document.createElement("input");
                  s3.setAttribute("type", i3), a3 = "text" === s3.type, s3 = null;
                } else
                  a3 = "partial";
              return false !== a3 ? function(t6) {
                var i4, a4;
                function s4() {
                  return this.inputmask ? this.inputmask.opts.autoUnmask ? this.inputmask.unmaskedvalue() : -1 !== l2.getLastValidPosition.call(e4) || true !== n5.nullable ? (this.inputmask.shadowRoot || this.ownerDocument).activeElement === this && n5.clearMaskOnLostFocus ? (e4.isRTL ? o2.clearOptionalTail.call(e4, l2.getBuffer.call(e4).slice()).reverse() : o2.clearOptionalTail.call(e4, l2.getBuffer.call(e4).slice())).join("") : i4.call(this) : "" : i4.call(this);
                }
                function u3(e5) {
                  a4.call(this, e5), this.inputmask && (0, o2.applyInputValue)(this, e5);
                }
                if (!t6.inputmask.__valueGet) {
                  if (true !== n5.noValuePatching) {
                    if (Object.getOwnPropertyDescriptor) {
                      var f3 = Object.getPrototypeOf ? Object.getOwnPropertyDescriptor(Object.getPrototypeOf(t6), "value") : void 0;
                      f3 && f3.get && f3.set ? (i4 = f3.get, a4 = f3.set, Object.defineProperty(t6, "value", {
                        get: s4,
                        set: u3,
                        configurable: true
                      })) : "input" !== t6.tagName.toLowerCase() && (i4 = function() {
                        return this.textContent;
                      }, a4 = function(e5) {
                        this.textContent = e5;
                      }, Object.defineProperty(t6, "value", {
                        get: s4,
                        set: u3,
                        configurable: true
                      }));
                    } else
                      document.__lookupGetter__ && t6.__lookupGetter__("value") && (i4 = t6.__lookupGetter__("value"), a4 = t6.__lookupSetter__("value"), t6.__defineGetter__("value", s4), t6.__defineSetter__("value", u3));
                    t6.inputmask.__valueGet = i4, t6.inputmask.__valueSet = a4;
                  }
                  t6.inputmask._valueGet = function(t7) {
                    return e4.isRTL && true !== t7 ? i4.call(this.el).split("").reverse().join("") : i4.call(this.el);
                  }, t6.inputmask._valueSet = function(t7, n6) {
                    a4.call(this.el, null == t7 ? "" : true !== n6 && e4.isRTL ? t7.split("").reverse().join("") : t7);
                  }, void 0 === i4 && (i4 = function() {
                    return this.value;
                  }, a4 = function(e5) {
                    this.value = e5;
                  }, function(t7) {
                    if (c2.valHooks && (void 0 === c2.valHooks[t7] || true !== c2.valHooks[t7].inputmaskpatch)) {
                      var i5 = c2.valHooks[t7] && c2.valHooks[t7].get ? c2.valHooks[t7].get : function(e5) {
                        return e5.value;
                      }, a5 = c2.valHooks[t7] && c2.valHooks[t7].set ? c2.valHooks[t7].set : function(e5, t8) {
                        return e5.value = t8, e5;
                      };
                      c2.valHooks[t7] = {
                        get: function(t8) {
                          if (t8.inputmask) {
                            if (t8.inputmask.opts.autoUnmask)
                              return t8.inputmask.unmaskedvalue();
                            var a6 = i5(t8);
                            return -1 !== l2.getLastValidPosition.call(e4, void 0, void 0, t8.inputmask.maskset.validPositions) || true !== n5.nullable ? a6 : "";
                          }
                          return i5(t8);
                        },
                        set: function(e5, t8) {
                          var n6 = a5(e5, t8);
                          return e5.inputmask && (0, o2.applyInputValue)(e5, t8), n6;
                        },
                        inputmaskpatch: true
                      };
                    }
                  }(t6.type), function(e5) {
                    r2.EventRuler.on(e5, "mouseenter", function() {
                      var e6 = this, t7 = e6.inputmask._valueGet(true);
                      t7 != (e6.inputmask.isRTL ? l2.getBuffer.call(e6.inputmask).slice().reverse() : l2.getBuffer.call(e6.inputmask)).join("") && (0, o2.applyInputValue)(e6, t7);
                    });
                  }(t6));
                }
              }(t5) : t5.inputmask = void 0, a3;
            }(n4, t4);
            if (false !== u2) {
              e4.originalPlaceholder = n4.placeholder, e4.maxLength = void 0 !== n4 ? n4.maxLength : void 0, -1 === e4.maxLength && (e4.maxLength = void 0), "inputMode" in n4 && null === n4.getAttribute("inputmode") && (n4.inputMode = t4.inputmode, n4.setAttribute("inputmode", t4.inputmode)), true === u2 && (t4.showMaskOnFocus = t4.showMaskOnFocus && -1 === ["cc-number", "cc-exp"].indexOf(n4.autocomplete), i2.iphone && (t4.insertModeVisual = false, n4.setAttribute("autocorrect", "off")), r2.EventRuler.on(n4, "submit", a2.EventHandlers.submitEvent), r2.EventRuler.on(n4, "reset", a2.EventHandlers.resetEvent), r2.EventRuler.on(n4, "blur", a2.EventHandlers.blurEvent), r2.EventRuler.on(n4, "focus", a2.EventHandlers.focusEvent), r2.EventRuler.on(n4, "invalid", a2.EventHandlers.invalidEvent), r2.EventRuler.on(n4, "click", a2.EventHandlers.clickEvent), r2.EventRuler.on(n4, "mouseleave", a2.EventHandlers.mouseleaveEvent), r2.EventRuler.on(n4, "mouseenter", a2.EventHandlers.mouseenterEvent), r2.EventRuler.on(n4, "paste", a2.EventHandlers.pasteEvent), r2.EventRuler.on(n4, "cut", a2.EventHandlers.cutEvent), r2.EventRuler.on(n4, "complete", t4.oncomplete), r2.EventRuler.on(n4, "incomplete", t4.onincomplete), r2.EventRuler.on(n4, "cleared", t4.oncleared), true !== t4.inputEventOnly && r2.EventRuler.on(n4, "keydown", a2.EventHandlers.keyEvent), (i2.mobile || t4.inputEventOnly) && n4.removeAttribute("maxLength"), r2.EventRuler.on(n4, "input", a2.EventHandlers.inputFallBackEvent)), r2.EventRuler.on(n4, "setvalue", a2.EventHandlers.setValueEvent), void 0 === e4.applyMaskHook || e4.applyMaskHook(), l2.getBufferTemplate.call(e4).join(""), e4.undoValue = e4._valueGet(true);
              var f2 = (n4.inputmask.shadowRoot || n4.ownerDocument).activeElement;
              if ("" !== n4.inputmask._valueGet(true) || false === t4.clearMaskOnLostFocus || f2 === n4) {
                (0, o2.applyInputValue)(n4, n4.inputmask._valueGet(true), t4);
                var p2 = l2.getBuffer.call(e4).slice();
                false === s2.isComplete.call(e4, p2) && t4.clearIncomplete && l2.resetMaskSet.call(e4, false), t4.clearMaskOnLostFocus && f2 !== n4 && (-1 === l2.getLastValidPosition.call(e4) ? p2 = [] : o2.clearOptionalTail.call(e4, p2)), (false === t4.clearMaskOnLostFocus || t4.showMaskOnFocus && f2 === n4 || "" !== n4.inputmask._valueGet(true)) && (0, o2.writeBuffer)(n4, p2), f2 === n4 && l2.caret.call(e4, n4, l2.seekNext.call(e4, l2.getLastValidPosition.call(e4)));
              }
            }
          };
          var i2 = n3(9845), a2 = n3(6030), r2 = n3(9716), o2 = n3(7760), l2 = n3(8711), s2 = n3(7215);
        },
        9695: function(e3, t3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.default = function(e4, t4, n3, i2) {
            this.matches = [], this.openGroup = e4 || false, this.alternatorGroup = false, this.isGroup = e4 || false, this.isOptional = t4 || false, this.isQuantifier = n3 || false, this.isAlternator = i2 || false, this.quantifier = {
              min: 1,
              max: 1
            };
          };
        },
        3194: function() {
          Array.prototype.includes || Object.defineProperty(Array.prototype, "includes", {
            value: function(e3, t3) {
              if (null == this)
                throw new TypeError('"this" is null or not defined');
              var n3 = Object(this), i2 = n3.length >>> 0;
              if (0 === i2)
                return false;
              for (var a2 = 0 | t3, r2 = Math.max(a2 >= 0 ? a2 : i2 - Math.abs(a2), 0); r2 < i2; ) {
                if (n3[r2] === e3)
                  return true;
                r2++;
              }
              return false;
            }
          });
        },
        9302: function() {
          var e3 = Function.bind.call(Function.call, Array.prototype.reduce), t3 = Function.bind.call(Function.call, Object.prototype.propertyIsEnumerable), n3 = Function.bind.call(Function.call, Array.prototype.concat), i2 = Object.keys;
          Object.entries || (Object.entries = function(a2) {
            return e3(i2(a2), function(e4, i3) {
              return n3(e4, "string" == typeof i3 && t3(a2, i3) ? [[i3, a2[i3]]] : []);
            }, []);
          });
        },
        7149: function() {
          function e3(t3) {
            return e3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
              return typeof e4;
            } : function(e4) {
              return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
            }, e3(t3);
          }
          "function" != typeof Object.getPrototypeOf && (Object.getPrototypeOf = "object" === e3("test".__proto__) ? function(e4) {
            return e4.__proto__;
          } : function(e4) {
            return e4.constructor.prototype;
          });
        },
        4013: function() {
          String.prototype.includes || (String.prototype.includes = function(e3, t3) {
            return "number" != typeof t3 && (t3 = 0), !(t3 + e3.length > this.length) && -1 !== this.indexOf(e3, t3);
          });
        },
        8711: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.caret = function(e4, t4, n4, i3, r3) {
            var o3, l3 = this, s3 = this.opts;
            if (void 0 === t4)
              return "selectionStart" in e4 && "selectionEnd" in e4 ? (t4 = e4.selectionStart, n4 = e4.selectionEnd) : a2.default.getSelection ? (o3 = a2.default.getSelection().getRangeAt(0)).commonAncestorContainer.parentNode !== e4 && o3.commonAncestorContainer !== e4 || (t4 = o3.startOffset, n4 = o3.endOffset) : document.selection && document.selection.createRange && (n4 = (t4 = 0 - (o3 = document.selection.createRange()).duplicate().moveStart("character", -e4.inputmask._valueGet().length)) + o3.text.length), {
                begin: i3 ? t4 : f2.call(l3, t4),
                end: i3 ? n4 : f2.call(l3, n4)
              };
            if (Array.isArray(t4) && (n4 = l3.isRTL ? t4[0] : t4[1], t4 = l3.isRTL ? t4[1] : t4[0]), void 0 !== t4.begin && (n4 = l3.isRTL ? t4.begin : t4.end, t4 = l3.isRTL ? t4.end : t4.begin), "number" == typeof t4) {
              t4 = i3 ? t4 : f2.call(l3, t4), n4 = "number" == typeof (n4 = i3 ? n4 : f2.call(l3, n4)) ? n4 : t4;
              var c3 = parseInt(((e4.ownerDocument.defaultView || a2.default).getComputedStyle ? (e4.ownerDocument.defaultView || a2.default).getComputedStyle(e4, null) : e4.currentStyle).fontSize) * n4;
              if (e4.scrollLeft = c3 > e4.scrollWidth ? c3 : 0, e4.inputmask.caretPos = {
                begin: t4,
                end: n4
              }, s3.insertModeVisual && false === s3.insertMode && t4 === n4 && (r3 || n4++), e4 === (e4.inputmask.shadowRoot || e4.ownerDocument).activeElement) {
                if ("setSelectionRange" in e4)
                  e4.setSelectionRange(t4, n4);
                else if (a2.default.getSelection) {
                  if (o3 = document.createRange(), void 0 === e4.firstChild || null === e4.firstChild) {
                    var u3 = document.createTextNode("");
                    e4.appendChild(u3);
                  }
                  o3.setStart(e4.firstChild, t4 < e4.inputmask._valueGet().length ? t4 : e4.inputmask._valueGet().length), o3.setEnd(e4.firstChild, n4 < e4.inputmask._valueGet().length ? n4 : e4.inputmask._valueGet().length), o3.collapse(true);
                  var p2 = a2.default.getSelection();
                  p2.removeAllRanges(), p2.addRange(o3);
                } else
                  e4.createTextRange && ((o3 = e4.createTextRange()).collapse(true), o3.moveEnd("character", n4), o3.moveStart("character", t4), o3.select());
                void 0 === e4.inputmask.caretHook || e4.inputmask.caretHook.call(l3, {
                  begin: t4,
                  end: n4
                });
              }
            }
          }, t3.determineLastRequiredPosition = function(e4) {
            var t4, n4, i3 = this, a3 = i3.maskset, l3 = i3.dependencyLib, c3 = s2.call(i3), u3 = {}, f3 = a3.validPositions[c3], p2 = o2.getMaskTemplate.call(i3, true, s2.call(i3), true, true), d2 = p2.length, h2 = void 0 !== f3 ? f3.locator.slice() : void 0;
            for (t4 = c3 + 1; t4 < p2.length; t4++)
              h2 = (n4 = o2.getTestTemplate.call(i3, t4, h2, t4 - 1)).locator.slice(), u3[t4] = l3.extend(true, {}, n4);
            var v2 = f3 && void 0 !== f3.alternation ? f3.locator[f3.alternation] : void 0;
            for (t4 = d2 - 1; t4 > c3 && (((n4 = u3[t4]).match.optionality || n4.match.optionalQuantifier && n4.match.newBlockMarker || v2 && (v2 !== u3[t4].locator[f3.alternation] && true !== n4.match.static || true === n4.match.static && n4.locator[f3.alternation] && r2.checkAlternationMatch.call(i3, n4.locator[f3.alternation].toString().split(","), v2.toString().split(",")) && "" !== o2.getTests.call(i3, t4)[0].def)) && p2[t4] === o2.getPlaceholder.call(i3, t4, n4.match)); t4--)
              d2--;
            return e4 ? {
              l: d2,
              def: u3[d2] ? u3[d2].match : void 0
            } : d2;
          }, t3.determineNewCaretPosition = function(e4, t4, n4) {
            var i3, a3, r3, f3 = this, p2 = f3.maskset, d2 = f3.opts;
            t4 && (f3.isRTL ? e4.end = e4.begin : e4.begin = e4.end);
            if (e4.begin === e4.end) {
              switch (n4 = n4 || d2.positionCaretOnClick) {
                case "none":
                  break;
                case "select":
                  e4 = {
                    begin: 0,
                    end: l2.call(f3).length
                  };
                  break;
                case "ignore":
                  e4.end = e4.begin = u2.call(f3, s2.call(f3));
                  break;
                case "radixFocus":
                  if (f3.clicked > 1 && 0 === p2.validPositions.length)
                    break;
                  if (function(e5) {
                    if ("" !== d2.radixPoint && 0 !== d2.digits) {
                      var t5 = p2.validPositions;
                      if (void 0 === t5[e5] || void 0 === t5[e5].input) {
                        if (e5 < u2.call(f3, -1))
                          return true;
                        var n5 = l2.call(f3).indexOf(d2.radixPoint);
                        if (-1 !== n5) {
                          for (var i4 = 0, a4 = t5.length; i4 < a4; i4++)
                            if (t5[i4] && n5 < i4 && t5[i4].input !== o2.getPlaceholder.call(f3, i4))
                              return false;
                          return true;
                        }
                      }
                    }
                    return false;
                  }(e4.begin)) {
                    var h2 = l2.call(f3).join("").indexOf(d2.radixPoint);
                    e4.end = e4.begin = d2.numericInput ? u2.call(f3, h2) : h2;
                    break;
                  }
                default:
                  if (i3 = e4.begin, a3 = s2.call(f3, i3, true), i3 <= (r3 = u2.call(f3, -1 !== a3 || c2.call(f3, 0) ? a3 : -1)))
                    e4.end = e4.begin = c2.call(f3, i3, false, true) ? i3 : u2.call(f3, i3);
                  else {
                    var v2 = p2.validPositions[a3], m2 = o2.getTestTemplate.call(f3, r3, v2 ? v2.match.locator : void 0, v2), g2 = o2.getPlaceholder.call(f3, r3, m2.match);
                    if ("" !== g2 && l2.call(f3)[r3] !== g2 && true !== m2.match.optionalQuantifier && true !== m2.match.newBlockMarker || !c2.call(f3, r3, d2.keepStatic, true) && m2.match.def === g2) {
                      var y2 = u2.call(f3, r3);
                      (i3 >= y2 || i3 === r3) && (r3 = y2);
                    }
                    e4.end = e4.begin = r3;
                  }
              }
              return e4;
            }
          }, t3.getBuffer = l2, t3.getBufferTemplate = function() {
            var e4 = this.maskset;
            void 0 === e4._buffer && (e4._buffer = o2.getMaskTemplate.call(this, false, 1), void 0 === e4.buffer && (e4.buffer = e4._buffer.slice()));
            return e4._buffer;
          }, t3.getLastValidPosition = s2, t3.isMask = c2, t3.resetMaskSet = function(e4) {
            var t4 = this.maskset;
            t4.buffer = void 0, true !== e4 && (t4.validPositions = [], t4.p = 0);
            false === e4 && (t4.tests = {}, t4.jitOffset = {});
          }, t3.seekNext = u2, t3.seekPrevious = function(e4, t4) {
            var n4 = this, i3 = e4 - 1;
            if (e4 <= 0)
              return 0;
            for (; i3 > 0 && (true === t4 && (true !== o2.getTest.call(n4, i3).match.newBlockMarker || !c2.call(n4, i3, void 0, true)) || true !== t4 && !c2.call(n4, i3, void 0, true)); )
              i3--;
            return i3;
          }, t3.translatePosition = f2;
          var i2, a2 = (i2 = n3(9380)) && i2.__esModule ? i2 : {
            default: i2
          }, r2 = n3(7215), o2 = n3(4713);
          function l2(e4) {
            var t4 = this, n4 = t4.maskset;
            return void 0 !== n4.buffer && true !== e4 || (n4.buffer = o2.getMaskTemplate.call(t4, true, s2.call(t4), true), void 0 === n4._buffer && (n4._buffer = n4.buffer.slice())), n4.buffer;
          }
          function s2(e4, t4, n4) {
            var i3 = this.maskset, a3 = -1, r3 = -1, o3 = n4 || i3.validPositions;
            void 0 === e4 && (e4 = -1);
            for (var l3 = 0, s3 = o3.length; l3 < s3; l3++)
              o3[l3] && (t4 || true !== o3[l3].generatedInput) && (l3 <= e4 && (a3 = l3), l3 >= e4 && (r3 = l3));
            return -1 === a3 || a3 === e4 ? r3 : -1 === r3 || e4 - a3 < r3 - e4 ? a3 : r3;
          }
          function c2(e4, t4, n4) {
            var i3 = this, a3 = this.maskset, r3 = o2.getTestTemplate.call(i3, e4).match;
            if ("" === r3.def && (r3 = o2.getTest.call(i3, e4).match), true !== r3.static)
              return r3.fn;
            if (true === n4 && void 0 !== a3.validPositions[e4] && true !== a3.validPositions[e4].generatedInput)
              return true;
            if (true !== t4 && e4 > -1) {
              if (n4) {
                var l3 = o2.getTests.call(i3, e4);
                return l3.length > 1 + ("" === l3[l3.length - 1].match.def ? 1 : 0);
              }
              var s3 = o2.determineTestTemplate.call(i3, e4, o2.getTests.call(i3, e4)), c3 = o2.getPlaceholder.call(i3, e4, s3.match);
              return s3.match.def !== c3;
            }
            return false;
          }
          function u2(e4, t4, n4) {
            var i3 = this;
            void 0 === n4 && (n4 = true);
            for (var a3 = e4 + 1; "" !== o2.getTest.call(i3, a3).match.def && (true === t4 && (true !== o2.getTest.call(i3, a3).match.newBlockMarker || !c2.call(i3, a3, void 0, true)) || true !== t4 && !c2.call(i3, a3, void 0, n4)); )
              a3++;
            return a3;
          }
          function f2(e4) {
            var t4 = this.opts, n4 = this.el;
            return !this.isRTL || "number" != typeof e4 || t4.greedy && "" === t4.placeholder || !n4 || (e4 = this._valueGet().length - e4) < 0 && (e4 = 0), e4;
          }
        },
        4713: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.determineTestTemplate = f2, t3.getDecisionTaker = s2, t3.getMaskTemplate = function(e4, t4, n4, i3, a3) {
            var r3 = this, o3 = this.opts, l3 = this.maskset, s3 = o3.greedy;
            a3 && o3.greedy && (o3.greedy = false, r3.maskset.tests = {});
            t4 = t4 || 0;
            var p3, d3, v2, m2, g2 = [], y2 = 0;
            do {
              if (true === e4 && l3.validPositions[y2])
                d3 = (v2 = a3 && l3.validPositions[y2].match.optionality && void 0 === l3.validPositions[y2 + 1] && (true === l3.validPositions[y2].generatedInput || l3.validPositions[y2].input == o3.skipOptionalPartCharacter && y2 > 0) ? f2.call(r3, y2, h2.call(r3, y2, p3, y2 - 1)) : l3.validPositions[y2]).match, p3 = v2.locator.slice(), g2.push(true === n4 ? v2.input : false === n4 ? d3.nativeDef : c2.call(r3, y2, d3));
              else {
                d3 = (v2 = u2.call(r3, y2, p3, y2 - 1)).match, p3 = v2.locator.slice();
                var k2 = true !== i3 && (false !== o3.jitMasking ? o3.jitMasking : d3.jit);
                (m2 = (m2 || l3.validPositions[y2 - 1]) && d3.static && d3.def !== o3.groupSeparator && null === d3.fn) || false === k2 || void 0 === k2 || "number" == typeof k2 && isFinite(k2) && k2 > y2 ? g2.push(false === n4 ? d3.nativeDef : c2.call(r3, g2.length, d3)) : m2 = false;
              }
              y2++;
            } while (true !== d3.static || "" !== d3.def || t4 > y2);
            "" === g2[g2.length - 1] && g2.pop();
            false === n4 && void 0 !== l3.maskLength || (l3.maskLength = y2 - 1);
            return o3.greedy = s3, g2;
          }, t3.getPlaceholder = c2, t3.getTest = p2, t3.getTestTemplate = u2, t3.getTests = h2, t3.isSubsetOf = d2;
          var i2, a2 = (i2 = n3(2394)) && i2.__esModule ? i2 : {
            default: i2
          }, r2 = n3(8711);
          function o2(e4) {
            return o2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
              return typeof e5;
            } : function(e5) {
              return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
            }, o2(e4);
          }
          function l2(e4, t4) {
            var n4 = (null != e4.alternation ? e4.mloc[s2(e4)] : e4.locator).join("");
            if ("" !== n4)
              for (n4 = n4.split(":")[0]; n4.length < t4; )
                n4 += "0";
            return n4;
          }
          function s2(e4) {
            var t4 = e4.locator[e4.alternation];
            return "string" == typeof t4 && t4.length > 0 && (t4 = t4.split(",")[0]), void 0 !== t4 ? t4.toString() : "";
          }
          function c2(e4, t4, n4) {
            var i3 = this, a3 = this.opts, l3 = this.maskset;
            if (void 0 !== (t4 = t4 || p2.call(i3, e4).match).placeholder || true === n4) {
              if ("" !== t4.placeholder && true === t4.static && true !== t4.generated) {
                var s3 = r2.getLastValidPosition.call(i3, e4), c3 = r2.seekNext.call(i3, s3);
                return (n4 ? e4 <= c3 : e4 < c3) ? a3.staticDefinitionSymbol && t4.static ? t4.nativeDef : t4.def : "function" == typeof t4.placeholder ? t4.placeholder(a3) : t4.placeholder;
              }
              return "function" == typeof t4.placeholder ? t4.placeholder(a3) : t4.placeholder;
            }
            if (true === t4.static) {
              if (e4 > -1 && void 0 === l3.validPositions[e4]) {
                var u3, f3 = h2.call(i3, e4), d3 = [];
                if ("string" == typeof a3.placeholder && f3.length > 1 + ("" === f3[f3.length - 1].match.def ? 1 : 0)) {
                  for (var v2 = 0; v2 < f3.length; v2++)
                    if ("" !== f3[v2].match.def && true !== f3[v2].match.optionality && true !== f3[v2].match.optionalQuantifier && (true === f3[v2].match.static || void 0 === u3 || false !== f3[v2].match.fn.test(u3.match.def, l3, e4, true, a3)) && (d3.push(f3[v2]), true === f3[v2].match.static && (u3 = f3[v2]), d3.length > 1 && /[0-9a-bA-Z]/.test(d3[0].match.def)))
                      return a3.placeholder.charAt(e4 % a3.placeholder.length);
                }
              }
              return t4.def;
            }
            return "object" === o2(a3.placeholder) ? t4.def : a3.placeholder.charAt(e4 % a3.placeholder.length);
          }
          function u2(e4, t4, n4) {
            return this.maskset.validPositions[e4] || f2.call(this, e4, h2.call(this, e4, t4 ? t4.slice() : t4, n4));
          }
          function f2(e4, t4) {
            var n4 = this.opts, i3 = 0, a3 = function(e5, t5) {
              var n5 = 0, i4 = false;
              t5.forEach(function(e6) {
                e6.match.optionality && (0 !== n5 && n5 !== e6.match.optionality && (i4 = true), (0 === n5 || n5 > e6.match.optionality) && (n5 = e6.match.optionality));
              }), n5 && (0 == e5 || 1 == t5.length ? n5 = 0 : i4 || (n5 = 0));
              return n5;
            }(e4, t4);
            e4 = e4 > 0 ? e4 - 1 : 0;
            var r3, o3, s3, c3 = l2(p2.call(this, e4));
            n4.greedy && t4.length > 1 && "" === t4[t4.length - 1].match.def && (i3 = 1);
            for (var u3 = 0; u3 < t4.length - i3; u3++) {
              var f3 = t4[u3];
              r3 = l2(f3, c3.length);
              var d3 = Math.abs(r3 - c3);
              (true !== f3.unMatchedAlternationStopped || t4.filter(function(e5) {
                return true !== e5.unMatchedAlternationStopped;
              }).length <= 1) && (void 0 === o3 || "" !== r3 && d3 < o3 || s3 && !n4.greedy && s3.match.optionality && s3.match.optionality - a3 > 0 && "master" === s3.match.newBlockMarker && (!f3.match.optionality || f3.match.optionality - a3 < 1 || !f3.match.newBlockMarker) || s3 && !n4.greedy && s3.match.optionalQuantifier && !f3.match.optionalQuantifier) && (o3 = d3, s3 = f3);
            }
            return s3;
          }
          function p2(e4, t4) {
            var n4 = this.maskset;
            return n4.validPositions[e4] ? n4.validPositions[e4] : (t4 || h2.call(this, e4))[0];
          }
          function d2(e4, t4, n4) {
            function i3(e5) {
              for (var t5, n5 = [], i4 = -1, a3 = 0, r3 = e5.length; a3 < r3; a3++)
                if ("-" === e5.charAt(a3))
                  for (t5 = e5.charCodeAt(a3 + 1); ++i4 < t5; )
                    n5.push(String.fromCharCode(i4));
                else
                  i4 = e5.charCodeAt(a3), n5.push(e5.charAt(a3));
              return n5.join("");
            }
            return e4.match.def === t4.match.nativeDef || !(!(n4.regex || e4.match.fn instanceof RegExp && t4.match.fn instanceof RegExp) || true === e4.match.static || true === t4.match.static) && ("." === t4.match.fn.source || -1 !== i3(t4.match.fn.source.replace(/[[\]/]/g, "")).indexOf(i3(e4.match.fn.source.replace(/[[\]/]/g, ""))));
          }
          function h2(e4, t4, n4) {
            var i3, r3, o3 = this, l3 = this.dependencyLib, s3 = this.maskset, c3 = this.opts, u3 = this.el, p3 = s3.maskToken, h3 = t4 ? n4 : 0, v2 = t4 ? t4.slice() : [0], m2 = [], g2 = false, y2 = t4 ? t4.join("") : "", k2 = false;
            function b2(t5, n5, r4, l4) {
              function f3(r5, l5, p5) {
                function v4(e5, t6) {
                  var n6 = 0 === t6.matches.indexOf(e5);
                  return n6 || t6.matches.every(function(i4, a3) {
                    return true === i4.isQuantifier ? n6 = v4(e5, t6.matches[a3 - 1]) : Object.prototype.hasOwnProperty.call(i4, "matches") && (n6 = v4(e5, i4)), !n6;
                  }), n6;
                }
                function w3(e5, t6, n6) {
                  var i4, a3;
                  if ((s3.tests[e5] || s3.validPositions[e5]) && (s3.validPositions[e5] ? [s3.validPositions[e5]] : s3.tests[e5]).every(function(e6, r7) {
                    if (e6.mloc[t6])
                      return i4 = e6, false;
                    var o5 = void 0 !== n6 ? n6 : e6.alternation, l6 = void 0 !== e6.locator[o5] ? e6.locator[o5].toString().indexOf(t6) : -1;
                    return (void 0 === a3 || l6 < a3) && -1 !== l6 && (i4 = e6, a3 = l6), true;
                  }), i4) {
                    var r6 = i4.locator[i4.alternation], o4 = i4.mloc[t6] || i4.mloc[r6] || i4.locator;
                    if (-1 !== o4[o4.length - 1].toString().indexOf(":"))
                      o4.pop();
                    return o4.slice((void 0 !== n6 ? n6 : i4.alternation) + 1);
                  }
                  return void 0 !== n6 ? w3(e5, t6) : void 0;
                }
                function P3(t6, n6) {
                  return true === t6.match.static && true !== n6.match.static && n6.match.fn.test(t6.match.def, s3, e4, false, c3, false);
                }
                function S3(e5, t6) {
                  var n6 = e5.alternation, i4 = void 0 === t6 || n6 <= t6.alternation && -1 === e5.locator[n6].toString().indexOf(t6.locator[n6]);
                  if (!i4 && n6 > t6.alternation) {
                    for (var a3 = 0; a3 < n6; a3++)
                      if (e5.locator[a3] !== t6.locator[a3]) {
                        n6 = a3, i4 = true;
                        break;
                      }
                  }
                  return !!i4 && function(n7) {
                    e5.mloc = e5.mloc || {};
                    var i5 = e5.locator[n7];
                    if (void 0 !== i5) {
                      if ("string" == typeof i5 && (i5 = i5.split(",")[0]), void 0 === e5.mloc[i5] && (e5.mloc[i5] = e5.locator.slice(), e5.mloc[i5].push(":".concat(e5.alternation))), void 0 !== t6) {
                        for (var a4 in t6.mloc)
                          "string" == typeof a4 && (a4 = parseInt(a4.split(",")[0])), e5.mloc[a4 + 0] = t6.mloc[a4];
                        e5.locator[n7] = Object.keys(e5.mloc).join(",");
                      }
                      return e5.alternation > n7 && (e5.alternation = n7), true;
                    }
                    return e5.alternation = void 0, false;
                  }(n6);
                }
                function O2(e5, t6) {
                  if (e5.locator.length !== t6.locator.length)
                    return false;
                  for (var n6 = e5.alternation + 1; n6 < e5.locator.length; n6++)
                    if (e5.locator[n6] !== t6.locator[n6])
                      return false;
                  return true;
                }
                if (h3 > e4 + c3._maxTestPos)
                  throw new Error("Inputmask: There is probably an error in your mask definition or in the code. Create an issue on github with an example of the mask you are using. ".concat(s3.mask));
                if (h3 === e4 && void 0 === r5.matches) {
                  if (m2.push({
                    match: r5,
                    locator: l5.reverse(),
                    cd: y2,
                    mloc: {}
                  }), !r5.optionality || void 0 !== p5 || !(c3.definitions && c3.definitions[r5.nativeDef] && c3.definitions[r5.nativeDef].optional || a2.default.prototype.definitions[r5.nativeDef] && a2.default.prototype.definitions[r5.nativeDef].optional))
                    return true;
                  g2 = true, h3 = e4;
                } else if (void 0 !== r5.matches) {
                  if (r5.isGroup && p5 !== r5)
                    return function() {
                      if (r5 = f3(t5.matches[t5.matches.indexOf(r5) + 1], l5, p5))
                        return true;
                    }();
                  if (r5.isOptional)
                    return function() {
                      var t6 = r5, a3 = m2.length;
                      if (r5 = b2(r5, n5, l5, p5), m2.length > 0) {
                        if (m2.forEach(function(e5, t7) {
                          t7 >= a3 && (e5.match.optionality = e5.match.optionality ? e5.match.optionality + 1 : 1);
                        }), i3 = m2[m2.length - 1].match, void 0 !== p5 || !v4(i3, t6))
                          return r5;
                        g2 = true, h3 = e4;
                      }
                    }();
                  if (r5.isAlternator)
                    return function() {
                      function i4(e5) {
                        for (var t6, n6 = e5.matches[0].matches ? e5.matches[0].matches.length : 1, i5 = 0; i5 < e5.matches.length && n6 === (t6 = e5.matches[i5].matches ? e5.matches[i5].matches.length : 1); i5++)
                          ;
                        return n6 !== t6;
                      }
                      o3.hasAlternator = true;
                      var a3, v5 = r5, y3 = [], b3 = m2.slice(), x3 = l5.length, _2 = n5.length > 0 ? n5.shift() : -1;
                      if (-1 === _2 || "string" == typeof _2) {
                        var M2, E2 = h3, j2 = n5.slice(), T2 = [];
                        if ("string" == typeof _2)
                          T2 = _2.split(",");
                        else
                          for (M2 = 0; M2 < v5.matches.length; M2++)
                            T2.push(M2.toString());
                        if (void 0 !== s3.excludes[e4]) {
                          for (var A2 = T2.slice(), D2 = 0, L2 = s3.excludes[e4].length; D2 < L2; D2++) {
                            var C2 = s3.excludes[e4][D2].toString().split(":");
                            l5.length == C2[1] && T2.splice(T2.indexOf(C2[0]), 1);
                          }
                          0 === T2.length && (delete s3.excludes[e4], T2 = A2);
                        }
                        (true === c3.keepStatic || isFinite(parseInt(c3.keepStatic)) && E2 >= c3.keepStatic) && (T2 = T2.slice(0, 1));
                        for (var B2 = 0; B2 < T2.length; B2++) {
                          M2 = parseInt(T2[B2]), m2 = [], n5 = "string" == typeof _2 && w3(h3, M2, x3) || j2.slice();
                          var I2 = v5.matches[M2];
                          if (I2 && f3(I2, [M2].concat(l5), p5))
                            r5 = true;
                          else if (0 === B2 && (k2 = i4(v5)), I2 && I2.matches && I2.matches.length > v5.matches[0].matches.length)
                            break;
                          a3 = m2.slice(), h3 = E2, m2 = [];
                          for (var R2 = 0; R2 < a3.length; R2++) {
                            var F2 = a3[R2], N2 = false;
                            F2.alternation = F2.alternation || x3, S3(F2);
                            for (var V2 = 0; V2 < y3.length; V2++) {
                              var G2 = y3[V2];
                              if ("string" != typeof _2 || void 0 !== F2.alternation && T2.includes(F2.locator[F2.alternation].toString())) {
                                if (F2.match.nativeDef === G2.match.nativeDef) {
                                  N2 = true, S3(G2, F2);
                                  break;
                                }
                                if (d2(F2, G2, c3)) {
                                  S3(F2, G2) && (N2 = true, y3.splice(y3.indexOf(G2), 0, F2));
                                  break;
                                }
                                if (d2(G2, F2, c3)) {
                                  S3(G2, F2);
                                  break;
                                }
                                if (P3(F2, G2)) {
                                  O2(F2, G2) || void 0 !== u3.inputmask.userOptions.keepStatic ? S3(F2, G2) && (N2 = true, y3.splice(y3.indexOf(G2), 0, F2)) : c3.keepStatic = true;
                                  break;
                                }
                                if (P3(G2, F2)) {
                                  S3(G2, F2);
                                  break;
                                }
                              }
                            }
                            N2 || y3.push(F2);
                          }
                        }
                        m2 = b3.concat(y3), h3 = e4, g2 = m2.length > 0 && k2, r5 = y3.length > 0 && !k2, k2 && g2 && !r5 && m2.forEach(function(e5, t6) {
                          e5.unMatchedAlternationStopped = true;
                        }), n5 = j2.slice();
                      } else
                        r5 = f3(v5.matches[_2] || t5.matches[_2], [_2].concat(l5), p5);
                      if (r5)
                        return true;
                    }();
                  if (r5.isQuantifier && p5 !== t5.matches[t5.matches.indexOf(r5) - 1])
                    return function() {
                      for (var a3 = r5, o4 = false, u4 = n5.length > 0 ? n5.shift() : 0; u4 < (isNaN(a3.quantifier.max) ? u4 + 1 : a3.quantifier.max) && h3 <= e4; u4++) {
                        var p6 = t5.matches[t5.matches.indexOf(a3) - 1];
                        if (r5 = f3(p6, [u4].concat(l5), p6)) {
                          if (m2.forEach(function(t6, n6) {
                            (i3 = x2(p6, t6.match) ? t6.match : m2[m2.length - 1].match).optionalQuantifier = u4 >= a3.quantifier.min, i3.jit = (u4 + 1) * (p6.matches.indexOf(i3) + 1) > a3.quantifier.jit, i3.optionalQuantifier && v4(i3, p6) && (g2 = true, h3 = e4, c3.greedy && null == s3.validPositions[e4 - 1] && u4 > a3.quantifier.min && -1 != ["*", "+"].indexOf(a3.quantifier.max) && (m2.pop(), y2 = void 0), o4 = true, r5 = false), !o4 && i3.jit && (s3.jitOffset[e4] = p6.matches.length - p6.matches.indexOf(i3));
                          }), o4)
                            break;
                          return true;
                        }
                      }
                    }();
                  if (r5 = b2(r5, n5, l5, p5))
                    return true;
                } else
                  h3++;
              }
              for (var p4 = n5.length > 0 ? n5.shift() : 0; p4 < t5.matches.length; p4++)
                if (true !== t5.matches[p4].isQuantifier) {
                  var v3 = f3(t5.matches[p4], [p4].concat(r4), l4);
                  if (v3 && h3 === e4)
                    return v3;
                  if (h3 > e4)
                    break;
                }
            }
            function x2(e5, t5) {
              var n5 = -1 != e5.matches.indexOf(t5);
              return n5 || e5.matches.forEach(function(e6, i4) {
                void 0 === e6.matches || n5 || (n5 = x2(e6, t5));
              }), n5;
            }
            if (e4 > -1) {
              if (void 0 === t4) {
                for (var w2, P2 = e4 - 1; void 0 === (w2 = s3.validPositions[P2] || s3.tests[P2]) && P2 > -1; )
                  P2--;
                void 0 !== w2 && P2 > -1 && (v2 = function(e5, t5) {
                  var n5, i4 = [];
                  return Array.isArray(t5) || (t5 = [t5]), t5.length > 0 && (void 0 === t5[0].alternation || true === c3.keepStatic ? 0 === (i4 = f2.call(o3, e5, t5.slice()).locator.slice()).length && (i4 = t5[0].locator.slice()) : t5.forEach(function(e6) {
                    "" !== e6.def && (0 === i4.length ? (n5 = e6.alternation, i4 = e6.locator.slice()) : e6.locator[n5] && -1 === i4[n5].toString().indexOf(e6.locator[n5]) && (i4[n5] += "," + e6.locator[n5]));
                  })), i4;
                }(P2, w2), y2 = v2.join(""), h3 = P2);
              }
              if (s3.tests[e4] && s3.tests[e4][0].cd === y2)
                return s3.tests[e4];
              for (var S2 = v2.shift(); S2 < p3.length; S2++) {
                if (b2(p3[S2], v2, [S2]) && h3 === e4 || h3 > e4)
                  break;
              }
            }
            return (0 === m2.length || g2) && m2.push({
              match: {
                fn: null,
                static: true,
                optionality: false,
                casing: null,
                def: "",
                placeholder: ""
              },
              locator: k2 && 0 === m2.filter(function(e5) {
                return true !== e5.unMatchedAlternationStopped;
              }).length ? [0] : [],
              mloc: {},
              cd: y2
            }), void 0 !== t4 && s3.tests[e4] ? r3 = l3.extend(true, [], m2) : (s3.tests[e4] = l3.extend(true, [], m2), r3 = s3.tests[e4]), m2.forEach(function(e5) {
              e5.match.optionality = e5.match.defOptionality || false;
            }), r3;
          }
        },
        7215: function(e3, t3, n3) {
          Object.defineProperty(t3, "__esModule", {
            value: true
          }), t3.alternate = l2, t3.checkAlternationMatch = function(e4, t4, n4) {
            for (var i3, a3 = this.opts.greedy ? t4 : t4.slice(0, 1), r3 = false, o3 = void 0 !== n4 ? n4.split(",") : [], l3 = 0; l3 < o3.length; l3++)
              -1 !== (i3 = e4.indexOf(o3[l3])) && e4.splice(i3, 1);
            for (var s3 = 0; s3 < e4.length; s3++)
              if (a3.includes(e4[s3])) {
                r3 = true;
                break;
              }
            return r3;
          }, t3.handleRemove = function(e4, t4, n4, i3, s3) {
            var c3 = this, u3 = this.maskset, f3 = this.opts;
            if ((f3.numericInput || c3.isRTL) && (t4 === a2.keys.Backspace ? t4 = a2.keys.Delete : t4 === a2.keys.Delete && (t4 = a2.keys.Backspace), c3.isRTL)) {
              var p3 = n4.end;
              n4.end = n4.begin, n4.begin = p3;
            }
            var d3, h3 = r2.getLastValidPosition.call(c3, void 0, true);
            n4.end >= r2.getBuffer.call(c3).length && h3 >= n4.end && (n4.end = h3 + 1);
            t4 === a2.keys.Backspace ? n4.end - n4.begin < 1 && (n4.begin = r2.seekPrevious.call(c3, n4.begin)) : t4 === a2.keys.Delete && n4.begin === n4.end && (n4.end = r2.isMask.call(c3, n4.end, true, true) ? n4.end + 1 : r2.seekNext.call(c3, n4.end) + 1);
            false !== (d3 = v2.call(c3, n4)) && ((true !== i3 && false !== f3.keepStatic || null !== f3.regex && -1 !== o2.getTest.call(c3, n4.begin).match.def.indexOf("|")) && l2.call(c3, true), true !== i3 && (u3.p = t4 === a2.keys.Delete ? n4.begin + d3 : n4.begin, u3.p = r2.determineNewCaretPosition.call(c3, {
              begin: u3.p,
              end: u3.p
            }, false, false === f3.insertMode && t4 === a2.keys.Backspace ? "none" : void 0).begin));
          }, t3.isComplete = c2, t3.isSelection = u2, t3.isValid = f2, t3.refreshFromBuffer = d2, t3.revalidateMask = v2;
          var i2 = n3(6030), a2 = n3(2839), r2 = n3(8711), o2 = n3(4713);
          function l2(e4, t4, n4, i3, a3, s3) {
            var c3 = this, u3 = this.dependencyLib, p3 = this.opts, d3 = c3.maskset;
            if (!c3.hasAlternator)
              return false;
            var h3, v3, m2, g2, y2, k2, b2, x2, w2, P2, S2, O2 = u3.extend(true, [], d3.validPositions), _2 = u3.extend(true, {}, d3.tests), M2 = false, E2 = false, j2 = void 0 !== a3 ? a3 : r2.getLastValidPosition.call(c3);
            if (s3 && (P2 = s3.begin, S2 = s3.end, s3.begin > s3.end && (P2 = s3.end, S2 = s3.begin)), -1 === j2 && void 0 === a3)
              h3 = 0, v3 = (g2 = o2.getTest.call(c3, h3)).alternation;
            else
              for (; j2 >= 0; j2--)
                if ((m2 = d3.validPositions[j2]) && void 0 !== m2.alternation) {
                  if (j2 <= (e4 || 0) && g2 && g2.locator[m2.alternation] !== m2.locator[m2.alternation])
                    break;
                  h3 = j2, v3 = d3.validPositions[h3].alternation, g2 = m2;
                }
            if (void 0 !== v3) {
              b2 = parseInt(h3), d3.excludes[b2] = d3.excludes[b2] || [], true !== e4 && d3.excludes[b2].push((0, o2.getDecisionTaker)(g2) + ":" + g2.alternation);
              var T2 = [], A2 = -1;
              for (y2 = b2; b2 < r2.getLastValidPosition.call(c3, void 0, true) + 1; y2++)
                -1 === A2 && e4 <= y2 && void 0 !== t4 && (T2.push(t4), A2 = T2.length - 1), (k2 = d3.validPositions[b2]) && true !== k2.generatedInput && (void 0 === s3 || y2 < P2 || y2 >= S2) && T2.push(k2.input), d3.validPositions.splice(b2, 1);
              for (-1 === A2 && void 0 !== t4 && (T2.push(t4), A2 = T2.length - 1); void 0 !== d3.excludes[b2] && d3.excludes[b2].length < 10; ) {
                for (d3.tests = {}, r2.resetMaskSet.call(c3, true), M2 = true, y2 = 0; y2 < T2.length && (x2 = M2.caret || 0 == p3.insertMode && null != x2 ? r2.seekNext.call(c3, x2) : r2.getLastValidPosition.call(c3, void 0, true) + 1, w2 = T2[y2], M2 = f2.call(c3, x2, w2, false, i3, true)); y2++)
                  y2 === A2 && (E2 = M2), 1 == e4 && M2 && (E2 = {
                    caretPos: y2
                  });
                if (M2)
                  break;
                if (r2.resetMaskSet.call(c3), g2 = o2.getTest.call(c3, b2), d3.validPositions = u3.extend(true, [], O2), d3.tests = u3.extend(true, {}, _2), !d3.excludes[b2]) {
                  E2 = l2.call(c3, e4, t4, n4, i3, b2 - 1, s3);
                  break;
                }
                if (null != g2.alternation) {
                  var D2 = (0, o2.getDecisionTaker)(g2);
                  if (-1 !== d3.excludes[b2].indexOf(D2 + ":" + g2.alternation)) {
                    E2 = l2.call(c3, e4, t4, n4, i3, b2 - 1, s3);
                    break;
                  }
                  for (d3.excludes[b2].push(D2 + ":" + g2.alternation), y2 = b2; y2 < r2.getLastValidPosition.call(c3, void 0, true) + 1; y2++)
                    d3.validPositions.splice(b2);
                } else
                  delete d3.excludes[b2];
              }
            }
            return E2 && false === p3.keepStatic || delete d3.excludes[b2], E2;
          }
          function s2(e4, t4, n4) {
            var i3 = this.opts, r3 = this.maskset;
            switch (i3.casing || t4.casing) {
              case "upper":
                e4 = e4.toUpperCase();
                break;
              case "lower":
                e4 = e4.toLowerCase();
                break;
              case "title":
                var o3 = r3.validPositions[n4 - 1];
                e4 = 0 === n4 || o3 && o3.input === String.fromCharCode(a2.keyCode.Space) ? e4.toUpperCase() : e4.toLowerCase();
                break;
              default:
                if ("function" == typeof i3.casing) {
                  var l3 = Array.prototype.slice.call(arguments);
                  l3.push(r3.validPositions), e4 = i3.casing.apply(this, l3);
                }
            }
            return e4;
          }
          function c2(e4) {
            var t4 = this, n4 = this.opts, i3 = this.maskset;
            if ("function" == typeof n4.isComplete)
              return n4.isComplete(e4, n4);
            if ("*" !== n4.repeat) {
              var a3 = false, l3 = r2.determineLastRequiredPosition.call(t4, true), s3 = l3.l;
              if (void 0 === l3.def || l3.def.newBlockMarker || l3.def.optionality || l3.def.optionalQuantifier) {
                a3 = true;
                for (var c3 = 0; c3 <= s3; c3++) {
                  var u3 = o2.getTestTemplate.call(t4, c3).match;
                  if (true !== u3.static && void 0 === i3.validPositions[c3] && (false === u3.optionality || void 0 === u3.optionality || u3.optionality && 0 == u3.newBlockMarker) && (false === u3.optionalQuantifier || void 0 === u3.optionalQuantifier) || true === u3.static && "" != u3.def && e4[c3] !== o2.getPlaceholder.call(t4, c3, u3)) {
                    a3 = false;
                    break;
                  }
                }
              }
              return a3;
            }
          }
          function u2(e4) {
            var t4 = this.opts.insertMode ? 0 : 1;
            return this.isRTL ? e4.begin - e4.end > t4 : e4.end - e4.begin > t4;
          }
          function f2(e4, t4, n4, i3, a3, p3, m2) {
            var g2 = this, y2 = this.dependencyLib, k2 = this.opts, b2 = g2.maskset;
            n4 = true === n4;
            var x2 = e4;
            function w2(e5) {
              if (void 0 !== e5) {
                if (void 0 !== e5.remove && (Array.isArray(e5.remove) || (e5.remove = [e5.remove]), e5.remove.sort(function(e6, t6) {
                  return g2.isRTL ? e6.pos - t6.pos : t6.pos - e6.pos;
                }).forEach(function(e6) {
                  v2.call(g2, {
                    begin: e6,
                    end: e6 + 1
                  });
                }), e5.remove = void 0), void 0 !== e5.insert && (Array.isArray(e5.insert) || (e5.insert = [e5.insert]), e5.insert.sort(function(e6, t6) {
                  return g2.isRTL ? t6.pos - e6.pos : e6.pos - t6.pos;
                }).forEach(function(e6) {
                  "" !== e6.c && f2.call(g2, e6.pos, e6.c, void 0 === e6.strict || e6.strict, void 0 !== e6.fromIsValid ? e6.fromIsValid : i3);
                }), e5.insert = void 0), e5.refreshFromBuffer && e5.buffer) {
                  var t5 = e5.refreshFromBuffer;
                  d2.call(g2, true === t5 ? t5 : t5.start, t5.end, e5.buffer), e5.refreshFromBuffer = void 0;
                }
                void 0 !== e5.rewritePosition && (x2 = e5.rewritePosition, e5 = true);
              }
              return e5;
            }
            function P2(t5, n5, a4) {
              var l3 = false;
              return o2.getTests.call(g2, t5).every(function(c3, f3) {
                var p4 = c3.match;
                if (r2.getBuffer.call(g2, true), false !== (l3 = (!p4.jit || void 0 !== b2.validPositions[r2.seekPrevious.call(g2, t5)]) && (null != p4.fn ? p4.fn.test(n5, b2, t5, a4, k2, u2.call(g2, e4)) : (n5 === p4.def || n5 === k2.skipOptionalPartCharacter) && "" !== p4.def && {
                  c: o2.getPlaceholder.call(g2, t5, p4, true) || p4.def,
                  pos: t5
                }))) {
                  var d3 = void 0 !== l3.c ? l3.c : n5, h3 = t5;
                  return d3 = d3 === k2.skipOptionalPartCharacter && true === p4.static ? o2.getPlaceholder.call(g2, t5, p4, true) || p4.def : d3, true !== (l3 = w2(l3)) && void 0 !== l3.pos && l3.pos !== t5 && (h3 = l3.pos), true !== l3 && void 0 === l3.pos && void 0 === l3.c ? false : (false === v2.call(g2, e4, y2.extend({}, c3, {
                    input: s2.call(g2, d3, p4, h3)
                  }), i3, h3) && (l3 = false), false);
                }
                return true;
              }), l3;
            }
            void 0 !== e4.begin && (x2 = g2.isRTL ? e4.end : e4.begin);
            var S2 = true, O2 = y2.extend(true, [], b2.validPositions);
            if (false === k2.keepStatic && void 0 !== b2.excludes[x2] && true !== a3 && true !== i3)
              for (var _2 = x2; _2 < (g2.isRTL ? e4.begin : e4.end); _2++)
                void 0 !== b2.excludes[_2] && (b2.excludes[_2] = void 0, delete b2.tests[_2]);
            if ("function" == typeof k2.preValidation && true !== i3 && true !== p3 && (S2 = w2(S2 = k2.preValidation.call(g2, r2.getBuffer.call(g2), x2, t4, u2.call(g2, e4), k2, b2, e4, n4 || a3))), true === S2) {
              if (S2 = P2(x2, t4, n4), (!n4 || true === i3) && false === S2 && true !== p3) {
                var M2 = b2.validPositions[x2];
                if (!M2 || true !== M2.match.static || M2.match.def !== t4 && t4 !== k2.skipOptionalPartCharacter) {
                  if (k2.insertMode || void 0 === b2.validPositions[r2.seekNext.call(g2, x2)] || e4.end > x2) {
                    var E2 = false;
                    if (b2.jitOffset[x2] && void 0 === b2.validPositions[r2.seekNext.call(g2, x2)] && false !== (S2 = f2.call(g2, x2 + b2.jitOffset[x2], t4, true, true)) && (true !== a3 && (S2.caret = x2), E2 = true), e4.end > x2 && (b2.validPositions[x2] = void 0), !E2 && !r2.isMask.call(g2, x2, k2.keepStatic && 0 === x2)) {
                      for (var j2 = x2 + 1, T2 = r2.seekNext.call(g2, x2, false, 0 !== x2); j2 <= T2; j2++)
                        if (false !== (S2 = P2(j2, t4, n4))) {
                          S2 = h2.call(g2, x2, void 0 !== S2.pos ? S2.pos : j2) || S2, x2 = j2;
                          break;
                        }
                    }
                  }
                } else
                  S2 = {
                    caret: r2.seekNext.call(g2, x2)
                  };
              }
              g2.hasAlternator && true !== a3 && !n4 && (a3 = true, false === S2 && k2.keepStatic && (c2.call(g2, r2.getBuffer.call(g2)) || 0 === x2) ? S2 = l2.call(g2, x2, t4, n4, i3, void 0, e4) : (u2.call(g2, e4) && b2.tests[x2] && b2.tests[x2].length > 1 && k2.keepStatic || 1 == S2 && true !== k2.numericInput && b2.tests[x2] && b2.tests[x2].length > 1 && r2.getLastValidPosition.call(g2, void 0, true) > x2) && (S2 = l2.call(g2, true))), true === S2 && (S2 = {
                pos: x2
              });
            }
            if ("function" == typeof k2.postValidation && true !== i3 && true !== p3) {
              var A2 = k2.postValidation.call(g2, r2.getBuffer.call(g2, true), void 0 !== e4.begin ? g2.isRTL ? e4.end : e4.begin : e4, t4, S2, k2, b2, n4, m2);
              void 0 !== A2 && (S2 = true === A2 ? S2 : A2);
            }
            S2 && void 0 === S2.pos && (S2.pos = x2), false === S2 || true === p3 ? (r2.resetMaskSet.call(g2, true), b2.validPositions = y2.extend(true, [], O2)) : h2.call(g2, void 0, x2, true);
            var D2 = w2(S2);
            void 0 !== g2.maxLength && (r2.getBuffer.call(g2).length > g2.maxLength && !i3 && (r2.resetMaskSet.call(g2, true), b2.validPositions = y2.extend(true, [], O2), D2 = false));
            return D2;
          }
          function p2(e4, t4, n4) {
            for (var i3 = this.maskset, a3 = false, r3 = o2.getTests.call(this, e4), l3 = 0; l3 < r3.length; l3++) {
              if (r3[l3].match && (r3[l3].match.nativeDef === t4.match[n4.shiftPositions ? "def" : "nativeDef"] && (!n4.shiftPositions || !t4.match.static) || r3[l3].match.nativeDef === t4.match.nativeDef || n4.regex && !r3[l3].match.static && r3[l3].match.fn.test(t4.input, i3, e4, false, n4))) {
                a3 = true;
                break;
              }
              if (r3[l3].match && r3[l3].match.def === t4.match.nativeDef) {
                a3 = void 0;
                break;
              }
            }
            return false === a3 && void 0 !== i3.jitOffset[e4] && (a3 = p2.call(this, e4 + i3.jitOffset[e4], t4, n4)), a3;
          }
          function d2(e4, t4, n4) {
            var a3, o3, l3 = this, s3 = this.maskset, c3 = this.opts, u3 = this.dependencyLib, f3 = c3.skipOptionalPartCharacter, p3 = l3.isRTL ? n4.slice().reverse() : n4;
            if (c3.skipOptionalPartCharacter = "", true === e4)
              r2.resetMaskSet.call(l3, false), e4 = 0, t4 = n4.length, o3 = r2.determineNewCaretPosition.call(l3, {
                begin: 0,
                end: 0
              }, false).begin;
            else {
              for (a3 = e4; a3 < t4; a3++)
                s3.validPositions.splice(e4, 0);
              o3 = e4;
            }
            var d3 = new u3.Event("keypress");
            for (a3 = e4; a3 < t4; a3++) {
              d3.key = p3[a3].toString(), l3.ignorable = false;
              var h3 = i2.EventHandlers.keypressEvent.call(l3, d3, true, false, false, o3);
              false !== h3 && void 0 !== h3 && (o3 = h3.forwardPosition);
            }
            c3.skipOptionalPartCharacter = f3;
          }
          function h2(e4, t4, n4) {
            var i3 = this, a3 = this.maskset, l3 = this.dependencyLib;
            if (void 0 === e4)
              for (e4 = t4 - 1; e4 > 0 && !a3.validPositions[e4]; e4--)
                ;
            for (var s3 = e4; s3 < t4; s3++) {
              if (void 0 === a3.validPositions[s3] && !r2.isMask.call(i3, s3, false)) {
                if (0 == s3 ? o2.getTest.call(i3, s3) : a3.validPositions[s3 - 1]) {
                  var c3 = o2.getTests.call(i3, s3).slice();
                  "" === c3[c3.length - 1].match.def && c3.pop();
                  var u3, p3 = o2.determineTestTemplate.call(i3, s3, c3);
                  if (p3 && (true !== p3.match.jit || "master" === p3.match.newBlockMarker && (u3 = a3.validPositions[s3 + 1]) && true === u3.match.optionalQuantifier) && ((p3 = l3.extend({}, p3, {
                    input: o2.getPlaceholder.call(i3, s3, p3.match, true) || p3.match.def
                  })).generatedInput = true, v2.call(i3, s3, p3, true), true !== n4)) {
                    var d3 = a3.validPositions[t4].input;
                    return a3.validPositions[t4] = void 0, f2.call(i3, t4, d3, true, true);
                  }
                }
              }
            }
          }
          function v2(e4, t4, n4, i3) {
            var a3 = this, l3 = this.maskset, s3 = this.opts, c3 = this.dependencyLib;
            function d3(e5, t5, n5) {
              var i4 = t5[e5];
              if (void 0 !== i4 && true === i4.match.static && true !== i4.match.optionality && (void 0 === t5[0] || void 0 === t5[0].alternation)) {
                var a4 = n5.begin <= e5 - 1 ? t5[e5 - 1] && true === t5[e5 - 1].match.static && t5[e5 - 1] : t5[e5 - 1], r3 = n5.end > e5 + 1 ? t5[e5 + 1] && true === t5[e5 + 1].match.static && t5[e5 + 1] : t5[e5 + 1];
                return a4 && r3;
              }
              return false;
            }
            var h3 = 0, v3 = void 0 !== e4.begin ? e4.begin : e4, m2 = void 0 !== e4.end ? e4.end : e4, g2 = true;
            if (e4.begin > e4.end && (v3 = e4.end, m2 = e4.begin), i3 = void 0 !== i3 ? i3 : v3, void 0 === n4 && (v3 !== m2 || s3.insertMode && void 0 !== l3.validPositions[i3] || void 0 === t4 || t4.match.optionalQuantifier || t4.match.optionality)) {
              var y2, k2 = c3.extend(true, [], l3.validPositions), b2 = r2.getLastValidPosition.call(a3, void 0, true);
              l3.p = v3;
              var x2 = u2.call(a3, e4) ? v3 : i3;
              for (y2 = b2; y2 >= x2; y2--)
                l3.validPositions.splice(y2, 1), void 0 === t4 && delete l3.tests[y2 + 1];
              var w2, P2, S2 = i3, O2 = S2;
              for (t4 && (l3.validPositions[i3] = c3.extend(true, {}, t4), O2++, S2++), null == k2[m2] && l3.jitOffset[m2] && (m2 += l3.jitOffset[m2] + 1), y2 = t4 ? m2 : m2 - 1; y2 <= b2; y2++) {
                if (void 0 !== (w2 = k2[y2]) && true !== w2.generatedInput && (y2 >= m2 || y2 >= v3 && d3(y2, k2, {
                  begin: v3,
                  end: m2
                }))) {
                  for (; "" !== o2.getTest.call(a3, O2).match.def; ) {
                    if (false !== (P2 = p2.call(a3, O2, w2, s3)) || "+" === w2.match.def) {
                      "+" === w2.match.def && r2.getBuffer.call(a3, true);
                      var _2 = f2.call(a3, O2, w2.input, "+" !== w2.match.def, true);
                      if (g2 = false !== _2, S2 = (_2.pos || O2) + 1, !g2 && P2)
                        break;
                    } else
                      g2 = false;
                    if (g2) {
                      void 0 === t4 && w2.match.static && y2 === e4.begin && h3++;
                      break;
                    }
                    if (!g2 && r2.getBuffer.call(a3), O2 > l3.maskLength)
                      break;
                    O2++;
                  }
                  "" == o2.getTest.call(a3, O2).match.def && (g2 = false), O2 = S2;
                }
                if (!g2)
                  break;
              }
              if (!g2)
                return l3.validPositions = c3.extend(true, [], k2), r2.resetMaskSet.call(a3, true), false;
            } else
              t4 && o2.getTest.call(a3, i3).match.cd === t4.match.cd && (l3.validPositions[i3] = c3.extend(true, {}, t4));
            return r2.resetMaskSet.call(a3, true), h3;
          }
        }
      }, t2 = {};
      function n2(i2) {
        var a2 = t2[i2];
        if (void 0 !== a2)
          return a2.exports;
        var r2 = t2[i2] = {
          exports: {}
        };
        return e2[i2](r2, r2.exports, n2), r2.exports;
      }
      var i = {};
      return function() {
        var e3 = i;
        Object.defineProperty(e3, "__esModule", {
          value: true
        }), e3.default = void 0, n2(7149), n2(3194), n2(9302), n2(4013), n2(3851), n2(219), n2(207), n2(5296);
        var t3, a2 = (t3 = n2(2394)) && t3.__esModule ? t3 : {
          default: t3
        };
        e3.default = a2.default;
      }(), i;
    }();
  });
})(inputmask);
var inputmaskExports = inputmask.exports;
const Inputmask = /* @__PURE__ */ getDefaultExportFromCjs(inputmaskExports);
var toastr$2 = { exports: {} };
(function(module) {
  (function(define) {
    define(["jquery"], function($2) {
      return function() {
        var $container;
        var listener;
        var toastId = 0;
        var toastType = {
          error: "error",
          info: "info",
          success: "success",
          warning: "warning"
        };
        var toastr2 = {
          clear: clear2,
          remove,
          error: error2,
          getContainer: getContainer2,
          info,
          options: {},
          subscribe,
          success,
          version: "2.1.4",
          warning
        };
        var previousToast;
        return toastr2;
        function error2(message, title, optionsOverride) {
          return notify({
            type: toastType.error,
            iconClass: getOptions2().iconClasses.error,
            message,
            optionsOverride,
            title
          });
        }
        function getContainer2(options, create2) {
          if (!options) {
            options = getOptions2();
          }
          $container = $2("#" + options.containerId);
          if ($container.length) {
            return $container;
          }
          if (create2) {
            $container = createContainer(options);
          }
          return $container;
        }
        function info(message, title, optionsOverride) {
          return notify({
            type: toastType.info,
            iconClass: getOptions2().iconClasses.info,
            message,
            optionsOverride,
            title
          });
        }
        function subscribe(callback) {
          listener = callback;
        }
        function success(message, title, optionsOverride) {
          return notify({
            type: toastType.success,
            iconClass: getOptions2().iconClasses.success,
            message,
            optionsOverride,
            title
          });
        }
        function warning(message, title, optionsOverride) {
          return notify({
            type: toastType.warning,
            iconClass: getOptions2().iconClasses.warning,
            message,
            optionsOverride,
            title
          });
        }
        function clear2($toastElement, clearOptions) {
          var options = getOptions2();
          if (!$container) {
            getContainer2(options);
          }
          if (!clearToast($toastElement, options, clearOptions)) {
            clearContainer(options);
          }
        }
        function remove($toastElement) {
          var options = getOptions2();
          if (!$container) {
            getContainer2(options);
          }
          if ($toastElement && $2(":focus", $toastElement).length === 0) {
            removeToast($toastElement);
            return;
          }
          if ($container.children().length) {
            $container.remove();
          }
        }
        function clearContainer(options) {
          var toastsToClear = $container.children();
          for (var i = toastsToClear.length - 1; i >= 0; i--) {
            clearToast($2(toastsToClear[i]), options);
          }
        }
        function clearToast($toastElement, options, clearOptions) {
          var force = clearOptions && clearOptions.force ? clearOptions.force : false;
          if ($toastElement && (force || $2(":focus", $toastElement).length === 0)) {
            $toastElement[options.hideMethod]({
              duration: options.hideDuration,
              easing: options.hideEasing,
              complete: function() {
                removeToast($toastElement);
              }
            });
            return true;
          }
          return false;
        }
        function createContainer(options) {
          $container = $2("<div/>").attr("id", options.containerId).addClass(options.positionClass);
          $container.appendTo($2(options.target));
          return $container;
        }
        function getDefaults() {
          return {
            tapToDismiss: true,
            toastClass: "toast",
            containerId: "toast-container",
            debug: false,
            showMethod: "fadeIn",
            //fadeIn, slideDown, and show are built into jQuery
            showDuration: 300,
            showEasing: "swing",
            //swing and linear are built into jQuery
            onShown: void 0,
            hideMethod: "fadeOut",
            hideDuration: 1e3,
            hideEasing: "swing",
            onHidden: void 0,
            closeMethod: false,
            closeDuration: false,
            closeEasing: false,
            closeOnHover: true,
            extendedTimeOut: 1e3,
            iconClasses: {
              error: "toast-error",
              info: "toast-info",
              success: "toast-success",
              warning: "toast-warning"
            },
            iconClass: "toast-info",
            positionClass: "toast-top-right",
            timeOut: 5e3,
            // Set timeOut and extendedTimeOut to 0 to make it sticky
            titleClass: "toast-title",
            messageClass: "toast-message",
            escapeHtml: false,
            target: "body",
            closeHtml: '<button type="button">&times;</button>',
            closeClass: "toast-close-button",
            newestOnTop: true,
            preventDuplicates: false,
            progressBar: false,
            progressClass: "toast-progress",
            rtl: false
          };
        }
        function publish(args) {
          if (!listener) {
            return;
          }
          listener(args);
        }
        function notify(map2) {
          var options = getOptions2();
          var iconClass = map2.iconClass || options.iconClass;
          if (typeof map2.optionsOverride !== "undefined") {
            options = $2.extend(options, map2.optionsOverride);
            iconClass = map2.optionsOverride.iconClass || iconClass;
          }
          if (shouldExit(options, map2)) {
            return;
          }
          toastId++;
          $container = getContainer2(options, true);
          var intervalId = null;
          var $toastElement = $2("<div/>");
          var $titleElement = $2("<div/>");
          var $messageElement = $2("<div/>");
          var $progressElement = $2("<div/>");
          var $closeElement = $2(options.closeHtml);
          var progressBar = {
            intervalId: null,
            hideEta: null,
            maxHideTime: null
          };
          var response2 = {
            toastId,
            state: "visible",
            startTime: /* @__PURE__ */ new Date(),
            options,
            map: map2
          };
          personalizeToast();
          displayToast();
          handleEvents();
          publish(response2);
          if (options.debug && console) {
            console.log(response2);
          }
          return $toastElement;
          function escapeHtml(source) {
            if (source == null) {
              source = "";
            }
            return source.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
          }
          function personalizeToast() {
            setIcon();
            setTitle();
            setMessage();
            setCloseButton();
            setProgressBar();
            setRTL();
            setSequence();
            setAria();
          }
          function setAria() {
            var ariaValue = "";
            switch (map2.iconClass) {
              case "toast-success":
              case "toast-info":
                ariaValue = "polite";
                break;
              default:
                ariaValue = "assertive";
            }
            $toastElement.attr("aria-live", ariaValue);
          }
          function handleEvents() {
            if (options.closeOnHover) {
              $toastElement.hover(stickAround, delayedHideToast);
            }
            if (!options.onclick && options.tapToDismiss) {
              $toastElement.click(hideToast);
            }
            if (options.closeButton && $closeElement) {
              $closeElement.click(function(event) {
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (event.cancelBubble !== void 0 && event.cancelBubble !== true) {
                  event.cancelBubble = true;
                }
                if (options.onCloseClick) {
                  options.onCloseClick(event);
                }
                hideToast(true);
              });
            }
            if (options.onclick) {
              $toastElement.click(function(event) {
                options.onclick(event);
                hideToast();
              });
            }
          }
          function displayToast() {
            $toastElement.hide();
            $toastElement[options.showMethod](
              { duration: options.showDuration, easing: options.showEasing, complete: options.onShown }
            );
            if (options.timeOut > 0) {
              intervalId = setTimeout(hideToast, options.timeOut);
              progressBar.maxHideTime = parseFloat(options.timeOut);
              progressBar.hideEta = (/* @__PURE__ */ new Date()).getTime() + progressBar.maxHideTime;
              if (options.progressBar) {
                progressBar.intervalId = setInterval(updateProgress, 10);
              }
            }
          }
          function setIcon() {
            if (map2.iconClass) {
              $toastElement.addClass(options.toastClass).addClass(iconClass);
            }
          }
          function setSequence() {
            if (options.newestOnTop) {
              $container.prepend($toastElement);
            } else {
              $container.append($toastElement);
            }
          }
          function setTitle() {
            if (map2.title) {
              var suffix = map2.title;
              if (options.escapeHtml) {
                suffix = escapeHtml(map2.title);
              }
              $titleElement.append(suffix).addClass(options.titleClass);
              $toastElement.append($titleElement);
            }
          }
          function setMessage() {
            if (map2.message) {
              var suffix = map2.message;
              if (options.escapeHtml) {
                suffix = escapeHtml(map2.message);
              }
              $messageElement.append(suffix).addClass(options.messageClass);
              $toastElement.append($messageElement);
            }
          }
          function setCloseButton() {
            if (options.closeButton) {
              $closeElement.addClass(options.closeClass).attr("role", "button");
              $toastElement.prepend($closeElement);
            }
          }
          function setProgressBar() {
            if (options.progressBar) {
              $progressElement.addClass(options.progressClass);
              $toastElement.prepend($progressElement);
            }
          }
          function setRTL() {
            if (options.rtl) {
              $toastElement.addClass("rtl");
            }
          }
          function shouldExit(options2, map3) {
            if (options2.preventDuplicates) {
              if (map3.message === previousToast) {
                return true;
              } else {
                previousToast = map3.message;
              }
            }
            return false;
          }
          function hideToast(override) {
            var method = override && options.closeMethod !== false ? options.closeMethod : options.hideMethod;
            var duration = override && options.closeDuration !== false ? options.closeDuration : options.hideDuration;
            var easing = override && options.closeEasing !== false ? options.closeEasing : options.hideEasing;
            if ($2(":focus", $toastElement).length && !override) {
              return;
            }
            clearTimeout(progressBar.intervalId);
            return $toastElement[method]({
              duration,
              easing,
              complete: function() {
                removeToast($toastElement);
                clearTimeout(intervalId);
                if (options.onHidden && response2.state !== "hidden") {
                  options.onHidden();
                }
                response2.state = "hidden";
                response2.endTime = /* @__PURE__ */ new Date();
                publish(response2);
              }
            });
          }
          function delayedHideToast() {
            if (options.timeOut > 0 || options.extendedTimeOut > 0) {
              intervalId = setTimeout(hideToast, options.extendedTimeOut);
              progressBar.maxHideTime = parseFloat(options.extendedTimeOut);
              progressBar.hideEta = (/* @__PURE__ */ new Date()).getTime() + progressBar.maxHideTime;
            }
          }
          function stickAround() {
            clearTimeout(intervalId);
            progressBar.hideEta = 0;
            $toastElement.stop(true, true)[options.showMethod](
              { duration: options.showDuration, easing: options.showEasing }
            );
          }
          function updateProgress() {
            var percentage = (progressBar.hideEta - (/* @__PURE__ */ new Date()).getTime()) / progressBar.maxHideTime * 100;
            $progressElement.width(percentage + "%");
          }
        }
        function getOptions2() {
          return $2.extend({}, getDefaults(), toastr2.options);
        }
        function removeToast($toastElement) {
          if (!$container) {
            $container = getContainer2();
          }
          if ($toastElement.is(":visible")) {
            return;
          }
          $toastElement.remove();
          $toastElement = null;
          if ($container.children().length === 0) {
            $container.remove();
            previousToast = void 0;
          }
        }
      }();
    });
  })(function(deps, factory) {
    if (module.exports) {
      module.exports = factory(requireJquery());
    } else {
      window.toastr = factory(window.jQuery);
    }
  });
})(toastr$2);
var toastrExports = toastr$2.exports;
const toastr$1 = /* @__PURE__ */ getDefaultExportFromCjs(toastrExports);
/*!
* sweetalert2 v11.17.2
* Released under the MIT License.
*/
function _assertClassBrand(e2, t2, n2) {
  if ("function" == typeof e2 ? e2 === t2 : e2.has(t2))
    return arguments.length < 3 ? t2 : n2;
  throw new TypeError("Private element is not present on this object");
}
function _checkPrivateRedeclaration(e2, t2) {
  if (t2.has(e2))
    throw new TypeError("Cannot initialize the same private elements twice on an object");
}
function _classPrivateFieldGet2(s2, a2) {
  return s2.get(_assertClassBrand(s2, a2));
}
function _classPrivateFieldInitSpec(e2, t2, a2) {
  _checkPrivateRedeclaration(e2, t2), t2.set(e2, a2);
}
function _classPrivateFieldSet2(s2, a2, r2) {
  return s2.set(_assertClassBrand(s2, a2), r2), r2;
}
const RESTORE_FOCUS_TIMEOUT = 100;
const globalState = {};
const focusPreviousActiveElement = () => {
  if (globalState.previousActiveElement instanceof HTMLElement) {
    globalState.previousActiveElement.focus();
    globalState.previousActiveElement = null;
  } else if (document.body) {
    document.body.focus();
  }
};
const restoreActiveElement = (returnFocus) => {
  return new Promise((resolve) => {
    if (!returnFocus) {
      return resolve();
    }
    const x2 = window.scrollX;
    const y2 = window.scrollY;
    globalState.restoreFocusTimeout = setTimeout(() => {
      focusPreviousActiveElement();
      resolve();
    }, RESTORE_FOCUS_TIMEOUT);
    window.scrollTo(x2, y2);
  });
};
const swalPrefix = "swal2-";
const classNames = ["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error", "draggable", "dragging"];
const swalClasses = classNames.reduce(
  (acc, className) => {
    acc[className] = swalPrefix + className;
    return acc;
  },
  /** @type {SwalClasses} */
  {}
);
const icons = ["success", "warning", "info", "question", "error"];
const iconTypes = icons.reduce(
  (acc, icon) => {
    acc[icon] = swalPrefix + icon;
    return acc;
  },
  /** @type {SwalIcons} */
  {}
);
const consolePrefix = "SweetAlert2:";
const capitalizeFirstLetter = (str2) => str2.charAt(0).toUpperCase() + str2.slice(1);
const warn = (message) => {
  console.warn(`${consolePrefix} ${typeof message === "object" ? message.join(" ") : message}`);
};
const error$1 = (message) => {
  console.error(`${consolePrefix} ${message}`);
};
const previousWarnOnceMessages = [];
const warnOnce = (message) => {
  if (!previousWarnOnceMessages.includes(message)) {
    previousWarnOnceMessages.push(message);
    warn(message);
  }
};
const warnAboutDeprecation = function(deprecatedParam) {
  let useInstead = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
  warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release.${useInstead ? ` Use "${useInstead}" instead.` : ""}`);
};
const callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === "function";
const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);
const isPromise$1 = (arg) => arg && Promise.resolve(arg) === arg;
const getContainer = () => document.body.querySelector(`.${swalClasses.container}`);
const elementBySelector = (selectorString) => {
  const container = getContainer();
  return container ? container.querySelector(selectorString) : null;
};
const elementByClass = (className) => {
  return elementBySelector(`.${className}`);
};
const getPopup = () => elementByClass(swalClasses.popup);
const getIcon = () => elementByClass(swalClasses.icon);
const getIconContent = () => elementByClass(swalClasses["icon-content"]);
const getTitle = () => elementByClass(swalClasses.title);
const getHtmlContainer = () => elementByClass(swalClasses["html-container"]);
const getImage = () => elementByClass(swalClasses.image);
const getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
const getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
const getConfirmButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.confirm}`)
);
const getCancelButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.cancel}`)
);
const getDenyButton = () => (
  /** @type {HTMLButtonElement} */
  elementBySelector(`.${swalClasses.actions} .${swalClasses.deny}`)
);
const getInputLabel = () => elementByClass(swalClasses["input-label"]);
const getLoader = () => elementBySelector(`.${swalClasses.loader}`);
const getActions = () => elementByClass(swalClasses.actions);
const getFooter = () => elementByClass(swalClasses.footer);
const getTimerProgressBar = () => elementByClass(swalClasses["timer-progress-bar"]);
const getCloseButton = () => elementByClass(swalClasses.close);
const focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
const getFocusableElements = () => {
  const popup = getPopup();
  if (!popup) {
    return [];
  }
  const focusableElementsWithTabindex = popup.querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])');
  const focusableElementsWithTabindexSorted = Array.from(focusableElementsWithTabindex).sort((a2, b2) => {
    const tabindexA = parseInt(a2.getAttribute("tabindex") || "0");
    const tabindexB = parseInt(b2.getAttribute("tabindex") || "0");
    if (tabindexA > tabindexB) {
      return 1;
    } else if (tabindexA < tabindexB) {
      return -1;
    }
    return 0;
  });
  const otherFocusableElements = popup.querySelectorAll(focusable);
  const otherFocusableElementsFiltered = Array.from(otherFocusableElements).filter((el) => el.getAttribute("tabindex") !== "-1");
  return [...new Set(focusableElementsWithTabindexSorted.concat(otherFocusableElementsFiltered))].filter((el) => isVisible$1(el));
};
const isModal = () => {
  return hasClass(document.body, swalClasses.shown) && !hasClass(document.body, swalClasses["toast-shown"]) && !hasClass(document.body, swalClasses["no-backdrop"]);
};
const isToast = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return hasClass(popup, swalClasses.toast);
};
const isLoading = () => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  return popup.hasAttribute("data-loading");
};
const setInnerHtml = (elem, html) => {
  elem.textContent = "";
  if (html) {
    const parser = new DOMParser();
    const parsed = parser.parseFromString(html, `text/html`);
    const head = parsed.querySelector("head");
    if (head) {
      Array.from(head.childNodes).forEach((child) => {
        elem.appendChild(child);
      });
    }
    const body = parsed.querySelector("body");
    if (body) {
      Array.from(body.childNodes).forEach((child) => {
        if (child instanceof HTMLVideoElement || child instanceof HTMLAudioElement) {
          elem.appendChild(child.cloneNode(true));
        } else {
          elem.appendChild(child);
        }
      });
    }
  }
};
const hasClass = (elem, className) => {
  if (!className) {
    return false;
  }
  const classList = className.split(/\s+/);
  for (let i = 0; i < classList.length; i++) {
    if (!elem.classList.contains(classList[i])) {
      return false;
    }
  }
  return true;
};
const removeCustomClasses = (elem, params) => {
  Array.from(elem.classList).forEach((className) => {
    if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass || {}).includes(className)) {
      elem.classList.remove(className);
    }
  });
};
const applyCustomClass = (elem, params, className) => {
  removeCustomClasses(elem, params);
  if (!params.customClass) {
    return;
  }
  const customClass = params.customClass[
    /** @type {keyof SweetAlertCustomClass} */
    className
  ];
  if (!customClass) {
    return;
  }
  if (typeof customClass !== "string" && !customClass.forEach) {
    warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass}"`);
    return;
  }
  addClass(elem, customClass);
};
const getInput$1 = (popup, inputClass) => {
  if (!inputClass) {
    return null;
  }
  switch (inputClass) {
    case "select":
    case "textarea":
    case "file":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses[inputClass]}`);
    case "checkbox":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.checkbox} input`);
    case "radio":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:checked`) || popup.querySelector(`.${swalClasses.popup} > .${swalClasses.radio} input:first-child`);
    case "range":
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.range} input`);
    default:
      return popup.querySelector(`.${swalClasses.popup} > .${swalClasses.input}`);
  }
};
const focusInput = (input) => {
  input.focus();
  if (input.type !== "file") {
    const val = input.value;
    input.value = "";
    input.value = val;
  }
};
const toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return;
  }
  if (typeof classList === "string") {
    classList = classList.split(/\s+/).filter(Boolean);
  }
  classList.forEach((className) => {
    if (Array.isArray(target)) {
      target.forEach((elem) => {
        if (condition) {
          elem.classList.add(className);
        } else {
          elem.classList.remove(className);
        }
      });
    } else {
      if (condition) {
        target.classList.add(className);
      } else {
        target.classList.remove(className);
      }
    }
  });
};
const addClass = (target, classList) => {
  toggleClass(target, classList, true);
};
const removeClass = (target, classList) => {
  toggleClass(target, classList, false);
};
const getDirectChildByClass = (elem, className) => {
  const children = Array.from(elem.children);
  for (let i = 0; i < children.length; i++) {
    const child = children[i];
    if (child instanceof HTMLElement && hasClass(child, className)) {
      return child;
    }
  }
};
const applyNumericalStyle = (elem, property, value) => {
  if (value === `${parseInt(value)}`) {
    value = parseInt(value);
  }
  if (value || parseInt(value) === 0) {
    elem.style.setProperty(property, typeof value === "number" ? `${value}px` : value);
  } else {
    elem.style.removeProperty(property);
  }
};
const show = function(elem) {
  let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "flex";
  if (!elem) {
    return;
  }
  elem.style.display = display;
};
const hide$2 = (elem) => {
  if (!elem) {
    return;
  }
  elem.style.display = "none";
};
const showWhenInnerHtmlPresent = function(elem) {
  let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "block";
  if (!elem) {
    return;
  }
  new MutationObserver(() => {
    toggle(elem, elem.innerHTML, display);
  }).observe(elem, {
    childList: true,
    subtree: true
  });
};
const setStyle = (parent, selector, property, value) => {
  const el = parent.querySelector(selector);
  if (el) {
    el.style.setProperty(property, value);
  }
};
const toggle = function(elem, condition) {
  let display = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "flex";
  if (condition) {
    show(elem, display);
  } else {
    hide$2(elem);
  }
};
const isVisible$1 = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
const allButtonsAreHidden = () => !isVisible$1(getConfirmButton()) && !isVisible$1(getDenyButton()) && !isVisible$1(getCancelButton());
const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
const hasCssAnimation = (elem) => {
  const style = window.getComputedStyle(elem);
  const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
  const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
  return animDuration > 0 || transDuration > 0;
};
const animateTimerProgressBar = function(timer) {
  let reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  if (isVisible$1(timerProgressBar)) {
    if (reset) {
      timerProgressBar.style.transition = "none";
      timerProgressBar.style.width = "100%";
    }
    setTimeout(() => {
      timerProgressBar.style.transition = `width ${timer / 1e3}s linear`;
      timerProgressBar.style.width = "0%";
    }, 10);
  }
};
const stopTimerProgressBar = () => {
  const timerProgressBar = getTimerProgressBar();
  if (!timerProgressBar) {
    return;
  }
  const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  timerProgressBar.style.removeProperty("transition");
  timerProgressBar.style.width = "100%";
  const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);
  const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;
  timerProgressBar.style.width = `${timerProgressBarPercent}%`;
};
const isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";
const sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses["html-container"]}" class="${swalClasses.popup}" tabindex="-1">
   <button type="button" class="${swalClasses.close}"></button>
   <ul class="${swalClasses["progress-steps"]}"></ul>
   <div class="${swalClasses.icon}"></div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div class="${swalClasses["html-container"]}" id="${swalClasses["html-container"]}"></div>
   <input class="${swalClasses.input}" id="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <input type="range" />
     <output></output>
   </div>
   <select class="${swalClasses.select}" id="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label class="${swalClasses.checkbox}">
     <input type="checkbox" id="${swalClasses.checkbox}" />
     <span class="${swalClasses.label}"></span>
   </label>
   <textarea class="${swalClasses.textarea}" id="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   <div class="${swalClasses.actions}">
     <div class="${swalClasses.loader}"></div>
     <button type="button" class="${swalClasses.confirm}"></button>
     <button type="button" class="${swalClasses.deny}"></button>
     <button type="button" class="${swalClasses.cancel}"></button>
   </div>
   <div class="${swalClasses.footer}"></div>
   <div class="${swalClasses["timer-progress-bar-container"]}">
     <div class="${swalClasses["timer-progress-bar"]}"></div>
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
const resetOldContainer = () => {
  const oldContainer = getContainer();
  if (!oldContainer) {
    return false;
  }
  oldContainer.remove();
  removeClass([document.documentElement, document.body], [swalClasses["no-backdrop"], swalClasses["toast-shown"], swalClasses["has-column"]]);
  return true;
};
const resetValidationMessage$1 = () => {
  globalState.currentInstance.resetValidationMessage();
};
const addInputChangeListeners = () => {
  const popup = getPopup();
  const input = getDirectChildByClass(popup, swalClasses.input);
  const file2 = getDirectChildByClass(popup, swalClasses.file);
  const range = popup.querySelector(`.${swalClasses.range} input`);
  const rangeOutput = popup.querySelector(`.${swalClasses.range} output`);
  const select = getDirectChildByClass(popup, swalClasses.select);
  const checkbox = popup.querySelector(`.${swalClasses.checkbox} input`);
  const textarea = getDirectChildByClass(popup, swalClasses.textarea);
  input.oninput = resetValidationMessage$1;
  file2.onchange = resetValidationMessage$1;
  select.onchange = resetValidationMessage$1;
  checkbox.onchange = resetValidationMessage$1;
  textarea.oninput = resetValidationMessage$1;
  range.oninput = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
  range.onchange = () => {
    resetValidationMessage$1();
    rangeOutput.value = range.value;
  };
};
const getTarget = (target) => typeof target === "string" ? document.querySelector(target) : target;
const setupAccessibility = (params) => {
  const popup = getPopup();
  popup.setAttribute("role", params.toast ? "alert" : "dialog");
  popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
  if (!params.toast) {
    popup.setAttribute("aria-modal", "true");
  }
};
const setupRTL = (targetElement) => {
  if (window.getComputedStyle(targetElement).direction === "rtl") {
    addClass(getContainer(), swalClasses.rtl);
  }
};
const init$3 = (params) => {
  const oldContainerExisted = resetOldContainer();
  if (isNodeEnv()) {
    error$1("SweetAlert2 requires document to initialize");
    return;
  }
  const container = document.createElement("div");
  container.className = swalClasses.container;
  if (oldContainerExisted) {
    addClass(container, swalClasses["no-transition"]);
  }
  setInnerHtml(container, sweetHTML);
  container.dataset["swal2Theme"] = params.theme;
  const targetElement = getTarget(params.target);
  targetElement.appendChild(container);
  setupAccessibility(params);
  setupRTL(targetElement);
  addInputChangeListeners();
};
const parseHtmlToContainer = (param, target) => {
  if (param instanceof HTMLElement) {
    target.appendChild(param);
  } else if (typeof param === "object") {
    handleObject(param, target);
  } else if (param) {
    setInnerHtml(target, param);
  }
};
const handleObject = (param, target) => {
  if (param.jquery) {
    handleJqueryElem(target, param);
  } else {
    setInnerHtml(target, param.toString());
  }
};
const handleJqueryElem = (target, elem) => {
  target.textContent = "";
  if (0 in elem) {
    for (let i = 0; i in elem; i++) {
      target.appendChild(elem[i].cloneNode(true));
    }
  } else {
    target.appendChild(elem.cloneNode(true));
  }
};
const renderActions = (instance, params) => {
  const actions2 = getActions();
  const loader = getLoader();
  if (!actions2 || !loader) {
    return;
  }
  if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {
    hide$2(actions2);
  } else {
    show(actions2);
  }
  applyCustomClass(actions2, params, "actions");
  renderButtons(actions2, loader, params);
  setInnerHtml(loader, params.loaderHtml || "");
  applyCustomClass(loader, params, "loader");
};
function renderButtons(actions2, loader, params) {
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!confirmButton || !denyButton || !cancelButton) {
    return;
  }
  renderButton(confirmButton, "confirm", params);
  renderButton(denyButton, "deny", params);
  renderButton(cancelButton, "cancel", params);
  handleButtonsStyling(confirmButton, denyButton, cancelButton, params);
  if (params.reverseButtons) {
    if (params.toast) {
      actions2.insertBefore(cancelButton, confirmButton);
      actions2.insertBefore(denyButton, confirmButton);
    } else {
      actions2.insertBefore(cancelButton, loader);
      actions2.insertBefore(denyButton, loader);
      actions2.insertBefore(confirmButton, loader);
    }
  }
}
function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {
  if (!params.buttonsStyling) {
    removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
    return;
  }
  addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);
  if (params.confirmButtonColor) {
    confirmButton.style.backgroundColor = params.confirmButtonColor;
    addClass(confirmButton, swalClasses["default-outline"]);
  }
  if (params.denyButtonColor) {
    denyButton.style.backgroundColor = params.denyButtonColor;
    addClass(denyButton, swalClasses["default-outline"]);
  }
  if (params.cancelButtonColor) {
    cancelButton.style.backgroundColor = params.cancelButtonColor;
    addClass(cancelButton, swalClasses["default-outline"]);
  }
}
function renderButton(button, buttonType, params) {
  const buttonName = (
    /** @type {'Confirm' | 'Deny' | 'Cancel'} */
    capitalizeFirstLetter(buttonType)
  );
  toggle(button, params[`show${buttonName}Button`], "inline-block");
  setInnerHtml(button, params[`${buttonType}ButtonText`] || "");
  button.setAttribute("aria-label", params[`${buttonType}ButtonAriaLabel`] || "");
  button.className = swalClasses[buttonType];
  applyCustomClass(button, params, `${buttonType}Button`);
}
const renderCloseButton = (instance, params) => {
  const closeButton = getCloseButton();
  if (!closeButton) {
    return;
  }
  setInnerHtml(closeButton, params.closeButtonHtml || "");
  applyCustomClass(closeButton, params, "closeButton");
  toggle(closeButton, params.showCloseButton);
  closeButton.setAttribute("aria-label", params.closeButtonAriaLabel || "");
};
const renderContainer = (instance, params) => {
  const container = getContainer();
  if (!container) {
    return;
  }
  handleBackdropParam(container, params.backdrop);
  handlePositionParam(container, params.position);
  handleGrowParam(container, params.grow);
  applyCustomClass(container, params, "container");
};
function handleBackdropParam(container, backdrop) {
  if (typeof backdrop === "string") {
    container.style.background = backdrop;
  } else if (!backdrop) {
    addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
  }
}
function handlePositionParam(container, position) {
  if (!position) {
    return;
  }
  if (position in swalClasses) {
    addClass(container, swalClasses[position]);
  } else {
    warn('The "position" parameter is not valid, defaulting to "center"');
    addClass(container, swalClasses.center);
  }
}
function handleGrowParam(container, grow) {
  if (!grow) {
    return;
  }
  addClass(container, swalClasses[`grow-${grow}`]);
}
var privateProps = {
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
};
const inputClasses = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
const renderInput = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const innerParams = privateProps.innerParams.get(instance);
  const rerender = !innerParams || params.input !== innerParams.input;
  inputClasses.forEach((inputClass) => {
    const inputContainer = getDirectChildByClass(popup, swalClasses[inputClass]);
    if (!inputContainer) {
      return;
    }
    setAttributes(inputClass, params.inputAttributes);
    inputContainer.className = swalClasses[inputClass];
    if (rerender) {
      hide$2(inputContainer);
    }
  });
  if (params.input) {
    if (rerender) {
      showInput(params);
    }
    setCustomClass(params);
  }
};
const showInput = (params) => {
  if (!params.input) {
    return;
  }
  if (!renderInputType[params.input]) {
    error$1(`Unexpected type of input! Expected ${Object.keys(renderInputType).join(" | ")}, got "${params.input}"`);
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (!inputContainer) {
    return;
  }
  const input = renderInputType[params.input](inputContainer, params);
  show(inputContainer);
  if (params.inputAutoFocus) {
    setTimeout(() => {
      focusInput(input);
    });
  }
};
const removeAttributes = (input) => {
  for (let i = 0; i < input.attributes.length; i++) {
    const attrName = input.attributes[i].name;
    if (!["id", "type", "value", "style"].includes(attrName)) {
      input.removeAttribute(attrName);
    }
  }
};
const setAttributes = (inputClass, inputAttributes) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const input = getInput$1(popup, inputClass);
  if (!input) {
    return;
  }
  removeAttributes(input);
  for (const attr2 in inputAttributes) {
    input.setAttribute(attr2, inputAttributes[attr2]);
  }
};
const setCustomClass = (params) => {
  if (!params.input) {
    return;
  }
  const inputContainer = getInputContainer(params.input);
  if (inputContainer) {
    applyCustomClass(inputContainer, params, "input");
  }
};
const setInputPlaceholder = (input, params) => {
  if (!input.placeholder && params.inputPlaceholder) {
    input.placeholder = params.inputPlaceholder;
  }
};
const setInputLabel = (input, prependTo, params) => {
  if (params.inputLabel) {
    const label = document.createElement("label");
    const labelClass = swalClasses["input-label"];
    label.setAttribute("for", input.id);
    label.className = labelClass;
    if (typeof params.customClass === "object") {
      addClass(label, params.customClass.inputLabel);
    }
    label.innerText = params.inputLabel;
    prependTo.insertAdjacentElement("beforebegin", label);
  }
};
const getInputContainer = (inputType) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  return getDirectChildByClass(popup, swalClasses[
    /** @type {SwalClass} */
    inputType
  ] || swalClasses.input);
};
const checkAndSetInputValue = (input, inputValue) => {
  if (["string", "number"].includes(typeof inputValue)) {
    input.value = `${inputValue}`;
  } else if (!isPromise$1(inputValue)) {
    warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof inputValue}"`);
  }
};
const renderInputType = {};
renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = renderInputType.search = renderInputType.date = renderInputType["datetime-local"] = renderInputType.time = renderInputType.week = renderInputType.month = /** @type {(input: Input | HTMLElement, params: SweetAlertOptions) => Input} */
(input, params) => {
  checkAndSetInputValue(input, params.inputValue);
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  input.type = params.input;
  return input;
};
renderInputType.file = (input, params) => {
  setInputLabel(input, input, params);
  setInputPlaceholder(input, params);
  return input;
};
renderInputType.range = (range, params) => {
  const rangeInput = range.querySelector("input");
  const rangeOutput = range.querySelector("output");
  checkAndSetInputValue(rangeInput, params.inputValue);
  rangeInput.type = params.input;
  checkAndSetInputValue(rangeOutput, params.inputValue);
  setInputLabel(rangeInput, range, params);
  return range;
};
renderInputType.select = (select, params) => {
  select.textContent = "";
  if (params.inputPlaceholder) {
    const placeholder = document.createElement("option");
    setInnerHtml(placeholder, params.inputPlaceholder);
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
  setInputLabel(select, select, params);
  return select;
};
renderInputType.radio = (radio) => {
  radio.textContent = "";
  return radio;
};
renderInputType.checkbox = (checkboxContainer, params) => {
  const checkbox = getInput$1(getPopup(), "checkbox");
  checkbox.value = "1";
  checkbox.checked = Boolean(params.inputValue);
  const label = checkboxContainer.querySelector("span");
  setInnerHtml(label, params.inputPlaceholder || params.inputLabel);
  return checkbox;
};
renderInputType.textarea = (textarea, params) => {
  checkAndSetInputValue(textarea, params.inputValue);
  setInputPlaceholder(textarea, params);
  setInputLabel(textarea, textarea, params);
  const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);
  setTimeout(() => {
    if ("MutationObserver" in window) {
      const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
      const textareaResizeHandler = () => {
        if (!document.body.contains(textarea)) {
          return;
        }
        const textareaWidth = textarea.offsetWidth + getMargin(textarea);
        if (textareaWidth > initialPopupWidth) {
          getPopup().style.width = `${textareaWidth}px`;
        } else {
          applyNumericalStyle(getPopup(), "width", params.width);
        }
      };
      new MutationObserver(textareaResizeHandler).observe(textarea, {
        attributes: true,
        attributeFilter: ["style"]
      });
    }
  });
  return textarea;
};
const renderContent = (instance, params) => {
  const htmlContainer = getHtmlContainer();
  if (!htmlContainer) {
    return;
  }
  showWhenInnerHtmlPresent(htmlContainer);
  applyCustomClass(htmlContainer, params, "htmlContainer");
  if (params.html) {
    parseHtmlToContainer(params.html, htmlContainer);
    show(htmlContainer, "block");
  } else if (params.text) {
    htmlContainer.textContent = params.text;
    show(htmlContainer, "block");
  } else {
    hide$2(htmlContainer);
  }
  renderInput(instance, params);
};
const renderFooter = (instance, params) => {
  const footer = getFooter();
  if (!footer) {
    return;
  }
  showWhenInnerHtmlPresent(footer);
  toggle(footer, params.footer, "block");
  if (params.footer) {
    parseHtmlToContainer(params.footer, footer);
  }
  applyCustomClass(footer, params, "footer");
};
const renderIcon = (instance, params) => {
  const innerParams = privateProps.innerParams.get(instance);
  const icon = getIcon();
  if (!icon) {
    return;
  }
  if (innerParams && params.icon === innerParams.icon) {
    setContent(icon, params);
    applyStyles$3(icon, params);
    return;
  }
  if (!params.icon && !params.iconHtml) {
    hide$2(icon);
    return;
  }
  if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {
    error$1(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${params.icon}"`);
    hide$2(icon);
    return;
  }
  show(icon);
  setContent(icon, params);
  applyStyles$3(icon, params);
  addClass(icon, params.showClass && params.showClass.icon);
  const colorSchemeQueryList = window.matchMedia("(prefers-color-scheme: dark)");
  colorSchemeQueryList.addEventListener("change", adjustSuccessIconBackgroundColor);
};
const applyStyles$3 = (icon, params) => {
  for (const [iconType, iconClassName] of Object.entries(iconTypes)) {
    if (params.icon !== iconType) {
      removeClass(icon, iconClassName);
    }
  }
  addClass(icon, params.icon && iconTypes[params.icon]);
  setColor(icon, params);
  adjustSuccessIconBackgroundColor();
  applyCustomClass(icon, params, "icon");
};
const adjustSuccessIconBackgroundColor = () => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
  const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i = 0; i < successIconParts.length; i++) {
    successIconParts[i].style.backgroundColor = popupBackgroundColor;
  }
};
const successIconHtml = `
  <div class="swal2-success-circular-line-left"></div>
  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
  <div class="swal2-success-circular-line-right"></div>
`;
const errorIconHtml = `
  <span class="swal2-x-mark">
    <span class="swal2-x-mark-line-left"></span>
    <span class="swal2-x-mark-line-right"></span>
  </span>
`;
const setContent = (icon, params) => {
  if (!params.icon && !params.iconHtml) {
    return;
  }
  let oldContent = icon.innerHTML;
  let newContent = "";
  if (params.iconHtml) {
    newContent = iconContent(params.iconHtml);
  } else if (params.icon === "success") {
    newContent = successIconHtml;
    oldContent = oldContent.replace(/ style=".*?"/g, "");
  } else if (params.icon === "error") {
    newContent = errorIconHtml;
  } else if (params.icon) {
    const defaultIconHtml = {
      question: "?",
      warning: "!",
      info: "i"
    };
    newContent = iconContent(defaultIconHtml[params.icon]);
  }
  if (oldContent.trim() !== newContent.trim()) {
    setInnerHtml(icon, newContent);
  }
};
const setColor = (icon, params) => {
  if (!params.iconColor) {
    return;
  }
  icon.style.color = params.iconColor;
  icon.style.borderColor = params.iconColor;
  for (const sel of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) {
    setStyle(icon, sel, "background-color", params.iconColor);
  }
  setStyle(icon, ".swal2-success-ring", "border-color", params.iconColor);
};
const iconContent = (content) => `<div class="${swalClasses["icon-content"]}">${content}</div>`;
const renderImage = (instance, params) => {
  const image = getImage();
  if (!image) {
    return;
  }
  if (!params.imageUrl) {
    hide$2(image);
    return;
  }
  show(image, "");
  image.setAttribute("src", params.imageUrl);
  image.setAttribute("alt", params.imageAlt || "");
  applyNumericalStyle(image, "width", params.imageWidth);
  applyNumericalStyle(image, "height", params.imageHeight);
  image.className = swalClasses.image;
  applyCustomClass(image, params, "image");
};
let dragging = false;
let mousedownX = 0;
let mousedownY = 0;
let initialX = 0;
let initialY = 0;
const addDraggableListeners = (popup) => {
  popup.addEventListener("mousedown", down);
  document.body.addEventListener("mousemove", move);
  popup.addEventListener("mouseup", up);
  popup.addEventListener("touchstart", down);
  document.body.addEventListener("touchmove", move);
  popup.addEventListener("touchend", up);
};
const removeDraggableListeners = (popup) => {
  popup.removeEventListener("mousedown", down);
  document.body.removeEventListener("mousemove", move);
  popup.removeEventListener("mouseup", up);
  popup.removeEventListener("touchstart", down);
  document.body.removeEventListener("touchmove", move);
  popup.removeEventListener("touchend", up);
};
const down = (event) => {
  const popup = getPopup();
  if (event.target === popup || getIcon().contains(
    /** @type {HTMLElement} */
    event.target
  )) {
    dragging = true;
    const clientXY = getClientXY(event);
    mousedownX = clientXY.clientX;
    mousedownY = clientXY.clientY;
    initialX = parseInt(popup.style.insetInlineStart) || 0;
    initialY = parseInt(popup.style.insetBlockStart) || 0;
    addClass(popup, "swal2-dragging");
  }
};
const move = (event) => {
  const popup = getPopup();
  if (dragging) {
    let {
      clientX,
      clientY
    } = getClientXY(event);
    popup.style.insetInlineStart = `${initialX + (clientX - mousedownX)}px`;
    popup.style.insetBlockStart = `${initialY + (clientY - mousedownY)}px`;
  }
};
const up = () => {
  const popup = getPopup();
  dragging = false;
  removeClass(popup, "swal2-dragging");
};
const getClientXY = (event) => {
  let clientX = 0, clientY = 0;
  if (event.type.startsWith("mouse")) {
    clientX = /** @type {MouseEvent} */
    event.clientX;
    clientY = /** @type {MouseEvent} */
    event.clientY;
  } else if (event.type.startsWith("touch")) {
    clientX = /** @type {TouchEvent} */
    event.touches[0].clientX;
    clientY = /** @type {TouchEvent} */
    event.touches[0].clientY;
  }
  return {
    clientX,
    clientY
  };
};
const renderPopup = (instance, params) => {
  const container = getContainer();
  const popup = getPopup();
  if (!container || !popup) {
    return;
  }
  if (params.toast) {
    applyNumericalStyle(container, "width", params.width);
    popup.style.width = "100%";
    const loader = getLoader();
    if (loader) {
      popup.insertBefore(loader, getIcon());
    }
  } else {
    applyNumericalStyle(popup, "width", params.width);
  }
  applyNumericalStyle(popup, "padding", params.padding);
  if (params.color) {
    popup.style.color = params.color;
  }
  if (params.background) {
    popup.style.background = params.background;
  }
  hide$2(getValidationMessage());
  addClasses$1$1(popup, params);
  if (params.draggable && !params.toast) {
    addClass(popup, swalClasses.draggable);
    addDraggableListeners(popup);
  } else {
    removeClass(popup, swalClasses.draggable);
    removeDraggableListeners(popup);
  }
};
const addClasses$1$1 = (popup, params) => {
  const showClass = params.showClass || {};
  popup.className = `${swalClasses.popup} ${isVisible$1(popup) ? showClass.popup : ""}`;
  if (params.toast) {
    addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
    addClass(popup, swalClasses.toast);
  } else {
    addClass(popup, swalClasses.modal);
  }
  applyCustomClass(popup, params, "popup");
  if (typeof params.customClass === "string") {
    addClass(popup, params.customClass);
  }
  if (params.icon) {
    addClass(popup, swalClasses[`icon-${params.icon}`]);
  }
};
const renderProgressSteps = (instance, params) => {
  const progressStepsContainer = getProgressSteps();
  if (!progressStepsContainer) {
    return;
  }
  const {
    progressSteps,
    currentProgressStep
  } = params;
  if (!progressSteps || progressSteps.length === 0 || currentProgressStep === void 0) {
    hide$2(progressStepsContainer);
    return;
  }
  show(progressStepsContainer);
  progressStepsContainer.textContent = "";
  if (currentProgressStep >= progressSteps.length) {
    warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
  }
  progressSteps.forEach((step, index) => {
    const stepEl = createStepElement(step);
    progressStepsContainer.appendChild(stepEl);
    if (index === currentProgressStep) {
      addClass(stepEl, swalClasses["active-progress-step"]);
    }
    if (index !== progressSteps.length - 1) {
      const lineEl = createLineElement(params);
      progressStepsContainer.appendChild(lineEl);
    }
  });
};
const createStepElement = (step) => {
  const stepEl = document.createElement("li");
  addClass(stepEl, swalClasses["progress-step"]);
  setInnerHtml(stepEl, step);
  return stepEl;
};
const createLineElement = (params) => {
  const lineEl = document.createElement("li");
  addClass(lineEl, swalClasses["progress-step-line"]);
  if (params.progressStepsDistance) {
    applyNumericalStyle(lineEl, "width", params.progressStepsDistance);
  }
  return lineEl;
};
const renderTitle = (instance, params) => {
  const title = getTitle();
  if (!title) {
    return;
  }
  showWhenInnerHtmlPresent(title);
  toggle(title, params.title || params.titleText, "block");
  if (params.title) {
    parseHtmlToContainer(params.title, title);
  }
  if (params.titleText) {
    title.innerText = params.titleText;
  }
  applyCustomClass(title, params, "title");
};
const render = (instance, params) => {
  renderPopup(instance, params);
  renderContainer(instance, params);
  renderProgressSteps(instance, params);
  renderIcon(instance, params);
  renderImage(instance, params);
  renderTitle(instance, params);
  renderCloseButton(instance, params);
  renderContent(instance, params);
  renderActions(instance, params);
  renderFooter(instance, params);
  const popup = getPopup();
  if (typeof params.didRender === "function" && popup) {
    params.didRender(popup);
  }
  globalState.eventEmitter.emit("didRender", popup);
};
const isVisible$2 = () => {
  return isVisible$1(getPopup());
};
const clickConfirm = () => {
  var _dom$getConfirmButton;
  return (_dom$getConfirmButton = getConfirmButton()) === null || _dom$getConfirmButton === void 0 ? void 0 : _dom$getConfirmButton.click();
};
const clickDeny = () => {
  var _dom$getDenyButton;
  return (_dom$getDenyButton = getDenyButton()) === null || _dom$getDenyButton === void 0 ? void 0 : _dom$getDenyButton.click();
};
const clickCancel = () => {
  var _dom$getCancelButton;
  return (_dom$getCancelButton = getCancelButton()) === null || _dom$getCancelButton === void 0 ? void 0 : _dom$getCancelButton.click();
};
const DismissReason = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
});
const removeKeydownHandler = (globalState2) => {
  if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
    globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = false;
  }
};
const addKeydownHandler = (globalState2, innerParams, dismissWith) => {
  removeKeydownHandler(globalState2);
  if (!innerParams.toast) {
    globalState2.keydownHandler = (e2) => keydownHandler(innerParams, e2, dismissWith);
    globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
    globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, {
      capture: globalState2.keydownListenerCapture
    });
    globalState2.keydownHandlerAdded = true;
  }
};
const setFocus = (index, increment) => {
  var _dom$getPopup;
  const focusableElements = getFocusableElements();
  if (focusableElements.length) {
    index = index + increment;
    if (index === focusableElements.length) {
      index = 0;
    } else if (index === -1) {
      index = focusableElements.length - 1;
    }
    focusableElements[index].focus();
    return;
  }
  (_dom$getPopup = getPopup()) === null || _dom$getPopup === void 0 || _dom$getPopup.focus();
};
const arrowKeysNextButton = ["ArrowRight", "ArrowDown"];
const arrowKeysPreviousButton = ["ArrowLeft", "ArrowUp"];
const keydownHandler = (innerParams, event, dismissWith) => {
  if (!innerParams) {
    return;
  }
  if (event.isComposing || event.keyCode === 229) {
    return;
  }
  if (innerParams.stopKeydownPropagation) {
    event.stopPropagation();
  }
  if (event.key === "Enter") {
    handleEnter(event, innerParams);
  } else if (event.key === "Tab") {
    handleTab(event);
  } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(event.key)) {
    handleArrows(event.key);
  } else if (event.key === "Escape") {
    handleEsc(event, innerParams, dismissWith);
  }
};
const handleEnter = (event, innerParams) => {
  if (!callIfFunction(innerParams.allowEnterKey)) {
    return;
  }
  const input = getInput$1(getPopup(), innerParams.input);
  if (event.target && input && event.target instanceof HTMLElement && event.target.outerHTML === input.outerHTML) {
    if (["textarea", "file"].includes(innerParams.input)) {
      return;
    }
    clickConfirm();
    event.preventDefault();
  }
};
const handleTab = (event) => {
  const targetElement = event.target;
  const focusableElements = getFocusableElements();
  let btnIndex = -1;
  for (let i = 0; i < focusableElements.length; i++) {
    if (targetElement === focusableElements[i]) {
      btnIndex = i;
      break;
    }
  }
  if (!event.shiftKey) {
    setFocus(btnIndex, 1);
  } else {
    setFocus(btnIndex, -1);
  }
  event.stopPropagation();
  event.preventDefault();
};
const handleArrows = (key) => {
  const actions2 = getActions();
  const confirmButton = getConfirmButton();
  const denyButton = getDenyButton();
  const cancelButton = getCancelButton();
  if (!actions2 || !confirmButton || !denyButton || !cancelButton) {
    return;
  }
  const buttons = [confirmButton, denyButton, cancelButton];
  if (document.activeElement instanceof HTMLElement && !buttons.includes(document.activeElement)) {
    return;
  }
  const sibling = arrowKeysNextButton.includes(key) ? "nextElementSibling" : "previousElementSibling";
  let buttonToFocus = document.activeElement;
  if (!buttonToFocus) {
    return;
  }
  for (let i = 0; i < actions2.children.length; i++) {
    buttonToFocus = buttonToFocus[sibling];
    if (!buttonToFocus) {
      return;
    }
    if (buttonToFocus instanceof HTMLButtonElement && isVisible$1(buttonToFocus)) {
      break;
    }
  }
  if (buttonToFocus instanceof HTMLButtonElement) {
    buttonToFocus.focus();
  }
};
const handleEsc = (event, innerParams, dismissWith) => {
  if (callIfFunction(innerParams.allowEscapeKey)) {
    event.preventDefault();
    dismissWith(DismissReason.esc);
  }
};
var privateMethods = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap(),
  swalPromiseReject: /* @__PURE__ */ new WeakMap()
};
const setAriaHidden = () => {
  const container = getContainer();
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.contains(container)) {
      return;
    }
    if (el.hasAttribute("aria-hidden")) {
      el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden") || "");
    }
    el.setAttribute("aria-hidden", "true");
  });
};
const unsetAriaHidden = () => {
  const bodyChildren = Array.from(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.hasAttribute("data-previous-aria-hidden")) {
      el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden") || "");
      el.removeAttribute("data-previous-aria-hidden");
    } else {
      el.removeAttribute("aria-hidden");
    }
  });
};
const isSafariOrIOS = typeof window !== "undefined" && !!window.GestureEvent;
const iOSfix = () => {
  if (isSafariOrIOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset2 = document.body.scrollTop;
    document.body.style.top = `${offset2 * -1}px`;
    addClass(document.body, swalClasses.iosfix);
    lockBodyScroll();
  }
};
const lockBodyScroll = () => {
  const container = getContainer();
  if (!container) {
    return;
  }
  let preventTouchMove;
  container.ontouchstart = (event) => {
    preventTouchMove = shouldPreventTouchMove(event);
  };
  container.ontouchmove = (event) => {
    if (preventTouchMove) {
      event.preventDefault();
      event.stopPropagation();
    }
  };
};
const shouldPreventTouchMove = (event) => {
  const target = event.target;
  const container = getContainer();
  const htmlContainer = getHtmlContainer();
  if (!container || !htmlContainer) {
    return false;
  }
  if (isStylus(event) || isZoom(event)) {
    return false;
  }
  if (target === container) {
    return true;
  }
  if (!isScrollable(container) && target instanceof HTMLElement && target.tagName !== "INPUT" && // #1603
  target.tagName !== "TEXTAREA" && // #2266
  !(isScrollable(htmlContainer) && // #1944
  htmlContainer.contains(target))) {
    return true;
  }
  return false;
};
const isStylus = (event) => {
  return event.touches && event.touches.length && event.touches[0].touchType === "stylus";
};
const isZoom = (event) => {
  return event.touches && event.touches.length > 1;
};
const undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset2 = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = "";
    document.body.scrollTop = offset2 * -1;
  }
};
const measureScrollbar = () => {
  const scrollDiv = document.createElement("div");
  scrollDiv.className = swalClasses["scrollbar-measure"];
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};
let previousBodyPadding = null;
const replaceScrollbarWithPadding = (initialBodyOverflow) => {
  if (previousBodyPadding !== null) {
    return;
  }
  if (document.body.scrollHeight > window.innerHeight || initialBodyOverflow === "scroll") {
    previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
    document.body.style.paddingRight = `${previousBodyPadding + measureScrollbar()}px`;
  }
};
const undoReplaceScrollbarWithPadding = () => {
  if (previousBodyPadding !== null) {
    document.body.style.paddingRight = `${previousBodyPadding}px`;
    previousBodyPadding = null;
  }
};
function removePopupAndResetState(instance, container, returnFocus, didClose) {
  if (isToast()) {
    triggerDidCloseAndDispose(instance, didClose);
  } else {
    restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));
    removeKeydownHandler(globalState);
  }
  if (isSafariOrIOS) {
    container.setAttribute("style", "display:none !important");
    container.removeAttribute("class");
    container.innerHTML = "";
  } else {
    container.remove();
  }
  if (isModal()) {
    undoReplaceScrollbarWithPadding();
    undoIOSfix();
    unsetAriaHidden();
  }
  removeBodyClasses();
}
function removeBodyClasses() {
  removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses["height-auto"], swalClasses["no-backdrop"], swalClasses["toast-shown"]]);
}
function close(resolveValue) {
  resolveValue = prepareResolveValue(resolveValue);
  const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);
  const didClose = triggerClosePopup(this);
  if (this.isAwaitingPromise) {
    if (!resolveValue.isDismissed) {
      handleAwaitingPromise(this);
      swalPromiseResolve(resolveValue);
    }
  } else if (didClose) {
    swalPromiseResolve(resolveValue);
  }
}
const triggerClosePopup = (instance) => {
  const popup = getPopup();
  if (!popup) {
    return false;
  }
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {
    return false;
  }
  removeClass(popup, innerParams.showClass.popup);
  addClass(popup, innerParams.hideClass.popup);
  const backdrop = getContainer();
  removeClass(backdrop, innerParams.showClass.backdrop);
  addClass(backdrop, innerParams.hideClass.backdrop);
  handlePopupAnimation(instance, popup, innerParams);
  return true;
};
function rejectPromise(error2) {
  const rejectPromise2 = privateMethods.swalPromiseReject.get(this);
  handleAwaitingPromise(this);
  if (rejectPromise2) {
    rejectPromise2(error2);
  }
}
const handleAwaitingPromise = (instance) => {
  if (instance.isAwaitingPromise) {
    delete instance.isAwaitingPromise;
    if (!privateProps.innerParams.get(instance)) {
      instance._destroy();
    }
  }
};
const prepareResolveValue = (resolveValue) => {
  if (typeof resolveValue === "undefined") {
    return {
      isConfirmed: false,
      isDenied: false,
      isDismissed: true
    };
  }
  return Object.assign({
    isConfirmed: false,
    isDenied: false,
    isDismissed: false
  }, resolveValue);
};
const handlePopupAnimation = (instance, popup, innerParams) => {
  var _globalState$eventEmi;
  const container = getContainer();
  const animationIsSupported = hasCssAnimation(popup);
  if (typeof innerParams.willClose === "function") {
    innerParams.willClose(popup);
  }
  (_globalState$eventEmi = globalState.eventEmitter) === null || _globalState$eventEmi === void 0 || _globalState$eventEmi.emit("willClose", popup);
  if (animationIsSupported) {
    animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);
  } else {
    removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);
  }
};
const animatePopup = (instance, popup, container, returnFocus, didClose) => {
  globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);
  const swalCloseAnimationFinished = function(e2) {
    if (e2.target === popup) {
      var _globalState$swalClos;
      (_globalState$swalClos = globalState.swalCloseEventFinishedCallback) === null || _globalState$swalClos === void 0 || _globalState$swalClos.call(globalState);
      delete globalState.swalCloseEventFinishedCallback;
      popup.removeEventListener("animationend", swalCloseAnimationFinished);
      popup.removeEventListener("transitionend", swalCloseAnimationFinished);
    }
  };
  popup.addEventListener("animationend", swalCloseAnimationFinished);
  popup.addEventListener("transitionend", swalCloseAnimationFinished);
};
const triggerDidCloseAndDispose = (instance, didClose) => {
  setTimeout(() => {
    var _globalState$eventEmi2;
    if (typeof didClose === "function") {
      didClose.bind(instance.params)();
    }
    (_globalState$eventEmi2 = globalState.eventEmitter) === null || _globalState$eventEmi2 === void 0 || _globalState$eventEmi2.emit("didClose");
    if (instance._destroy) {
      instance._destroy();
    }
  });
};
const showLoading = (buttonToReplace) => {
  let popup = getPopup();
  if (!popup) {
    new Swal$1();
  }
  popup = getPopup();
  if (!popup) {
    return;
  }
  const loader = getLoader();
  if (isToast()) {
    hide$2(getIcon());
  } else {
    replaceButton(popup, buttonToReplace);
  }
  show(loader);
  popup.setAttribute("data-loading", "true");
  popup.setAttribute("aria-busy", "true");
  popup.focus();
};
const replaceButton = (popup, buttonToReplace) => {
  const actions2 = getActions();
  const loader = getLoader();
  if (!actions2 || !loader) {
    return;
  }
  if (!buttonToReplace && isVisible$1(getConfirmButton())) {
    buttonToReplace = getConfirmButton();
  }
  show(actions2);
  if (buttonToReplace) {
    hide$2(buttonToReplace);
    loader.setAttribute("data-button-to-replace", buttonToReplace.className);
    actions2.insertBefore(loader, buttonToReplace);
  }
  addClass([popup, actions2], swalClasses.loading);
};
const handleInputOptionsAndValue = (instance, params) => {
  if (params.input === "select" || params.input === "radio") {
    handleInputOptions(instance, params);
  } else if (["text", "email", "number", "tel", "textarea"].some((i) => i === params.input) && (hasToPromiseFn(params.inputValue) || isPromise$1(params.inputValue))) {
    showLoading(getConfirmButton());
    handleInputValue(instance, params);
  }
};
const getInputValue = (instance, innerParams) => {
  const input = instance.getInput();
  if (!input) {
    return null;
  }
  switch (innerParams.input) {
    case "checkbox":
      return getCheckboxValue(input);
    case "radio":
      return getRadioValue(input);
    case "file":
      return getFileValue(input);
    default:
      return innerParams.inputAutoTrim ? input.value.trim() : input.value;
  }
};
const getCheckboxValue = (input) => input.checked ? 1 : 0;
const getRadioValue = (input) => input.checked ? input.value : null;
const getFileValue = (input) => input.files && input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
const handleInputOptions = (instance, params) => {
  const popup = getPopup();
  if (!popup) {
    return;
  }
  const processInputOptions = (inputOptions) => {
    if (params.input === "select") {
      populateSelectOptions(popup, formatInputOptions(inputOptions), params);
    } else if (params.input === "radio") {
      populateRadioOptions(popup, formatInputOptions(inputOptions), params);
    }
  };
  if (hasToPromiseFn(params.inputOptions) || isPromise$1(params.inputOptions)) {
    showLoading(getConfirmButton());
    asPromise(params.inputOptions).then((inputOptions) => {
      instance.hideLoading();
      processInputOptions(inputOptions);
    });
  } else if (typeof params.inputOptions === "object") {
    processInputOptions(params.inputOptions);
  } else {
    error$1(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
  }
};
const handleInputValue = (instance, params) => {
  const input = instance.getInput();
  if (!input) {
    return;
  }
  hide$2(input);
  asPromise(params.inputValue).then((inputValue) => {
    input.value = params.input === "number" ? `${parseFloat(inputValue) || 0}` : `${inputValue}`;
    show(input);
    input.focus();
    instance.hideLoading();
  }).catch((err) => {
    error$1(`Error in inputValue promise: ${err}`);
    input.value = "";
    show(input);
    input.focus();
    instance.hideLoading();
  });
};
function populateSelectOptions(popup, inputOptions, params) {
  const select = getDirectChildByClass(popup, swalClasses.select);
  if (!select) {
    return;
  }
  const renderOption = (parent, optionLabel, optionValue) => {
    const option2 = document.createElement("option");
    option2.value = optionValue;
    setInnerHtml(option2, optionLabel);
    option2.selected = isSelected(optionValue, params.inputValue);
    parent.appendChild(option2);
  };
  inputOptions.forEach((inputOption) => {
    const optionValue = inputOption[0];
    const optionLabel = inputOption[1];
    if (Array.isArray(optionLabel)) {
      const optgroup = document.createElement("optgroup");
      optgroup.label = optionValue;
      optgroup.disabled = false;
      select.appendChild(optgroup);
      optionLabel.forEach((o2) => renderOption(optgroup, o2[1], o2[0]));
    } else {
      renderOption(select, optionLabel, optionValue);
    }
  });
  select.focus();
}
function populateRadioOptions(popup, inputOptions, params) {
  const radio = getDirectChildByClass(popup, swalClasses.radio);
  if (!radio) {
    return;
  }
  inputOptions.forEach((inputOption) => {
    const radioValue = inputOption[0];
    const radioLabel = inputOption[1];
    const radioInput = document.createElement("input");
    const radioLabelElement = document.createElement("label");
    radioInput.type = "radio";
    radioInput.name = swalClasses.radio;
    radioInput.value = radioValue;
    if (isSelected(radioValue, params.inputValue)) {
      radioInput.checked = true;
    }
    const label = document.createElement("span");
    setInnerHtml(label, radioLabel);
    label.className = swalClasses.label;
    radioLabelElement.appendChild(radioInput);
    radioLabelElement.appendChild(label);
    radio.appendChild(radioLabelElement);
  });
  const radios = radio.querySelectorAll("input");
  if (radios.length) {
    radios[0].focus();
  }
}
const formatInputOptions = (inputOptions) => {
  const result = [];
  if (inputOptions instanceof Map) {
    inputOptions.forEach((value, key) => {
      let valueFormatted = value;
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  } else {
    Object.keys(inputOptions).forEach((key) => {
      let valueFormatted = inputOptions[key];
      if (typeof valueFormatted === "object") {
        valueFormatted = formatInputOptions(valueFormatted);
      }
      result.push([key, valueFormatted]);
    });
  }
  return result;
};
const isSelected = (optionValue, inputValue) => {
  return !!inputValue && inputValue.toString() === optionValue.toString();
};
const handleConfirmButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.input) {
    handleConfirmOrDenyWithInput(instance, "confirm");
  } else {
    confirm(instance, true);
  }
};
const handleDenyButtonClick = (instance) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableButtons();
  if (innerParams.returnInputValueOnDeny) {
    handleConfirmOrDenyWithInput(instance, "deny");
  } else {
    deny(instance, false);
  }
};
const handleCancelButtonClick = (instance, dismissWith) => {
  instance.disableButtons();
  dismissWith(DismissReason.cancel);
};
const handleConfirmOrDenyWithInput = (instance, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  if (!innerParams.input) {
    error$1(`The "input" parameter is needed to be set when using returnInputValueOn${capitalizeFirstLetter(type)}`);
    return;
  }
  const input = instance.getInput();
  const inputValue = getInputValue(instance, innerParams);
  if (innerParams.inputValidator) {
    handleInputValidator(instance, inputValue, type);
  } else if (input && !input.checkValidity()) {
    instance.enableButtons();
    instance.showValidationMessage(innerParams.validationMessage || input.validationMessage);
  } else if (type === "deny") {
    deny(instance, inputValue);
  } else {
    confirm(instance, inputValue);
  }
};
const handleInputValidator = (instance, inputValue, type) => {
  const innerParams = privateProps.innerParams.get(instance);
  instance.disableInput();
  const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));
  validationPromise.then((validationMessage) => {
    instance.enableButtons();
    instance.enableInput();
    if (validationMessage) {
      instance.showValidationMessage(validationMessage);
    } else if (type === "deny") {
      deny(instance, inputValue);
    } else {
      confirm(instance, inputValue);
    }
  });
};
const deny = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnDeny) {
    showLoading(getDenyButton());
  }
  if (innerParams.preDeny) {
    instance.isAwaitingPromise = true;
    const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));
    preDenyPromise.then((preDenyValue) => {
      if (preDenyValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        instance.close({
          isDenied: true,
          value: typeof preDenyValue === "undefined" ? value : preDenyValue
        });
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    instance.close({
      isDenied: true,
      value
    });
  }
};
const succeedWith = (instance, value) => {
  instance.close({
    isConfirmed: true,
    value
  });
};
const rejectWith = (instance, error2) => {
  instance.rejectPromise(error2);
};
const confirm = (instance, value) => {
  const innerParams = privateProps.innerParams.get(instance || void 0);
  if (innerParams.showLoaderOnConfirm) {
    showLoading();
  }
  if (innerParams.preConfirm) {
    instance.resetValidationMessage();
    instance.isAwaitingPromise = true;
    const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));
    preConfirmPromise.then((preConfirmValue) => {
      if (isVisible$1(getValidationMessage()) || preConfirmValue === false) {
        instance.hideLoading();
        handleAwaitingPromise(instance);
      } else {
        succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
      }
    }).catch((error2) => rejectWith(instance || void 0, error2));
  } else {
    succeedWith(instance, value);
  }
};
function hideLoading() {
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    return;
  }
  const domCache = privateProps.domCache.get(this);
  hide$2(domCache.loader);
  if (isToast()) {
    if (innerParams.icon) {
      show(getIcon());
    }
  } else {
    showRelatedButton(domCache);
  }
  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
  domCache.popup.removeAttribute("aria-busy");
  domCache.popup.removeAttribute("data-loading");
  domCache.confirmButton.disabled = false;
  domCache.denyButton.disabled = false;
  domCache.cancelButton.disabled = false;
}
const showRelatedButton = (domCache) => {
  const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute("data-button-to-replace"));
  if (buttonToReplace.length) {
    show(buttonToReplace[0], "inline-block");
  } else if (allButtonsAreHidden()) {
    hide$2(domCache.actions);
  }
};
function getInput() {
  const innerParams = privateProps.innerParams.get(this);
  const domCache = privateProps.domCache.get(this);
  if (!domCache) {
    return null;
  }
  return getInput$1(domCache.popup, innerParams.input);
}
function setButtonsDisabled(instance, buttons, disabled) {
  const domCache = privateProps.domCache.get(instance);
  buttons.forEach((button) => {
    domCache[button].disabled = disabled;
  });
}
function setInputDisabled(input, disabled) {
  const popup = getPopup();
  if (!popup || !input) {
    return;
  }
  if (input.type === "radio") {
    const radios = popup.querySelectorAll(`[name="${swalClasses.radio}"]`);
    for (let i = 0; i < radios.length; i++) {
      radios[i].disabled = disabled;
    }
  } else {
    input.disabled = disabled;
  }
}
function enableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], false);
}
function disableButtons() {
  setButtonsDisabled(this, ["confirmButton", "denyButton", "cancelButton"], true);
}
function enableInput() {
  setInputDisabled(this.getInput(), false);
}
function disableInput() {
  setInputDisabled(this.getInput(), true);
}
function showValidationMessage(error2) {
  const domCache = privateProps.domCache.get(this);
  const params = privateProps.innerParams.get(this);
  setInnerHtml(domCache.validationMessage, error2);
  domCache.validationMessage.className = swalClasses["validation-message"];
  if (params.customClass && params.customClass.validationMessage) {
    addClass(domCache.validationMessage, params.customClass.validationMessage);
  }
  show(domCache.validationMessage);
  const input = this.getInput();
  if (input) {
    input.setAttribute("aria-invalid", "true");
    input.setAttribute("aria-describedby", swalClasses["validation-message"]);
    focusInput(input);
    addClass(input, swalClasses.inputerror);
  }
}
function resetValidationMessage() {
  const domCache = privateProps.domCache.get(this);
  if (domCache.validationMessage) {
    hide$2(domCache.validationMessage);
  }
  const input = this.getInput();
  if (input) {
    input.removeAttribute("aria-invalid");
    input.removeAttribute("aria-describedby");
    removeClass(input, swalClasses.inputerror);
  }
}
const defaultParams = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  icon: void 0,
  iconColor: void 0,
  iconHtml: void 0,
  template: void 0,
  toast: false,
  draggable: false,
  animation: true,
  theme: "light",
  showClass: {
    popup: "swal2-show",
    backdrop: "swal2-backdrop-show",
    icon: "swal2-icon-show"
  },
  hideClass: {
    popup: "swal2-hide",
    backdrop: "swal2-backdrop-hide",
    icon: "swal2-icon-hide"
  },
  customClass: {},
  target: "body",
  color: void 0,
  backdrop: true,
  heightAuto: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  stopKeydownPropagation: true,
  keydownListenerCapture: false,
  showConfirmButton: true,
  showDenyButton: false,
  showCancelButton: false,
  preConfirm: void 0,
  preDeny: void 0,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: void 0,
  denyButtonText: "No",
  denyButtonAriaLabel: "",
  denyButtonColor: void 0,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: void 0,
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusDeny: false,
  focusCancel: false,
  returnFocus: true,
  showCloseButton: false,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  loaderHtml: "",
  showLoaderOnConfirm: false,
  showLoaderOnDeny: false,
  imageUrl: void 0,
  imageWidth: void 0,
  imageHeight: void 0,
  imageAlt: "",
  timer: void 0,
  timerProgressBar: false,
  width: void 0,
  padding: void 0,
  background: void 0,
  input: void 0,
  inputPlaceholder: "",
  inputLabel: "",
  inputValue: "",
  inputOptions: {},
  inputAutoFocus: true,
  inputAutoTrim: true,
  inputAttributes: {},
  inputValidator: void 0,
  returnInputValueOnDeny: false,
  validationMessage: void 0,
  grow: false,
  position: "center",
  progressSteps: [],
  currentProgressStep: void 0,
  progressStepsDistance: void 0,
  willOpen: void 0,
  didOpen: void 0,
  didRender: void 0,
  willClose: void 0,
  didClose: void 0,
  didDestroy: void 0,
  scrollbarPadding: true
};
const updatableParams = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "draggable", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "theme", "willClose"];
const deprecatedParams = {
  allowEnterKey: void 0
};
const toastIncompatibleParams = ["allowOutsideClick", "allowEnterKey", "backdrop", "draggable", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"];
const isValidParameter = (paramName) => {
  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};
const isUpdatableParameter = (paramName) => {
  return updatableParams.indexOf(paramName) !== -1;
};
const isDeprecatedParameter = (paramName) => {
  return deprecatedParams[paramName];
};
const checkIfParamIsValid = (param) => {
  if (!isValidParameter(param)) {
    warn(`Unknown parameter "${param}"`);
  }
};
const checkIfToastParamIsValid = (param) => {
  if (toastIncompatibleParams.includes(param)) {
    warn(`The parameter "${param}" is incompatible with toasts`);
  }
};
const checkIfParamIsDeprecated = (param) => {
  const isDeprecated = isDeprecatedParameter(param);
  if (isDeprecated) {
    warnAboutDeprecation(param, isDeprecated);
  }
};
const showWarningsForParams = (params) => {
  if (params.backdrop === false && params.allowOutsideClick) {
    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  }
  if (params.theme && !["light", "dark", "auto", "borderless"].includes(params.theme)) {
    warn(`Invalid theme "${params.theme}". Expected "light", "dark", "auto", or "borderless"`);
  }
  for (const param in params) {
    checkIfParamIsValid(param);
    if (params.toast) {
      checkIfToastParamIsValid(param);
    }
    checkIfParamIsDeprecated(param);
  }
};
function update(params) {
  const container = getContainer();
  const popup = getPopup();
  const innerParams = privateProps.innerParams.get(this);
  if (!popup || hasClass(popup, innerParams.hideClass.popup)) {
    warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
    return;
  }
  const validUpdatableParams = filterValidParams(params);
  const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
  showWarningsForParams(updatedParams);
  container.dataset["swal2Theme"] = updatedParams.theme;
  render(this, updatedParams);
  privateProps.innerParams.set(this, updatedParams);
  Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, params),
      writable: false,
      enumerable: true
    }
  });
}
const filterValidParams = (params) => {
  const validUpdatableParams = {};
  Object.keys(params).forEach((param) => {
    if (isUpdatableParameter(param)) {
      validUpdatableParams[param] = params[param];
    } else {
      warn(`Invalid parameter to update: ${param}`);
    }
  });
  return validUpdatableParams;
};
function _destroy() {
  const domCache = privateProps.domCache.get(this);
  const innerParams = privateProps.innerParams.get(this);
  if (!innerParams) {
    disposeWeakMaps(this);
    return;
  }
  if (domCache.popup && globalState.swalCloseEventFinishedCallback) {
    globalState.swalCloseEventFinishedCallback();
    delete globalState.swalCloseEventFinishedCallback;
  }
  if (typeof innerParams.didDestroy === "function") {
    innerParams.didDestroy();
  }
  globalState.eventEmitter.emit("didDestroy");
  disposeSwal(this);
}
const disposeSwal = (instance) => {
  disposeWeakMaps(instance);
  delete instance.params;
  delete globalState.keydownHandler;
  delete globalState.keydownTarget;
  delete globalState.currentInstance;
};
const disposeWeakMaps = (instance) => {
  if (instance.isAwaitingPromise) {
    unsetWeakMaps(privateProps, instance);
    instance.isAwaitingPromise = true;
  } else {
    unsetWeakMaps(privateMethods, instance);
    unsetWeakMaps(privateProps, instance);
    delete instance.isAwaitingPromise;
    delete instance.disableButtons;
    delete instance.enableButtons;
    delete instance.getInput;
    delete instance.disableInput;
    delete instance.enableInput;
    delete instance.hideLoading;
    delete instance.disableLoading;
    delete instance.showValidationMessage;
    delete instance.resetValidationMessage;
    delete instance.close;
    delete instance.closePopup;
    delete instance.closeModal;
    delete instance.closeToast;
    delete instance.rejectPromise;
    delete instance.update;
    delete instance._destroy;
  }
};
const unsetWeakMaps = (obj, instance) => {
  for (const i in obj) {
    obj[i].delete(instance);
  }
};
var instanceMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  _destroy,
  close,
  closeModal: close,
  closePopup: close,
  closeToast: close,
  disableButtons,
  disableInput,
  disableLoading: hideLoading,
  enableButtons,
  enableInput,
  getInput,
  handleAwaitingPromise,
  hideLoading,
  rejectPromise,
  resetValidationMessage,
  showValidationMessage,
  update
});
const handlePopupClick = (innerParams, domCache, dismissWith) => {
  if (innerParams.toast) {
    handleToastClick(innerParams, domCache, dismissWith);
  } else {
    handleModalMousedown(domCache);
    handleContainerMousedown(domCache);
    handleModalClick(innerParams, domCache, dismissWith);
  }
};
const handleToastClick = (innerParams, domCache, dismissWith) => {
  domCache.popup.onclick = () => {
    if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {
      return;
    }
    dismissWith(DismissReason.close);
  };
};
const isAnyButtonShown = (innerParams) => {
  return !!(innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton);
};
let ignoreOutsideClick = false;
const handleModalMousedown = (domCache) => {
  domCache.popup.onmousedown = () => {
    domCache.container.onmouseup = function(e2) {
      domCache.container.onmouseup = () => {
      };
      if (e2.target === domCache.container) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleContainerMousedown = (domCache) => {
  domCache.container.onmousedown = (e2) => {
    if (e2.target === domCache.container) {
      e2.preventDefault();
    }
    domCache.popup.onmouseup = function(e3) {
      domCache.popup.onmouseup = () => {
      };
      if (e3.target === domCache.popup || e3.target instanceof HTMLElement && domCache.popup.contains(e3.target)) {
        ignoreOutsideClick = true;
      }
    };
  };
};
const handleModalClick = (innerParams, domCache, dismissWith) => {
  domCache.container.onclick = (e2) => {
    if (ignoreOutsideClick) {
      ignoreOutsideClick = false;
      return;
    }
    if (e2.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
      dismissWith(DismissReason.backdrop);
    }
  };
};
const isJqueryElement = (elem) => typeof elem === "object" && elem.jquery;
const isElement$2 = (elem) => elem instanceof Element || isJqueryElement(elem);
const argsToParams = (args) => {
  const params = {};
  if (typeof args[0] === "object" && !isElement$2(args[0])) {
    Object.assign(params, args[0]);
  } else {
    ["title", "html", "icon"].forEach((name2, index) => {
      const arg = args[index];
      if (typeof arg === "string" || isElement$2(arg)) {
        params[name2] = arg;
      } else if (arg !== void 0) {
        error$1(`Unexpected type of ${name2}! Expected "string" or "Element", got ${typeof arg}`);
      }
    });
  }
  return params;
};
function fire() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return new this(...args);
}
function mixin(mixinParams) {
  class MixinSwal extends this {
    _main(params, priorityMixinParams) {
      return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));
    }
  }
  return MixinSwal;
}
const getTimerLeft = () => {
  return globalState.timeout && globalState.timeout.getTimerLeft();
};
const stopTimer = () => {
  if (globalState.timeout) {
    stopTimerProgressBar();
    return globalState.timeout.stop();
  }
};
const resumeTimer = () => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.start();
    animateTimerProgressBar(remaining);
    return remaining;
  }
};
const toggleTimer = () => {
  const timer = globalState.timeout;
  return timer && (timer.running ? stopTimer() : resumeTimer());
};
const increaseTimer = (ms) => {
  if (globalState.timeout) {
    const remaining = globalState.timeout.increase(ms);
    animateTimerProgressBar(remaining, true);
    return remaining;
  }
};
const isTimerRunning = () => {
  return !!(globalState.timeout && globalState.timeout.isRunning());
};
let bodyClickListenerAdded = false;
const clickHandlers = {};
function bindClickHandler() {
  let attr2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "data-swal-template";
  clickHandlers[attr2] = this;
  if (!bodyClickListenerAdded) {
    document.body.addEventListener("click", bodyClickListener);
    bodyClickListenerAdded = true;
  }
}
const bodyClickListener = (event) => {
  for (let el = event.target; el && el !== document; el = el.parentNode) {
    for (const attr2 in clickHandlers) {
      const template = el.getAttribute(attr2);
      if (template) {
        clickHandlers[attr2].fire({
          template
        });
        return;
      }
    }
  }
};
class EventEmitter {
  constructor() {
    this.events = {};
  }
  /**
   * @param {string} eventName
   * @returns {EventHandlers}
   */
  _getHandlersByEventName(eventName) {
    if (typeof this.events[eventName] === "undefined") {
      this.events[eventName] = [];
    }
    return this.events[eventName];
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  on(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    if (!currentHandlers.includes(eventHandler)) {
      currentHandlers.push(eventHandler);
    }
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  once(eventName, eventHandler) {
    var _this = this;
    const onceFn = function() {
      _this.removeListener(eventName, onceFn);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      eventHandler.apply(_this, args);
    };
    this.on(eventName, onceFn);
  }
  /**
   * @param {string} eventName
   * @param {Array} args
   */
  emit(eventName) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    this._getHandlersByEventName(eventName).forEach(
      /**
       * @param {EventHandler} eventHandler
       */
      (eventHandler) => {
        try {
          eventHandler.apply(this, args);
        } catch (error2) {
          console.error(error2);
        }
      }
    );
  }
  /**
   * @param {string} eventName
   * @param {EventHandler} eventHandler
   */
  removeListener(eventName, eventHandler) {
    const currentHandlers = this._getHandlersByEventName(eventName);
    const index = currentHandlers.indexOf(eventHandler);
    if (index > -1) {
      currentHandlers.splice(index, 1);
    }
  }
  /**
   * @param {string} eventName
   */
  removeAllListeners(eventName) {
    if (this.events[eventName] !== void 0) {
      this.events[eventName].length = 0;
    }
  }
  reset() {
    this.events = {};
  }
}
globalState.eventEmitter = new EventEmitter();
const on$1 = (eventName, eventHandler) => {
  globalState.eventEmitter.on(eventName, eventHandler);
};
const once = (eventName, eventHandler) => {
  globalState.eventEmitter.once(eventName, eventHandler);
};
const off = (eventName, eventHandler) => {
  if (!eventName) {
    globalState.eventEmitter.reset();
    return;
  }
  if (eventHandler) {
    globalState.eventEmitter.removeListener(eventName, eventHandler);
  } else {
    globalState.eventEmitter.removeAllListeners(eventName);
  }
};
var staticMethods = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  argsToParams,
  bindClickHandler,
  clickCancel,
  clickConfirm,
  clickDeny,
  enableLoading: showLoading,
  fire,
  getActions,
  getCancelButton,
  getCloseButton,
  getConfirmButton,
  getContainer,
  getDenyButton,
  getFocusableElements,
  getFooter,
  getHtmlContainer,
  getIcon,
  getIconContent,
  getImage,
  getInputLabel,
  getLoader,
  getPopup,
  getProgressSteps,
  getTimerLeft,
  getTimerProgressBar,
  getTitle,
  getValidationMessage,
  increaseTimer,
  isDeprecatedParameter,
  isLoading,
  isTimerRunning,
  isUpdatableParameter,
  isValidParameter,
  isVisible: isVisible$2,
  mixin,
  off,
  on: on$1,
  once,
  resumeTimer,
  showLoading,
  stopTimer,
  toggleTimer
});
class Timer {
  /**
   * @param {Function} callback
   * @param {number} delay
   */
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.running = false;
    this.start();
  }
  /**
   * @returns {number}
   */
  start() {
    if (!this.running) {
      this.running = true;
      this.started = /* @__PURE__ */ new Date();
      this.id = setTimeout(this.callback, this.remaining);
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  stop() {
    if (this.started && this.running) {
      this.running = false;
      clearTimeout(this.id);
      this.remaining -= (/* @__PURE__ */ new Date()).getTime() - this.started.getTime();
    }
    return this.remaining;
  }
  /**
   * @param {number} n
   * @returns {number}
   */
  increase(n2) {
    const running = this.running;
    if (running) {
      this.stop();
    }
    this.remaining += n2;
    if (running) {
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {number}
   */
  getTimerLeft() {
    if (this.running) {
      this.stop();
      this.start();
    }
    return this.remaining;
  }
  /**
   * @returns {boolean}
   */
  isRunning() {
    return this.running;
  }
}
const swalStringParams = ["swal-title", "swal-html", "swal-footer"];
const getTemplateParams = (params) => {
  const template = typeof params.template === "string" ? (
    /** @type {HTMLTemplateElement} */
    document.querySelector(params.template)
  ) : params.template;
  if (!template) {
    return {};
  }
  const templateContent = template.content;
  showWarningsForElements(templateContent);
  const result = Object.assign(getSwalParams(templateContent), getSwalFunctionParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));
  return result;
};
const getSwalParams = (templateContent) => {
  const result = {};
  const swalParams = Array.from(templateContent.querySelectorAll("swal-param"));
  swalParams.forEach((param) => {
    showWarningsForAttributes(param, ["name", "value"]);
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    if (typeof defaultParams[paramName] === "boolean") {
      result[paramName] = value !== "false";
    } else if (typeof defaultParams[paramName] === "object") {
      result[paramName] = JSON.parse(value);
    } else {
      result[paramName] = value;
    }
  });
  return result;
};
const getSwalFunctionParams = (templateContent) => {
  const result = {};
  const swalFunctions = Array.from(templateContent.querySelectorAll("swal-function-param"));
  swalFunctions.forEach((param) => {
    const paramName = (
      /** @type {keyof SweetAlertOptions} */
      param.getAttribute("name")
    );
    const value = param.getAttribute("value");
    if (!paramName || !value) {
      return;
    }
    result[paramName] = new Function(`return ${value}`)();
  });
  return result;
};
const getSwalButtons = (templateContent) => {
  const result = {};
  const swalButtons = Array.from(templateContent.querySelectorAll("swal-button"));
  swalButtons.forEach((button) => {
    showWarningsForAttributes(button, ["type", "color", "aria-label"]);
    const type = button.getAttribute("type");
    if (!type || !["confirm", "cancel", "deny"].includes(type)) {
      return;
    }
    result[`${type}ButtonText`] = button.innerHTML;
    result[`show${capitalizeFirstLetter(type)}Button`] = true;
    if (button.hasAttribute("color")) {
      result[`${type}ButtonColor`] = button.getAttribute("color");
    }
    if (button.hasAttribute("aria-label")) {
      result[`${type}ButtonAriaLabel`] = button.getAttribute("aria-label");
    }
  });
  return result;
};
const getSwalImage = (templateContent) => {
  const result = {};
  const image = templateContent.querySelector("swal-image");
  if (image) {
    showWarningsForAttributes(image, ["src", "width", "height", "alt"]);
    if (image.hasAttribute("src")) {
      result.imageUrl = image.getAttribute("src") || void 0;
    }
    if (image.hasAttribute("width")) {
      result.imageWidth = image.getAttribute("width") || void 0;
    }
    if (image.hasAttribute("height")) {
      result.imageHeight = image.getAttribute("height") || void 0;
    }
    if (image.hasAttribute("alt")) {
      result.imageAlt = image.getAttribute("alt") || void 0;
    }
  }
  return result;
};
const getSwalIcon = (templateContent) => {
  const result = {};
  const icon = templateContent.querySelector("swal-icon");
  if (icon) {
    showWarningsForAttributes(icon, ["type", "color"]);
    if (icon.hasAttribute("type")) {
      result.icon = icon.getAttribute("type");
    }
    if (icon.hasAttribute("color")) {
      result.iconColor = icon.getAttribute("color");
    }
    result.iconHtml = icon.innerHTML;
  }
  return result;
};
const getSwalInput = (templateContent) => {
  const result = {};
  const input = templateContent.querySelector("swal-input");
  if (input) {
    showWarningsForAttributes(input, ["type", "label", "placeholder", "value"]);
    result.input = input.getAttribute("type") || "text";
    if (input.hasAttribute("label")) {
      result.inputLabel = input.getAttribute("label");
    }
    if (input.hasAttribute("placeholder")) {
      result.inputPlaceholder = input.getAttribute("placeholder");
    }
    if (input.hasAttribute("value")) {
      result.inputValue = input.getAttribute("value");
    }
  }
  const inputOptions = Array.from(templateContent.querySelectorAll("swal-input-option"));
  if (inputOptions.length) {
    result.inputOptions = {};
    inputOptions.forEach((option2) => {
      showWarningsForAttributes(option2, ["value"]);
      const optionValue = option2.getAttribute("value");
      if (!optionValue) {
        return;
      }
      const optionName = option2.innerHTML;
      result.inputOptions[optionValue] = optionName;
    });
  }
  return result;
};
const getSwalStringParams = (templateContent, paramNames) => {
  const result = {};
  for (const i in paramNames) {
    const paramName = paramNames[i];
    const tag = templateContent.querySelector(paramName);
    if (tag) {
      showWarningsForAttributes(tag, []);
      result[paramName.replace(/^swal-/, "")] = tag.innerHTML.trim();
    }
  }
  return result;
};
const showWarningsForElements = (templateContent) => {
  const allowedElements = swalStringParams.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
  Array.from(templateContent.children).forEach((el) => {
    const tagName = el.tagName.toLowerCase();
    if (!allowedElements.includes(tagName)) {
      warn(`Unrecognized element <${tagName}>`);
    }
  });
};
const showWarningsForAttributes = (el, allowedAttributes) => {
  Array.from(el.attributes).forEach((attribute) => {
    if (allowedAttributes.indexOf(attribute.name) === -1) {
      warn([`Unrecognized attribute "${attribute.name}" on <${el.tagName.toLowerCase()}>.`, `${allowedAttributes.length ? `Allowed attributes are: ${allowedAttributes.join(", ")}` : "To set the value, use HTML within the element."}`]);
    }
  });
};
const SHOW_CLASS_TIMEOUT = 10;
const openPopup = (params) => {
  const container = getContainer();
  const popup = getPopup();
  if (typeof params.willOpen === "function") {
    params.willOpen(popup);
  }
  globalState.eventEmitter.emit("willOpen", popup);
  const bodyStyles = window.getComputedStyle(document.body);
  const initialBodyOverflow = bodyStyles.overflowY;
  addClasses$3(container, popup, params);
  setTimeout(() => {
    setScrollingVisibility(container, popup);
  }, SHOW_CLASS_TIMEOUT);
  if (isModal()) {
    fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);
    setAriaHidden();
  }
  if (!isToast() && !globalState.previousActiveElement) {
    globalState.previousActiveElement = document.activeElement;
  }
  if (typeof params.didOpen === "function") {
    setTimeout(() => params.didOpen(popup));
  }
  globalState.eventEmitter.emit("didOpen", popup);
  removeClass(container, swalClasses["no-transition"]);
};
const swalOpenAnimationFinished = (event) => {
  const popup = getPopup();
  if (event.target !== popup) {
    return;
  }
  const container = getContainer();
  popup.removeEventListener("animationend", swalOpenAnimationFinished);
  popup.removeEventListener("transitionend", swalOpenAnimationFinished);
  container.style.overflowY = "auto";
};
const setScrollingVisibility = (container, popup) => {
  if (hasCssAnimation(popup)) {
    container.style.overflowY = "hidden";
    popup.addEventListener("animationend", swalOpenAnimationFinished);
    popup.addEventListener("transitionend", swalOpenAnimationFinished);
  } else {
    container.style.overflowY = "auto";
  }
};
const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {
  iOSfix();
  if (scrollbarPadding && initialBodyOverflow !== "hidden") {
    replaceScrollbarWithPadding(initialBodyOverflow);
  }
  setTimeout(() => {
    container.scrollTop = 0;
  });
};
const addClasses$3 = (container, popup, params) => {
  addClass(container, params.showClass.backdrop);
  if (params.animation) {
    popup.style.setProperty("opacity", "0", "important");
    show(popup, "grid");
    setTimeout(() => {
      addClass(popup, params.showClass.popup);
      popup.style.removeProperty("opacity");
    }, SHOW_CLASS_TIMEOUT);
  } else {
    show(popup, "grid");
  }
  addClass([document.documentElement, document.body], swalClasses.shown);
  if (params.heightAuto && params.backdrop && !params.toast) {
    addClass([document.documentElement, document.body], swalClasses["height-auto"]);
  }
};
var defaultInputValidators = {
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  email: (string, validationMessage) => {
    return /^[a-zA-Z0-9.+_'-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]+$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
  },
  /**
   * @param {string} string
   * @param {string} [validationMessage]
   * @returns {Promise<string | void>}
   */
  url: (string, validationMessage) => {
    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
  }
};
function setDefaultInputValidators(params) {
  if (params.inputValidator) {
    return;
  }
  if (params.input === "email") {
    params.inputValidator = defaultInputValidators["email"];
  }
  if (params.input === "url") {
    params.inputValidator = defaultInputValidators["url"];
  }
}
function validateCustomTargetElement(params) {
  if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = "body";
  }
}
function setParameters(params) {
  setDefaultInputValidators(params);
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
  }
  validateCustomTargetElement(params);
  if (typeof params.title === "string") {
    params.title = params.title.split("\n").join("<br />");
  }
  init$3(params);
}
let currentInstance;
var _promise = /* @__PURE__ */ new WeakMap();
class SweetAlert {
  /**
   * @param {...any} args
   * @this {SweetAlert}
   */
  constructor() {
    _classPrivateFieldInitSpec(this, _promise, void 0);
    if (typeof window === "undefined") {
      return;
    }
    currentInstance = this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const outerParams = Object.freeze(this.constructor.argsToParams(args));
    this.params = outerParams;
    this.isAwaitingPromise = false;
    _classPrivateFieldSet2(_promise, this, this._main(currentInstance.params));
  }
  _main(userParams) {
    let mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    showWarningsForParams(Object.assign({}, mixinParams, userParams));
    if (globalState.currentInstance) {
      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(globalState.currentInstance);
      const {
        isAwaitingPromise
      } = globalState.currentInstance;
      globalState.currentInstance._destroy();
      if (!isAwaitingPromise) {
        swalPromiseResolve({
          isDismissed: true
        });
      }
      if (isModal()) {
        unsetAriaHidden();
      }
    }
    globalState.currentInstance = currentInstance;
    const innerParams = prepareParams(userParams, mixinParams);
    setParameters(innerParams);
    Object.freeze(innerParams);
    if (globalState.timeout) {
      globalState.timeout.stop();
      delete globalState.timeout;
    }
    clearTimeout(globalState.restoreFocusTimeout);
    const domCache = populateDomCache(currentInstance);
    render(currentInstance, innerParams);
    privateProps.innerParams.set(currentInstance, innerParams);
    return swalPromise(currentInstance, domCache, innerParams);
  }
  // `catch` cannot be the name of a module export, so we define our thenable methods here instead
  then(onFulfilled) {
    return _classPrivateFieldGet2(_promise, this).then(onFulfilled);
  }
  finally(onFinally) {
    return _classPrivateFieldGet2(_promise, this).finally(onFinally);
  }
}
const swalPromise = (instance, domCache, innerParams) => {
  return new Promise((resolve, reject) => {
    const dismissWith = (dismiss) => {
      instance.close({
        isDismissed: true,
        dismiss
      });
    };
    privateMethods.swalPromiseResolve.set(instance, resolve);
    privateMethods.swalPromiseReject.set(instance, reject);
    domCache.confirmButton.onclick = () => {
      handleConfirmButtonClick(instance);
    };
    domCache.denyButton.onclick = () => {
      handleDenyButtonClick(instance);
    };
    domCache.cancelButton.onclick = () => {
      handleCancelButtonClick(instance, dismissWith);
    };
    domCache.closeButton.onclick = () => {
      dismissWith(DismissReason.close);
    };
    handlePopupClick(innerParams, domCache, dismissWith);
    addKeydownHandler(globalState, innerParams, dismissWith);
    handleInputOptionsAndValue(instance, innerParams);
    openPopup(innerParams);
    setupTimer(globalState, innerParams, dismissWith);
    initFocus(domCache, innerParams);
    setTimeout(() => {
      domCache.container.scrollTop = 0;
    });
  });
};
const prepareParams = (userParams, mixinParams) => {
  const templateParams = getTemplateParams(userParams);
  const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);
  params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);
  params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);
  if (params.animation === false) {
    params.showClass = {
      backdrop: "swal2-noanimation"
    };
    params.hideClass = {};
  }
  return params;
};
const populateDomCache = (instance) => {
  const domCache = {
    popup: getPopup(),
    container: getContainer(),
    actions: getActions(),
    confirmButton: getConfirmButton(),
    denyButton: getDenyButton(),
    cancelButton: getCancelButton(),
    loader: getLoader(),
    closeButton: getCloseButton(),
    validationMessage: getValidationMessage(),
    progressSteps: getProgressSteps()
  };
  privateProps.domCache.set(instance, domCache);
  return domCache;
};
const setupTimer = (globalState2, innerParams, dismissWith) => {
  const timerProgressBar = getTimerProgressBar();
  hide$2(timerProgressBar);
  if (innerParams.timer) {
    globalState2.timeout = new Timer(() => {
      dismissWith("timer");
      delete globalState2.timeout;
    }, innerParams.timer);
    if (innerParams.timerProgressBar) {
      show(timerProgressBar);
      applyCustomClass(timerProgressBar, innerParams, "timerProgressBar");
      setTimeout(() => {
        if (globalState2.timeout && globalState2.timeout.running) {
          animateTimerProgressBar(innerParams.timer);
        }
      });
    }
  }
};
const initFocus = (domCache, innerParams) => {
  if (innerParams.toast) {
    return;
  }
  if (!callIfFunction(innerParams.allowEnterKey)) {
    warnAboutDeprecation("allowEnterKey");
    blurActiveElement();
    return;
  }
  if (focusAutofocus(domCache)) {
    return;
  }
  if (focusButton(domCache, innerParams)) {
    return;
  }
  setFocus(-1, 1);
};
const focusAutofocus = (domCache) => {
  const autofocusElements = Array.from(domCache.popup.querySelectorAll("[autofocus]"));
  for (const autofocusElement of autofocusElements) {
    if (autofocusElement instanceof HTMLElement && isVisible$1(autofocusElement)) {
      autofocusElement.focus();
      return true;
    }
  }
  return false;
};
const focusButton = (domCache, innerParams) => {
  if (innerParams.focusDeny && isVisible$1(domCache.denyButton)) {
    domCache.denyButton.focus();
    return true;
  }
  if (innerParams.focusCancel && isVisible$1(domCache.cancelButton)) {
    domCache.cancelButton.focus();
    return true;
  }
  if (innerParams.focusConfirm && isVisible$1(domCache.confirmButton)) {
    domCache.confirmButton.focus();
    return true;
  }
  return false;
};
const blurActiveElement = () => {
  if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === "function") {
    document.activeElement.blur();
  }
};
if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|by|xn--p1ai)$/)) {
  const now = /* @__PURE__ */ new Date();
  const initiationDate = localStorage.getItem("swal-initiation");
  if (!initiationDate) {
    localStorage.setItem("swal-initiation", `${now}`);
  } else if ((now.getTime() - Date.parse(initiationDate)) / (1e3 * 60 * 60 * 24) > 3) {
    setTimeout(() => {
      document.body.style.pointerEvents = "none";
      const ukrainianAnthem = document.createElement("audio");
      ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
      ukrainianAnthem.loop = true;
      document.body.appendChild(ukrainianAnthem);
      setTimeout(() => {
        ukrainianAnthem.play().catch(() => {
        });
      }, 2500);
    }, 500);
  }
}
SweetAlert.prototype.disableButtons = disableButtons;
SweetAlert.prototype.enableButtons = enableButtons;
SweetAlert.prototype.getInput = getInput;
SweetAlert.prototype.disableInput = disableInput;
SweetAlert.prototype.enableInput = enableInput;
SweetAlert.prototype.hideLoading = hideLoading;
SweetAlert.prototype.disableLoading = hideLoading;
SweetAlert.prototype.showValidationMessage = showValidationMessage;
SweetAlert.prototype.resetValidationMessage = resetValidationMessage;
SweetAlert.prototype.close = close;
SweetAlert.prototype.closePopup = close;
SweetAlert.prototype.closeModal = close;
SweetAlert.prototype.closeToast = close;
SweetAlert.prototype.rejectPromise = rejectPromise;
SweetAlert.prototype.update = update;
SweetAlert.prototype._destroy = _destroy;
Object.assign(SweetAlert, staticMethods);
Object.keys(instanceMethods).forEach((key) => {
  SweetAlert[key] = function() {
    if (currentInstance && currentInstance[key]) {
      return currentInstance[key](...arguments);
    }
    return null;
  };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = "11.17.2";
const Swal$1 = SweetAlert;
Swal$1.default = Swal$1;
"undefined" != typeof document && function(e2, t2) {
  var n2 = e2.createElement("style");
  if (e2.getElementsByTagName("head")[0].appendChild(n2), n2.styleSheet)
    n2.styleSheet.disabled || (n2.styleSheet.cssText = t2);
  else
    try {
      n2.innerHTML = t2;
    } catch (e3) {
      n2.innerText = t2;
    }
}(document, ':root{--swal2-container-padding: 0.625em;--swal2-backdrop: rgba(0, 0, 0, 0.4);--swal2-width: 32em;--swal2-padding: 0 0 1.25em;--swal2-border: none;--swal2-border-radius: 0.3125rem;--swal2-background: white;--swal2-color: #545454;--swal2-footer-border-color: #eee;--swal2-show-animation: swal2-show 0.3s;--swal2-hide-animation: swal2-hide 0.15s forwards;--swal2-input-background: transparent;--swal2-progress-step-background: #add8e6;--swal2-validation-message-background: #f0f0f0;--swal2-validation-message-color: #666;--swal2-close-button-position: initial;--swal2-close-button-inset: auto;--swal2-close-button-font-size: 2.5em;--swal2-close-button-color: #ccc}[data-swal2-theme=dark]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}@media(prefers-color-scheme: dark){[data-swal2-theme=auto]{--swal2-dark-theme-black: #19191a;--swal2-dark-theme-white: #e1e1e1;--swal2-background: var(--swal2-dark-theme-black);--swal2-color: var(--swal2-dark-theme-white);--swal2-footer-border-color: #555;--swal2-input-background: color-mix(in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10%);--swal2-validation-message-background: color-mix( in srgb, var(--swal2-dark-theme-black), var(--swal2-dark-theme-white) 10% );--swal2-validation-message-color: var(--swal2-dark-theme-white)}}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow:hidden}body.swal2-height-auto{height:auto !important}body.swal2-no-backdrop .swal2-container{background-color:rgba(0,0,0,0) !important;pointer-events:none}body.swal2-no-backdrop .swal2-container .swal2-popup{pointer-events:all}body.swal2-no-backdrop .swal2-container .swal2-modal{box-shadow:0 0 10px var(--swal2-backdrop)}body.swal2-toast-shown .swal2-container{box-sizing:border-box;width:360px;max-width:100%;background-color:rgba(0,0,0,0);pointer-events:none}body.swal2-toast-shown .swal2-container.swal2-top{inset:0 auto auto 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-top-end,body.swal2-toast-shown .swal2-container.swal2-top-right{inset:0 0 auto auto}body.swal2-toast-shown .swal2-container.swal2-top-start,body.swal2-toast-shown .swal2-container.swal2-top-left{inset:0 auto auto 0}body.swal2-toast-shown .swal2-container.swal2-center-start,body.swal2-toast-shown .swal2-container.swal2-center-left{inset:50% auto auto 0;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-center{inset:50% auto auto 50%;transform:translate(-50%, -50%)}body.swal2-toast-shown .swal2-container.swal2-center-end,body.swal2-toast-shown .swal2-container.swal2-center-right{inset:50% 0 auto auto;transform:translateY(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-start,body.swal2-toast-shown .swal2-container.swal2-bottom-left{inset:auto auto 0 0}body.swal2-toast-shown .swal2-container.swal2-bottom{inset:auto auto 0 50%;transform:translateX(-50%)}body.swal2-toast-shown .swal2-container.swal2-bottom-end,body.swal2-toast-shown .swal2-container.swal2-bottom-right{inset:auto 0 0 auto}@media print{body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown){overflow-y:scroll !important}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown)>[aria-hidden=true]{display:none}body.swal2-shown:not(.swal2-no-backdrop,.swal2-toast-shown) .swal2-container{position:static !important}}div:where(.swal2-container){display:grid;position:fixed;z-index:1060;inset:0;box-sizing:border-box;grid-template-areas:"top-start     top            top-end" "center-start  center         center-end" "bottom-start  bottom-center  bottom-end";grid-template-rows:minmax(min-content, auto) minmax(min-content, auto) minmax(min-content, auto);height:100%;padding:var(--swal2-container-padding);overflow-x:hidden;transition:background-color .1s;-webkit-overflow-scrolling:touch}div:where(.swal2-container).swal2-backdrop-show,div:where(.swal2-container).swal2-noanimation{background:var(--swal2-backdrop)}div:where(.swal2-container).swal2-backdrop-hide{background:rgba(0,0,0,0) !important}div:where(.swal2-container).swal2-top-start,div:where(.swal2-container).swal2-center-start,div:where(.swal2-container).swal2-bottom-start{grid-template-columns:minmax(0, 1fr) auto auto}div:where(.swal2-container).swal2-top,div:where(.swal2-container).swal2-center,div:where(.swal2-container).swal2-bottom{grid-template-columns:auto minmax(0, 1fr) auto}div:where(.swal2-container).swal2-top-end,div:where(.swal2-container).swal2-center-end,div:where(.swal2-container).swal2-bottom-end{grid-template-columns:auto auto minmax(0, 1fr)}div:where(.swal2-container).swal2-top-start>.swal2-popup{align-self:start}div:where(.swal2-container).swal2-top>.swal2-popup{grid-column:2;place-self:start center}div:where(.swal2-container).swal2-top-end>.swal2-popup,div:where(.swal2-container).swal2-top-right>.swal2-popup{grid-column:3;place-self:start end}div:where(.swal2-container).swal2-center-start>.swal2-popup,div:where(.swal2-container).swal2-center-left>.swal2-popup{grid-row:2;align-self:center}div:where(.swal2-container).swal2-center>.swal2-popup{grid-column:2;grid-row:2;place-self:center center}div:where(.swal2-container).swal2-center-end>.swal2-popup,div:where(.swal2-container).swal2-center-right>.swal2-popup{grid-column:3;grid-row:2;place-self:center end}div:where(.swal2-container).swal2-bottom-start>.swal2-popup,div:where(.swal2-container).swal2-bottom-left>.swal2-popup{grid-column:1;grid-row:3;align-self:end}div:where(.swal2-container).swal2-bottom>.swal2-popup{grid-column:2;grid-row:3;place-self:end center}div:where(.swal2-container).swal2-bottom-end>.swal2-popup,div:where(.swal2-container).swal2-bottom-right>.swal2-popup{grid-column:3;grid-row:3;place-self:end end}div:where(.swal2-container).swal2-grow-row>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-column:1/4;width:100%}div:where(.swal2-container).swal2-grow-column>.swal2-popup,div:where(.swal2-container).swal2-grow-fullscreen>.swal2-popup{grid-row:1/4;align-self:stretch}div:where(.swal2-container).swal2-no-transition{transition:none !important}div:where(.swal2-container) div:where(.swal2-popup){display:none;position:relative;box-sizing:border-box;grid-template-columns:minmax(0, 100%);width:var(--swal2-width);max-width:100%;padding:var(--swal2-padding);border:var(--swal2-border);border-radius:var(--swal2-border-radius);background:var(--swal2-background);color:var(--swal2-color);font-family:inherit;font-size:1rem}div:where(.swal2-container) div:where(.swal2-popup):focus{outline:none}div:where(.swal2-container) div:where(.swal2-popup).swal2-loading{overflow-y:hidden}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable{cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-draggable div:where(.swal2-icon){cursor:grab}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging{cursor:grabbing}div:where(.swal2-container) div:where(.swal2-popup).swal2-dragging div:where(.swal2-icon){cursor:grabbing}div:where(.swal2-container) h2:where(.swal2-title){position:relative;max-width:100%;margin:0;padding:.8em 1em 0;color:inherit;font-size:1.875em;font-weight:600;text-align:center;text-transform:none;word-wrap:break-word;cursor:initial}div:where(.swal2-container) div:where(.swal2-actions){display:flex;z-index:1;box-sizing:border-box;flex-wrap:wrap;align-items:center;justify-content:center;width:auto;margin:1.25em auto 0;padding:0}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled[disabled]{opacity:.4}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:hover{background-image:linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.1))}div:where(.swal2-container) div:where(.swal2-actions):not(.swal2-loading) .swal2-styled:active{background-image:linear-gradient(rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.2))}div:where(.swal2-container) div:where(.swal2-loader){display:none;align-items:center;justify-content:center;width:2.2em;height:2.2em;margin:0 1.875em;animation:swal2-rotate-loading 1.5s linear 0s infinite normal;border-width:.25em;border-style:solid;border-radius:100%;border-color:#2778c4 rgba(0,0,0,0) #2778c4 rgba(0,0,0,0)}div:where(.swal2-container) button:where(.swal2-styled){margin:.3125em;padding:.625em 1.1em;transition:box-shadow .1s;box-shadow:0 0 0 3px rgba(0,0,0,0);font-weight:500}div:where(.swal2-container) button:where(.swal2-styled):not([disabled]){cursor:pointer}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm){border:0;border-radius:.25em;background:initial;background-color:#7066e0;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-confirm):focus-visible{box-shadow:0 0 0 3px rgba(112,102,224,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny){border:0;border-radius:.25em;background:initial;background-color:#dc3741;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-deny):focus-visible{box-shadow:0 0 0 3px rgba(220,55,65,.5)}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel){border:0;border-radius:.25em;background:initial;background-color:#6e7881;color:#fff;font-size:1em}div:where(.swal2-container) button:where(.swal2-styled):where(.swal2-cancel):focus-visible{box-shadow:0 0 0 3px rgba(110,120,129,.5)}div:where(.swal2-container) button:where(.swal2-styled).swal2-default-outline:focus-visible{box-shadow:0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-styled):focus-visible{outline:none}div:where(.swal2-container) button:where(.swal2-styled)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-footer){margin:1em 0 0;padding:1em 1em 0;border-top:1px solid var(--swal2-footer-border-color);color:inherit;font-size:1em;text-align:center;cursor:initial}div:where(.swal2-container) .swal2-timer-progress-bar-container{position:absolute;right:0;bottom:0;left:0;grid-column:auto !important;overflow:hidden;border-bottom-right-radius:var(--swal2-border-radius);border-bottom-left-radius:var(--swal2-border-radius)}div:where(.swal2-container) div:where(.swal2-timer-progress-bar){width:100%;height:.25em;background:rgba(0,0,0,.2)}div:where(.swal2-container) img:where(.swal2-image){max-width:100%;margin:2em auto 1em;cursor:initial}div:where(.swal2-container) button:where(.swal2-close){position:var(--swal2-close-button-position);inset:var(--swal2-close-button-inset);z-index:2;align-items:center;justify-content:center;width:1.2em;height:1.2em;margin-top:0;margin-right:0;margin-bottom:-1.2em;padding:0;overflow:hidden;transition:color .1s,box-shadow .1s;border:none;border-radius:var(--swal2-border-radius);background:rgba(0,0,0,0);color:var(--swal2-close-button-color);font-family:monospace;font-size:var(--swal2-close-button-font-size);cursor:pointer;justify-self:end}div:where(.swal2-container) button:where(.swal2-close):hover{transform:none;background:rgba(0,0,0,0);color:#f27474}div:where(.swal2-container) button:where(.swal2-close):focus-visible{outline:none;box-shadow:inset 0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) button:where(.swal2-close)::-moz-focus-inner{border:0}div:where(.swal2-container) div:where(.swal2-html-container){z-index:1;justify-content:center;margin:0;padding:1em 1.6em .3em;overflow:auto;color:inherit;font-size:1.125em;font-weight:normal;line-height:normal;text-align:center;word-wrap:break-word;word-break:break-word;cursor:initial}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea),div:where(.swal2-container) select:where(.swal2-select),div:where(.swal2-container) div:where(.swal2-radio),div:where(.swal2-container) label:where(.swal2-checkbox){margin:1em 2em 3px}div:where(.swal2-container) input:where(.swal2-input),div:where(.swal2-container) input:where(.swal2-file),div:where(.swal2-container) textarea:where(.swal2-textarea){box-sizing:border-box;width:auto;transition:border-color .1s,box-shadow .1s;border:1px solid #d9d9d9;border-radius:.1875em;background:var(--swal2-input-background);box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(0,0,0,0);color:inherit;font-size:1.125em}div:where(.swal2-container) input:where(.swal2-input).swal2-inputerror,div:where(.swal2-container) input:where(.swal2-file).swal2-inputerror,div:where(.swal2-container) textarea:where(.swal2-textarea).swal2-inputerror{border-color:#f27474 !important;box-shadow:0 0 2px #f27474 !important}div:where(.swal2-container) input:where(.swal2-input):focus,div:where(.swal2-container) input:where(.swal2-file):focus,div:where(.swal2-container) textarea:where(.swal2-textarea):focus{border:1px solid #b4dbed;outline:none;box-shadow:inset 0 1px 1px rgba(0,0,0,.06),0 0 0 3px rgba(100,150,200,.5)}div:where(.swal2-container) input:where(.swal2-input)::placeholder,div:where(.swal2-container) input:where(.swal2-file)::placeholder,div:where(.swal2-container) textarea:where(.swal2-textarea)::placeholder{color:#ccc}div:where(.swal2-container) .swal2-range{margin:1em 2em 3px;background:var(--swal2-background)}div:where(.swal2-container) .swal2-range input{width:80%}div:where(.swal2-container) .swal2-range output{width:20%;color:inherit;font-weight:600;text-align:center}div:where(.swal2-container) .swal2-range input,div:where(.swal2-container) .swal2-range output{height:2.625em;padding:0;font-size:1.125em;line-height:2.625em}div:where(.swal2-container) .swal2-input{height:2.625em;padding:0 .75em}div:where(.swal2-container) .swal2-file{width:75%;margin-right:auto;margin-left:auto;background:var(--swal2-input-background);font-size:1.125em}div:where(.swal2-container) .swal2-textarea{height:6.75em;padding:.75em}div:where(.swal2-container) .swal2-select{min-width:50%;max-width:100%;padding:.375em .625em;background:var(--swal2-input-background);color:inherit;font-size:1.125em}div:where(.swal2-container) .swal2-radio,div:where(.swal2-container) .swal2-checkbox{align-items:center;justify-content:center;background:var(--swal2-background);color:inherit}div:where(.swal2-container) .swal2-radio label,div:where(.swal2-container) .swal2-checkbox label{margin:0 .6em;font-size:1.125em}div:where(.swal2-container) .swal2-radio input,div:where(.swal2-container) .swal2-checkbox input{flex-shrink:0;margin:0 .4em}div:where(.swal2-container) label:where(.swal2-input-label){display:flex;justify-content:center;margin:1em auto 0}div:where(.swal2-container) div:where(.swal2-validation-message){align-items:center;justify-content:center;margin:1em 0 0;padding:.625em;overflow:hidden;background:var(--swal2-validation-message-background);color:var(--swal2-validation-message-color);font-size:1em;font-weight:300}div:where(.swal2-container) div:where(.swal2-validation-message)::before{content:"!";display:inline-block;width:1.5em;min-width:1.5em;height:1.5em;margin:0 .625em;border-radius:50%;background-color:#f27474;color:#fff;font-weight:600;line-height:1.5em;text-align:center}div:where(.swal2-container) .swal2-progress-steps{flex-wrap:wrap;align-items:center;max-width:100%;margin:1.25em auto;padding:0;background:rgba(0,0,0,0);font-weight:600}div:where(.swal2-container) .swal2-progress-steps li{display:inline-block;position:relative}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step{z-index:20;flex-shrink:0;width:2em;height:2em;border-radius:2em;background:#2778c4;color:#fff;line-height:2em;text-align:center}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step{background:#2778c4}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step{background:var(--swal2-progress-step-background);color:#fff}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step.swal2-active-progress-step~.swal2-progress-step-line{background:var(--swal2-progress-step-background)}div:where(.swal2-container) .swal2-progress-steps .swal2-progress-step-line{z-index:10;flex-shrink:0;width:2.5em;height:.4em;margin:0 -1px;background:#2778c4}div:where(.swal2-icon){position:relative;box-sizing:content-box;justify-content:center;width:5em;height:5em;margin:2.5em auto .6em;border:.25em solid rgba(0,0,0,0);border-radius:50%;border-color:#000;font-family:inherit;line-height:5em;cursor:default;user-select:none}div:where(.swal2-icon) .swal2-icon-content{display:flex;align-items:center;font-size:3.75em}div:where(.swal2-icon).swal2-error{border-color:#f27474;color:#f27474}div:where(.swal2-icon).swal2-error .swal2-x-mark{position:relative;flex-grow:1}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line]{display:block;position:absolute;top:2.3125em;width:2.9375em;height:.3125em;border-radius:.125em;background-color:#f27474}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=left]{left:1.0625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-error [class^=swal2-x-mark-line][class$=right]{right:1em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-error.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-error.swal2-icon-show .swal2-x-mark{animation:swal2-animate-error-x-mark .5s}div:where(.swal2-icon).swal2-warning{border-color:#f8bb86;color:#f8bb86}div:where(.swal2-icon).swal2-warning.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-warning.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .5s}div:where(.swal2-icon).swal2-info{border-color:#3fc3ee;color:#3fc3ee}div:where(.swal2-icon).swal2-info.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-info.swal2-icon-show .swal2-icon-content{animation:swal2-animate-i-mark .8s}div:where(.swal2-icon).swal2-question{border-color:#87adbd;color:#87adbd}div:where(.swal2-icon).swal2-question.swal2-icon-show{animation:swal2-animate-error-icon .5s}div:where(.swal2-icon).swal2-question.swal2-icon-show .swal2-icon-content{animation:swal2-animate-question-mark .8s}div:where(.swal2-icon).swal2-success{border-color:#a5dc86;color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line]{position:absolute;width:3.75em;height:7.5em;border-radius:50%}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.4375em;left:-2.0635em;transform:rotate(-45deg);transform-origin:3.75em 3.75em;border-radius:7.5em 0 0 7.5em}div:where(.swal2-icon).swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.6875em;left:1.875em;transform:rotate(-45deg);transform-origin:0 3.75em;border-radius:0 7.5em 7.5em 0}div:where(.swal2-icon).swal2-success .swal2-success-ring{position:absolute;z-index:2;top:-0.25em;left:-0.25em;box-sizing:content-box;width:100%;height:100%;border:.25em solid rgba(165,220,134,.3);border-radius:50%}div:where(.swal2-icon).swal2-success .swal2-success-fix{position:absolute;z-index:1;top:.5em;left:1.625em;width:.4375em;height:5.625em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line]{display:block;position:absolute;z-index:2;height:.3125em;border-radius:.125em;background-color:#a5dc86}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=tip]{top:2.875em;left:.8125em;width:1.5625em;transform:rotate(45deg)}div:where(.swal2-icon).swal2-success [class^=swal2-success-line][class$=long]{top:2.375em;right:.5em;width:2.9375em;transform:rotate(-45deg)}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-animate-success-line-tip .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-animate-success-line-long .75s}div:where(.swal2-icon).swal2-success.swal2-icon-show .swal2-success-circular-line-right{animation:swal2-rotate-success-circular-line 4.25s ease-in}[class^=swal2]{-webkit-tap-highlight-color:rgba(0,0,0,0)}.swal2-show{animation:var(--swal2-show-animation)}.swal2-hide{animation:var(--swal2-hide-animation)}.swal2-noanimation{transition:none}.swal2-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.swal2-rtl .swal2-close{margin-right:initial;margin-left:0}.swal2-rtl .swal2-timer-progress-bar{right:0;left:auto}.swal2-toast{box-sizing:border-box;grid-column:1/4 !important;grid-row:1/4 !important;grid-template-columns:min-content auto min-content;padding:1em;overflow-y:hidden;background:var(--swal2-background);box-shadow:0 0 1px rgba(0,0,0,.075),0 1px 2px rgba(0,0,0,.075),1px 2px 4px rgba(0,0,0,.075),1px 3px 8px rgba(0,0,0,.075),2px 4px 16px rgba(0,0,0,.075);pointer-events:all}.swal2-toast>*{grid-column:2}.swal2-toast h2:where(.swal2-title){margin:.5em 1em;padding:0;font-size:1em;text-align:initial}.swal2-toast .swal2-loading{justify-content:center}.swal2-toast input:where(.swal2-input){height:2em;margin:.5em;font-size:1em}.swal2-toast .swal2-validation-message{font-size:1em}.swal2-toast div:where(.swal2-footer){margin:.5em 0 0;padding:.5em 0 0;font-size:.8em}.swal2-toast button:where(.swal2-close){grid-column:3/3;grid-row:1/99;align-self:center;width:.8em;height:.8em;margin:0;font-size:2em}.swal2-toast div:where(.swal2-html-container){margin:.5em 1em;padding:0;overflow:initial;font-size:1em;text-align:initial}.swal2-toast div:where(.swal2-html-container):empty{padding:0}.swal2-toast .swal2-loader{grid-column:1;grid-row:1/99;align-self:center;width:2em;height:2em;margin:.25em}.swal2-toast .swal2-icon{grid-column:1;grid-row:1/99;align-self:center;width:2em;min-width:2em;height:2em;margin:0 .5em 0 0}.swal2-toast .swal2-icon .swal2-icon-content{display:flex;align-items:center;font-size:1.8em;font-weight:bold}.swal2-toast .swal2-icon.swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line]{top:.875em;width:1.375em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=left]{left:.3125em}.swal2-toast .swal2-icon.swal2-error [class^=swal2-x-mark-line][class$=right]{right:.3125em}.swal2-toast div:where(.swal2-actions){justify-content:flex-start;height:auto;margin:0;margin-top:.5em;padding:0 .5em}.swal2-toast button:where(.swal2-styled){margin:.25em .5em;padding:.4em .6em;font-size:1em}.swal2-toast .swal2-success{border-color:#a5dc86}.swal2-toast .swal2-success [class^=swal2-success-circular-line]{position:absolute;width:1.6em;height:3em;border-radius:50%}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=left]{top:-0.8em;left:-0.5em;transform:rotate(-45deg);transform-origin:2em 2em;border-radius:4em 0 0 4em}.swal2-toast .swal2-success [class^=swal2-success-circular-line][class$=right]{top:-0.25em;left:.9375em;transform-origin:0 1.5em;border-radius:0 4em 4em 0}.swal2-toast .swal2-success .swal2-success-ring{width:2em;height:2em}.swal2-toast .swal2-success .swal2-success-fix{top:0;left:.4375em;width:.4375em;height:2.6875em}.swal2-toast .swal2-success [class^=swal2-success-line]{height:.3125em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=tip]{top:1.125em;left:.1875em;width:.75em}.swal2-toast .swal2-success [class^=swal2-success-line][class$=long]{top:.9375em;right:.1875em;width:1.375em}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-tip{animation:swal2-toast-animate-success-line-tip .75s}.swal2-toast .swal2-success.swal2-icon-show .swal2-success-line-long{animation:swal2-toast-animate-success-line-long .75s}.swal2-toast.swal2-show{animation:swal2-toast-show .5s}.swal2-toast.swal2-hide{animation:swal2-toast-hide .1s forwards}@keyframes swal2-show{0%{transform:scale(0.7)}45%{transform:scale(1.05)}80%{transform:scale(0.95)}100%{transform:scale(1)}}@keyframes swal2-hide{0%{transform:scale(1);opacity:1}100%{transform:scale(0.5);opacity:0}}@keyframes swal2-animate-success-line-tip{0%{top:1.1875em;left:.0625em;width:0}54%{top:1.0625em;left:.125em;width:0}70%{top:2.1875em;left:-0.375em;width:3.125em}84%{top:3em;left:1.3125em;width:1.0625em}100%{top:2.8125em;left:.8125em;width:1.5625em}}@keyframes swal2-animate-success-line-long{0%{top:3.375em;right:2.875em;width:0}65%{top:3.375em;right:2.875em;width:0}84%{top:2.1875em;right:0;width:3.4375em}100%{top:2.375em;right:.5em;width:2.9375em}}@keyframes swal2-rotate-success-circular-line{0%{transform:rotate(-45deg)}5%{transform:rotate(-45deg)}12%{transform:rotate(-405deg)}100%{transform:rotate(-405deg)}}@keyframes swal2-animate-error-x-mark{0%{margin-top:1.625em;transform:scale(0.4);opacity:0}50%{margin-top:1.625em;transform:scale(0.4);opacity:0}80%{margin-top:-0.375em;transform:scale(1.15)}100%{margin-top:0;transform:scale(1);opacity:1}}@keyframes swal2-animate-error-icon{0%{transform:rotateX(100deg);opacity:0}100%{transform:rotateX(0deg);opacity:1}}@keyframes swal2-rotate-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}@keyframes swal2-animate-question-mark{0%{transform:rotateY(-360deg)}100%{transform:rotateY(0)}}@keyframes swal2-animate-i-mark{0%{transform:rotateZ(45deg);opacity:0}25%{transform:rotateZ(-25deg);opacity:.4}50%{transform:rotateZ(15deg);opacity:.8}75%{transform:rotateZ(-5deg);opacity:1}100%{transform:rotateX(0);opacity:1}}@keyframes swal2-toast-show{0%{transform:translateY(-0.625em) rotateZ(2deg)}33%{transform:translateY(0) rotateZ(-2deg)}66%{transform:translateY(0.3125em) rotateZ(2deg)}100%{transform:translateY(0) rotateZ(0deg)}}@keyframes swal2-toast-hide{100%{transform:rotateZ(1deg);opacity:0}}@keyframes swal2-toast-animate-success-line-tip{0%{top:.5625em;left:.0625em;width:0}54%{top:.125em;left:.125em;width:0}70%{top:.625em;left:-0.25em;width:1.625em}84%{top:1.0625em;left:.75em;width:.5em}100%{top:1.125em;left:.1875em;width:.75em}}@keyframes swal2-toast-animate-success-line-long{0%{top:1.625em;right:1.375em;width:0}65%{top:1.25em;right:.9375em;width:0}84%{top:.9375em;right:0;width:1.125em}100%{top:.9375em;right:.1875em;width:1.375em}}');
/*!
 * ApexCharts v4.5.0
 * (c) 2018-2025 ApexCharts
 * Released under the MIT License.
 */
function t$1(t2, e2) {
  (null == e2 || e2 > t2.length) && (e2 = t2.length);
  for (var i = 0, a2 = Array(e2); i < e2; i++)
    a2[i] = t2[i];
  return a2;
}
function e(t2) {
  if (void 0 === t2)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t2;
}
function i$1(t2, e2) {
  if (!(t2 instanceof e2))
    throw new TypeError("Cannot call a class as a function");
}
function a(t2, e2) {
  for (var i = 0; i < e2.length; i++) {
    var a2 = e2[i];
    a2.enumerable = a2.enumerable || false, a2.configurable = true, "value" in a2 && (a2.writable = true), Object.defineProperty(t2, x(a2.key), a2);
  }
}
function s(t2, e2, i) {
  return e2 && a(t2.prototype, e2), i && a(t2, i), Object.defineProperty(t2, "prototype", { writable: false }), t2;
}
function r(t2, e2) {
  var i = "undefined" != typeof Symbol && t2[Symbol.iterator] || t2["@@iterator"];
  if (!i) {
    if (Array.isArray(t2) || (i = m(t2)) || e2 && t2 && "number" == typeof t2.length) {
      i && (t2 = i);
      var a2 = 0, s2 = function() {
      };
      return { s: s2, n: function() {
        return a2 >= t2.length ? { done: true } : { done: false, value: t2[a2++] };
      }, e: function(t3) {
        throw t3;
      }, f: s2 };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var r2, n2 = true, o2 = false;
  return { s: function() {
    i = i.call(t2);
  }, n: function() {
    var t3 = i.next();
    return n2 = t3.done, t3;
  }, e: function(t3) {
    o2 = true, r2 = t3;
  }, f: function() {
    try {
      n2 || null == i.return || i.return();
    } finally {
      if (o2)
        throw r2;
    }
  } };
}
function n(t2) {
  var i = c();
  return function() {
    var a2, s2 = l(t2);
    if (i) {
      var r2 = l(this).constructor;
      a2 = Reflect.construct(s2, arguments, r2);
    } else
      a2 = s2.apply(this, arguments);
    return function(t3, i2) {
      if (i2 && ("object" == typeof i2 || "function" == typeof i2))
        return i2;
      if (void 0 !== i2)
        throw new TypeError("Derived constructors may only return object or undefined");
      return e(t3);
    }(this, a2);
  };
}
function o(t2, e2, i) {
  return (e2 = x(e2)) in t2 ? Object.defineProperty(t2, e2, { value: i, enumerable: true, configurable: true, writable: true }) : t2[e2] = i, t2;
}
function l(t2) {
  return l = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t3) {
    return t3.__proto__ || Object.getPrototypeOf(t3);
  }, l(t2);
}
function h(t2, e2) {
  if ("function" != typeof e2 && null !== e2)
    throw new TypeError("Super expression must either be null or a function");
  t2.prototype = Object.create(e2 && e2.prototype, { constructor: { value: t2, writable: true, configurable: true } }), Object.defineProperty(t2, "prototype", { writable: false }), e2 && g(t2, e2);
}
function c() {
  try {
    var t2 = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch (t3) {
  }
  return (c = function() {
    return !!t2;
  })();
}
function d(t2, e2) {
  var i = Object.keys(t2);
  if (Object.getOwnPropertySymbols) {
    var a2 = Object.getOwnPropertySymbols(t2);
    e2 && (a2 = a2.filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t2, e3).enumerable;
    })), i.push.apply(i, a2);
  }
  return i;
}
function u(t2) {
  for (var e2 = 1; e2 < arguments.length; e2++) {
    var i = null != arguments[e2] ? arguments[e2] : {};
    e2 % 2 ? d(Object(i), true).forEach(function(e3) {
      o(t2, e3, i[e3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t2, Object.getOwnPropertyDescriptors(i)) : d(Object(i)).forEach(function(e3) {
      Object.defineProperty(t2, e3, Object.getOwnPropertyDescriptor(i, e3));
    });
  }
  return t2;
}
function g(t2, e2) {
  return g = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t3, e3) {
    return t3.__proto__ = e3, t3;
  }, g(t2, e2);
}
function p(t2, e2) {
  return function(t3) {
    if (Array.isArray(t3))
      return t3;
  }(t2) || function(t3, e3) {
    var i = null == t3 ? null : "undefined" != typeof Symbol && t3[Symbol.iterator] || t3["@@iterator"];
    if (null != i) {
      var a2, s2, r2, n2, o2 = [], l2 = true, h2 = false;
      try {
        if (r2 = (i = i.call(t3)).next, 0 === e3) {
          if (Object(i) !== i)
            return;
          l2 = false;
        } else
          for (; !(l2 = (a2 = r2.call(i)).done) && (o2.push(a2.value), o2.length !== e3); l2 = true)
            ;
      } catch (t4) {
        h2 = true, s2 = t4;
      } finally {
        try {
          if (!l2 && null != i.return && (n2 = i.return(), Object(n2) !== n2))
            return;
        } finally {
          if (h2)
            throw s2;
        }
      }
      return o2;
    }
  }(t2, e2) || m(t2, e2) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function f(e2) {
  return function(e3) {
    if (Array.isArray(e3))
      return t$1(e3);
  }(e2) || function(t2) {
    if ("undefined" != typeof Symbol && null != t2[Symbol.iterator] || null != t2["@@iterator"])
      return Array.from(t2);
  }(e2) || m(e2) || function() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }();
}
function x(t2) {
  var e2 = function(t3, e3) {
    if ("object" != typeof t3 || !t3)
      return t3;
    var i = t3[Symbol.toPrimitive];
    if (void 0 !== i) {
      var a2 = i.call(t3, e3 || "default");
      if ("object" != typeof a2)
        return a2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === e3 ? String : Number)(t3);
  }(t2, "string");
  return "symbol" == typeof e2 ? e2 : e2 + "";
}
function b(t2) {
  return b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
    return typeof t3;
  } : function(t3) {
    return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
  }, b(t2);
}
function m(e2, i) {
  if (e2) {
    if ("string" == typeof e2)
      return t$1(e2, i);
    var a2 = {}.toString.call(e2).slice(8, -1);
    return "Object" === a2 && e2.constructor && (a2 = e2.constructor.name), "Map" === a2 || "Set" === a2 ? Array.from(e2) : "Arguments" === a2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a2) ? t$1(e2, i) : void 0;
  }
}
var v = function() {
  function t2() {
    i$1(this, t2);
  }
  return s(t2, [{ key: "shadeRGBColor", value: function(t3, e2) {
    var i = e2.split(","), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = parseInt(i[0].slice(4), 10), n2 = parseInt(i[1], 10), o2 = parseInt(i[2], 10);
    return "rgb(" + (Math.round((a2 - r2) * s2) + r2) + "," + (Math.round((a2 - n2) * s2) + n2) + "," + (Math.round((a2 - o2) * s2) + o2) + ")";
  } }, { key: "shadeHexColor", value: function(t3, e2) {
    var i = parseInt(e2.slice(1), 16), a2 = t3 < 0 ? 0 : 255, s2 = t3 < 0 ? -1 * t3 : t3, r2 = i >> 16, n2 = i >> 8 & 255, o2 = 255 & i;
    return "#" + (16777216 + 65536 * (Math.round((a2 - r2) * s2) + r2) + 256 * (Math.round((a2 - n2) * s2) + n2) + (Math.round((a2 - o2) * s2) + o2)).toString(16).slice(1);
  } }, { key: "shadeColor", value: function(e2, i) {
    return t2.isColorHex(i) ? this.shadeHexColor(e2, i) : this.shadeRGBColor(e2, i);
  } }], [{ key: "bind", value: function(t3, e2) {
    return function() {
      return t3.apply(e2, arguments);
    };
  } }, { key: "isObject", value: function(t3) {
    return t3 && "object" === b(t3) && !Array.isArray(t3) && null != t3;
  } }, { key: "is", value: function(t3, e2) {
    return Object.prototype.toString.call(e2) === "[object " + t3 + "]";
  } }, { key: "listToArray", value: function(t3) {
    var e2, i = [];
    for (e2 = 0; e2 < t3.length; e2++)
      i[e2] = t3[e2];
    return i;
  } }, { key: "extend", value: function(t3, e2) {
    var i = this;
    "function" != typeof Object.assign && (Object.assign = function(t4) {
      if (null == t4)
        throw new TypeError("Cannot convert undefined or null to object");
      for (var e3 = Object(t4), i2 = 1; i2 < arguments.length; i2++) {
        var a3 = arguments[i2];
        if (null != a3)
          for (var s2 in a3)
            a3.hasOwnProperty(s2) && (e3[s2] = a3[s2]);
      }
      return e3;
    });
    var a2 = Object.assign({}, t3);
    return this.isObject(t3) && this.isObject(e2) && Object.keys(e2).forEach(function(s2) {
      i.isObject(e2[s2]) && s2 in t3 ? a2[s2] = i.extend(t3[s2], e2[s2]) : Object.assign(a2, o({}, s2, e2[s2]));
    }), a2;
  } }, { key: "extendArray", value: function(e2, i) {
    var a2 = [];
    return e2.map(function(e3) {
      a2.push(t2.extend(i, e3));
    }), e2 = a2;
  } }, { key: "monthMod", value: function(t3) {
    return t3 % 12;
  } }, { key: "clone", value: function(t3) {
    var e2, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /* @__PURE__ */ new WeakMap();
    if (null === t3 || "object" !== b(t3))
      return t3;
    if (i.has(t3))
      return i.get(t3);
    if (Array.isArray(t3)) {
      e2 = [], i.set(t3, e2);
      for (var a2 = 0; a2 < t3.length; a2++)
        e2[a2] = this.clone(t3[a2], i);
    } else if (t3 instanceof Date)
      e2 = new Date(t3.getTime());
    else
      for (var s2 in e2 = {}, i.set(t3, e2), t3)
        t3.hasOwnProperty(s2) && (e2[s2] = this.clone(t3[s2], i));
    return e2;
  } }, { key: "log10", value: function(t3) {
    return Math.log(t3) / Math.LN10;
  } }, { key: "roundToBase10", value: function(t3) {
    return Math.pow(10, Math.floor(Math.log10(t3)));
  } }, { key: "roundToBase", value: function(t3, e2) {
    return Math.pow(e2, Math.floor(Math.log(t3) / Math.log(e2)));
  } }, { key: "parseNumber", value: function(t3) {
    return null === t3 ? t3 : parseFloat(t3);
  } }, { key: "stripNumber", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 2;
    return Number.isInteger(t3) ? t3 : parseFloat(t3.toPrecision(e2));
  } }, { key: "randomId", value: function() {
    return (Math.random() + 1).toString(36).substring(4);
  } }, { key: "noExponents", value: function(t3) {
    return t3.toString().includes("e") ? Math.round(t3) : t3;
  } }, { key: "elementExists", value: function(t3) {
    return !(!t3 || !t3.isConnected);
  } }, { key: "getDimensions", value: function(t3) {
    var e2 = getComputedStyle(t3, null), i = t3.clientHeight, a2 = t3.clientWidth;
    return i -= parseFloat(e2.paddingTop) + parseFloat(e2.paddingBottom), [a2 -= parseFloat(e2.paddingLeft) + parseFloat(e2.paddingRight), i];
  } }, { key: "getBoundingClientRect", value: function(t3) {
    var e2 = t3.getBoundingClientRect();
    return { top: e2.top, right: e2.right, bottom: e2.bottom, left: e2.left, width: t3.clientWidth, height: t3.clientHeight, x: e2.left, y: e2.top };
  } }, { key: "getLargestStringFromArr", value: function(t3) {
    return t3.reduce(function(t4, e2) {
      return Array.isArray(e2) && (e2 = e2.reduce(function(t5, e3) {
        return t5.length > e3.length ? t5 : e3;
      })), t4.length > e2.length ? t4 : e2;
    }, 0);
  } }, { key: "hexToRgba", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0.6;
    "#" !== t3.substring(0, 1) && (t3 = "#999999");
    var i = t3.replace("#", "");
    i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
    for (var a2 = 0; a2 < i.length; a2++)
      i[a2] = parseInt(1 === i[a2].length ? i[a2] + i[a2] : i[a2], 16);
    return void 0 !== e2 && i.push(e2), "rgba(" + i.join(",") + ")";
  } }, { key: "getOpacityFromRGBA", value: function(t3) {
    return parseFloat(t3.replace(/^.*,(.+)\)/, "$1"));
  } }, { key: "rgb2hex", value: function(t3) {
    return (t3 = t3.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t3.length ? "#" + ("0" + parseInt(t3[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t3[3], 10).toString(16)).slice(-2) : "";
  } }, { key: "isColorHex", value: function(t3) {
    return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t3);
  } }, { key: "getPolygonPos", value: function(t3, e2) {
    for (var i = [], a2 = 2 * Math.PI / e2, s2 = 0; s2 < e2; s2++) {
      var r2 = {};
      r2.x = t3 * Math.sin(s2 * a2), r2.y = -t3 * Math.cos(s2 * a2), i.push(r2);
    }
    return i;
  } }, { key: "polarToCartesian", value: function(t3, e2, i, a2) {
    var s2 = (a2 - 90) * Math.PI / 180;
    return { x: t3 + i * Math.cos(s2), y: e2 + i * Math.sin(s2) };
  } }, { key: "escapeString", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x", i = t3.toString().slice();
    return i = i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e2);
  } }, { key: "negToZero", value: function(t3) {
    return t3 < 0 ? 0 : t3;
  } }, { key: "moveIndexInArray", value: function(t3, e2, i) {
    if (i >= t3.length)
      for (var a2 = i - t3.length + 1; a2--; )
        t3.push(void 0);
    return t3.splice(i, 0, t3.splice(e2, 1)[0]), t3;
  } }, { key: "extractNumber", value: function(t3) {
    return parseFloat(t3.replace(/[^\d.]*/g, ""));
  } }, { key: "findAncestor", value: function(t3, e2) {
    for (; (t3 = t3.parentElement) && !t3.classList.contains(e2); )
      ;
    return t3;
  } }, { key: "setELstyles", value: function(t3, e2) {
    for (var i in e2)
      e2.hasOwnProperty(i) && (t3.style.key = e2[i]);
  } }, { key: "preciseAddition", value: function(t3, e2) {
    var i = (String(t3).split(".")[1] || "").length, a2 = (String(e2).split(".")[1] || "").length, s2 = Math.pow(10, Math.max(i, a2));
    return (Math.round(t3 * s2) + Math.round(e2 * s2)) / s2;
  } }, { key: "isNumber", value: function(t3) {
    return !isNaN(t3) && parseFloat(Number(t3)) === t3 && !isNaN(parseInt(t3, 10));
  } }, { key: "isFloat", value: function(t3) {
    return Number(t3) === t3 && t3 % 1 != 0;
  } }, { key: "isMsEdge", value: function() {
    var t3 = window.navigator.userAgent, e2 = t3.indexOf("Edge/");
    return e2 > 0 && parseInt(t3.substring(e2 + 5, t3.indexOf(".", e2)), 10);
  } }, { key: "getGCD", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i - Math.floor(Math.log10(Math.max(t3, e2))));
    for (t3 = Math.round(Math.abs(t3) * a2), e2 = Math.round(Math.abs(e2) * a2); e2; ) {
      var s2 = e2;
      e2 = t3 % e2, t3 = s2;
    }
    return t3 / a2;
  } }, { key: "getPrimeFactors", value: function(t3) {
    for (var e2 = [], i = 2; t3 >= 2; )
      t3 % i == 0 ? (e2.push(i), t3 /= i) : i++;
    return e2;
  } }, { key: "mod", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 7, a2 = Math.pow(10, i - Math.floor(Math.log10(Math.max(t3, e2))));
    return (t3 = Math.round(Math.abs(t3) * a2)) % (e2 = Math.round(Math.abs(e2) * a2)) / a2;
  } }]), t2;
}(), y = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "animateLine", value: function(t3, e2, i, a2) {
    t3.attr(e2).animate(a2).attr(i);
  } }, { key: "animateMarker", value: function(t3, e2, i, a2) {
    t3.attr({ opacity: 0 }).animate(e2).attr({ opacity: 1 }).after(function() {
      a2();
    });
  } }, { key: "animateRect", value: function(t3, e2, i, a2, s2) {
    t3.attr(e2).animate(a2).attr(i).after(function() {
      return s2();
    });
  } }, { key: "animatePathsGradually", value: function(t3) {
    var e2 = t3.el, i = t3.realIndex, a2 = t3.j, s2 = t3.fill, r2 = t3.pathFrom, n2 = t3.pathTo, o2 = t3.speed, l2 = t3.delay, h2 = this.w, c2 = 0;
    h2.config.chart.animations.animateGradually.enabled && (c2 = h2.config.chart.animations.animateGradually.delay), h2.config.chart.animations.dynamicAnimation.enabled && h2.globals.dataChanged && "bar" !== h2.config.chart.type && (c2 = 0), this.morphSVG(e2, i, a2, "line" !== h2.config.chart.type || h2.globals.comboCharts ? s2 : "stroke", r2, n2, o2, l2 * c2);
  } }, { key: "showDelayedElements", value: function() {
    this.w.globals.delayedElements.forEach(function(t3) {
      var e2 = t3.el;
      e2.classList.remove("apexcharts-element-hidden"), e2.classList.add("apexcharts-hidden-element-shown");
    });
  } }, { key: "animationCompleted", value: function(t3) {
    var e2 = this.w;
    e2.globals.animationEnded || (e2.globals.animationEnded = true, this.showDelayedElements(), "function" == typeof e2.config.chart.events.animationEnd && e2.config.chart.events.animationEnd(this.ctx, { el: t3, w: e2 }));
  } }, { key: "morphSVG", value: function(t3, e2, i, a2, s2, r2, n2, o2) {
    var l2 = this, h2 = this.w;
    s2 || (s2 = t3.attr("pathFrom")), r2 || (r2 = t3.attr("pathTo"));
    var c2 = function(t4) {
      return "radar" === h2.config.chart.type && (n2 = 1), "M 0 ".concat(h2.globals.gridHeight);
    };
    (!s2 || s2.indexOf("undefined") > -1 || s2.indexOf("NaN") > -1) && (s2 = c2()), (!r2.trim() || r2.indexOf("undefined") > -1 || r2.indexOf("NaN") > -1) && (r2 = c2()), h2.globals.shouldAnimate || (n2 = 1), t3.plot(s2).animate(1, o2).plot(s2).animate(n2, o2).plot(r2).after(function() {
      v.isNumber(i) ? i === h2.globals.series[h2.globals.maxValsInArrayIndex].length - 2 && h2.globals.shouldAnimate && l2.animationCompleted(t3) : "none" !== a2 && h2.globals.shouldAnimate && (!h2.globals.comboCharts && e2 === h2.globals.series.length - 1 || h2.globals.comboCharts) && l2.animationCompleted(t3), l2.showDelayedElements();
    });
  } }]), t2;
}();
const w = {}, k = [];
function A(t2, e2) {
  if (Array.isArray(t2))
    for (const i of t2)
      A(i, e2);
  else if ("object" != typeof t2)
    S(Object.getOwnPropertyNames(e2)), w[t2] = Object.assign(w[t2] || {}, e2);
  else
    for (const e3 in t2)
      A(e3, t2[e3]);
}
function C(t2) {
  return w[t2] || {};
}
function S(t2) {
  k.push(...t2);
}
function L(t2, e2) {
  let i;
  const a2 = t2.length, s2 = [];
  for (i = 0; i < a2; i++)
    s2.push(e2(t2[i]));
  return s2;
}
function M(t2) {
  return t2 % 360 * Math.PI / 180;
}
function P(t2) {
  return t2.charAt(0).toUpperCase() + t2.slice(1);
}
function I(t2, e2, i, a2) {
  return null != e2 && null != i || (a2 = a2 || t2.bbox(), null == e2 ? e2 = a2.width / a2.height * i : null == i && (i = a2.height / a2.width * e2)), { width: e2, height: i };
}
function T(t2, e2) {
  const i = t2.origin;
  let a2 = null != t2.ox ? t2.ox : null != t2.originX ? t2.originX : "center", s2 = null != t2.oy ? t2.oy : null != t2.originY ? t2.originY : "center";
  null != i && ([a2, s2] = Array.isArray(i) ? i : "object" == typeof i ? [i.x, i.y] : [i, i]);
  const r2 = "string" == typeof a2, n2 = "string" == typeof s2;
  if (r2 || n2) {
    const { height: t3, width: i2, x: o2, y: l2 } = e2.bbox();
    r2 && (a2 = a2.includes("left") ? o2 : a2.includes("right") ? o2 + i2 : o2 + i2 / 2), n2 && (s2 = s2.includes("top") ? l2 : s2.includes("bottom") ? l2 + t3 : l2 + t3 / 2);
  }
  return [a2, s2];
}
const z = /* @__PURE__ */ new Set(["desc", "metadata", "title"]), X = (t2) => z.has(t2.nodeName), R = (t2, e2, i = {}) => {
  const a2 = { ...e2 };
  for (const t3 in a2)
    a2[t3].valueOf() === i[t3] && delete a2[t3];
  Object.keys(a2).length ? t2.node.setAttribute("data-svgjs", JSON.stringify(a2)) : (t2.node.removeAttribute("data-svgjs"), t2.node.removeAttribute("svgjs:data"));
}, E = "http://www.w3.org/2000/svg", Y = "http://www.w3.org/2000/xmlns/", H = "http://www.w3.org/1999/xlink", O = { window: "undefined" == typeof window ? null : window, document: "undefined" == typeof document ? null : document };
function F() {
  return O.window;
}
let D = class {
};
const _ = {}, N = "___SYMBOL___ROOT___";
function W(t2, e2 = E) {
  return O.document.createElementNS(e2, t2);
}
function B(t2, e2 = false) {
  if (t2 instanceof D)
    return t2;
  if ("object" == typeof t2)
    return U(t2);
  if (null == t2)
    return new _[N]();
  if ("string" == typeof t2 && "<" !== t2.charAt(0))
    return U(O.document.querySelector(t2));
  const i = e2 ? O.document.createElement("div") : W("svg");
  return i.innerHTML = t2, t2 = U(i.firstChild), i.removeChild(i.firstChild), t2;
}
function G(t2, e2) {
  return e2 && (e2 instanceof O.window.Node || e2.ownerDocument && e2 instanceof e2.ownerDocument.defaultView.Node) ? e2 : W(t2);
}
function V(t2) {
  if (!t2)
    return null;
  if (t2.instance instanceof D)
    return t2.instance;
  if ("#document-fragment" === t2.nodeName)
    return new _.Fragment(t2);
  let e2 = P(t2.nodeName || "Dom");
  return "LinearGradient" === e2 || "RadialGradient" === e2 ? e2 = "Gradient" : _[e2] || (e2 = "Dom"), new _[e2](t2);
}
let U = V;
function q(t2, e2 = t2.name, i = false) {
  return _[e2] = t2, i && (_[N] = t2), S(Object.getOwnPropertyNames(t2.prototype)), t2;
}
let Z = 1e3;
function $$7(t2) {
  return "Svgjs" + P(t2) + Z++;
}
function J(t2) {
  for (let e2 = t2.children.length - 1; e2 >= 0; e2--)
    J(t2.children[e2]);
  return t2.id ? (t2.id = $$7(t2.nodeName), t2) : t2;
}
function Q(t2, e2) {
  let i, a2;
  for (a2 = (t2 = Array.isArray(t2) ? t2 : [t2]).length - 1; a2 >= 0; a2--)
    for (i in e2)
      t2[a2].prototype[i] = e2[i];
}
function K(t2) {
  return function(...e2) {
    const i = e2[e2.length - 1];
    return !i || i.constructor !== Object || i instanceof Array ? t2.apply(this, e2) : t2.apply(this, e2.slice(0, -1)).attr(i);
  };
}
A("Dom", { siblings: function() {
  return this.parent().children();
}, position: function() {
  return this.parent().index(this);
}, next: function() {
  return this.siblings()[this.position() + 1];
}, prev: function() {
  return this.siblings()[this.position() - 1];
}, forward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 + 1), this;
}, backward: function() {
  const t2 = this.position();
  return this.parent().add(this.remove(), t2 ? t2 - 1 : 0), this;
}, front: function() {
  return this.parent().add(this.remove()), this;
}, back: function() {
  return this.parent().add(this.remove(), 0), this;
}, before: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2), this;
}, after: function(t2) {
  (t2 = B(t2)).remove();
  const e2 = this.position();
  return this.parent().add(t2, e2 + 1), this;
}, insertBefore: function(t2) {
  return (t2 = B(t2)).before(this), this;
}, insertAfter: function(t2) {
  return (t2 = B(t2)).after(this), this;
} });
const tt = /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i, et = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, it = /rgb\((\d+),(\d+),(\d+)\)/, at = /(#[a-z_][a-z0-9\-_]*)/i, st = /\)\s*,?\s*/, rt = /\s/g, nt = /^#[a-f0-9]{3}$|^#[a-f0-9]{6}$/i, ot = /^rgb\(/, lt = /^(\s+)?$/, ht = /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ct = /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i, dt = /[\s,]+/, ut = /[MLHVCSQTAZ]/i;
function gt(t2) {
  const e2 = Math.round(t2), i = Math.max(0, Math.min(255, e2)).toString(16);
  return 1 === i.length ? "0" + i : i;
}
function pt(t2, e2) {
  for (let i = e2.length; i--; )
    if (null == t2[e2[i]])
      return false;
  return true;
}
function ft(t2, e2, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t2 + 6 * (e2 - t2) * i : i < 0.5 ? e2 : i < 2 / 3 ? t2 + (e2 - t2) * (2 / 3 - i) * 6 : t2;
}
A("Dom", { classes: function() {
  const t2 = this.attr("class");
  return null == t2 ? [] : t2.trim().split(dt);
}, hasClass: function(t2) {
  return -1 !== this.classes().indexOf(t2);
}, addClass: function(t2) {
  if (!this.hasClass(t2)) {
    const e2 = this.classes();
    e2.push(t2), this.attr("class", e2.join(" "));
  }
  return this;
}, removeClass: function(t2) {
  return this.hasClass(t2) && this.attr("class", this.classes().filter(function(e2) {
    return e2 !== t2;
  }).join(" ")), this;
}, toggleClass: function(t2) {
  return this.hasClass(t2) ? this.removeClass(t2) : this.addClass(t2);
} }), A("Dom", { css: function(t2, e2) {
  const i = {};
  if (0 === arguments.length)
    return this.node.style.cssText.split(/\s*;\s*/).filter(function(t3) {
      return !!t3.length;
    }).forEach(function(t3) {
      const e3 = t3.split(/\s*:\s*/);
      i[e3[0]] = e3[1];
    }), i;
  if (arguments.length < 2) {
    if (Array.isArray(t2)) {
      for (const e3 of t2) {
        const t3 = e3;
        i[e3] = this.node.style.getPropertyValue(t3);
      }
      return i;
    }
    if ("string" == typeof t2)
      return this.node.style.getPropertyValue(t2);
    if ("object" == typeof t2)
      for (const e3 in t2)
        this.node.style.setProperty(e3, null == t2[e3] || lt.test(t2[e3]) ? "" : t2[e3]);
  }
  return 2 === arguments.length && this.node.style.setProperty(t2, null == e2 || lt.test(e2) ? "" : e2), this;
}, show: function() {
  return this.css("display", "");
}, hide: function() {
  return this.css("display", "none");
}, visible: function() {
  return "none" !== this.css("display");
} }), A("Dom", { data: function(t2, e2, i) {
  if (null == t2)
    return this.data(L(function(t3, e3) {
      let i2;
      const a2 = t3.length, s2 = [];
      for (i2 = 0; i2 < a2; i2++)
        e3(t3[i2]) && s2.push(t3[i2]);
      return s2;
    }(this.node.attributes, (t3) => 0 === t3.nodeName.indexOf("data-")), (t3) => t3.nodeName.slice(5)));
  if (t2 instanceof Array) {
    const e3 = {};
    for (const i2 of t2)
      e3[i2] = this.data(i2);
    return e3;
  }
  if ("object" == typeof t2)
    for (e2 in t2)
      this.data(e2, t2[e2]);
  else if (arguments.length < 2)
    try {
      return JSON.parse(this.attr("data-" + t2));
    } catch (e3) {
      return this.attr("data-" + t2);
    }
  else
    this.attr("data-" + t2, null === e2 ? null : true === i || "string" == typeof e2 || "number" == typeof e2 ? e2 : JSON.stringify(e2));
  return this;
} }), A("Dom", { remember: function(t2, e2) {
  if ("object" == typeof arguments[0])
    for (const e3 in t2)
      this.remember(e3, t2[e3]);
  else {
    if (1 === arguments.length)
      return this.memory()[t2];
    this.memory()[t2] = e2;
  }
  return this;
}, forget: function() {
  if (0 === arguments.length)
    this._memory = {};
  else
    for (let t2 = arguments.length - 1; t2 >= 0; t2--)
      delete this.memory()[arguments[t2]];
  return this;
}, memory: function() {
  return this._memory = this._memory || {};
} });
class xt {
  constructor(...t2) {
    this.init(...t2);
  }
  static isColor(t2) {
    return t2 && (t2 instanceof xt || this.isRgb(t2) || this.test(t2));
  }
  static isRgb(t2) {
    return t2 && "number" == typeof t2.r && "number" == typeof t2.g && "number" == typeof t2.b;
  }
  static random(t2 = "vibrant", e2) {
    const { random: i, round: a2, sin: s2, PI: r2 } = Math;
    if ("vibrant" === t2) {
      const t3 = 24 * i() + 57, e3 = 38 * i() + 45, a3 = 360 * i();
      return new xt(t3, e3, a3, "lch");
    }
    if ("sine" === t2) {
      const t3 = a2(80 * s2(2 * r2 * (e2 = null == e2 ? i() : e2) / 0.5 + 0.01) + 150), n2 = a2(50 * s2(2 * r2 * e2 / 0.5 + 4.6) + 200), o2 = a2(100 * s2(2 * r2 * e2 / 0.5 + 2.3) + 150);
      return new xt(t3, n2, o2);
    }
    if ("pastel" === t2) {
      const t3 = 8 * i() + 86, e3 = 17 * i() + 9, a3 = 360 * i();
      return new xt(t3, e3, a3, "lch");
    }
    if ("dark" === t2) {
      const t3 = 10 + 10 * i(), e3 = 50 * i() + 86, a3 = 360 * i();
      return new xt(t3, e3, a3, "lch");
    }
    if ("rgb" === t2) {
      const t3 = 255 * i(), e3 = 255 * i(), a3 = 255 * i();
      return new xt(t3, e3, a3);
    }
    if ("lab" === t2) {
      const t3 = 100 * i(), e3 = 256 * i() - 128, a3 = 256 * i() - 128;
      return new xt(t3, e3, a3, "lab");
    }
    if ("grey" === t2) {
      const t3 = 255 * i();
      return new xt(t3, t3, t3);
    }
    throw new Error("Unsupported random color mode");
  }
  static test(t2) {
    return "string" == typeof t2 && (nt.test(t2) || ot.test(t2));
  }
  cmyk() {
    const { _a: t2, _b: e2, _c: i } = this.rgb(), [a2, s2, r2] = [t2, e2, i].map((t3) => t3 / 255), n2 = Math.min(1 - a2, 1 - s2, 1 - r2);
    if (1 === n2)
      return new xt(0, 0, 0, 1, "cmyk");
    return new xt((1 - a2 - n2) / (1 - n2), (1 - s2 - n2) / (1 - n2), (1 - r2 - n2) / (1 - n2), n2, "cmyk");
  }
  hsl() {
    const { _a: t2, _b: e2, _c: i } = this.rgb(), [a2, s2, r2] = [t2, e2, i].map((t3) => t3 / 255), n2 = Math.max(a2, s2, r2), o2 = Math.min(a2, s2, r2), l2 = (n2 + o2) / 2, h2 = n2 === o2, c2 = n2 - o2;
    return new xt(360 * (h2 ? 0 : n2 === a2 ? ((s2 - r2) / c2 + (s2 < r2 ? 6 : 0)) / 6 : n2 === s2 ? ((r2 - a2) / c2 + 2) / 6 : n2 === r2 ? ((a2 - s2) / c2 + 4) / 6 : 0), 100 * (h2 ? 0 : l2 > 0.5 ? c2 / (2 - n2 - o2) : c2 / (n2 + o2)), 100 * l2, "hsl");
  }
  init(t2 = 0, e2 = 0, i = 0, a2 = 0, s2 = "rgb") {
    if (t2 = t2 || 0, this.space)
      for (const t3 in this.space)
        delete this[this.space[t3]];
    if ("number" == typeof t2)
      s2 = "string" == typeof a2 ? a2 : s2, a2 = "string" == typeof a2 ? 0 : a2, Object.assign(this, { _a: t2, _b: e2, _c: i, _d: a2, space: s2 });
    else if (t2 instanceof Array)
      this.space = e2 || ("string" == typeof t2[3] ? t2[3] : t2[4]) || "rgb", Object.assign(this, { _a: t2[0], _b: t2[1], _c: t2[2], _d: t2[3] || 0 });
    else if (t2 instanceof Object) {
      const i2 = function(t3, e3) {
        const i3 = pt(t3, "rgb") ? { _a: t3.r, _b: t3.g, _c: t3.b, _d: 0, space: "rgb" } : pt(t3, "xyz") ? { _a: t3.x, _b: t3.y, _c: t3.z, _d: 0, space: "xyz" } : pt(t3, "hsl") ? { _a: t3.h, _b: t3.s, _c: t3.l, _d: 0, space: "hsl" } : pt(t3, "lab") ? { _a: t3.l, _b: t3.a, _c: t3.b, _d: 0, space: "lab" } : pt(t3, "lch") ? { _a: t3.l, _b: t3.c, _c: t3.h, _d: 0, space: "lch" } : pt(t3, "cmyk") ? { _a: t3.c, _b: t3.m, _c: t3.y, _d: t3.k, space: "cmyk" } : { _a: 0, _b: 0, _c: 0, space: "rgb" };
        return i3.space = e3 || i3.space, i3;
      }(t2, e2);
      Object.assign(this, i2);
    } else if ("string" == typeof t2)
      if (ot.test(t2)) {
        const e3 = t2.replace(rt, ""), [i2, a3, s3] = it.exec(e3).slice(1, 4).map((t3) => parseInt(t3));
        Object.assign(this, { _a: i2, _b: a3, _c: s3, _d: 0, space: "rgb" });
      } else {
        if (!nt.test(t2))
          throw Error("Unsupported string format, can't construct Color");
        {
          const e3 = (t3) => parseInt(t3, 16), [, i2, a3, s3] = et.exec(function(t3) {
            return 4 === t3.length ? ["#", t3.substring(1, 2), t3.substring(1, 2), t3.substring(2, 3), t3.substring(2, 3), t3.substring(3, 4), t3.substring(3, 4)].join("") : t3;
          }(t2)).map(e3);
          Object.assign(this, { _a: i2, _b: a3, _c: s3, _d: 0, space: "rgb" });
        }
      }
    const { _a: r2, _b: n2, _c: o2, _d: l2 } = this, h2 = "rgb" === this.space ? { r: r2, g: n2, b: o2 } : "xyz" === this.space ? { x: r2, y: n2, z: o2 } : "hsl" === this.space ? { h: r2, s: n2, l: o2 } : "lab" === this.space ? { l: r2, a: n2, b: o2 } : "lch" === this.space ? { l: r2, c: n2, h: o2 } : "cmyk" === this.space ? { c: r2, m: n2, y: o2, k: l2 } : {};
    Object.assign(this, h2);
  }
  lab() {
    const { x: t2, y: e2, z: i } = this.xyz();
    return new xt(116 * e2 - 16, 500 * (t2 - e2), 200 * (e2 - i), "lab");
  }
  lch() {
    const { l: t2, a: e2, b: i } = this.lab(), a2 = Math.sqrt(e2 ** 2 + i ** 2);
    let s2 = 180 * Math.atan2(i, e2) / Math.PI;
    s2 < 0 && (s2 *= -1, s2 = 360 - s2);
    return new xt(t2, a2, s2, "lch");
  }
  rgb() {
    if ("rgb" === this.space)
      return this;
    if ("lab" === (t2 = this.space) || "xyz" === t2 || "lch" === t2) {
      let { x: t3, y: e2, z: i } = this;
      if ("lab" === this.space || "lch" === this.space) {
        let { l: a3, a: s3, b: r3 } = this;
        if ("lch" === this.space) {
          const { c: t4, h: e3 } = this, i2 = Math.PI / 180;
          s3 = t4 * Math.cos(i2 * e3), r3 = t4 * Math.sin(i2 * e3);
        }
        const n3 = (a3 + 16) / 116, o3 = s3 / 500 + n3, l3 = n3 - r3 / 200, h3 = 16 / 116, c3 = 8856e-6, d2 = 7.787;
        t3 = 0.95047 * (o3 ** 3 > c3 ? o3 ** 3 : (o3 - h3) / d2), e2 = 1 * (n3 ** 3 > c3 ? n3 ** 3 : (n3 - h3) / d2), i = 1.08883 * (l3 ** 3 > c3 ? l3 ** 3 : (l3 - h3) / d2);
      }
      const a2 = 3.2406 * t3 + -1.5372 * e2 + -0.4986 * i, s2 = -0.9689 * t3 + 1.8758 * e2 + 0.0415 * i, r2 = 0.0557 * t3 + -0.204 * e2 + 1.057 * i, n2 = Math.pow, o2 = 31308e-7, l2 = a2 > o2 ? 1.055 * n2(a2, 1 / 2.4) - 0.055 : 12.92 * a2, h2 = s2 > o2 ? 1.055 * n2(s2, 1 / 2.4) - 0.055 : 12.92 * s2, c2 = r2 > o2 ? 1.055 * n2(r2, 1 / 2.4) - 0.055 : 12.92 * r2;
      return new xt(255 * l2, 255 * h2, 255 * c2);
    }
    if ("hsl" === this.space) {
      let { h: t3, s: e2, l: i } = this;
      if (t3 /= 360, e2 /= 100, i /= 100, 0 === e2) {
        i *= 255;
        return new xt(i, i, i);
      }
      const a2 = i < 0.5 ? i * (1 + e2) : i + e2 - i * e2, s2 = 2 * i - a2, r2 = 255 * ft(s2, a2, t3 + 1 / 3), n2 = 255 * ft(s2, a2, t3), o2 = 255 * ft(s2, a2, t3 - 1 / 3);
      return new xt(r2, n2, o2);
    }
    if ("cmyk" === this.space) {
      const { c: t3, m: e2, y: i, k: a2 } = this, s2 = 255 * (1 - Math.min(1, t3 * (1 - a2) + a2)), r2 = 255 * (1 - Math.min(1, e2 * (1 - a2) + a2)), n2 = 255 * (1 - Math.min(1, i * (1 - a2) + a2));
      return new xt(s2, r2, n2);
    }
    return this;
    var t2;
  }
  toArray() {
    const { _a: t2, _b: e2, _c: i, _d: a2, space: s2 } = this;
    return [t2, e2, i, a2, s2];
  }
  toHex() {
    const [t2, e2, i] = this._clamped().map(gt);
    return `#${t2}${e2}${i}`;
  }
  toRgb() {
    const [t2, e2, i] = this._clamped();
    return `rgb(${t2},${e2},${i})`;
  }
  toString() {
    return this.toHex();
  }
  xyz() {
    const { _a: t2, _b: e2, _c: i } = this.rgb(), [a2, s2, r2] = [t2, e2, i].map((t3) => t3 / 255), n2 = a2 > 0.04045 ? Math.pow((a2 + 0.055) / 1.055, 2.4) : a2 / 12.92, o2 = s2 > 0.04045 ? Math.pow((s2 + 0.055) / 1.055, 2.4) : s2 / 12.92, l2 = r2 > 0.04045 ? Math.pow((r2 + 0.055) / 1.055, 2.4) : r2 / 12.92, h2 = (0.4124 * n2 + 0.3576 * o2 + 0.1805 * l2) / 0.95047, c2 = (0.2126 * n2 + 0.7152 * o2 + 0.0722 * l2) / 1, d2 = (0.0193 * n2 + 0.1192 * o2 + 0.9505 * l2) / 1.08883, u2 = h2 > 8856e-6 ? Math.pow(h2, 1 / 3) : 7.787 * h2 + 16 / 116, g2 = c2 > 8856e-6 ? Math.pow(c2, 1 / 3) : 7.787 * c2 + 16 / 116, p2 = d2 > 8856e-6 ? Math.pow(d2, 1 / 3) : 7.787 * d2 + 16 / 116;
    return new xt(u2, g2, p2, "xyz");
  }
  _clamped() {
    const { _a: t2, _b: e2, _c: i } = this.rgb(), { max: a2, min: s2, round: r2 } = Math;
    return [t2, e2, i].map((t3) => a2(0, s2(r2(t3), 255)));
  }
}
class bt {
  constructor(...t2) {
    this.init(...t2);
  }
  clone() {
    return new bt(this);
  }
  init(t2, e2) {
    const i = 0, a2 = 0, s2 = Array.isArray(t2) ? { x: t2[0], y: t2[1] } : "object" == typeof t2 ? { x: t2.x, y: t2.y } : { x: t2, y: e2 };
    return this.x = null == s2.x ? i : s2.x, this.y = null == s2.y ? a2 : s2.y, this;
  }
  toArray() {
    return [this.x, this.y];
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    const { x: e2, y: i } = this;
    return this.x = t2.a * e2 + t2.c * i + t2.e, this.y = t2.b * e2 + t2.d * i + t2.f, this;
  }
}
function mt(t2, e2, i) {
  return Math.abs(e2 - t2) < (i || 1e-6);
}
class vt {
  constructor(...t2) {
    this.init(...t2);
  }
  static formatTransforms(t2) {
    const e2 = "both" === t2.flip || true === t2.flip, i = t2.flip && (e2 || "x" === t2.flip) ? -1 : 1, a2 = t2.flip && (e2 || "y" === t2.flip) ? -1 : 1, s2 = t2.skew && t2.skew.length ? t2.skew[0] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewX) ? t2.skewX : 0, r2 = t2.skew && t2.skew.length ? t2.skew[1] : isFinite(t2.skew) ? t2.skew : isFinite(t2.skewY) ? t2.skewY : 0, n2 = t2.scale && t2.scale.length ? t2.scale[0] * i : isFinite(t2.scale) ? t2.scale * i : isFinite(t2.scaleX) ? t2.scaleX * i : i, o2 = t2.scale && t2.scale.length ? t2.scale[1] * a2 : isFinite(t2.scale) ? t2.scale * a2 : isFinite(t2.scaleY) ? t2.scaleY * a2 : a2, l2 = t2.shear || 0, h2 = t2.rotate || t2.theta || 0, c2 = new bt(t2.origin || t2.around || t2.ox || t2.originX, t2.oy || t2.originY), d2 = c2.x, u2 = c2.y, g2 = new bt(t2.position || t2.px || t2.positionX || NaN, t2.py || t2.positionY || NaN), p2 = g2.x, f2 = g2.y, x2 = new bt(t2.translate || t2.tx || t2.translateX, t2.ty || t2.translateY), b2 = x2.x, m2 = x2.y, v2 = new bt(t2.relative || t2.rx || t2.relativeX, t2.ry || t2.relativeY);
    return { scaleX: n2, scaleY: o2, skewX: s2, skewY: r2, shear: l2, theta: h2, rx: v2.x, ry: v2.y, tx: b2, ty: m2, ox: d2, oy: u2, px: p2, py: f2 };
  }
  static fromArray(t2) {
    return { a: t2[0], b: t2[1], c: t2[2], d: t2[3], e: t2[4], f: t2[5] };
  }
  static isMatrixLike(t2) {
    return null != t2.a || null != t2.b || null != t2.c || null != t2.d || null != t2.e || null != t2.f;
  }
  static matrixMultiply(t2, e2, i) {
    const a2 = t2.a * e2.a + t2.c * e2.b, s2 = t2.b * e2.a + t2.d * e2.b, r2 = t2.a * e2.c + t2.c * e2.d, n2 = t2.b * e2.c + t2.d * e2.d, o2 = t2.e + t2.a * e2.e + t2.c * e2.f, l2 = t2.f + t2.b * e2.e + t2.d * e2.f;
    return i.a = a2, i.b = s2, i.c = r2, i.d = n2, i.e = o2, i.f = l2, i;
  }
  around(t2, e2, i) {
    return this.clone().aroundO(t2, e2, i);
  }
  aroundO(t2, e2, i) {
    const a2 = t2 || 0, s2 = e2 || 0;
    return this.translateO(-a2, -s2).lmultiplyO(i).translateO(a2, s2);
  }
  clone() {
    return new vt(this);
  }
  decompose(t2 = 0, e2 = 0) {
    const i = this.a, a2 = this.b, s2 = this.c, r2 = this.d, n2 = this.e, o2 = this.f, l2 = i * r2 - a2 * s2, h2 = l2 > 0 ? 1 : -1, c2 = h2 * Math.sqrt(i * i + a2 * a2), d2 = Math.atan2(h2 * a2, h2 * i), u2 = 180 / Math.PI * d2, g2 = Math.cos(d2), p2 = Math.sin(d2), f2 = (i * s2 + a2 * r2) / l2, x2 = s2 * c2 / (f2 * i - a2) || r2 * c2 / (f2 * a2 + i);
    return { scaleX: c2, scaleY: x2, shear: f2, rotate: u2, translateX: n2 - t2 + t2 * g2 * c2 + e2 * (f2 * g2 * c2 - p2 * x2), translateY: o2 - e2 + t2 * p2 * c2 + e2 * (f2 * p2 * c2 + g2 * x2), originX: t2, originY: e2, a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
  equals(t2) {
    if (t2 === this)
      return true;
    const e2 = new vt(t2);
    return mt(this.a, e2.a) && mt(this.b, e2.b) && mt(this.c, e2.c) && mt(this.d, e2.d) && mt(this.e, e2.e) && mt(this.f, e2.f);
  }
  flip(t2, e2) {
    return this.clone().flipO(t2, e2);
  }
  flipO(t2, e2) {
    return "x" === t2 ? this.scaleO(-1, 1, e2, 0) : "y" === t2 ? this.scaleO(1, -1, 0, e2) : this.scaleO(-1, -1, t2, e2 || t2);
  }
  init(t2) {
    const e2 = vt.fromArray([1, 0, 0, 1, 0, 0]);
    return t2 = t2 instanceof Gt ? t2.matrixify() : "string" == typeof t2 ? vt.fromArray(t2.split(dt).map(parseFloat)) : Array.isArray(t2) ? vt.fromArray(t2) : "object" == typeof t2 && vt.isMatrixLike(t2) ? t2 : "object" == typeof t2 ? new vt().transform(t2) : 6 === arguments.length ? vt.fromArray([].slice.call(arguments)) : e2, this.a = null != t2.a ? t2.a : e2.a, this.b = null != t2.b ? t2.b : e2.b, this.c = null != t2.c ? t2.c : e2.c, this.d = null != t2.d ? t2.d : e2.d, this.e = null != t2.e ? t2.e : e2.e, this.f = null != t2.f ? t2.f : e2.f, this;
  }
  inverse() {
    return this.clone().inverseO();
  }
  inverseO() {
    const t2 = this.a, e2 = this.b, i = this.c, a2 = this.d, s2 = this.e, r2 = this.f, n2 = t2 * a2 - e2 * i;
    if (!n2)
      throw new Error("Cannot invert " + this);
    const o2 = a2 / n2, l2 = -e2 / n2, h2 = -i / n2, c2 = t2 / n2, d2 = -(o2 * s2 + h2 * r2), u2 = -(l2 * s2 + c2 * r2);
    return this.a = o2, this.b = l2, this.c = h2, this.d = c2, this.e = d2, this.f = u2, this;
  }
  lmultiply(t2) {
    return this.clone().lmultiplyO(t2);
  }
  lmultiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(e2, this, this);
  }
  multiply(t2) {
    return this.clone().multiplyO(t2);
  }
  multiplyO(t2) {
    const e2 = t2 instanceof vt ? t2 : new vt(t2);
    return vt.matrixMultiply(this, e2, this);
  }
  rotate(t2, e2, i) {
    return this.clone().rotateO(t2, e2, i);
  }
  rotateO(t2, e2 = 0, i = 0) {
    t2 = M(t2);
    const a2 = Math.cos(t2), s2 = Math.sin(t2), { a: r2, b: n2, c: o2, d: l2, e: h2, f: c2 } = this;
    return this.a = r2 * a2 - n2 * s2, this.b = n2 * a2 + r2 * s2, this.c = o2 * a2 - l2 * s2, this.d = l2 * a2 + o2 * s2, this.e = h2 * a2 - c2 * s2 + i * s2 - e2 * a2 + e2, this.f = c2 * a2 + h2 * s2 - e2 * s2 - i * a2 + i, this;
  }
  scale() {
    return this.clone().scaleO(...arguments);
  }
  scaleO(t2, e2 = t2, i = 0, a2 = 0) {
    3 === arguments.length && (a2 = i, i = e2, e2 = t2);
    const { a: s2, b: r2, c: n2, d: o2, e: l2, f: h2 } = this;
    return this.a = s2 * t2, this.b = r2 * e2, this.c = n2 * t2, this.d = o2 * e2, this.e = l2 * t2 - i * t2 + i, this.f = h2 * e2 - a2 * e2 + a2, this;
  }
  shear(t2, e2, i) {
    return this.clone().shearO(t2, e2, i);
  }
  shearO(t2, e2 = 0, i = 0) {
    const { a: a2, b: s2, c: r2, d: n2, e: o2, f: l2 } = this;
    return this.a = a2 + s2 * t2, this.c = r2 + n2 * t2, this.e = o2 + l2 * t2 - i * t2, this;
  }
  skew() {
    return this.clone().skewO(...arguments);
  }
  skewO(t2, e2 = t2, i = 0, a2 = 0) {
    3 === arguments.length && (a2 = i, i = e2, e2 = t2), t2 = M(t2), e2 = M(e2);
    const s2 = Math.tan(t2), r2 = Math.tan(e2), { a: n2, b: o2, c: l2, d: h2, e: c2, f: d2 } = this;
    return this.a = n2 + o2 * s2, this.b = o2 + n2 * r2, this.c = l2 + h2 * s2, this.d = h2 + l2 * r2, this.e = c2 + d2 * s2 - a2 * s2, this.f = d2 + c2 * r2 - i * r2, this;
  }
  skewX(t2, e2, i) {
    return this.skew(t2, 0, e2, i);
  }
  skewY(t2, e2, i) {
    return this.skew(0, t2, e2, i);
  }
  toArray() {
    return [this.a, this.b, this.c, this.d, this.e, this.f];
  }
  toString() {
    return "matrix(" + this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.e + "," + this.f + ")";
  }
  transform(t2) {
    if (vt.isMatrixLike(t2)) {
      return new vt(t2).multiplyO(this);
    }
    const e2 = vt.formatTransforms(t2), { x: i, y: a2 } = new bt(e2.ox, e2.oy).transform(this), s2 = new vt().translateO(e2.rx, e2.ry).lmultiplyO(this).translateO(-i, -a2).scaleO(e2.scaleX, e2.scaleY).skewO(e2.skewX, e2.skewY).shearO(e2.shear).rotateO(e2.theta).translateO(i, a2);
    if (isFinite(e2.px) || isFinite(e2.py)) {
      const t3 = new bt(i, a2).transform(s2), r2 = isFinite(e2.px) ? e2.px - t3.x : 0, n2 = isFinite(e2.py) ? e2.py - t3.y : 0;
      s2.translateO(r2, n2);
    }
    return s2.translateO(e2.tx, e2.ty), s2;
  }
  translate(t2, e2) {
    return this.clone().translateO(t2, e2);
  }
  translateO(t2, e2) {
    return this.e += t2 || 0, this.f += e2 || 0, this;
  }
  valueOf() {
    return { a: this.a, b: this.b, c: this.c, d: this.d, e: this.e, f: this.f };
  }
}
function yt() {
  if (!yt.nodes) {
    const t2 = B().size(2, 0);
    t2.node.style.cssText = ["opacity: 0", "position: absolute", "left: -100%", "top: -100%", "overflow: hidden"].join(";"), t2.attr("focusable", "false"), t2.attr("aria-hidden", "true");
    const e2 = t2.path().node;
    yt.nodes = { svg: t2, path: e2 };
  }
  if (!yt.nodes.svg.node.parentNode) {
    const t2 = O.document.body || O.document.documentElement;
    yt.nodes.svg.addTo(t2);
  }
  return yt.nodes;
}
function wt(t2) {
  return !(t2.width || t2.height || t2.x || t2.y);
}
q(vt, "Matrix");
class kt {
  constructor(...t2) {
    this.init(...t2);
  }
  addOffset() {
    return this.x += O.window.pageXOffset, this.y += O.window.pageYOffset, new kt(this);
  }
  init(t2) {
    return t2 = "string" == typeof t2 ? t2.split(dt).map(parseFloat) : Array.isArray(t2) ? t2 : "object" == typeof t2 ? [null != t2.left ? t2.left : t2.x, null != t2.top ? t2.top : t2.y, t2.width, t2.height] : 4 === arguments.length ? [].slice.call(arguments) : [0, 0, 0, 0], this.x = t2[0] || 0, this.y = t2[1] || 0, this.width = this.w = t2[2] || 0, this.height = this.h = t2[3] || 0, this.x2 = this.x + this.w, this.y2 = this.y + this.h, this.cx = this.x + this.w / 2, this.cy = this.y + this.h / 2, this;
  }
  isNulled() {
    return wt(this);
  }
  merge(t2) {
    const e2 = Math.min(this.x, t2.x), i = Math.min(this.y, t2.y), a2 = Math.max(this.x + this.width, t2.x + t2.width) - e2, s2 = Math.max(this.y + this.height, t2.y + t2.height) - i;
    return new kt(e2, i, a2, s2);
  }
  toArray() {
    return [this.x, this.y, this.width, this.height];
  }
  toString() {
    return this.x + " " + this.y + " " + this.width + " " + this.height;
  }
  transform(t2) {
    t2 instanceof vt || (t2 = new vt(t2));
    let e2 = 1 / 0, i = -1 / 0, a2 = 1 / 0, s2 = -1 / 0;
    return [new bt(this.x, this.y), new bt(this.x2, this.y), new bt(this.x, this.y2), new bt(this.x2, this.y2)].forEach(function(r2) {
      r2 = r2.transform(t2), e2 = Math.min(e2, r2.x), i = Math.max(i, r2.x), a2 = Math.min(a2, r2.y), s2 = Math.max(s2, r2.y);
    }), new kt(e2, a2, i - e2, s2 - a2);
  }
}
function At(t2, e2, i) {
  let a2;
  try {
    if (a2 = e2(t2.node), wt(a2) && ((s2 = t2.node) !== O.document && !(O.document.documentElement.contains || function(t3) {
      for (; t3.parentNode; )
        t3 = t3.parentNode;
      return t3 === O.document;
    }).call(O.document.documentElement, s2)))
      throw new Error("Element not in the dom");
  } catch (e3) {
    a2 = i(t2);
  }
  var s2;
  return a2;
}
A({ viewbox: { viewbox(t2, e2, i, a2) {
  return null == t2 ? new kt(this.attr("viewBox")) : this.attr("viewBox", new kt(t2, e2, i, a2));
}, zoom(t2, e2) {
  let { width: i, height: a2 } = this.attr(["width", "height"]);
  if ((i || a2) && "string" != typeof i && "string" != typeof a2 || (i = this.node.clientWidth, a2 = this.node.clientHeight), !i || !a2)
    throw new Error("Impossible to get absolute width and height. Please provide an absolute width and height attribute on the zooming element");
  const s2 = this.viewbox(), r2 = i / s2.width, n2 = a2 / s2.height, o2 = Math.min(r2, n2);
  if (null == t2)
    return o2;
  let l2 = o2 / t2;
  l2 === 1 / 0 && (l2 = Number.MAX_SAFE_INTEGER / 100), e2 = e2 || new bt(i / 2 / r2 + s2.x, a2 / 2 / n2 + s2.y);
  const h2 = new kt(s2).transform(new vt({ scale: l2, origin: e2 }));
  return this.viewbox(h2);
} } }), q(kt, "Box");
class Ct extends Array {
  constructor(t2 = [], ...e2) {
    if (super(t2, ...e2), "number" == typeof t2)
      return this;
    this.length = 0, this.push(...t2);
  }
}
Q([Ct], { each(t2, ...e2) {
  return "function" == typeof t2 ? this.map((e3, i, a2) => t2.call(e3, e3, i, a2)) : this.map((i) => i[t2](...e2));
}, toArray() {
  return Array.prototype.concat.apply([], this);
} });
const St = ["toArray", "constructor", "each"];
function Lt(t2, e2) {
  return new Ct(L((e2 || O.document).querySelectorAll(t2), function(t3) {
    return V(t3);
  }));
}
Ct.extend = function(t2) {
  t2 = t2.reduce((t3, e2) => (St.includes(e2) || "_" === e2[0] || (e2 in Array.prototype && (t3["$" + e2] = Array.prototype[e2]), t3[e2] = function(...t4) {
    return this.each(e2, ...t4);
  }), t3), {}), Q([Ct], t2);
};
let Mt = 0;
const Pt = {};
function It(t2) {
  let e2 = t2.getEventHolder();
  return e2 === O.window && (e2 = Pt), e2.events || (e2.events = {}), e2.events;
}
function Tt(t2) {
  return t2.getEventTarget();
}
function zt(t2, e2, i, a2, s2) {
  const r2 = i.bind(a2 || t2), n2 = B(t2), o2 = It(n2), l2 = Tt(n2);
  e2 = Array.isArray(e2) ? e2 : e2.split(dt), i._svgjsListenerId || (i._svgjsListenerId = ++Mt), e2.forEach(function(t3) {
    const e3 = t3.split(".")[0], a3 = t3.split(".")[1] || "*";
    o2[e3] = o2[e3] || {}, o2[e3][a3] = o2[e3][a3] || {}, o2[e3][a3][i._svgjsListenerId] = r2, l2.addEventListener(e3, r2, s2 || false);
  });
}
function Xt(t2, e2, i, a2) {
  const s2 = B(t2), r2 = It(s2), n2 = Tt(s2);
  ("function" != typeof i || (i = i._svgjsListenerId)) && (e2 = Array.isArray(e2) ? e2 : (e2 || "").split(dt)).forEach(function(t3) {
    const e3 = t3 && t3.split(".")[0], o2 = t3 && t3.split(".")[1];
    let l2, h2;
    if (i)
      r2[e3] && r2[e3][o2 || "*"] && (n2.removeEventListener(e3, r2[e3][o2 || "*"][i], a2 || false), delete r2[e3][o2 || "*"][i]);
    else if (e3 && o2) {
      if (r2[e3] && r2[e3][o2]) {
        for (h2 in r2[e3][o2])
          Xt(n2, [e3, o2].join("."), h2);
        delete r2[e3][o2];
      }
    } else if (o2)
      for (t3 in r2)
        for (l2 in r2[t3])
          o2 === l2 && Xt(n2, [t3, o2].join("."));
    else if (e3) {
      if (r2[e3]) {
        for (l2 in r2[e3])
          Xt(n2, [e3, l2].join("."));
        delete r2[e3];
      }
    } else {
      for (t3 in r2)
        Xt(n2, t3);
      !function(t4) {
        let e4 = t4.getEventHolder();
        e4 === O.window && (e4 = Pt), e4.events && (e4.events = {});
      }(s2);
    }
  });
}
class Rt extends D {
  addEventListener() {
  }
  dispatch(t2, e2, i) {
    return function(t3, e3, i2, a2) {
      const s2 = Tt(t3);
      return e3 instanceof O.window.Event || (e3 = new O.window.CustomEvent(e3, { detail: i2, cancelable: true, ...a2 })), s2.dispatchEvent(e3), e3;
    }(this, t2, e2, i);
  }
  dispatchEvent(t2) {
    const e2 = this.getEventHolder().events;
    if (!e2)
      return true;
    const i = e2[t2.type];
    for (const e3 in i)
      for (const a2 in i[e3])
        i[e3][a2](t2);
    return !t2.defaultPrevented;
  }
  fire(t2, e2, i) {
    return this.dispatch(t2, e2, i), this;
  }
  getEventHolder() {
    return this;
  }
  getEventTarget() {
    return this;
  }
  off(t2, e2, i) {
    return Xt(this, t2, e2, i), this;
  }
  on(t2, e2, i, a2) {
    return zt(this, t2, e2, i, a2), this;
  }
  removeEventListener() {
  }
}
function Et() {
}
q(Rt, "EventTarget");
const Yt = 400, Ht = ">", Ot = 0, Ft = { "fill-opacity": 1, "stroke-opacity": 1, "stroke-width": 0, "stroke-linejoin": "miter", "stroke-linecap": "butt", fill: "#000000", stroke: "#000000", opacity: 1, x: 0, y: 0, cx: 0, cy: 0, width: 0, height: 0, r: 0, rx: 0, ry: 0, offset: 0, "stop-opacity": 1, "stop-color": "#000000", "text-anchor": "start" };
class Dt extends Array {
  constructor(...t2) {
    super(...t2), this.init(...t2);
  }
  clone() {
    return new this.constructor(this);
  }
  init(t2) {
    return "number" == typeof t2 || (this.length = 0, this.push(...this.parse(t2))), this;
  }
  parse(t2 = []) {
    return t2 instanceof Array ? t2 : t2.trim().split(dt).map(parseFloat);
  }
  toArray() {
    return Array.prototype.concat.apply([], this);
  }
  toSet() {
    return new Set(this);
  }
  toString() {
    return this.join(" ");
  }
  valueOf() {
    const t2 = [];
    return t2.push(...this), t2;
  }
}
class _t {
  constructor(...t2) {
    this.init(...t2);
  }
  convert(t2) {
    return new _t(this.value, t2);
  }
  divide(t2) {
    return t2 = new _t(t2), new _t(this / t2, this.unit || t2.unit);
  }
  init(t2, e2) {
    return e2 = Array.isArray(t2) ? t2[1] : e2, t2 = Array.isArray(t2) ? t2[0] : t2, this.value = 0, this.unit = e2 || "", "number" == typeof t2 ? this.value = isNaN(t2) ? 0 : isFinite(t2) ? t2 : t2 < 0 ? -34e37 : 34e37 : "string" == typeof t2 ? (e2 = t2.match(tt)) && (this.value = parseFloat(e2[1]), "%" === e2[5] ? this.value /= 100 : "s" === e2[5] && (this.value *= 1e3), this.unit = e2[5]) : t2 instanceof _t && (this.value = t2.valueOf(), this.unit = t2.unit), this;
  }
  minus(t2) {
    return t2 = new _t(t2), new _t(this - t2, this.unit || t2.unit);
  }
  plus(t2) {
    return t2 = new _t(t2), new _t(this + t2, this.unit || t2.unit);
  }
  times(t2) {
    return t2 = new _t(t2), new _t(this * t2, this.unit || t2.unit);
  }
  toArray() {
    return [this.value, this.unit];
  }
  toJSON() {
    return this.toString();
  }
  toString() {
    return ("%" === this.unit ? ~~(1e8 * this.value) / 1e6 : "s" === this.unit ? this.value / 1e3 : this.value) + this.unit;
  }
  valueOf() {
    return this.value;
  }
}
const Nt = /* @__PURE__ */ new Set(["fill", "stroke", "color", "bgcolor", "stop-color", "flood-color", "lighting-color"]), Wt = [];
class Bt extends Rt {
  constructor(t2, e2) {
    super(), this.node = t2, this.type = t2.nodeName, e2 && t2 !== e2 && this.attr(e2);
  }
  add(t2, e2) {
    return (t2 = B(t2)).removeNamespace && this.node instanceof O.window.SVGElement && t2.removeNamespace(), null == e2 ? this.node.appendChild(t2.node) : t2.node !== this.node.childNodes[e2] && this.node.insertBefore(t2.node, this.node.childNodes[e2]), this;
  }
  addTo(t2, e2) {
    return B(t2).put(this, e2);
  }
  children() {
    return new Ct(L(this.node.children, function(t2) {
      return V(t2);
    }));
  }
  clear() {
    for (; this.node.hasChildNodes(); )
      this.node.removeChild(this.node.lastChild);
    return this;
  }
  clone(t2 = true, e2 = true) {
    this.writeDataToDom();
    let i = this.node.cloneNode(t2);
    return e2 && (i = J(i)), new this.constructor(i);
  }
  each(t2, e2) {
    const i = this.children();
    let a2, s2;
    for (a2 = 0, s2 = i.length; a2 < s2; a2++)
      t2.apply(i[a2], [a2, i]), e2 && i[a2].each(t2, e2);
    return this;
  }
  element(t2, e2) {
    return this.put(new Bt(W(t2), e2));
  }
  first() {
    return V(this.node.firstChild);
  }
  get(t2) {
    return V(this.node.childNodes[t2]);
  }
  getEventHolder() {
    return this.node;
  }
  getEventTarget() {
    return this.node;
  }
  has(t2) {
    return this.index(t2) >= 0;
  }
  html(t2, e2) {
    return this.xml(t2, e2, "http://www.w3.org/1999/xhtml");
  }
  id(t2) {
    return void 0 !== t2 || this.node.id || (this.node.id = $$7(this.type)), this.attr("id", t2);
  }
  index(t2) {
    return [].slice.call(this.node.childNodes).indexOf(t2.node);
  }
  last() {
    return V(this.node.lastChild);
  }
  matches(t2) {
    const e2 = this.node, i = e2.matches || e2.matchesSelector || e2.msMatchesSelector || e2.mozMatchesSelector || e2.webkitMatchesSelector || e2.oMatchesSelector || null;
    return i && i.call(e2, t2);
  }
  parent(t2) {
    let e2 = this;
    if (!e2.node.parentNode)
      return null;
    if (e2 = V(e2.node.parentNode), !t2)
      return e2;
    do {
      if ("string" == typeof t2 ? e2.matches(t2) : e2 instanceof t2)
        return e2;
    } while (e2 = V(e2.node.parentNode));
    return e2;
  }
  put(t2, e2) {
    return t2 = B(t2), this.add(t2, e2), t2;
  }
  putIn(t2, e2) {
    return B(t2).add(this, e2);
  }
  remove() {
    return this.parent() && this.parent().removeElement(this), this;
  }
  removeElement(t2) {
    return this.node.removeChild(t2.node), this;
  }
  replace(t2) {
    return t2 = B(t2), this.node.parentNode && this.node.parentNode.replaceChild(t2.node, this.node), t2;
  }
  round(t2 = 2, e2 = null) {
    const i = 10 ** t2, a2 = this.attr(e2);
    for (const t3 in a2)
      "number" == typeof a2[t3] && (a2[t3] = Math.round(a2[t3] * i) / i);
    return this.attr(a2), this;
  }
  svg(t2, e2) {
    return this.xml(t2, e2, E);
  }
  toString() {
    return this.id();
  }
  words(t2) {
    return this.node.textContent = t2, this;
  }
  wrap(t2) {
    const e2 = this.parent();
    if (!e2)
      return this.addTo(t2);
    const i = e2.index(this);
    return e2.put(t2, i).put(this);
  }
  writeDataToDom() {
    return this.each(function() {
      this.writeDataToDom();
    }), this;
  }
  xml(t2, e2, i) {
    if ("boolean" == typeof t2 && (i = e2, e2 = t2, t2 = null), null == t2 || "function" == typeof t2) {
      e2 = null == e2 || e2, this.writeDataToDom();
      let i2 = this;
      if (null != t2) {
        if (i2 = V(i2.node.cloneNode(true)), e2) {
          const e3 = t2(i2);
          if (i2 = e3 || i2, false === e3)
            return "";
        }
        i2.each(function() {
          const e3 = t2(this), i3 = e3 || this;
          false === e3 ? this.remove() : e3 && this !== i3 && this.replace(i3);
        }, true);
      }
      return e2 ? i2.node.outerHTML : i2.node.innerHTML;
    }
    e2 = null != e2 && e2;
    const a2 = W("wrapper", i), s2 = O.document.createDocumentFragment();
    a2.innerHTML = t2;
    for (let t3 = a2.children.length; t3--; )
      s2.appendChild(a2.firstElementChild);
    const r2 = this.parent();
    return e2 ? this.replace(s2) && r2 : this.add(s2);
  }
}
Q(Bt, { attr: function(t2, e2, i) {
  if (null == t2) {
    t2 = {}, e2 = this.node.attributes;
    for (const i2 of e2)
      t2[i2.nodeName] = ht.test(i2.nodeValue) ? parseFloat(i2.nodeValue) : i2.nodeValue;
    return t2;
  }
  if (t2 instanceof Array)
    return t2.reduce((t3, e3) => (t3[e3] = this.attr(e3), t3), {});
  if ("object" == typeof t2 && t2.constructor === Object)
    for (e2 in t2)
      this.attr(e2, t2[e2]);
  else if (null === e2)
    this.node.removeAttribute(t2);
  else {
    if (null == e2)
      return null == (e2 = this.node.getAttribute(t2)) ? Ft[t2] : ht.test(e2) ? parseFloat(e2) : e2;
    "number" == typeof (e2 = Wt.reduce((e3, i2) => i2(t2, e3, this), e2)) ? e2 = new _t(e2) : Nt.has(t2) && xt.isColor(e2) ? e2 = new xt(e2) : e2.constructor === Array && (e2 = new Dt(e2)), "leading" === t2 ? this.leading && this.leading(e2) : "string" == typeof i ? this.node.setAttributeNS(i, t2, e2.toString()) : this.node.setAttribute(t2, e2.toString()), !this.rebuild || "font-size" !== t2 && "x" !== t2 || this.rebuild();
  }
  return this;
}, find: function(t2) {
  return Lt(t2, this.node);
}, findOne: function(t2) {
  return V(this.node.querySelector(t2));
} }), q(Bt, "Dom");
let Gt = class extends Bt {
  constructor(t2, e2) {
    super(t2, e2), this.dom = {}, this.node.instance = this, (t2.hasAttribute("data-svgjs") || t2.hasAttribute("svgjs:data")) && this.setData(JSON.parse(t2.getAttribute("data-svgjs")) ?? JSON.parse(t2.getAttribute("svgjs:data")) ?? {});
  }
  center(t2, e2) {
    return this.cx(t2).cy(e2);
  }
  cx(t2) {
    return null == t2 ? this.x() + this.width() / 2 : this.x(t2 - this.width() / 2);
  }
  cy(t2) {
    return null == t2 ? this.y() + this.height() / 2 : this.y(t2 - this.height() / 2);
  }
  defs() {
    const t2 = this.root();
    return t2 && t2.defs();
  }
  dmove(t2, e2) {
    return this.dx(t2).dy(e2);
  }
  dx(t2 = 0) {
    return this.x(new _t(t2).plus(this.x()));
  }
  dy(t2 = 0) {
    return this.y(new _t(t2).plus(this.y()));
  }
  getEventHolder() {
    return this;
  }
  height(t2) {
    return this.attr("height", t2);
  }
  move(t2, e2) {
    return this.x(t2).y(e2);
  }
  parents(t2 = this.root()) {
    const e2 = "string" == typeof t2;
    e2 || (t2 = B(t2));
    const i = new Ct();
    let a2 = this;
    for (; (a2 = a2.parent()) && a2.node !== O.document && "#document-fragment" !== a2.nodeName && (i.push(a2), e2 || a2.node !== t2.node) && (!e2 || !a2.matches(t2)); )
      if (a2.node === this.root().node)
        return null;
    return i;
  }
  reference(t2) {
    if (!(t2 = this.attr(t2)))
      return null;
    const e2 = (t2 + "").match(at);
    return e2 ? B(e2[1]) : null;
  }
  root() {
    const t2 = this.parent(function(t3) {
      return _[t3];
    }(N));
    return t2 && t2.root();
  }
  setData(t2) {
    return this.dom = t2, this;
  }
  size(t2, e2) {
    const i = I(this, t2, e2);
    return this.width(new _t(i.width)).height(new _t(i.height));
  }
  width(t2) {
    return this.attr("width", t2);
  }
  writeDataToDom() {
    return R(this, this.dom), super.writeDataToDom();
  }
  x(t2) {
    return this.attr("x", t2);
  }
  y(t2) {
    return this.attr("y", t2);
  }
};
Q(Gt, { bbox: function() {
  const t2 = At(this, (t3) => t3.getBBox(), (t3) => {
    try {
      const e2 = t3.clone().addTo(yt().svg).show(), i = e2.node.getBBox();
      return e2.remove(), i;
    } catch (e2) {
      throw new Error(`Getting bbox of element "${t3.node.nodeName}" is not possible: ${e2.toString()}`);
    }
  });
  return new kt(t2);
}, rbox: function(t2) {
  const e2 = At(this, (t3) => t3.getBoundingClientRect(), (t3) => {
    throw new Error(`Getting rbox of element "${t3.node.nodeName}" is not possible`);
  }), i = new kt(e2);
  return t2 ? i.transform(t2.screenCTM().inverseO()) : i.addOffset();
}, inside: function(t2, e2) {
  const i = this.bbox();
  return t2 > i.x && e2 > i.y && t2 < i.x + i.width && e2 < i.y + i.height;
}, point: function(t2, e2) {
  return new bt(t2, e2).transformO(this.screenCTM().inverseO());
}, ctm: function() {
  return new vt(this.node.getCTM());
}, screenCTM: function() {
  try {
    if ("function" == typeof this.isRoot && !this.isRoot()) {
      const t2 = this.rect(1, 1), e2 = t2.node.getScreenCTM();
      return t2.remove(), new vt(e2);
    }
    return new vt(this.node.getScreenCTM());
  } catch (t2) {
    return console.warn(`Cannot get CTM from SVG node ${this.node.nodeName}. Is the element rendered?`), new vt();
  }
} }), q(Gt, "Element");
const jt = { stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"], fill: ["color", "opacity", "rule"], prefix: function(t2, e2) {
  return "color" === e2 ? t2 : t2 + "-" + e2;
} };
["fill", "stroke"].forEach(function(t2) {
  const e2 = {};
  let i;
  e2[t2] = function(e3) {
    if (void 0 === e3)
      return this.attr(t2);
    if ("string" == typeof e3 || e3 instanceof xt || xt.isRgb(e3) || e3 instanceof Gt)
      this.attr(t2, e3);
    else
      for (i = jt[t2].length - 1; i >= 0; i--)
        null != e3[jt[t2][i]] && this.attr(jt.prefix(t2, jt[t2][i]), e3[jt[t2][i]]);
    return this;
  }, A(["Element", "Runner"], e2);
}), A(["Element", "Runner"], { matrix: function(t2, e2, i, a2, s2, r2) {
  return null == t2 ? new vt(this) : this.attr("transform", new vt(t2, e2, i, a2, s2, r2));
}, rotate: function(t2, e2, i) {
  return this.transform({ rotate: t2, ox: e2, oy: i }, true);
}, skew: function(t2, e2, i, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ skew: t2, ox: e2, oy: i }, true) : this.transform({ skew: [t2, e2], ox: i, oy: a2 }, true);
}, shear: function(t2, e2, i) {
  return this.transform({ shear: t2, ox: e2, oy: i }, true);
}, scale: function(t2, e2, i, a2) {
  return 1 === arguments.length || 3 === arguments.length ? this.transform({ scale: t2, ox: e2, oy: i }, true) : this.transform({ scale: [t2, e2], ox: i, oy: a2 }, true);
}, translate: function(t2, e2) {
  return this.transform({ translate: [t2, e2] }, true);
}, relative: function(t2, e2) {
  return this.transform({ relative: [t2, e2] }, true);
}, flip: function(t2 = "both", e2 = "center") {
  return -1 === "xybothtrue".indexOf(t2) && (e2 = t2, t2 = "both"), this.transform({ flip: t2, origin: e2 }, true);
}, opacity: function(t2) {
  return this.attr("opacity", t2);
} }), A("radius", { radius: function(t2, e2 = t2) {
  return "radialGradient" === (this._element || this).type ? this.attr("r", new _t(t2)) : this.rx(t2).ry(e2);
} }), A("Path", { length: function() {
  return this.node.getTotalLength();
}, pointAt: function(t2) {
  return new bt(this.node.getPointAtLength(t2));
} }), A(["Element", "Runner"], { font: function(t2, e2) {
  if ("object" == typeof t2) {
    for (e2 in t2)
      this.font(e2, t2[e2]);
    return this;
  }
  return "leading" === t2 ? this.leading(e2) : "anchor" === t2 ? this.attr("text-anchor", e2) : "size" === t2 || "family" === t2 || "weight" === t2 || "stretch" === t2 || "variant" === t2 || "style" === t2 ? this.attr("font-" + t2, e2) : this.attr(t2, e2);
} });
A("Element", ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "mouseenter", "mouseleave", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel", "contextmenu", "wheel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel"].reduce(function(t2, e2) {
  return t2[e2] = function(t3) {
    return null === t3 ? this.off(e2) : this.on(e2, t3), this;
  }, t2;
}, {})), A("Element", { untransform: function() {
  return this.attr("transform", null);
}, matrixify: function() {
  const t2 = (this.attr("transform") || "").split(st).slice(0, -1).map(function(t3) {
    const e2 = t3.trim().split("(");
    return [e2[0], e2[1].split(dt).map(function(t4) {
      return parseFloat(t4);
    })];
  }).reverse().reduce(function(t3, e2) {
    return "matrix" === e2[0] ? t3.lmultiply(vt.fromArray(e2[1])) : t3[e2[0]].apply(t3, e2[1]);
  }, new vt());
  return t2;
}, toParent: function(t2, e2) {
  if (this === t2)
    return this;
  if (X(this.node))
    return this.addTo(t2, e2);
  const i = this.screenCTM(), a2 = t2.screenCTM().inverse();
  return this.addTo(t2, e2).untransform().transform(a2.multiply(i)), this;
}, toRoot: function(t2) {
  return this.toParent(this.root(), t2);
}, transform: function(t2, e2) {
  if (null == t2 || "string" == typeof t2) {
    const e3 = new vt(this).decompose();
    return null == t2 ? e3 : e3[t2];
  }
  vt.isMatrixLike(t2) || (t2 = { ...t2, origin: T(t2, this) });
  const i = new vt(true === e2 ? this : e2 || false).transform(t2);
  return this.attr("transform", i);
} });
class Vt extends Gt {
  flatten() {
    return this.each(function() {
      if (this instanceof Vt)
        return this.flatten().ungroup();
    }), this;
  }
  ungroup(t2 = this.parent(), e2 = t2.index(this)) {
    return e2 = -1 === e2 ? t2.children().length : e2, this.each(function(i, a2) {
      return a2[a2.length - i - 1].toParent(t2, e2);
    }), this.remove();
  }
}
q(Vt, "Container");
class Ut extends Vt {
  constructor(t2, e2 = t2) {
    super(G("defs", t2), e2);
  }
  flatten() {
    return this;
  }
  ungroup() {
    return this;
  }
}
q(Ut, "Defs");
class qt extends Gt {
}
function Zt(t2) {
  return this.attr("rx", t2);
}
function $t(t2) {
  return this.attr("ry", t2);
}
function Jt(t2) {
  return null == t2 ? this.cx() - this.rx() : this.cx(t2 + this.rx());
}
function Qt(t2) {
  return null == t2 ? this.cy() - this.ry() : this.cy(t2 + this.ry());
}
function Kt(t2) {
  return this.attr("cx", t2);
}
function te(t2) {
  return this.attr("cy", t2);
}
function ee(t2) {
  return null == t2 ? 2 * this.rx() : this.rx(new _t(t2).divide(2));
}
function ie(t2) {
  return null == t2 ? 2 * this.ry() : this.ry(new _t(t2).divide(2));
}
q(qt, "Shape");
var ae = Object.freeze({ __proto__: null, cx: Kt, cy: te, height: ie, rx: Zt, ry: $t, width: ee, x: Jt, y: Qt });
class se extends qt {
  constructor(t2, e2 = t2) {
    super(G("ellipse", t2), e2);
  }
  size(t2, e2) {
    const i = I(this, t2, e2);
    return this.rx(new _t(i.width).divide(2)).ry(new _t(i.height).divide(2));
  }
}
Q(se, ae), A("Container", { ellipse: K(function(t2 = 0, e2 = t2) {
  return this.put(new se()).size(t2, e2).move(0, 0);
}) }), q(se, "Ellipse");
class re extends Bt {
  constructor(t2 = O.document.createDocumentFragment()) {
    super(t2);
  }
  xml(t2, e2, i) {
    if ("boolean" == typeof t2 && (i = e2, e2 = t2, t2 = null), null == t2 || "function" == typeof t2) {
      const t3 = new Bt(W("wrapper", i));
      return t3.add(this.node.cloneNode(true)), t3.xml(false, i);
    }
    return super.xml(t2, false, i);
  }
}
function ne(t2, e2) {
  return "radialGradient" === (this._element || this).type ? this.attr({ fx: new _t(t2), fy: new _t(e2) }) : this.attr({ x1: new _t(t2), y1: new _t(e2) });
}
function oe(t2, e2) {
  return "radialGradient" === (this._element || this).type ? this.attr({ cx: new _t(t2), cy: new _t(e2) }) : this.attr({ x2: new _t(t2), y2: new _t(e2) });
}
q(re, "Fragment");
var le = Object.freeze({ __proto__: null, from: ne, to: oe });
class he extends Vt {
  constructor(t2, e2) {
    super(G(t2 + "Gradient", "string" == typeof t2 ? null : t2), e2);
  }
  attr(t2, e2, i) {
    return "transform" === t2 && (t2 = "gradientTransform"), super.attr(t2, e2, i);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
Q(he, le), A({ Container: { gradient(...t2) {
  return this.defs().gradient(...t2);
} }, Defs: { gradient: K(function(t2, e2) {
  return this.put(new he(t2)).update(e2);
}) } }), q(he, "Gradient");
class ce extends Vt {
  constructor(t2, e2 = t2) {
    super(G("pattern", t2), e2);
  }
  attr(t2, e2, i) {
    return "transform" === t2 && (t2 = "patternTransform"), super.attr(t2, e2, i);
  }
  bbox() {
    return new kt();
  }
  targets() {
    return Lt("svg [fill*=" + this.id() + "]");
  }
  toString() {
    return this.url();
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  url() {
    return "url(#" + this.id() + ")";
  }
}
A({ Container: { pattern(...t2) {
  return this.defs().pattern(...t2);
} }, Defs: { pattern: K(function(t2, e2, i) {
  return this.put(new ce()).update(i).attr({ x: 0, y: 0, width: t2, height: e2, patternUnits: "userSpaceOnUse" });
}) } }), q(ce, "Pattern");
let de = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("image", t2), e2);
  }
  load(t2, e2) {
    if (!t2)
      return this;
    const i = new O.window.Image();
    return zt(i, "load", function(t3) {
      const a2 = this.parent(ce);
      0 === this.width() && 0 === this.height() && this.size(i.width, i.height), a2 instanceof ce && 0 === a2.width() && 0 === a2.height() && a2.size(this.width(), this.height()), "function" == typeof e2 && e2.call(this, t3);
    }, this), zt(i, "load error", function() {
      Xt(i);
    }), this.attr("href", i.src = t2, H);
  }
};
var ue;
ue = function(t2, e2, i) {
  return "fill" !== t2 && "stroke" !== t2 || ct.test(e2) && (e2 = i.root().defs().image(e2)), e2 instanceof de && (e2 = i.root().defs().pattern(0, 0, (t3) => {
    t3.add(e2);
  })), e2;
}, Wt.push(ue), A({ Container: { image: K(function(t2, e2) {
  return this.put(new de()).size(0, 0).load(t2, e2);
}) } }), q(de, "Image");
class ge extends Dt {
  bbox() {
    let t2 = -1 / 0, e2 = -1 / 0, i = 1 / 0, a2 = 1 / 0;
    return this.forEach(function(s2) {
      t2 = Math.max(s2[0], t2), e2 = Math.max(s2[1], e2), i = Math.min(s2[0], i), a2 = Math.min(s2[1], a2);
    }), new kt(i, a2, t2 - i, e2 - a2);
  }
  move(t2, e2) {
    const i = this.bbox();
    if (t2 -= i.x, e2 -= i.y, !isNaN(t2) && !isNaN(e2))
      for (let i2 = this.length - 1; i2 >= 0; i2--)
        this[i2] = [this[i2][0] + t2, this[i2][1] + e2];
    return this;
  }
  parse(t2 = [0, 0]) {
    const e2 = [];
    (t2 = t2 instanceof Array ? Array.prototype.concat.apply([], t2) : t2.trim().split(dt).map(parseFloat)).length % 2 != 0 && t2.pop();
    for (let i = 0, a2 = t2.length; i < a2; i += 2)
      e2.push([t2[i], t2[i + 1]]);
    return e2;
  }
  size(t2, e2) {
    let i;
    const a2 = this.bbox();
    for (i = this.length - 1; i >= 0; i--)
      a2.width && (this[i][0] = (this[i][0] - a2.x) * t2 / a2.width + a2.x), a2.height && (this[i][1] = (this[i][1] - a2.y) * e2 / a2.height + a2.y);
    return this;
  }
  toLine() {
    return { x1: this[0][0], y1: this[0][1], x2: this[1][0], y2: this[1][1] };
  }
  toString() {
    const t2 = [];
    for (let e2 = 0, i = this.length; e2 < i; e2++)
      t2.push(this[e2].join(","));
    return t2.join(" ");
  }
  transform(t2) {
    return this.clone().transformO(t2);
  }
  transformO(t2) {
    vt.isMatrixLike(t2) || (t2 = new vt(t2));
    for (let e2 = this.length; e2--; ) {
      const [i, a2] = this[e2];
      this[e2][0] = t2.a * i + t2.c * a2 + t2.e, this[e2][1] = t2.b * i + t2.d * a2 + t2.f;
    }
    return this;
  }
}
const pe = ge;
var fe = Object.freeze({ __proto__: null, MorphArray: pe, height: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.height : this.size(e2.width, t2);
}, width: function(t2) {
  const e2 = this.bbox();
  return null == t2 ? e2.width : this.size(t2, e2.height);
}, x: function(t2) {
  return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
}, y: function(t2) {
  return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
} });
let xe = class extends qt {
  constructor(t2, e2 = t2) {
    super(G("line", t2), e2);
  }
  array() {
    return new ge([[this.attr("x1"), this.attr("y1")], [this.attr("x2"), this.attr("y2")]]);
  }
  move(t2, e2) {
    return this.attr(this.array().move(t2, e2).toLine());
  }
  plot(t2, e2, i, a2) {
    return null == t2 ? this.array() : (t2 = void 0 !== e2 ? { x1: t2, y1: e2, x2: i, y2: a2 } : new ge(t2).toLine(), this.attr(t2));
  }
  size(t2, e2) {
    const i = I(this, t2, e2);
    return this.attr(this.array().size(i.width, i.height).toLine());
  }
};
Q(xe, fe), A({ Container: { line: K(function(...t2) {
  return xe.prototype.plot.apply(this.put(new xe()), null != t2[0] ? t2 : [0, 0, 0, 0]);
}) } }), q(xe, "Line");
let be = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("marker", t2), e2);
  }
  height(t2) {
    return this.attr("markerHeight", t2);
  }
  orient(t2) {
    return this.attr("orient", t2);
  }
  ref(t2, e2) {
    return this.attr("refX", t2).attr("refY", e2);
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
  update(t2) {
    return this.clear(), "function" == typeof t2 && t2.call(this, this), this;
  }
  width(t2) {
    return this.attr("markerWidth", t2);
  }
};
function me(t2, e2) {
  return function(i) {
    return null == i ? this[t2] : (this[t2] = i, e2 && e2.call(this), this);
  };
}
A({ Container: { marker(...t2) {
  return this.defs().marker(...t2);
} }, Defs: { marker: K(function(t2, e2, i) {
  return this.put(new be()).size(t2, e2).ref(t2 / 2, e2 / 2).viewbox(0, 0, t2, e2).attr("orient", "auto").update(i);
}) }, marker: { marker(t2, e2, i, a2) {
  let s2 = ["marker"];
  return "all" !== t2 && s2.push(t2), s2 = s2.join("-"), t2 = arguments[1] instanceof be ? arguments[1] : this.defs().marker(e2, i, a2), this.attr(s2, t2);
} } }), q(be, "Marker");
const ve = { "-": function(t2) {
  return t2;
}, "<>": function(t2) {
  return -Math.cos(t2 * Math.PI) / 2 + 0.5;
}, ">": function(t2) {
  return Math.sin(t2 * Math.PI / 2);
}, "<": function(t2) {
  return 1 - Math.cos(t2 * Math.PI / 2);
}, bezier: function(t2, e2, i, a2) {
  return function(s2) {
    return s2 < 0 ? t2 > 0 ? e2 / t2 * s2 : i > 0 ? a2 / i * s2 : 0 : s2 > 1 ? i < 1 ? (1 - a2) / (1 - i) * s2 + (a2 - i) / (1 - i) : t2 < 1 ? (1 - e2) / (1 - t2) * s2 + (e2 - t2) / (1 - t2) : 1 : 3 * s2 * (1 - s2) ** 2 * e2 + 3 * s2 ** 2 * (1 - s2) * a2 + s2 ** 3;
  };
}, steps: function(t2, e2 = "end") {
  e2 = e2.split("-").reverse()[0];
  let i = t2;
  return "none" === e2 ? --i : "both" === e2 && ++i, (a2, s2 = false) => {
    let r2 = Math.floor(a2 * t2);
    const n2 = a2 * r2 % 1 == 0;
    return "start" !== e2 && "both" !== e2 || ++r2, s2 && n2 && --r2, a2 >= 0 && r2 < 0 && (r2 = 0), a2 <= 1 && r2 > i && (r2 = i), r2 / i;
  };
} };
class ye {
  done() {
    return false;
  }
}
class we extends ye {
  constructor(t2 = Ht) {
    super(), this.ease = ve[t2] || t2;
  }
  step(t2, e2, i) {
    return "number" != typeof t2 ? i < 1 ? t2 : e2 : t2 + (e2 - t2) * this.ease(i);
  }
}
class ke extends ye {
  constructor(t2) {
    super(), this.stepper = t2;
  }
  done(t2) {
    return t2.done;
  }
  step(t2, e2, i, a2) {
    return this.stepper(t2, e2, i, a2);
  }
}
function Ae() {
  const t2 = (this._duration || 500) / 1e3, e2 = this._overshoot || 0, i = Math.PI, a2 = Math.log(e2 / 100 + 1e-10), s2 = -a2 / Math.sqrt(i * i + a2 * a2), r2 = 3.9 / (s2 * t2);
  this.d = 2 * s2 * r2, this.k = r2 * r2;
}
Q(class extends ke {
  constructor(t2 = 500, e2 = 0) {
    super(), this.duration(t2).overshoot(e2);
  }
  step(t2, e2, i, a2) {
    if ("string" == typeof t2)
      return t2;
    if (a2.done = i === 1 / 0, i === 1 / 0)
      return e2;
    if (0 === i)
      return t2;
    i > 100 && (i = 16), i /= 1e3;
    const s2 = a2.velocity || 0, r2 = -this.d * s2 - this.k * (t2 - e2), n2 = t2 + s2 * i + r2 * i * i / 2;
    return a2.velocity = s2 + r2 * i, a2.done = Math.abs(e2 - n2) + Math.abs(s2) < 2e-3, a2.done ? e2 : n2;
  }
}, { duration: me("_duration", Ae), overshoot: me("_overshoot", Ae) });
Q(class extends ke {
  constructor(t2 = 0.1, e2 = 0.01, i = 0, a2 = 1e3) {
    super(), this.p(t2).i(e2).d(i).windup(a2);
  }
  step(t2, e2, i, a2) {
    if ("string" == typeof t2)
      return t2;
    if (a2.done = i === 1 / 0, i === 1 / 0)
      return e2;
    if (0 === i)
      return t2;
    const s2 = e2 - t2;
    let r2 = (a2.integral || 0) + s2 * i;
    const n2 = (s2 - (a2.error || 0)) / i, o2 = this._windup;
    return false !== o2 && (r2 = Math.max(-o2, Math.min(r2, o2))), a2.error = s2, a2.integral = r2, a2.done = Math.abs(s2) < 1e-3, a2.done ? e2 : t2 + (this.P * s2 + this.I * r2 + this.D * n2);
  }
}, { windup: me("_windup"), p: me("P"), i: me("I"), d: me("D") });
const Ce = { M: 2, L: 2, H: 1, V: 1, C: 6, S: 4, Q: 4, T: 2, A: 7, Z: 0 }, Se = { M: function(t2, e2, i) {
  return e2.x = i.x = t2[0], e2.y = i.y = t2[1], ["M", e2.x, e2.y];
}, L: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["L", t2[0], t2[1]];
}, H: function(t2, e2) {
  return e2.x = t2[0], ["H", t2[0]];
}, V: function(t2, e2) {
  return e2.y = t2[0], ["V", t2[0]];
}, C: function(t2, e2) {
  return e2.x = t2[4], e2.y = t2[5], ["C", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5]];
}, S: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["S", t2[0], t2[1], t2[2], t2[3]];
}, Q: function(t2, e2) {
  return e2.x = t2[2], e2.y = t2[3], ["Q", t2[0], t2[1], t2[2], t2[3]];
}, T: function(t2, e2) {
  return e2.x = t2[0], e2.y = t2[1], ["T", t2[0], t2[1]];
}, Z: function(t2, e2, i) {
  return e2.x = i.x, e2.y = i.y, ["Z"];
}, A: function(t2, e2) {
  return e2.x = t2[5], e2.y = t2[6], ["A", t2[0], t2[1], t2[2], t2[3], t2[4], t2[5], t2[6]];
} }, Le = "mlhvqtcsaz".split("");
for (let t2 = 0, e2 = Le.length; t2 < e2; ++t2)
  Se[Le[t2]] = function(t3) {
    return function(e3, i, a2) {
      if ("H" === t3)
        e3[0] = e3[0] + i.x;
      else if ("V" === t3)
        e3[0] = e3[0] + i.y;
      else if ("A" === t3)
        e3[5] = e3[5] + i.x, e3[6] = e3[6] + i.y;
      else
        for (let t4 = 0, a3 = e3.length; t4 < a3; ++t4)
          e3[t4] = e3[t4] + (t4 % 2 ? i.y : i.x);
      return Se[t3](e3, i, a2);
    };
  }(Le[t2].toUpperCase());
function Me(t2) {
  return t2.segment.length && t2.segment.length - 1 === Ce[t2.segment[0].toUpperCase()];
}
function Pe(t2, e2) {
  t2.inNumber && Ie(t2, false);
  const i = ut.test(e2);
  if (i)
    t2.segment = [e2];
  else {
    const e3 = t2.lastCommand, i2 = e3.toLowerCase(), a2 = e3 === i2;
    t2.segment = ["m" === i2 ? a2 ? "l" : "L" : e3];
  }
  return t2.inSegment = true, t2.lastCommand = t2.segment[0], i;
}
function Ie(t2, e2) {
  if (!t2.inNumber)
    throw new Error("Parser Error");
  t2.number && t2.segment.push(parseFloat(t2.number)), t2.inNumber = e2, t2.number = "", t2.pointSeen = false, t2.hasExponent = false, Me(t2) && Te(t2);
}
function Te(t2) {
  t2.inSegment = false, t2.absolute && (t2.segment = function(t3) {
    const e2 = t3.segment[0];
    return Se[e2](t3.segment.slice(1), t3.p, t3.p0);
  }(t2)), t2.segments.push(t2.segment);
}
function ze(t2) {
  if (!t2.segment.length)
    return false;
  const e2 = "A" === t2.segment[0].toUpperCase(), i = t2.segment.length;
  return e2 && (4 === i || 5 === i);
}
function Xe(t2) {
  return "E" === t2.lastToken.toUpperCase();
}
const Re = /* @__PURE__ */ new Set([" ", ",", "	", "\n", "\r", "\f"]);
class Ee extends Dt {
  bbox() {
    return yt().path.setAttribute("d", this.toString()), new kt(yt.nodes.path.getBBox());
  }
  move(t2, e2) {
    const i = this.bbox();
    if (t2 -= i.x, e2 -= i.y, !isNaN(t2) && !isNaN(e2))
      for (let i2, a2 = this.length - 1; a2 >= 0; a2--)
        i2 = this[a2][0], "M" === i2 || "L" === i2 || "T" === i2 ? (this[a2][1] += t2, this[a2][2] += e2) : "H" === i2 ? this[a2][1] += t2 : "V" === i2 ? this[a2][1] += e2 : "C" === i2 || "S" === i2 || "Q" === i2 ? (this[a2][1] += t2, this[a2][2] += e2, this[a2][3] += t2, this[a2][4] += e2, "C" === i2 && (this[a2][5] += t2, this[a2][6] += e2)) : "A" === i2 && (this[a2][6] += t2, this[a2][7] += e2);
    return this;
  }
  parse(t2 = "M0 0") {
    return Array.isArray(t2) && (t2 = Array.prototype.concat.apply([], t2).toString()), function(t3, e2 = true) {
      let i = 0, a2 = "";
      const s2 = { segment: [], inNumber: false, number: "", lastToken: "", inSegment: false, segments: [], pointSeen: false, hasExponent: false, absolute: e2, p0: new bt(), p: new bt() };
      for (; s2.lastToken = a2, a2 = t3.charAt(i++); )
        if (s2.inSegment || !Pe(s2, a2))
          if ("." !== a2)
            if (isNaN(parseInt(a2)))
              if (Re.has(a2))
                s2.inNumber && Ie(s2, false);
              else if ("-" !== a2 && "+" !== a2)
                if ("E" !== a2.toUpperCase()) {
                  if (ut.test(a2)) {
                    if (s2.inNumber)
                      Ie(s2, false);
                    else {
                      if (!Me(s2))
                        throw new Error("parser Error");
                      Te(s2);
                    }
                    --i;
                  }
                } else
                  s2.number += a2, s2.hasExponent = true;
              else {
                if (s2.inNumber && !Xe(s2)) {
                  Ie(s2, false), --i;
                  continue;
                }
                s2.number += a2, s2.inNumber = true;
              }
            else {
              if ("0" === s2.number || ze(s2)) {
                s2.inNumber = true, s2.number = a2, Ie(s2, true);
                continue;
              }
              s2.inNumber = true, s2.number += a2;
            }
          else {
            if (s2.pointSeen || s2.hasExponent) {
              Ie(s2, false), --i;
              continue;
            }
            s2.inNumber = true, s2.pointSeen = true, s2.number += a2;
          }
      return s2.inNumber && Ie(s2, false), s2.inSegment && Me(s2) && Te(s2), s2.segments;
    }(t2);
  }
  size(t2, e2) {
    const i = this.bbox();
    let a2, s2;
    for (i.width = 0 === i.width ? 1 : i.width, i.height = 0 === i.height ? 1 : i.height, a2 = this.length - 1; a2 >= 0; a2--)
      s2 = this[a2][0], "M" === s2 || "L" === s2 || "T" === s2 ? (this[a2][1] = (this[a2][1] - i.x) * t2 / i.width + i.x, this[a2][2] = (this[a2][2] - i.y) * e2 / i.height + i.y) : "H" === s2 ? this[a2][1] = (this[a2][1] - i.x) * t2 / i.width + i.x : "V" === s2 ? this[a2][1] = (this[a2][1] - i.y) * e2 / i.height + i.y : "C" === s2 || "S" === s2 || "Q" === s2 ? (this[a2][1] = (this[a2][1] - i.x) * t2 / i.width + i.x, this[a2][2] = (this[a2][2] - i.y) * e2 / i.height + i.y, this[a2][3] = (this[a2][3] - i.x) * t2 / i.width + i.x, this[a2][4] = (this[a2][4] - i.y) * e2 / i.height + i.y, "C" === s2 && (this[a2][5] = (this[a2][5] - i.x) * t2 / i.width + i.x, this[a2][6] = (this[a2][6] - i.y) * e2 / i.height + i.y)) : "A" === s2 && (this[a2][1] = this[a2][1] * t2 / i.width, this[a2][2] = this[a2][2] * e2 / i.height, this[a2][6] = (this[a2][6] - i.x) * t2 / i.width + i.x, this[a2][7] = (this[a2][7] - i.y) * e2 / i.height + i.y);
    return this;
  }
  toString() {
    return function(t2) {
      let e2 = "";
      for (let i = 0, a2 = t2.length; i < a2; i++)
        e2 += t2[i][0], null != t2[i][1] && (e2 += t2[i][1], null != t2[i][2] && (e2 += " ", e2 += t2[i][2], null != t2[i][3] && (e2 += " ", e2 += t2[i][3], e2 += " ", e2 += t2[i][4], null != t2[i][5] && (e2 += " ", e2 += t2[i][5], e2 += " ", e2 += t2[i][6], null != t2[i][7] && (e2 += " ", e2 += t2[i][7])))));
      return e2 + " ";
    }(this);
  }
}
const Ye = (t2) => {
  const e2 = typeof t2;
  return "number" === e2 ? _t : "string" === e2 ? xt.isColor(t2) ? xt : dt.test(t2) ? ut.test(t2) ? Ee : Dt : tt.test(t2) ? _t : Oe : Ne.indexOf(t2.constructor) > -1 ? t2.constructor : Array.isArray(t2) ? Dt : "object" === e2 ? _e : Oe;
};
class He {
  constructor(t2) {
    this._stepper = t2 || new we("-"), this._from = null, this._to = null, this._type = null, this._context = null, this._morphObj = null;
  }
  at(t2) {
    return this._morphObj.morph(this._from, this._to, t2, this._stepper, this._context);
  }
  done() {
    return this._context.map(this._stepper.done).reduce(function(t2, e2) {
      return t2 && e2;
    }, true);
  }
  from(t2) {
    return null == t2 ? this._from : (this._from = this._set(t2), this);
  }
  stepper(t2) {
    return null == t2 ? this._stepper : (this._stepper = t2, this);
  }
  to(t2) {
    return null == t2 ? this._to : (this._to = this._set(t2), this);
  }
  type(t2) {
    return null == t2 ? this._type : (this._type = t2, this);
  }
  _set(t2) {
    this._type || this.type(Ye(t2));
    let e2 = new this._type(t2);
    return this._type === xt && (e2 = this._to ? e2[this._to[4]]() : this._from ? e2[this._from[4]]() : e2), this._type === _e && (e2 = this._to ? e2.align(this._to) : this._from ? e2.align(this._from) : e2), e2 = e2.toConsumable(), this._morphObj = this._morphObj || new this._type(), this._context = this._context || Array.apply(null, Array(e2.length)).map(Object).map(function(t3) {
      return t3.done = true, t3;
    }), e2;
  }
}
class Oe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return t2 = Array.isArray(t2) ? t2[0] : t2, this.value = t2, this;
  }
  toArray() {
    return [this.value];
  }
  valueOf() {
    return this.value;
  }
}
class Fe {
  constructor(...t2) {
    this.init(...t2);
  }
  init(t2) {
    return Array.isArray(t2) && (t2 = { scaleX: t2[0], scaleY: t2[1], shear: t2[2], rotate: t2[3], translateX: t2[4], translateY: t2[5], originX: t2[6], originY: t2[7] }), Object.assign(this, Fe.defaults, t2), this;
  }
  toArray() {
    const t2 = this;
    return [t2.scaleX, t2.scaleY, t2.shear, t2.rotate, t2.translateX, t2.translateY, t2.originX, t2.originY];
  }
}
Fe.defaults = { scaleX: 1, scaleY: 1, shear: 0, rotate: 0, translateX: 0, translateY: 0, originX: 0, originY: 0 };
const De = (t2, e2) => t2[0] < e2[0] ? -1 : t2[0] > e2[0] ? 1 : 0;
class _e {
  constructor(...t2) {
    this.init(...t2);
  }
  align(t2) {
    const e2 = this.values;
    for (let i = 0, a2 = e2.length; i < a2; ++i) {
      if (e2[i + 1] === t2[i + 1]) {
        if (e2[i + 1] === xt && t2[i + 7] !== e2[i + 7]) {
          const e3 = t2[i + 7], a4 = new xt(this.values.splice(i + 3, 5))[e3]().toArray();
          this.values.splice(i + 3, 0, ...a4);
        }
        i += e2[i + 2] + 2;
        continue;
      }
      if (!t2[i + 1])
        return this;
      const a3 = new t2[i + 1]().toArray(), s2 = e2[i + 2] + 3;
      e2.splice(i, s2, t2[i], t2[i + 1], t2[i + 2], ...a3), i += e2[i + 2] + 2;
    }
    return this;
  }
  init(t2) {
    if (this.values = [], Array.isArray(t2))
      return void (this.values = t2.slice());
    t2 = t2 || {};
    const e2 = [];
    for (const i in t2) {
      const a2 = Ye(t2[i]), s2 = new a2(t2[i]).toArray();
      e2.push([i, a2, s2.length, ...s2]);
    }
    return e2.sort(De), this.values = e2.reduce((t3, e3) => t3.concat(e3), []), this;
  }
  toArray() {
    return this.values;
  }
  valueOf() {
    const t2 = {}, e2 = this.values;
    for (; e2.length; ) {
      const i = e2.shift(), a2 = e2.shift(), s2 = e2.shift(), r2 = e2.splice(0, s2);
      t2[i] = new a2(r2);
    }
    return t2;
  }
}
const Ne = [Oe, Fe, _e];
class We extends qt {
  constructor(t2, e2 = t2) {
    super(G("path", t2), e2);
  }
  array() {
    return this._array || (this._array = new Ee(this.attr("d")));
  }
  clear() {
    return delete this._array, this;
  }
  height(t2) {
    return null == t2 ? this.bbox().height : this.size(this.bbox().width, t2);
  }
  move(t2, e2) {
    return this.attr("d", this.array().move(t2, e2));
  }
  plot(t2) {
    return null == t2 ? this.array() : this.clear().attr("d", "string" == typeof t2 ? t2 : this._array = new Ee(t2));
  }
  size(t2, e2) {
    const i = I(this, t2, e2);
    return this.attr("d", this.array().size(i.width, i.height));
  }
  width(t2) {
    return null == t2 ? this.bbox().width : this.size(t2, this.bbox().height);
  }
  x(t2) {
    return null == t2 ? this.bbox().x : this.move(t2, this.bbox().y);
  }
  y(t2) {
    return null == t2 ? this.bbox().y : this.move(this.bbox().x, t2);
  }
}
We.prototype.MorphArray = Ee, A({ Container: { path: K(function(t2) {
  return this.put(new We()).plot(t2 || new Ee());
}) } }), q(We, "Path");
var Be = Object.freeze({ __proto__: null, array: function() {
  return this._array || (this._array = new ge(this.attr("points")));
}, clear: function() {
  return delete this._array, this;
}, move: function(t2, e2) {
  return this.attr("points", this.array().move(t2, e2));
}, plot: function(t2) {
  return null == t2 ? this.array() : this.clear().attr("points", "string" == typeof t2 ? t2 : this._array = new ge(t2));
}, size: function(t2, e2) {
  const i = I(this, t2, e2);
  return this.attr("points", this.array().size(i.width, i.height));
} });
class Ge extends qt {
  constructor(t2, e2 = t2) {
    super(G("polygon", t2), e2);
  }
}
A({ Container: { polygon: K(function(t2) {
  return this.put(new Ge()).plot(t2 || new ge());
}) } }), Q(Ge, fe), Q(Ge, Be), q(Ge, "Polygon");
class je extends qt {
  constructor(t2, e2 = t2) {
    super(G("polyline", t2), e2);
  }
}
A({ Container: { polyline: K(function(t2) {
  return this.put(new je()).plot(t2 || new ge());
}) } }), Q(je, fe), Q(je, Be), q(je, "Polyline");
class Ve extends qt {
  constructor(t2, e2 = t2) {
    super(G("rect", t2), e2);
  }
}
Q(Ve, { rx: Zt, ry: $t }), A({ Container: { rect: K(function(t2, e2) {
  return this.put(new Ve()).size(t2, e2);
}) } }), q(Ve, "Rect");
class Ue {
  constructor() {
    this._first = null, this._last = null;
  }
  first() {
    return this._first && this._first.value;
  }
  last() {
    return this._last && this._last.value;
  }
  push(t2) {
    const e2 = void 0 !== t2.next ? t2 : { value: t2, next: null, prev: null };
    return this._last ? (e2.prev = this._last, this._last.next = e2, this._last = e2) : (this._last = e2, this._first = e2), e2;
  }
  remove(t2) {
    t2.prev && (t2.prev.next = t2.next), t2.next && (t2.next.prev = t2.prev), t2 === this._last && (this._last = t2.prev), t2 === this._first && (this._first = t2.next), t2.prev = null, t2.next = null;
  }
  shift() {
    const t2 = this._first;
    return t2 ? (this._first = t2.next, this._first && (this._first.prev = null), this._last = this._first ? this._last : null, t2.value) : null;
  }
}
const qe = { nextDraw: null, frames: new Ue(), timeouts: new Ue(), immediates: new Ue(), timer: () => O.window.performance || O.window.Date, transforms: [], frame(t2) {
  const e2 = qe.frames.push({ run: t2 });
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, timeout(t2, e2) {
  e2 = e2 || 0;
  const i = qe.timer().now() + e2, a2 = qe.timeouts.push({ run: t2, time: i });
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), a2;
}, immediate(t2) {
  const e2 = qe.immediates.push(t2);
  return null === qe.nextDraw && (qe.nextDraw = O.window.requestAnimationFrame(qe._draw)), e2;
}, cancelFrame(t2) {
  null != t2 && qe.frames.remove(t2);
}, clearTimeout(t2) {
  null != t2 && qe.timeouts.remove(t2);
}, cancelImmediate(t2) {
  null != t2 && qe.immediates.remove(t2);
}, _draw(t2) {
  let e2 = null;
  const i = qe.timeouts.last();
  for (; (e2 = qe.timeouts.shift()) && (t2 >= e2.time ? e2.run() : qe.timeouts.push(e2), e2 !== i); )
    ;
  let a2 = null;
  const s2 = qe.frames.last();
  for (; a2 !== s2 && (a2 = qe.frames.shift()); )
    a2.run(t2);
  let r2 = null;
  for (; r2 = qe.immediates.shift(); )
    r2();
  qe.nextDraw = qe.timeouts.first() || qe.frames.first() ? O.window.requestAnimationFrame(qe._draw) : null;
} }, Ze = function(t2) {
  const e2 = t2.start, i = t2.runner.duration();
  return { start: e2, duration: i, end: e2 + i, runner: t2.runner };
}, $e = function() {
  const t2 = O.window;
  return (t2.performance || t2.Date).now();
};
class Je extends Rt {
  constructor(t2 = $e) {
    super(), this._timeSource = t2, this.terminate();
  }
  active() {
    return !!this._nextFrame;
  }
  finish() {
    return this.time(this.getEndTimeOfTimeline() + 1), this.pause();
  }
  getEndTime() {
    const t2 = this.getLastRunnerInfo(), e2 = t2 ? t2.runner.duration() : 0;
    return (t2 ? t2.start : this._time) + e2;
  }
  getEndTimeOfTimeline() {
    const t2 = this._runners.map((t3) => t3.start + t3.runner.duration());
    return Math.max(0, ...t2);
  }
  getLastRunnerInfo() {
    return this.getRunnerInfoById(this._lastRunnerId);
  }
  getRunnerInfoById(t2) {
    return this._runners[this._runnerIds.indexOf(t2)] || null;
  }
  pause() {
    return this._paused = true, this._continue();
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  play() {
    return this._paused = false, this.updateTime()._continue();
  }
  reverse(t2) {
    const e2 = this.speed();
    if (null == t2)
      return this.speed(-e2);
    const i = Math.abs(e2);
    return this.speed(t2 ? -i : i);
  }
  schedule(t2, e2, i) {
    if (null == t2)
      return this._runners.map(Ze);
    let a2 = 0;
    const s2 = this.getEndTime();
    if (e2 = e2 || 0, null == i || "last" === i || "after" === i)
      a2 = s2;
    else if ("absolute" === i || "start" === i)
      a2 = e2, e2 = 0;
    else if ("now" === i)
      a2 = this._time;
    else if ("relative" === i) {
      const i2 = this.getRunnerInfoById(t2.id);
      i2 && (a2 = i2.start + e2, e2 = 0);
    } else {
      if ("with-last" !== i)
        throw new Error('Invalid value for the "when" parameter');
      {
        const t3 = this.getLastRunnerInfo();
        a2 = t3 ? t3.start : this._time;
      }
    }
    t2.unschedule(), t2.timeline(this);
    const r2 = t2.persist(), n2 = { persist: null === r2 ? this._persist : r2, start: a2 + e2, runner: t2 };
    return this._lastRunnerId = t2.id, this._runners.push(n2), this._runners.sort((t3, e3) => t3.start - e3.start), this._runnerIds = this._runners.map((t3) => t3.runner.id), this.updateTime()._continue(), this;
  }
  seek(t2) {
    return this.time(this._time + t2);
  }
  source(t2) {
    return null == t2 ? this._timeSource : (this._timeSource = t2, this);
  }
  speed(t2) {
    return null == t2 ? this._speed : (this._speed = t2, this);
  }
  stop() {
    return this.time(0), this.pause();
  }
  time(t2) {
    return null == t2 ? this._time : (this._time = t2, this._continue(true));
  }
  unschedule(t2) {
    const e2 = this._runnerIds.indexOf(t2.id);
    return e2 < 0 || (this._runners.splice(e2, 1), this._runnerIds.splice(e2, 1), t2.timeline(null)), this;
  }
  updateTime() {
    return this.active() || (this._lastSourceTime = this._timeSource()), this;
  }
  _continue(t2 = false) {
    return qe.cancelFrame(this._nextFrame), this._nextFrame = null, t2 ? this._stepImmediate() : (this._paused || (this._nextFrame = qe.frame(this._step)), this);
  }
  _stepFn(t2 = false) {
    const e2 = this._timeSource();
    let i = e2 - this._lastSourceTime;
    t2 && (i = 0);
    const a2 = this._speed * i + (this._time - this._lastStepTime);
    this._lastSourceTime = e2, t2 || (this._time += a2, this._time = this._time < 0 ? 0 : this._time), this._lastStepTime = this._time, this.fire("time", this._time);
    for (let t3 = this._runners.length; t3--; ) {
      const e3 = this._runners[t3], i2 = e3.runner;
      this._time - e3.start <= 0 && i2.reset();
    }
    let s2 = false;
    for (let t3 = 0, e3 = this._runners.length; t3 < e3; t3++) {
      const i2 = this._runners[t3], r2 = i2.runner;
      let n2 = a2;
      const o2 = this._time - i2.start;
      if (o2 <= 0) {
        s2 = true;
        continue;
      }
      if (o2 < n2 && (n2 = o2), !r2.active())
        continue;
      if (r2.step(n2).done) {
        if (true !== i2.persist) {
          r2.duration() - r2.time() + this._time + i2.persist < this._time && (r2.unschedule(), --t3, --e3);
        }
      } else
        s2 = true;
    }
    return s2 && !(this._speed < 0 && 0 === this._time) || this._runnerIds.length && this._speed < 0 && this._time > 0 ? this._continue() : (this.pause(), this.fire("finished")), this;
  }
  terminate() {
    this._startTime = 0, this._speed = 1, this._persist = 0, this._nextFrame = null, this._paused = true, this._runners = [], this._runnerIds = [], this._lastRunnerId = -1, this._time = 0, this._lastSourceTime = 0, this._lastStepTime = 0, this._step = this._stepFn.bind(this, false), this._stepImmediate = this._stepFn.bind(this, true);
  }
}
A({ Element: { timeline: function(t2) {
  return null == t2 ? (this._timeline = this._timeline || new Je(), this._timeline) : (this._timeline = t2, this);
} } });
class Qe extends Rt {
  constructor(t2) {
    super(), this.id = Qe.id++, t2 = "function" == typeof (t2 = null == t2 ? Yt : t2) ? new ke(t2) : t2, this._element = null, this._timeline = null, this.done = false, this._queue = [], this._duration = "number" == typeof t2 && t2, this._isDeclarative = t2 instanceof ke, this._stepper = this._isDeclarative ? t2 : new we(), this._history = {}, this.enabled = true, this._time = 0, this._lastTime = 0, this._reseted = true, this.transforms = new vt(), this.transformId = 1, this._haveReversed = false, this._reverse = false, this._loopsDone = 0, this._swing = false, this._wait = 0, this._times = 1, this._frameId = null, this._persist = !!this._isDeclarative || null;
  }
  static sanitise(t2, e2, i) {
    let a2 = 1, s2 = false, r2 = 0;
    return e2 = e2 ?? Ot, i = i || "last", "object" != typeof (t2 = t2 ?? Yt) || t2 instanceof ye || (e2 = t2.delay ?? e2, i = t2.when ?? i, s2 = t2.swing || s2, a2 = t2.times ?? a2, r2 = t2.wait ?? r2, t2 = t2.duration ?? Yt), { duration: t2, delay: e2, swing: s2, times: a2, wait: r2, when: i };
  }
  active(t2) {
    return null == t2 ? this.enabled : (this.enabled = t2, this);
  }
  addTransform(t2) {
    return this.transforms.lmultiplyO(t2), this;
  }
  after(t2) {
    return this.on("finished", t2);
  }
  animate(t2, e2, i) {
    const a2 = Qe.sanitise(t2, e2, i), s2 = new Qe(a2.duration);
    return this._timeline && s2.timeline(this._timeline), this._element && s2.element(this._element), s2.loop(a2).schedule(a2.delay, a2.when);
  }
  clearTransform() {
    return this.transforms = new vt(), this;
  }
  clearTransformsFromQueue() {
    this.done && this._timeline && this._timeline._runnerIds.includes(this.id) || (this._queue = this._queue.filter((t2) => !t2.isTransform));
  }
  delay(t2) {
    return this.animate(0, t2);
  }
  duration() {
    return this._times * (this._wait + this._duration) - this._wait;
  }
  during(t2) {
    return this.queue(null, t2);
  }
  ease(t2) {
    return this._stepper = new we(t2), this;
  }
  element(t2) {
    return null == t2 ? this._element : (this._element = t2, t2._prepareRunner(), this);
  }
  finish() {
    return this.step(1 / 0);
  }
  loop(t2, e2, i) {
    return "object" == typeof t2 && (e2 = t2.swing, i = t2.wait, t2 = t2.times), this._times = t2 || 1 / 0, this._swing = e2 || false, this._wait = i || 0, true === this._times && (this._times = 1 / 0), this;
  }
  loops(t2) {
    const e2 = this._duration + this._wait;
    if (null == t2) {
      const t3 = Math.floor(this._time / e2), i2 = (this._time - t3 * e2) / this._duration;
      return Math.min(t3 + i2, this._times);
    }
    const i = t2 % 1, a2 = e2 * Math.floor(t2) + this._duration * i;
    return this.time(a2);
  }
  persist(t2) {
    return null == t2 ? this._persist : (this._persist = t2, this);
  }
  position(t2) {
    const e2 = this._time, i = this._duration, a2 = this._wait, s2 = this._times, r2 = this._swing, n2 = this._reverse;
    let o2;
    if (null == t2) {
      const t3 = function(t4) {
        const e3 = r2 * Math.floor(t4 % (2 * (a2 + i)) / (a2 + i)), s3 = e3 && !n2 || !e3 && n2, o3 = Math.pow(-1, s3) * (t4 % (a2 + i)) / i + s3;
        return Math.max(Math.min(o3, 1), 0);
      }, l3 = s2 * (a2 + i) - a2;
      return o2 = e2 <= 0 ? Math.round(t3(1e-5)) : e2 < l3 ? t3(e2) : Math.round(t3(l3 - 1e-5)), o2;
    }
    const l2 = Math.floor(this.loops()), h2 = r2 && l2 % 2 == 0;
    return o2 = l2 + (h2 && !n2 || n2 && h2 ? t2 : 1 - t2), this.loops(o2);
  }
  progress(t2) {
    return null == t2 ? Math.min(1, this._time / this.duration()) : this.time(t2 * this.duration());
  }
  queue(t2, e2, i, a2) {
    this._queue.push({ initialiser: t2 || Et, runner: e2 || Et, retarget: i, isTransform: a2, initialised: false, finished: false });
    return this.timeline() && this.timeline()._continue(), this;
  }
  reset() {
    return this._reseted || (this.time(0), this._reseted = true), this;
  }
  reverse(t2) {
    return this._reverse = null == t2 ? !this._reverse : t2, this;
  }
  schedule(t2, e2, i) {
    if (t2 instanceof Je || (i = e2, e2 = t2, t2 = this.timeline()), !t2)
      throw Error("Runner cannot be scheduled without timeline");
    return t2.schedule(this, e2, i), this;
  }
  step(t2) {
    if (!this.enabled)
      return this;
    t2 = null == t2 ? 16 : t2, this._time += t2;
    const e2 = this.position(), i = this._lastPosition !== e2 && this._time >= 0;
    this._lastPosition = e2;
    const a2 = this.duration(), s2 = this._lastTime <= 0 && this._time > 0, r2 = this._lastTime < a2 && this._time >= a2;
    this._lastTime = this._time, s2 && this.fire("start", this);
    const n2 = this._isDeclarative;
    this.done = !n2 && !r2 && this._time >= a2, this._reseted = false;
    let o2 = false;
    return (i || n2) && (this._initialise(i), this.transforms = new vt(), o2 = this._run(n2 ? t2 : e2), this.fire("step", this)), this.done = this.done || o2 && n2, r2 && this.fire("finished", this), this;
  }
  time(t2) {
    if (null == t2)
      return this._time;
    const e2 = t2 - this._time;
    return this.step(e2), this;
  }
  timeline(t2) {
    return void 0 === t2 ? this._timeline : (this._timeline = t2, this);
  }
  unschedule() {
    const t2 = this.timeline();
    return t2 && t2.unschedule(this), this;
  }
  _initialise(t2) {
    if (t2 || this._isDeclarative)
      for (let e2 = 0, i = this._queue.length; e2 < i; ++e2) {
        const i2 = this._queue[e2], a2 = this._isDeclarative || !i2.initialised && t2;
        t2 = !i2.finished, a2 && t2 && (i2.initialiser.call(this), i2.initialised = true);
      }
  }
  _rememberMorpher(t2, e2) {
    if (this._history[t2] = { morpher: e2, caller: this._queue[this._queue.length - 1] }, this._isDeclarative) {
      const t3 = this.timeline();
      t3 && t3.play();
    }
  }
  _run(t2) {
    let e2 = true;
    for (let i = 0, a2 = this._queue.length; i < a2; ++i) {
      const a3 = this._queue[i], s2 = a3.runner.call(this, t2);
      a3.finished = a3.finished || true === s2, e2 = e2 && a3.finished;
    }
    return e2;
  }
  _tryRetarget(t2, e2, i) {
    if (this._history[t2]) {
      if (!this._history[t2].caller.initialised) {
        const e3 = this._queue.indexOf(this._history[t2].caller);
        return this._queue.splice(e3, 1), false;
      }
      this._history[t2].caller.retarget ? this._history[t2].caller.retarget.call(this, e2, i) : this._history[t2].morpher.to(e2), this._history[t2].caller.finished = false;
      const a2 = this.timeline();
      return a2 && a2.play(), true;
    }
    return false;
  }
}
Qe.id = 0;
class Ke {
  constructor(t2 = new vt(), e2 = -1, i = true) {
    this.transforms = t2, this.id = e2, this.done = i;
  }
  clearTransformsFromQueue() {
  }
}
Q([Qe, Ke], { mergeWith(t2) {
  return new Ke(t2.transforms.lmultiply(this.transforms), t2.id);
} });
const ti = (t2, e2) => t2.lmultiplyO(e2), ei = (t2) => t2.transforms;
function ii() {
  const t2 = this._transformationRunners.runners.map(ei).reduce(ti, new vt());
  this.transform(t2), this._transformationRunners.merge(), 1 === this._transformationRunners.length() && (this._frameId = null);
}
class ai {
  constructor() {
    this.runners = [], this.ids = [];
  }
  add(t2) {
    if (this.runners.includes(t2))
      return;
    const e2 = t2.id + 1;
    return this.runners.push(t2), this.ids.push(e2), this;
  }
  clearBefore(t2) {
    const e2 = this.ids.indexOf(t2 + 1) || 1;
    return this.ids.splice(0, e2, 0), this.runners.splice(0, e2, new Ke()).forEach((t3) => t3.clearTransformsFromQueue()), this;
  }
  edit(t2, e2) {
    const i = this.ids.indexOf(t2 + 1);
    return this.ids.splice(i, 1, t2 + 1), this.runners.splice(i, 1, e2), this;
  }
  getByID(t2) {
    return this.runners[this.ids.indexOf(t2 + 1)];
  }
  length() {
    return this.ids.length;
  }
  merge() {
    let t2 = null;
    for (let e2 = 0; e2 < this.runners.length; ++e2) {
      const i = this.runners[e2];
      if (t2 && i.done && t2.done && (!i._timeline || !i._timeline._runnerIds.includes(i.id)) && (!t2._timeline || !t2._timeline._runnerIds.includes(t2.id))) {
        this.remove(i.id);
        const a2 = i.mergeWith(t2);
        this.edit(t2.id, a2), t2 = a2, --e2;
      } else
        t2 = i;
    }
    return this;
  }
  remove(t2) {
    const e2 = this.ids.indexOf(t2 + 1);
    return this.ids.splice(e2, 1), this.runners.splice(e2, 1), this;
  }
}
A({ Element: { animate(t2, e2, i) {
  const a2 = Qe.sanitise(t2, e2, i), s2 = this.timeline();
  return new Qe(a2.duration).loop(a2).element(this).timeline(s2.play()).schedule(a2.delay, a2.when);
}, delay(t2, e2) {
  return this.animate(0, t2, e2);
}, _clearTransformRunnersBefore(t2) {
  this._transformationRunners.clearBefore(t2.id);
}, _currentTransform(t2) {
  return this._transformationRunners.runners.filter((e2) => e2.id <= t2.id).map(ei).reduce(ti, new vt());
}, _addRunner(t2) {
  this._transformationRunners.add(t2), qe.cancelImmediate(this._frameId), this._frameId = qe.immediate(ii.bind(this));
}, _prepareRunner() {
  null == this._frameId && (this._transformationRunners = new ai().add(new Ke(new vt(this))));
} } });
Q(Qe, { attr(t2, e2) {
  return this.styleAttr("attr", t2, e2);
}, css(t2, e2) {
  return this.styleAttr("css", t2, e2);
}, styleAttr(t2, e2, i) {
  if ("string" == typeof e2)
    return this.styleAttr(t2, { [e2]: i });
  let a2 = e2;
  if (this._tryRetarget(t2, a2))
    return this;
  let s2 = new He(this._stepper).to(a2), r2 = Object.keys(a2);
  return this.queue(function() {
    s2 = s2.from(this.element()[t2](r2));
  }, function(e3) {
    return this.element()[t2](s2.at(e3).valueOf()), s2.done();
  }, function(e3) {
    const i2 = Object.keys(e3), n2 = (o2 = r2, i2.filter((t3) => !o2.includes(t3)));
    var o2;
    if (n2.length) {
      const e4 = this.element()[t2](n2), i3 = new _e(s2.from()).valueOf();
      Object.assign(i3, e4), s2.from(i3);
    }
    const l2 = new _e(s2.to()).valueOf();
    Object.assign(l2, e3), s2.to(l2), r2 = i2, a2 = e3;
  }), this._rememberMorpher(t2, s2), this;
}, zoom(t2, e2) {
  if (this._tryRetarget("zoom", t2, e2))
    return this;
  let i = new He(this._stepper).to(new _t(t2));
  return this.queue(function() {
    i = i.from(this.element().zoom());
  }, function(t3) {
    return this.element().zoom(i.at(t3), e2), i.done();
  }, function(t3, a2) {
    e2 = a2, i.to(t3);
  }), this._rememberMorpher("zoom", i), this;
}, transform(t2, e2, i) {
  if (e2 = t2.relative || e2, this._isDeclarative && !e2 && this._tryRetarget("transform", t2))
    return this;
  const a2 = vt.isMatrixLike(t2);
  i = null != t2.affine ? t2.affine : null != i ? i : !a2;
  const s2 = new He(this._stepper).type(i ? Fe : vt);
  let r2, n2, o2, l2, h2;
  return this.queue(function() {
    n2 = n2 || this.element(), r2 = r2 || T(t2, n2), h2 = new vt(e2 ? void 0 : n2), n2._addRunner(this), e2 || n2._clearTransformRunnersBefore(this);
  }, function(c2) {
    e2 || this.clearTransform();
    const { x: d2, y: u2 } = new bt(r2).transform(n2._currentTransform(this));
    let g2 = new vt({ ...t2, origin: [d2, u2] }), p2 = this._isDeclarative && o2 ? o2 : h2;
    if (i) {
      g2 = g2.decompose(d2, u2), p2 = p2.decompose(d2, u2);
      const t3 = g2.rotate, e3 = p2.rotate, i2 = [t3 - 360, t3, t3 + 360], a3 = i2.map((t4) => Math.abs(t4 - e3)), s3 = Math.min(...a3), r3 = a3.indexOf(s3);
      g2.rotate = i2[r3];
    }
    e2 && (a2 || (g2.rotate = t2.rotate || 0), this._isDeclarative && l2 && (p2.rotate = l2)), s2.from(p2), s2.to(g2);
    const f2 = s2.at(c2);
    return l2 = f2.rotate, o2 = new vt(f2), this.addTransform(o2), n2._addRunner(this), s2.done();
  }, function(e3) {
    (e3.origin || "center").toString() !== (t2.origin || "center").toString() && (r2 = T(e3, n2)), t2 = { ...e3, origin: r2 };
  }, true), this._isDeclarative && this._rememberMorpher("transform", s2), this;
}, x(t2) {
  return this._queueNumber("x", t2);
}, y(t2) {
  return this._queueNumber("y", t2);
}, ax(t2) {
  return this._queueNumber("ax", t2);
}, ay(t2) {
  return this._queueNumber("ay", t2);
}, dx(t2 = 0) {
  return this._queueNumberDelta("x", t2);
}, dy(t2 = 0) {
  return this._queueNumberDelta("y", t2);
}, dmove(t2, e2) {
  return this.dx(t2).dy(e2);
}, _queueNumberDelta(t2, e2) {
  if (e2 = new _t(e2), this._tryRetarget(t2, e2))
    return this;
  const i = new He(this._stepper).to(e2);
  let a2 = null;
  return this.queue(function() {
    a2 = this.element()[t2](), i.from(a2), i.to(a2 + e2);
  }, function(e3) {
    return this.element()[t2](i.at(e3)), i.done();
  }, function(t3) {
    i.to(a2 + new _t(t3));
  }), this._rememberMorpher(t2, i), this;
}, _queueObject(t2, e2) {
  if (this._tryRetarget(t2, e2))
    return this;
  const i = new He(this._stepper).to(e2);
  return this.queue(function() {
    i.from(this.element()[t2]());
  }, function(e3) {
    return this.element()[t2](i.at(e3)), i.done();
  }), this._rememberMorpher(t2, i), this;
}, _queueNumber(t2, e2) {
  return this._queueObject(t2, new _t(e2));
}, cx(t2) {
  return this._queueNumber("cx", t2);
}, cy(t2) {
  return this._queueNumber("cy", t2);
}, move(t2, e2) {
  return this.x(t2).y(e2);
}, amove(t2, e2) {
  return this.ax(t2).ay(e2);
}, center(t2, e2) {
  return this.cx(t2).cy(e2);
}, size(t2, e2) {
  let i;
  return t2 && e2 || (i = this._element.bbox()), t2 || (t2 = i.width / i.height * e2), e2 || (e2 = i.height / i.width * t2), this.width(t2).height(e2);
}, width(t2) {
  return this._queueNumber("width", t2);
}, height(t2) {
  return this._queueNumber("height", t2);
}, plot(t2, e2, i, a2) {
  if (4 === arguments.length)
    return this.plot([t2, e2, i, a2]);
  if (this._tryRetarget("plot", t2))
    return this;
  const s2 = new He(this._stepper).type(this._element.MorphArray).to(t2);
  return this.queue(function() {
    s2.from(this._element.array());
  }, function(t3) {
    return this._element.plot(s2.at(t3)), s2.done();
  }), this._rememberMorpher("plot", s2), this;
}, leading(t2) {
  return this._queueNumber("leading", t2);
}, viewbox(t2, e2, i, a2) {
  return this._queueObject("viewbox", new kt(t2, e2, i, a2));
}, update(t2) {
  return "object" != typeof t2 ? this.update({ offset: arguments[0], color: arguments[1], opacity: arguments[2] }) : (null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", t2.offset), this);
} }), Q(Qe, { rx: Zt, ry: $t, from: ne, to: oe }), q(Qe, "Runner");
class si extends Vt {
  constructor(t2, e2 = t2) {
    super(G("svg", t2), e2), this.namespace();
  }
  defs() {
    return this.isRoot() ? V(this.node.querySelector("defs")) || this.put(new Ut()) : this.root().defs();
  }
  isRoot() {
    return !this.node.parentNode || !(this.node.parentNode instanceof O.window.SVGElement) && "#document-fragment" !== this.node.parentNode.nodeName;
  }
  namespace() {
    return this.isRoot() ? this.attr({ xmlns: E, version: "1.1" }).attr("xmlns:xlink", H, Y) : this.root().namespace();
  }
  removeNamespace() {
    return this.attr({ xmlns: null, version: null }).attr("xmlns:xlink", null, Y).attr("xmlns:svgjs", null, Y);
  }
  root() {
    return this.isRoot() ? this : super.root();
  }
}
A({ Container: { nested: K(function() {
  return this.put(new si());
}) } }), q(si, "Svg", true);
let ri = class extends Vt {
  constructor(t2, e2 = t2) {
    super(G("symbol", t2), e2);
  }
};
A({ Container: { symbol: K(function() {
  return this.put(new ri());
}) } }), q(ri, "Symbol");
var ni = Object.freeze({ __proto__: null, amove: function(t2, e2) {
  return this.ax(t2).ay(e2);
}, ax: function(t2) {
  return this.attr("x", t2);
}, ay: function(t2) {
  return this.attr("y", t2);
}, build: function(t2) {
  return this._build = !!t2, this;
}, center: function(t2, e2, i = this.bbox()) {
  return this.cx(t2, i).cy(e2, i);
}, cx: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cx : this.attr("x", this.attr("x") + t2 - e2.cx);
}, cy: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.cy : this.attr("y", this.attr("y") + t2 - e2.cy);
}, length: function() {
  return this.node.getComputedTextLength();
}, move: function(t2, e2, i = this.bbox()) {
  return this.x(t2, i).y(e2, i);
}, plain: function(t2) {
  return false === this._build && this.clear(), this.node.appendChild(O.document.createTextNode(t2)), this;
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.attr("x", this.attr("x") + t2 - e2.x);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.attr("y", this.attr("y") + t2 - e2.y);
} });
class oi extends qt {
  constructor(t2, e2 = t2) {
    super(G("text", t2), e2), this.dom.leading = this.dom.leading ?? new _t(1.3), this._rebuild = true, this._build = false;
  }
  leading(t2) {
    return null == t2 ? this.dom.leading : (this.dom.leading = new _t(t2), this.rebuild());
  }
  rebuild(t2) {
    if ("boolean" == typeof t2 && (this._rebuild = t2), this._rebuild) {
      const t3 = this;
      let e2 = 0;
      const i = this.dom.leading;
      this.each(function(a2) {
        if (X(this.node))
          return;
        const s2 = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), r2 = i * new _t(s2);
        this.dom.newLined && (this.attr("x", t3.attr("x")), "\n" === this.text() ? e2 += r2 : (this.attr("dy", a2 ? r2 + e2 : 0), e2 = 0));
      }), this.fire("rebuild");
    }
    return this;
  }
  setData(t2) {
    return this.dom = t2, this.dom.leading = new _t(t2.leading || 1.3), this;
  }
  writeDataToDom() {
    return R(this, this.dom, { leading: 1.3 }), this;
  }
  text(t2) {
    if (void 0 === t2) {
      const e2 = this.node.childNodes;
      let i = 0;
      t2 = "";
      for (let a2 = 0, s2 = e2.length; a2 < s2; ++a2)
        "textPath" === e2[a2].nodeName || X(e2[a2]) ? 0 === a2 && (i = a2 + 1) : (a2 !== i && 3 !== e2[a2].nodeType && true === V(e2[a2]).dom.newLined && (t2 += "\n"), t2 += e2[a2].textContent);
      return t2;
    }
    if (this.clear().build(true), "function" == typeof t2)
      t2.call(this, this);
    else
      for (let e2 = 0, i = (t2 = (t2 + "").split("\n")).length; e2 < i; e2++)
        this.newLine(t2[e2]);
    return this.build(false).rebuild();
  }
}
Q(oi, ni), A({ Container: { text: K(function(t2 = "") {
  return this.put(new oi()).text(t2);
}), plain: K(function(t2 = "") {
  return this.put(new oi()).plain(t2);
}) } }), q(oi, "Text");
class li extends qt {
  constructor(t2, e2 = t2) {
    super(G("tspan", t2), e2), this._build = false;
  }
  dx(t2) {
    return this.attr("dx", t2);
  }
  dy(t2) {
    return this.attr("dy", t2);
  }
  newLine() {
    this.dom.newLined = true;
    const t2 = this.parent();
    if (!(t2 instanceof oi))
      return this;
    const e2 = t2.index(this), i = O.window.getComputedStyle(this.node).getPropertyValue("font-size"), a2 = t2.dom.leading * new _t(i);
    return this.dy(e2 ? a2 : 0).attr("x", t2.x());
  }
  text(t2) {
    return null == t2 ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t2 ? (this.clear().build(true), t2.call(this, this), this.build(false)) : this.plain(t2), this);
  }
}
Q(li, ni), A({ Tspan: { tspan: K(function(t2 = "") {
  const e2 = new li();
  return this._build || this.clear(), this.put(e2).text(t2);
}) }, Text: { newLine: function(t2 = "") {
  return this.tspan(t2).newLine();
} } }), q(li, "Tspan");
class hi extends qt {
  constructor(t2, e2 = t2) {
    super(G("circle", t2), e2);
  }
  radius(t2) {
    return this.attr("r", t2);
  }
  rx(t2) {
    return this.attr("r", t2);
  }
  ry(t2) {
    return this.rx(t2);
  }
  size(t2) {
    return this.radius(new _t(t2).divide(2));
  }
}
Q(hi, { x: Jt, y: Qt, cx: Kt, cy: te, width: ee, height: ie }), A({ Container: { circle: K(function(t2 = 0) {
  return this.put(new hi()).size(t2).move(0, 0);
}) } }), q(hi, "Circle");
class ci extends Vt {
  constructor(t2, e2 = t2) {
    super(G("clipPath", t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unclip();
    }), super.remove();
  }
  targets() {
    return Lt("svg [clip-path*=" + this.id() + "]");
  }
}
A({ Container: { clip: K(function() {
  return this.defs().put(new ci());
}) }, Element: { clipper() {
  return this.reference("clip-path");
}, clipWith(t2) {
  const e2 = t2 instanceof ci ? t2 : this.parent().clip().add(t2);
  return this.attr("clip-path", "url(#" + e2.id() + ")");
}, unclip() {
  return this.attr("clip-path", null);
} } }), q(ci, "ClipPath");
class di extends Gt {
  constructor(t2, e2 = t2) {
    super(G("foreignObject", t2), e2);
  }
}
A({ Container: { foreignObject: K(function(t2, e2) {
  return this.put(new di()).size(t2, e2);
}) } }), q(di, "ForeignObject");
var ui = Object.freeze({ __proto__: null, dmove: function(t2, e2) {
  return this.children().forEach((i) => {
    let a2;
    try {
      a2 = i.node instanceof F().SVGSVGElement ? new kt(i.attr(["x", "y", "width", "height"])) : i.bbox();
    } catch (t3) {
      return;
    }
    const s2 = new vt(i), r2 = s2.translate(t2, e2).transform(s2.inverse()), n2 = new bt(a2.x, a2.y).transform(r2);
    i.move(n2.x, n2.y);
  }), this;
}, dx: function(t2) {
  return this.dmove(t2, 0);
}, dy: function(t2) {
  return this.dmove(0, t2);
}, height: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.height : this.size(e2.width, t2, e2);
}, move: function(t2 = 0, e2 = 0, i = this.bbox()) {
  const a2 = t2 - i.x, s2 = e2 - i.y;
  return this.dmove(a2, s2);
}, size: function(t2, e2, i = this.bbox()) {
  const a2 = I(this, t2, e2, i), s2 = a2.width / i.width, r2 = a2.height / i.height;
  return this.children().forEach((t3) => {
    const e3 = new bt(i).transform(new vt(t3).inverse());
    t3.scale(s2, r2, e3.x, e3.y);
  }), this;
}, width: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.width : this.size(t2, e2.height, e2);
}, x: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.x : this.move(t2, e2.y, e2);
}, y: function(t2, e2 = this.bbox()) {
  return null == t2 ? e2.y : this.move(e2.x, t2, e2);
} });
class gi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("g", t2), e2);
  }
}
Q(gi, ui), A({ Container: { group: K(function() {
  return this.put(new gi());
}) } }), q(gi, "G");
class pi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("a", t2), e2);
  }
  target(t2) {
    return this.attr("target", t2);
  }
  to(t2) {
    return this.attr("href", t2, H);
  }
}
Q(pi, ui), A({ Container: { link: K(function(t2) {
  return this.put(new pi()).to(t2);
}) }, Element: { unlink() {
  const t2 = this.linker();
  if (!t2)
    return this;
  const e2 = t2.parent();
  if (!e2)
    return this.remove();
  const i = e2.index(t2);
  return e2.add(this, i), t2.remove(), this;
}, linkTo(t2) {
  let e2 = this.linker();
  return e2 || (e2 = new pi(), this.wrap(e2)), "function" == typeof t2 ? t2.call(e2, e2) : e2.to(t2), this;
}, linker() {
  const t2 = this.parent();
  return t2 && "a" === t2.node.nodeName.toLowerCase() ? t2 : null;
} } }), q(pi, "A");
class fi extends Vt {
  constructor(t2, e2 = t2) {
    super(G("mask", t2), e2);
  }
  remove() {
    return this.targets().forEach(function(t2) {
      t2.unmask();
    }), super.remove();
  }
  targets() {
    return Lt("svg [mask*=" + this.id() + "]");
  }
}
A({ Container: { mask: K(function() {
  return this.defs().put(new fi());
}) }, Element: { masker() {
  return this.reference("mask");
}, maskWith(t2) {
  const e2 = t2 instanceof fi ? t2 : this.parent().mask().add(t2);
  return this.attr("mask", "url(#" + e2.id() + ")");
}, unmask() {
  return this.attr("mask", null);
} } }), q(fi, "Mask");
class xi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("stop", t2), e2);
  }
  update(t2) {
    return ("number" == typeof t2 || t2 instanceof _t) && (t2 = { offset: arguments[0], color: arguments[1], opacity: arguments[2] }), null != t2.opacity && this.attr("stop-opacity", t2.opacity), null != t2.color && this.attr("stop-color", t2.color), null != t2.offset && this.attr("offset", new _t(t2.offset)), this;
  }
}
A({ Gradient: { stop: function(t2, e2, i) {
  return this.put(new xi()).update(t2, e2, i);
} } }), q(xi, "Stop");
class bi extends Gt {
  constructor(t2, e2 = t2) {
    super(G("style", t2), e2);
  }
  addText(t2 = "") {
    return this.node.textContent += t2, this;
  }
  font(t2, e2, i = {}) {
    return this.rule("@font-face", { fontFamily: t2, src: e2, ...i });
  }
  rule(t2, e2) {
    return this.addText(function(t3, e3) {
      if (!t3)
        return "";
      if (!e3)
        return t3;
      let i = t3 + "{";
      for (const t4 in e3)
        i += t4.replace(/([A-Z])/g, function(t5, e4) {
          return "-" + e4.toLowerCase();
        }) + ":" + e3[t4] + ";";
      return i += "}", i;
    }(t2, e2));
  }
}
A("Dom", { style(t2, e2) {
  return this.put(new bi()).rule(t2, e2);
}, fontface(t2, e2, i) {
  return this.put(new bi()).font(t2, e2, i);
} }), q(bi, "Style");
class mi extends oi {
  constructor(t2, e2 = t2) {
    super(G("textPath", t2), e2);
  }
  array() {
    const t2 = this.track();
    return t2 ? t2.array() : null;
  }
  plot(t2) {
    const e2 = this.track();
    let i = null;
    return e2 && (i = e2.plot(t2)), null == t2 ? i : this;
  }
  track() {
    return this.reference("href");
  }
}
A({ Container: { textPath: K(function(t2, e2) {
  return t2 instanceof oi || (t2 = this.text(t2)), t2.path(e2);
}) }, Text: { path: K(function(t2, e2 = true) {
  const i = new mi();
  let a2;
  if (t2 instanceof We || (t2 = this.defs().path(t2)), i.attr("href", "#" + t2, H), e2)
    for (; a2 = this.node.firstChild; )
      i.node.appendChild(a2);
  return this.put(i);
}), textPath() {
  return this.findOne("textPath");
} }, Path: { text: K(function(t2) {
  return t2 instanceof oi || (t2 = new oi().addTo(this.parent()).text(t2)), t2.path(this);
}), targets() {
  return Lt("svg textPath").filter((t2) => (t2.attr("href") || "").includes(this.id()));
} } }), mi.prototype.MorphArray = Ee, q(mi, "TextPath");
class vi extends qt {
  constructor(t2, e2 = t2) {
    super(G("use", t2), e2);
  }
  use(t2, e2) {
    return this.attr("href", (e2 || "") + "#" + t2, H);
  }
}
A({ Container: { use: K(function(t2, e2) {
  return this.put(new vi()).use(t2, e2);
}) } }), q(vi, "Use");
const yi = B;
Q([si, ri, de, ce, be], C("viewbox")), Q([xe, je, Ge, We], C("marker")), Q(oi, C("Text")), Q(We, C("Path")), Q(Ut, C("Defs")), Q([oi, li], C("Tspan")), Q([Ve, se, he, Qe], C("radius")), Q(Rt, C("EventTarget")), Q(Bt, C("Dom")), Q(Gt, C("Element")), Q(qt, C("Shape")), Q([Vt, re], C("Container")), Q(he, C("Gradient")), Q(Qe, C("Runner")), Ct.extend([...new Set(k)]), function(t2 = []) {
  Ne.push(...[].concat(t2));
}([_t, xt, kt, vt, Dt, ge, Ee, bt]), Q(Ne, { to(t2) {
  return new He().type(this.constructor).from(this.toArray()).to(t2);
}, fromArray(t2) {
  return this.init(t2), this;
}, toConsumable() {
  return this.toArray();
}, morph(t2, e2, i, a2, s2) {
  return this.fromArray(t2.map(function(t3, r2) {
    return a2.step(t3, e2[r2], i, s2[r2], s2);
  }));
} });
class wi extends Gt {
  constructor(t2) {
    super(G("filter", t2), t2), this.$source = "SourceGraphic", this.$sourceAlpha = "SourceAlpha", this.$background = "BackgroundImage", this.$backgroundAlpha = "BackgroundAlpha", this.$fill = "FillPaint", this.$stroke = "StrokePaint", this.$autoSetIn = true;
  }
  put(t2, e2) {
    return !(t2 = super.put(t2, e2)).attr("in") && this.$autoSetIn && t2.attr("in", this.$source), t2.attr("result") || t2.attr("result", t2.id()), t2;
  }
  remove() {
    return this.targets().each("unfilter"), super.remove();
  }
  targets() {
    return Lt('svg [filter*="' + this.id() + '"]');
  }
  toString() {
    return "url(#" + this.id() + ")";
  }
}
class ki extends Gt {
  constructor(t2, e2) {
    super(t2, e2), this.result(this.id());
  }
  in(t2) {
    if (null == t2) {
      const t3 = this.attr("in");
      return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
    }
    return this.attr("in", t2);
  }
  result(t2) {
    return this.attr("result", t2);
  }
  toString() {
    return this.result();
  }
}
const Ai = (t2) => function(...e2) {
  for (let i = t2.length; i--; )
    null != e2[i] && this.attr(t2[i], e2[i]);
}, Ci = { blend: Ai(["in", "in2", "mode"]), colorMatrix: Ai(["type", "values"]), composite: Ai(["in", "in2", "operator"]), convolveMatrix: function(t2) {
  t2 = new Dt(t2).toString(), this.attr({ order: Math.sqrt(t2.split(" ").length), kernelMatrix: t2 });
}, diffuseLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "kernelUnitLength"]), displacementMap: Ai(["in", "in2", "scale", "xChannelSelector", "yChannelSelector"]), dropShadow: Ai(["in", "dx", "dy", "stdDeviation"]), flood: Ai(["flood-color", "flood-opacity"]), gaussianBlur: function(t2 = 0, e2 = t2) {
  this.attr("stdDeviation", t2 + " " + e2);
}, image: function(t2) {
  this.attr("href", t2, H);
}, morphology: Ai(["operator", "radius"]), offset: Ai(["dx", "dy"]), specularLighting: Ai(["surfaceScale", "lightingColor", "diffuseConstant", "specularExponent", "kernelUnitLength"]), tile: Ai([]), turbulence: Ai(["baseFrequency", "numOctaves", "seed", "stitchTiles", "type"]) };
["blend", "colorMatrix", "componentTransfer", "composite", "convolveMatrix", "diffuseLighting", "displacementMap", "dropShadow", "flood", "gaussianBlur", "image", "merge", "morphology", "offset", "specularLighting", "tile", "turbulence"].forEach((t2) => {
  const e2 = P(t2), i = Ci[t2];
  wi[e2 + "Effect"] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
    update(t3) {
      return i.apply(this, t3), this;
    }
  }, wi.prototype[t2] = K(function(t3, ...i2) {
    const a2 = new wi[e2 + "Effect"]();
    return null == t3 ? this.put(a2) : ("function" == typeof t3 ? t3.call(a2, a2) : i2.unshift(t3), this.put(a2).update(i2));
  });
}), Q(wi, { merge(t2) {
  const e2 = this.put(new wi.MergeEffect());
  if ("function" == typeof t2)
    return t2.call(e2, e2), e2;
  return (t2 instanceof Array ? t2 : [...arguments]).forEach((t3) => {
    t3 instanceof wi.MergeNode ? e2.put(t3) : e2.mergeNode(t3);
  }), e2;
}, componentTransfer(t2 = {}) {
  const e2 = this.put(new wi.ComponentTransferEffect());
  if ("function" == typeof t2)
    return t2.call(e2, e2), e2;
  if (!(t2.r || t2.g || t2.b || t2.a)) {
    t2 = { r: t2, g: t2, b: t2, a: t2 };
  }
  for (const i in t2)
    e2.add(new wi["Func" + i.toUpperCase()](t2[i]));
  return e2;
} });
["distantLight", "pointLight", "spotLight", "mergeNode", "FuncR", "FuncG", "FuncB", "FuncA"].forEach((t2) => {
  const e2 = P(t2);
  wi[e2] = class extends ki {
    constructor(t3) {
      super(G("fe" + e2, t3), t3);
    }
  };
});
["funcR", "funcG", "funcB", "funcA"].forEach(function(t2) {
  const e2 = wi[P(t2)], i = K(function() {
    return this.put(new e2());
  });
  wi.ComponentTransferEffect.prototype[t2] = i;
});
["distantLight", "pointLight", "spotLight"].forEach((t2) => {
  const e2 = wi[P(t2)], i = K(function() {
    return this.put(new e2());
  });
  wi.DiffuseLightingEffect.prototype[t2] = i, wi.SpecularLightingEffect.prototype[t2] = i;
}), Q(wi.MergeEffect, { mergeNode(t2) {
  return this.put(new wi.MergeNode()).attr("in", t2);
} }), Q(Ut, { filter: function(t2) {
  const e2 = this.put(new wi());
  return "function" == typeof t2 && t2.call(e2, e2), e2;
} }), Q(Vt, { filter: function(t2) {
  return this.defs().filter(t2);
} }), Q(Gt, { filterWith: function(t2) {
  const e2 = t2 instanceof wi ? t2 : this.defs().filter(t2);
  return this.attr("filter", e2);
}, unfilter: function(t2) {
  return this.attr("filter", null);
}, filterer() {
  return this.reference("filter");
} });
const Si = { blend: function(t2, e2) {
  return this.parent() && this.parent().blend(this, t2, e2);
}, colorMatrix: function(t2, e2) {
  return this.parent() && this.parent().colorMatrix(t2, e2).in(this);
}, componentTransfer: function(t2) {
  return this.parent() && this.parent().componentTransfer(t2).in(this);
}, composite: function(t2, e2) {
  return this.parent() && this.parent().composite(this, t2, e2);
}, convolveMatrix: function(t2) {
  return this.parent() && this.parent().convolveMatrix(t2).in(this);
}, diffuseLighting: function(t2, e2, i, a2) {
  return this.parent() && this.parent().diffuseLighting(t2, i, a2).in(this);
}, displacementMap: function(t2, e2, i, a2) {
  return this.parent() && this.parent().displacementMap(this, t2, e2, i, a2);
}, dropShadow: function(t2, e2, i) {
  return this.parent() && this.parent().dropShadow(this, t2, e2, i).in(this);
}, flood: function(t2, e2) {
  return this.parent() && this.parent().flood(t2, e2);
}, gaussianBlur: function(t2, e2) {
  return this.parent() && this.parent().gaussianBlur(t2, e2).in(this);
}, image: function(t2) {
  return this.parent() && this.parent().image(t2);
}, merge: function(t2) {
  return t2 = t2 instanceof Array ? t2 : [...t2], this.parent() && this.parent().merge(this, ...t2);
}, morphology: function(t2, e2) {
  return this.parent() && this.parent().morphology(t2, e2).in(this);
}, offset: function(t2, e2) {
  return this.parent() && this.parent().offset(t2, e2).in(this);
}, specularLighting: function(t2, e2, i, a2, s2) {
  return this.parent() && this.parent().specularLighting(t2, i, a2, s2).in(this);
}, tile: function() {
  return this.parent() && this.parent().tile().in(this);
}, turbulence: function(t2, e2, i, a2, s2) {
  return this.parent() && this.parent().turbulence(t2, e2, i, a2, s2).in(this);
} };
Q(ki, Si), Q(wi.MergeEffect, { in: function(t2) {
  return t2 instanceof wi.MergeNode ? this.add(t2, 0) : this.add(new wi.MergeNode().in(t2), 0), this;
} }), Q([wi.CompositeEffect, wi.BlendEffect, wi.DisplacementMapEffect], { in2: function(t2) {
  if (null == t2) {
    const t3 = this.attr("in2");
    return this.parent() && this.parent().find(`[result="${t3}"]`)[0] || t3;
  }
  return this.attr("in2", t2);
} }), wi.filter = { sepiatone: [0.343, 0.669, 0.119, 0, 0, 0.249, 0.626, 0.13, 0, 0, 0.172, 0.334, 0.111, 0, 0, 0, 0, 0, 1, 0] };
var Li = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getDefaultFilter", value: function(t3, e2) {
    var i = this.w;
    t3.unfilter(true), new wi().size("120%", "180%", "-5%", "-40%"), i.config.chart.dropShadow.enabled && this.dropShadow(t3, i.config.chart.dropShadow, e2);
  } }, { key: "applyFilter", value: function(t3, e2, i) {
    var a2, s2 = this, r2 = this.w;
    if (t3.unfilter(true), "none" !== i) {
      var n2, o2, l2 = r2.config.chart.dropShadow, h2 = "lighten" === i ? 2 : 0.3;
      if (t3.filterWith(function(t4) {
        t4.colorMatrix({ type: "matrix", values: "\n          ".concat(h2, " 0 0 0 0\n          0 ").concat(h2, " 0 0 0\n          0 0 ").concat(h2, " 0 0\n          0 0 0 1 0\n        "), in: "SourceGraphic", result: "brightness" }), l2.enabled && s2.addShadow(t4, e2, l2, "brightness");
      }), !l2.noUserSpaceOnUse)
        null === (n2 = t3.filterer()) || void 0 === n2 || null === (o2 = n2.node) || void 0 === o2 || o2.setAttribute("filterUnits", "userSpaceOnUse");
      this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node);
    } else
      this.getDefaultFilter(t3, e2);
  } }, { key: "addShadow", value: function(t3, e2, i, a2) {
    var s2, r2 = this.w, n2 = i.blur, o2 = i.top, l2 = i.left, h2 = i.color, c2 = i.opacity;
    if (h2 = Array.isArray(h2) ? h2[e2] : h2, (null === (s2 = r2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.length) > 0 && -1 === r2.config.chart.dropShadow.enabledOnSeries.indexOf(e2))
      return t3;
    t3.offset({ in: a2, dx: l2, dy: o2, result: "offset" }), t3.gaussianBlur({ in: "offset", stdDeviation: n2, result: "blur" }), t3.flood({ "flood-color": h2, "flood-opacity": c2, result: "flood" }), t3.composite({ in: "flood", in2: "blur", operator: "in", result: "shadow" }), t3.merge(["shadow", a2]);
  } }, { key: "dropShadow", value: function(t3, e2) {
    var i, a2, s2, r2, n2, o2 = this, l2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, h2 = this.w;
    if (t3.unfilter(true), v.isMsEdge() && "radialBar" === h2.config.chart.type)
      return t3;
    if ((null === (i = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === i ? void 0 : i.length) > 0 && -1 === (null === (s2 = h2.config.chart.dropShadow.enabledOnSeries) || void 0 === s2 ? void 0 : s2.indexOf(l2)))
      return t3;
    (t3.filterWith(function(t4) {
      o2.addShadow(t4, l2, e2, "SourceGraphic");
    }), e2.noUserSpaceOnUse) || (null === (r2 = t3.filterer()) || void 0 === r2 || null === (n2 = r2.node) || void 0 === n2 || n2.setAttribute("filterUnits", "userSpaceOnUse"));
    return this._scaleFilterSize(null === (a2 = t3.filterer()) || void 0 === a2 ? void 0 : a2.node), t3;
  } }, { key: "setSelectionFilter", value: function(t3, e2, i) {
    var a2 = this.w;
    if (void 0 !== a2.globals.selectedDataPoints[e2] && a2.globals.selectedDataPoints[e2].indexOf(i) > -1) {
      t3.node.setAttribute("selected", true);
      var s2 = a2.config.states.active.filter;
      "none" !== s2 && this.applyFilter(t3, e2, s2.type);
    }
  } }, { key: "_scaleFilterSize", value: function(t3) {
    if (t3) {
      !function(e2) {
        for (var i in e2)
          e2.hasOwnProperty(i) && t3.setAttribute(i, e2[i]);
      }({ width: "200%", height: "200%", x: "-50%", y: "-50%" });
    }
  } }]), t2;
}(), Mi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "roundPathCorners", value: function(t3, e2) {
    function i(t4, e3, i2) {
      var s3 = e3.x - t4.x, r3 = e3.y - t4.y, n3 = Math.sqrt(s3 * s3 + r3 * r3);
      return a2(t4, e3, Math.min(1, i2 / n3));
    }
    function a2(t4, e3, i2) {
      return { x: t4.x + (e3.x - t4.x) * i2, y: t4.y + (e3.y - t4.y) * i2 };
    }
    function s2(t4, e3) {
      t4.length > 2 && (t4[t4.length - 2] = e3.x, t4[t4.length - 1] = e3.y);
    }
    function r2(t4) {
      return { x: parseFloat(t4[t4.length - 2]), y: parseFloat(t4[t4.length - 1]) };
    }
    t3.indexOf("NaN") > -1 && (t3 = "");
    var n2 = t3.split(/[,\s]/).reduce(function(t4, e3) {
      var i2 = e3.match("([a-zA-Z])(.+)");
      return i2 ? (t4.push(i2[1]), t4.push(i2[2])) : t4.push(e3), t4;
    }, []).reduce(function(t4, e3) {
      return parseFloat(e3) == e3 && t4.length ? t4[t4.length - 1].push(e3) : t4.push([e3]), t4;
    }, []), o2 = [];
    if (n2.length > 1) {
      var l2 = r2(n2[0]), h2 = null;
      "Z" == n2[n2.length - 1][0] && n2[0].length > 2 && (h2 = ["L", l2.x, l2.y], n2[n2.length - 1] = h2), o2.push(n2[0]);
      for (var c2 = 1; c2 < n2.length; c2++) {
        var d2 = o2[o2.length - 1], u2 = n2[c2], g2 = u2 == h2 ? n2[1] : n2[c2 + 1];
        if (g2 && d2 && d2.length > 2 && "L" == u2[0] && g2.length > 2 && "L" == g2[0]) {
          var p2, f2, x2 = r2(d2), b2 = r2(u2), m2 = r2(g2);
          p2 = i(b2, x2, e2), f2 = i(b2, m2, e2), s2(u2, p2), u2.origPoint = b2, o2.push(u2);
          var v2 = a2(p2, b2, 0.5), y2 = a2(b2, f2, 0.5), w2 = ["C", v2.x, v2.y, y2.x, y2.y, f2.x, f2.y];
          w2.origPoint = b2, o2.push(w2);
        } else
          o2.push(u2);
      }
      if (h2) {
        var k2 = r2(o2[o2.length - 1]);
        o2.push(["Z"]), s2(o2[0], k2);
      }
    } else
      o2 = n2;
    return o2.reduce(function(t4, e3) {
      return t4 + e3.join(" ") + " ";
    }, "");
  } }, { key: "drawLine", value: function(t3, e2, i, a2) {
    var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8", r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0, n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, o2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt";
    return this.w.globals.dom.Paper.line().attr({ x1: t3, y1: e2, x2: i, y2: a2, stroke: s2, "stroke-dasharray": r2, "stroke-width": n2, "stroke-linecap": o2 });
  } }, { key: "drawRect", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0, r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe", n2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1, o2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null, l2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null, h2 = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0, c2 = this.w.globals.dom.Paper.rect();
    return c2.attr({ x: t3, y: e2, width: i > 0 ? i : 0, height: a2 > 0 ? a2 : 0, rx: s2, ry: s2, opacity: n2, "stroke-width": null !== o2 ? o2 : 0, stroke: null !== l2 ? l2 : "none", "stroke-dasharray": h2 }), c2.node.setAttribute("fill", r2), c2;
  } }, { key: "drawPolygon", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1", i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none";
    return this.w.globals.dom.Paper.polygon(t3).attr({ fill: a2, stroke: e2, "stroke-width": i });
  } }, { key: "drawCircle", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
    t3 < 0 && (t3 = 0);
    var i = this.w.globals.dom.Paper.circle(2 * t3);
    return null !== e2 && i.attr(e2), i;
  } }, { key: "drawPath", value: function(t3) {
    var e2 = t3.d, i = void 0 === e2 ? "" : e2, a2 = t3.stroke, s2 = void 0 === a2 ? "#a8a8a8" : a2, r2 = t3.strokeWidth, n2 = void 0 === r2 ? 1 : r2, o2 = t3.fill, l2 = t3.fillOpacity, h2 = void 0 === l2 ? 1 : l2, c2 = t3.strokeOpacity, d2 = void 0 === c2 ? 1 : c2, u2 = t3.classes, g2 = t3.strokeLinecap, p2 = void 0 === g2 ? null : g2, f2 = t3.strokeDashArray, x2 = void 0 === f2 ? 0 : f2, b2 = this.w;
    return null === p2 && (p2 = b2.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(b2.globals.gridHeight)), b2.globals.dom.Paper.path(i).attr({ fill: o2, "fill-opacity": h2, stroke: s2, "stroke-opacity": d2, "stroke-linecap": p2, "stroke-width": n2, "stroke-dasharray": x2, class: u2 });
  } }, { key: "group", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w.globals.dom.Paper.group();
    return null !== t3 && e2.attr(t3), e2;
  } }, { key: "move", value: function(t3, e2) {
    var i = ["M", t3, e2].join(" ");
    return i;
  } }, { key: "line", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = null;
    return null === i ? a2 = [" L", t3, e2].join(" ") : "H" === i ? a2 = [" H", t3].join(" ") : "V" === i && (a2 = [" V", e2].join(" ")), a2;
  } }, { key: "curve", value: function(t3, e2, i, a2, s2, r2) {
    var n2 = ["C", t3, e2, i, a2, s2, r2].join(" ");
    return n2;
  } }, { key: "quadraticCurve", value: function(t3, e2, i, a2) {
    return ["Q", t3, e2, i, a2].join(" ");
  } }, { key: "arc", value: function(t3, e2, i, a2, s2, r2, n2) {
    var o2 = "A";
    arguments.length > 7 && void 0 !== arguments[7] && arguments[7] && (o2 = "a");
    var l2 = [o2, t3, e2, i, a2, s2, r2, n2].join(" ");
    return l2;
  } }, { key: "renderPaths", value: function(t3) {
    var e2, i = t3.j, a2 = t3.realIndex, s2 = t3.pathFrom, r2 = t3.pathTo, n2 = t3.stroke, o2 = t3.strokeWidth, l2 = t3.strokeLinecap, h2 = t3.fill, c2 = t3.animationDelay, d2 = t3.initialSpeed, g2 = t3.dataChangeSpeed, p2 = t3.className, f2 = t3.chartType, x2 = t3.shouldClipToGrid, b2 = void 0 === x2 || x2, m2 = t3.bindEventsOnPaths, v2 = void 0 === m2 || m2, w2 = t3.drawShadow, k2 = void 0 === w2 || w2, A2 = this.w, C2 = new Li(this.ctx), S2 = new y(this.ctx), L2 = this.w.config.chart.animations.enabled, M2 = L2 && this.w.config.chart.animations.dynamicAnimation.enabled, P2 = !!(L2 && !A2.globals.resized || M2 && A2.globals.dataChanged && A2.globals.shouldAnimate);
    P2 ? e2 = s2 : (e2 = r2, A2.globals.animationEnded = true);
    var I2 = A2.config.stroke.dashArray, T2 = 0;
    T2 = Array.isArray(I2) ? I2[a2] : A2.config.stroke.dashArray;
    var z2 = this.drawPath({ d: e2, stroke: n2, strokeWidth: o2, fill: h2, fillOpacity: 1, classes: p2, strokeLinecap: l2, strokeDashArray: T2 });
    z2.attr("index", a2), b2 && ("bar" === f2 && !A2.globals.isHorizontal || A2.globals.comboCharts ? z2.attr({ "clip-path": "url(#gridRectBarMask".concat(A2.globals.cuid, ")") }) : z2.attr({ "clip-path": "url(#gridRectMask".concat(A2.globals.cuid, ")") })), A2.config.chart.dropShadow.enabled && k2 && C2.dropShadow(z2, A2.config.chart.dropShadow, a2), v2 && (z2.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, z2)), z2.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, z2)), z2.node.addEventListener("mousedown", this.pathMouseDown.bind(this, z2))), z2.attr({ pathTo: r2, pathFrom: s2 });
    var X2 = { el: z2, j: i, realIndex: a2, pathFrom: s2, pathTo: r2, fill: h2, strokeWidth: o2, delay: c2 };
    return !L2 || A2.globals.resized || A2.globals.dataChanged ? !A2.globals.resized && A2.globals.dataChanged || S2.showDelayedElements() : S2.animatePathsGradually(u(u({}, X2), {}, { speed: d2 })), A2.globals.dataChanged && M2 && P2 && S2.animatePathsGradually(u(u({}, X2), {}, { speed: g2 })), z2;
  } }, { key: "drawPattern", value: function(t3, e2, i) {
    var a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8", s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0;
    return this.w.globals.dom.Paper.pattern(e2, i, function(r2) {
      "horizontalLines" === t3 ? r2.line(0, 0, i, 0).stroke({ color: a2, width: s2 + 1 }) : "verticalLines" === t3 ? r2.line(0, 0, 0, e2).stroke({ color: a2, width: s2 + 1 }) : "slantedLines" === t3 ? r2.line(0, 0, e2, i).stroke({ color: a2, width: s2 }) : "squares" === t3 ? r2.rect(e2, i).fill("none").stroke({ color: a2, width: s2 }) : "circles" === t3 && r2.circle(e2).fill("none").stroke({ color: a2, width: s2 });
    });
  } }, { key: "drawGradient", value: function(t3, e2, i, a2, s2) {
    var r2, n2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, o2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null, l2 = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : [], h2 = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0, c2 = this.w;
    e2.length < 9 && 0 === e2.indexOf("#") && (e2 = v.hexToRgba(e2, a2)), i.length < 9 && 0 === i.indexOf("#") && (i = v.hexToRgba(i, s2));
    var d2 = 0, u2 = 1, g2 = 1, p2 = null;
    null !== o2 && (d2 = void 0 !== o2[0] ? o2[0] / 100 : 0, u2 = void 0 !== o2[1] ? o2[1] / 100 : 1, g2 = void 0 !== o2[2] ? o2[2] / 100 : 1, p2 = void 0 !== o2[3] ? o2[3] / 100 : null);
    var f2 = !("donut" !== c2.config.chart.type && "pie" !== c2.config.chart.type && "polarArea" !== c2.config.chart.type && "bubble" !== c2.config.chart.type);
    if (r2 = l2 && 0 !== l2.length ? c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
      (Array.isArray(l2[h2]) ? l2[h2] : l2).forEach(function(e3) {
        t4.stop(e3.offset / 100, e3.color, e3.opacity);
      });
    }) : c2.globals.dom.Paper.gradient(f2 ? "radial" : "linear", function(t4) {
      t4.stop(d2, e2, a2), t4.stop(u2, i, s2), t4.stop(g2, i, s2), null !== p2 && t4.stop(p2, e2, a2);
    }), f2) {
      var x2 = c2.globals.gridWidth / 2, b2 = c2.globals.gridHeight / 2;
      "bubble" !== c2.config.chart.type ? r2.attr({ gradientUnits: "userSpaceOnUse", cx: x2, cy: b2, r: n2 }) : r2.attr({ cx: 0.5, cy: 0.5, r: 0.8, fx: 0.2, fy: 0.2 });
    } else
      "vertical" === t3 ? r2.from(0, 0).to(0, 1) : "diagonal" === t3 ? r2.from(0, 0).to(1, 1) : "horizontal" === t3 ? r2.from(0, 1).to(1, 1) : "diagonal2" === t3 && r2.from(1, 0).to(0, 1);
    return r2;
  } }, { key: "getTextBasedOnMaxWidth", value: function(t3) {
    var e2 = t3.text, i = t3.maxWidth, a2 = t3.fontSize, s2 = t3.fontFamily, r2 = this.getTextRects(e2, a2, s2), n2 = r2.width / e2.length, o2 = Math.floor(i / n2);
    return i < r2.width ? e2.slice(0, o2 - 3) + "..." : e2;
  } }, { key: "drawText", value: function(t3) {
    var e2 = this, i = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.fontSize, o2 = t3.fontFamily, l2 = t3.fontWeight, h2 = t3.foreColor, c2 = t3.opacity, d2 = t3.maxWidth, g2 = t3.cssClass, p2 = void 0 === g2 ? "" : g2, f2 = t3.isPlainText, x2 = void 0 === f2 || f2, b2 = t3.dominantBaseline, m2 = void 0 === b2 ? "auto" : b2, v2 = this.w;
    void 0 === s2 && (s2 = "");
    var y2 = s2;
    r2 || (r2 = "start"), h2 && h2.length || (h2 = v2.config.chart.foreColor), o2 = o2 || v2.config.chart.fontFamily, l2 = l2 || "regular";
    var w2, k2 = { maxWidth: d2, fontSize: n2 = n2 || "11px", fontFamily: o2 };
    return Array.isArray(s2) ? w2 = v2.globals.dom.Paper.text(function(t4) {
      for (var i2 = 0; i2 < s2.length; i2++)
        y2 = s2[i2], d2 && (y2 = e2.getTextBasedOnMaxWidth(u({ text: s2[i2] }, k2))), 0 === i2 ? t4.tspan(y2) : t4.tspan(y2).newLine();
    }) : (d2 && (y2 = this.getTextBasedOnMaxWidth(u({ text: s2 }, k2))), w2 = x2 ? v2.globals.dom.Paper.plain(s2) : v2.globals.dom.Paper.text(function(t4) {
      return t4.tspan(y2);
    })), w2.attr({ x: i, y: a2, "text-anchor": r2, "dominant-baseline": m2, "font-size": n2, "font-family": o2, "font-weight": l2, fill: h2, class: "apexcharts-text " + p2 }), w2.node.style.fontFamily = o2, w2.node.style.opacity = c2, w2;
  } }, { key: "getMarkerPath", value: function(t3, e2, i, a2) {
    var s2 = "";
    switch (i) {
      case "cross":
        s2 = "M ".concat(t3 - (a2 /= 1.4), " ").concat(e2 - a2, " L ").concat(t3 + a2, " ").concat(e2 + a2, "  M ").concat(t3 - a2, " ").concat(e2 + a2, " L ").concat(t3 + a2, " ").concat(e2 - a2);
        break;
      case "plus":
        s2 = "M ".concat(t3 - (a2 /= 1.12), " ").concat(e2, " L ").concat(t3 + a2, " ").concat(e2, "  M ").concat(t3, " ").concat(e2 - a2, " L ").concat(t3, " ").concat(e2 + a2);
        break;
      case "star":
      case "sparkle":
        var r2 = 5;
        a2 *= 1.15, "sparkle" === i && (a2 /= 1.1, r2 = 4);
        for (var n2 = Math.PI / r2, o2 = 0; o2 <= 2 * r2; o2++) {
          var l2 = o2 * n2, h2 = o2 % 2 == 0 ? a2 : a2 / 2;
          s2 += (0 === o2 ? "M" : "L") + (t3 + h2 * Math.sin(l2)) + "," + (e2 - h2 * Math.cos(l2));
        }
        s2 += "Z";
        break;
      case "triangle":
        s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2 + a2, " \n             Z");
        break;
      case "square":
      case "rect":
        s2 = "M ".concat(t3 - (a2 /= 1.125), " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 - a2, " \n           L ").concat(t3 + a2, " ").concat(e2 + a2, " \n           L ").concat(t3 - a2, " ").concat(e2 + a2, " \n           Z");
        break;
      case "diamond":
        a2 *= 1.05, s2 = "M ".concat(t3, " ").concat(e2 - a2, " \n             L ").concat(t3 + a2, " ").concat(e2, " \n             L ").concat(t3, " ").concat(e2 + a2, " \n             L ").concat(t3 - a2, " ").concat(e2, " \n            Z");
        break;
      case "line":
        s2 = "M ".concat(t3 - (a2 /= 1.1), " ").concat(e2, " \n           L ").concat(t3 + a2, " ").concat(e2);
        break;
      default:
        a2 *= 2, s2 = "M ".concat(t3, ", ").concat(e2, " \n           m -").concat(a2 / 2, ", 0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 ").concat(a2, ",0 \n           a ").concat(a2 / 2, ",").concat(a2 / 2, " 0 1,0 -").concat(a2, ",0");
    }
    return s2;
  } }, { key: "drawMarkerShape", value: function(t3, e2, i, a2, s2) {
    var r2 = this.drawPath({ d: this.getMarkerPath(t3, e2, i, a2, s2), stroke: s2.pointStrokeColor, strokeDashArray: s2.pointStrokeDashArray, strokeWidth: s2.pointStrokeWidth, fill: s2.pointFillColor, fillOpacity: s2.pointFillOpacity, strokeOpacity: s2.pointStrokeOpacity });
    return r2.attr({ cx: t3, cy: e2, shape: s2.shape, class: s2.class ? s2.class : "" }), r2;
  } }, { key: "drawMarker", value: function(t3, e2, i) {
    t3 = t3 || 0;
    var a2 = i.pSize || 0;
    return v.isNumber(e2) || (a2 = 0, e2 = 0), this.drawMarkerShape(t3, e2, null == i ? void 0 : i.shape, a2, u(u({}, i), "line" === i.shape || "plus" === i.shape || "cross" === i.shape ? { pointStrokeColor: i.pointFillColor, pointStrokeOpacity: i.pointFillOpacity } : {}));
  } }, { key: "pathMouseEnter", value: function(t3, e2) {
    var i = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i }), this.ctx.events.fireEvent("dataPointMouseEnter", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i }]), ("none" === i.config.states.active.filter.type || "true" !== t3.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && !i.globals.isTouchDevice) {
      var n2 = i.config.states.hover.filter;
      a2.applyFilter(t3, s2, n2.type);
    }
  } }, { key: "pathMouseLeave", value: function(t3, e2) {
    var i = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10);
    "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i }), this.ctx.events.fireEvent("dataPointMouseLeave", [e2, this.ctx, { seriesIndex: s2, dataPointIndex: r2, w: i }]), "none" !== i.config.states.active.filter.type && "true" === t3.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && a2.getDefaultFilter(t3, s2);
  } }, { key: "pathMouseDown", value: function(t3, e2) {
    var i = this.w, a2 = new Li(this.ctx), s2 = parseInt(t3.node.getAttribute("index"), 10), r2 = parseInt(t3.node.getAttribute("j"), 10), n2 = "false";
    if ("true" === t3.node.getAttribute("selected")) {
      if (t3.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s2].indexOf(r2) > -1) {
        var o2 = i.globals.selectedDataPoints[s2].indexOf(r2);
        i.globals.selectedDataPoints[s2].splice(o2, 1);
      }
    } else {
      if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
        i.globals.selectedDataPoints = [];
        var l2 = i.globals.dom.Paper.find(".apexcharts-series path:not(.apexcharts-decoration-element)"), h2 = i.globals.dom.Paper.find(".apexcharts-series circle:not(.apexcharts-decoration-element), .apexcharts-series rect:not(.apexcharts-decoration-element)"), c2 = function(t4) {
          Array.prototype.forEach.call(t4, function(t5) {
            t5.node.setAttribute("selected", "false"), a2.getDefaultFilter(t5, s2);
          });
        };
        c2(l2), c2(h2);
      }
      t3.node.setAttribute("selected", "true"), n2 = "true", void 0 === i.globals.selectedDataPoints[s2] && (i.globals.selectedDataPoints[s2] = []), i.globals.selectedDataPoints[s2].push(r2);
    }
    if ("true" === n2) {
      var d2 = i.config.states.active.filter;
      if ("none" !== d2)
        a2.applyFilter(t3, s2, d2.type);
      else if ("none" !== i.config.states.hover.filter && !i.globals.isTouchDevice) {
        var u2 = i.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    } else if ("none" !== i.config.states.active.filter.type)
      if ("none" === i.config.states.hover.filter.type || i.globals.isTouchDevice)
        a2.getDefaultFilter(t3, s2);
      else {
        u2 = i.config.states.hover.filter;
        a2.applyFilter(t3, s2, u2.type);
      }
    "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e2, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i }), e2 && this.ctx.events.fireEvent("dataPointSelection", [e2, this.ctx, { selectedDataPoints: i.globals.selectedDataPoints, seriesIndex: s2, dataPointIndex: r2, w: i }]);
  } }, { key: "rotateAroundCenter", value: function(t3) {
    var e2 = {};
    return t3 && "function" == typeof t3.getBBox && (e2 = t3.getBBox()), { x: e2.x + e2.width / 2, y: e2.y + e2.height / 2 };
  } }, { key: "getTextRects", value: function(t3, e2, i, a2) {
    var s2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], r2 = this.w, n2 = this.drawText({ x: -200, y: -200, text: t3, textAnchor: "start", fontSize: e2, fontFamily: i, foreColor: "#fff", opacity: 0 });
    a2 && n2.attr("transform", a2), r2.globals.dom.Paper.add(n2);
    var o2 = n2.bbox();
    return s2 || (o2 = n2.node.getBoundingClientRect()), n2.remove(), { width: o2.width, height: o2.height };
  } }, { key: "placeTextWithEllipsis", value: function(t3, e2, i) {
    if ("function" == typeof t3.getComputedTextLength && (t3.textContent = e2, e2.length > 0 && t3.getComputedTextLength() >= i / 1.1)) {
      for (var a2 = e2.length - 3; a2 > 0; a2 -= 3)
        if (t3.getSubStringLength(0, a2) <= i / 1.1)
          return void (t3.textContent = e2.substring(0, a2) + "...");
      t3.textContent = ".";
    }
  } }], [{ key: "setAttrs", value: function(t3, e2) {
    for (var i in e2)
      e2.hasOwnProperty(i) && t3.setAttribute(i, e2[i]);
  } }]), t2;
}(), Pi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getStackedSeriesTotals", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = this.w, i = [];
    if (0 === e2.globals.series.length)
      return i;
    for (var a2 = 0; a2 < e2.globals.series[e2.globals.maxValsInArrayIndex].length; a2++) {
      for (var s2 = 0, r2 = 0; r2 < e2.globals.series.length; r2++)
        void 0 !== e2.globals.series[r2][a2] && -1 === t3.indexOf(r2) && (s2 += e2.globals.series[r2][a2]);
      i.push(s2);
    }
    return i;
  } }, { key: "getSeriesTotalByIndex", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return null === t3 ? this.w.config.series.reduce(function(t4, e2) {
      return t4 + e2;
    }, 0) : this.w.globals.series[t3].reduce(function(t4, e2) {
      return t4 + e2;
    }, 0);
  } }, { key: "getStackedSeriesTotalsByGroups", value: function() {
    var t3 = this, e2 = this.w, i = [];
    return e2.globals.seriesGroups.forEach(function(a2) {
      var s2 = [];
      e2.config.series.forEach(function(t4, i2) {
        a2.indexOf(e2.globals.seriesNames[i2]) > -1 && s2.push(i2);
      });
      var r2 = e2.globals.series.map(function(t4, e3) {
        return -1 === s2.indexOf(e3) ? e3 : -1;
      }).filter(function(t4) {
        return -1 !== t4;
      });
      i.push(t3.getStackedSeriesTotals(r2));
    }), i;
  } }, { key: "setSeriesYAxisMappings", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i = [], a2 = [], s2 = [], r2 = t3.series.length > e2.yaxis.length || e2.yaxis.some(function(t4) {
      return Array.isArray(t4.seriesName);
    });
    e2.series.forEach(function(t4, e3) {
      s2.push(e3), a2.push(null);
    }), e2.yaxis.forEach(function(t4, e3) {
      i[e3] = [];
    });
    var n2 = [];
    e2.yaxis.forEach(function(t4, a3) {
      var o3 = false;
      if (t4.seriesName) {
        var l3 = [];
        Array.isArray(t4.seriesName) ? l3 = t4.seriesName : l3.push(t4.seriesName), l3.forEach(function(t5) {
          e2.series.forEach(function(e3, n3) {
            if (e3.name === t5) {
              var l4 = n3;
              a3 === n3 || r2 ? !r2 || s2.indexOf(n3) > -1 ? i[a3].push([a3, n3]) : console.warn("Series '" + e3.name + "' referenced more than once in what looks like the new style. That is, when using either seriesName: [], or when there are more series than yaxes.") : (i[n3].push([n3, a3]), l4 = a3), o3 = true, -1 !== (l4 = s2.indexOf(l4)) && s2.splice(l4, 1);
            }
          });
        });
      }
      o3 || n2.push(a3);
    }), i = i.map(function(t4, e3) {
      var i2 = [];
      return t4.forEach(function(t5) {
        a2[t5[1]] = t5[0], i2.push(t5[1]);
      }), i2;
    });
    for (var o2 = e2.yaxis.length - 1, l2 = 0; l2 < n2.length && (o2 = n2[l2], i[o2] = [], s2); l2++) {
      var h2 = s2[0];
      s2.shift(), i[o2].push(h2), a2[h2] = o2;
    }
    s2.forEach(function(t4) {
      i[o2].push(t4), a2[t4] = o2;
    }), t3.seriesYAxisMap = i.map(function(t4) {
      return t4;
    }), t3.seriesYAxisReverseMap = a2.map(function(t4) {
      return t4;
    }), t3.seriesYAxisMap.forEach(function(t4, i2) {
      t4.forEach(function(t5) {
        e2.series[t5] && void 0 === e2.series[t5].group && (e2.series[t5].group = "apexcharts-axis-".concat(i2.toString()));
      });
    });
  } }, { key: "isSeriesNull", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
    return 0 === (null === t3 ? this.w.config.series.filter(function(t4) {
      return null !== t4;
    }) : this.w.config.series[t3].data.filter(function(t4) {
      return null !== t4;
    })).length;
  } }, { key: "seriesHaveSameValues", value: function(t3) {
    return this.w.globals.series[t3].every(function(t4, e2, i) {
      return t4 === i[0];
    });
  } }, { key: "getCategoryLabels", value: function(t3) {
    var e2 = this.w, i = t3.slice();
    return e2.config.xaxis.convertedCatToNumeric && (i = t3.map(function(t4, i2) {
      return e2.config.xaxis.labels.formatter(t4 - e2.globals.minX + 1);
    })), i;
  } }, { key: "getLargestSeries", value: function() {
    var t3 = this.w;
    t3.globals.maxValsInArrayIndex = t3.globals.series.map(function(t4) {
      return t4.length;
    }).indexOf(Math.max.apply(Math, t3.globals.series.map(function(t4) {
      return t4.length;
    })));
  } }, { key: "getLargestMarkerSize", value: function() {
    var t3 = this.w, e2 = 0;
    return t3.globals.markers.size.forEach(function(t4) {
      e2 = Math.max(e2, t4);
    }), t3.config.markers.discrete && t3.config.markers.discrete.length && t3.config.markers.discrete.forEach(function(t4) {
      e2 = Math.max(e2, t4.size);
    }), e2 > 0 && (t3.config.markers.hover.size > 0 ? e2 = t3.config.markers.hover.size : e2 += t3.config.markers.hover.sizeOffset), t3.globals.markers.largestSize = e2, e2;
  } }, { key: "getSeriesTotals", value: function() {
    var t3 = this.w;
    t3.globals.seriesTotals = t3.globals.series.map(function(t4, e2) {
      var i = 0;
      if (Array.isArray(t4))
        for (var a2 = 0; a2 < t4.length; a2++)
          i += t4[a2];
      else
        i += t4;
      return i;
    });
  } }, { key: "getSeriesTotalsXRange", value: function(t3, e2) {
    var i = this.w;
    return i.globals.series.map(function(a2, s2) {
      for (var r2 = 0, n2 = 0; n2 < a2.length; n2++)
        i.globals.seriesX[s2][n2] > t3 && i.globals.seriesX[s2][n2] < e2 && (r2 += a2[n2]);
      return r2;
    });
  } }, { key: "getPercentSeries", value: function() {
    var t3 = this.w;
    t3.globals.seriesPercent = t3.globals.series.map(function(e2, i) {
      var a2 = [];
      if (Array.isArray(e2))
        for (var s2 = 0; s2 < e2.length; s2++) {
          var r2 = t3.globals.stackedSeriesTotals[s2], n2 = 0;
          r2 && (n2 = 100 * e2[s2] / r2), a2.push(n2);
        }
      else {
        var o2 = 100 * e2 / t3.globals.seriesTotals.reduce(function(t4, e3) {
          return t4 + e3;
        }, 0);
        a2.push(o2);
      }
      return a2;
    });
  } }, { key: "getCalculatedRatios", value: function() {
    var t3, e2, i, a2 = this, s2 = this.w, r2 = s2.globals, n2 = [], o2 = 0, l2 = [], h2 = 0.1, c2 = 0;
    if (r2.yRange = [], r2.isMultipleYAxis)
      for (var d2 = 0; d2 < r2.minYArr.length; d2++)
        r2.yRange.push(Math.abs(r2.minYArr[d2] - r2.maxYArr[d2])), l2.push(0);
    else
      r2.yRange.push(Math.abs(r2.minY - r2.maxY));
    r2.xRange = Math.abs(r2.maxX - r2.minX), r2.zRange = Math.abs(r2.maxZ - r2.minZ);
    for (var u2 = 0; u2 < r2.yRange.length; u2++)
      n2.push(r2.yRange[u2] / r2.gridHeight);
    if (e2 = r2.xRange / r2.gridWidth, t3 = r2.yRange / r2.gridWidth, i = r2.xRange / r2.gridHeight, (o2 = r2.zRange / r2.gridHeight * 16) || (o2 = 1), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (r2.hasNegs = true), s2.globals.seriesYAxisReverseMap.length > 0) {
      var g2 = function(t4, e3) {
        var i2 = s2.config.yaxis[s2.globals.seriesYAxisReverseMap[e3]], r3 = t4 < 0 ? -1 : 1;
        return t4 = Math.abs(t4), i2.logarithmic && (t4 = a2.getBaseLog(i2.logBase, t4)), -r3 * t4 / n2[e3];
      };
      if (r2.isMultipleYAxis) {
        l2 = [];
        for (var p2 = 0; p2 < n2.length; p2++)
          l2.push(g2(r2.minYArr[p2], p2));
      } else
        (l2 = []).push(g2(r2.minY, 0)), r2.minY !== Number.MIN_VALUE && 0 !== Math.abs(r2.minY) && (h2 = -r2.minY / t3, c2 = r2.minX / e2);
    } else
      (l2 = []).push(0), h2 = 0, c2 = 0;
    return { yRatio: n2, invertedYRatio: t3, zRatio: o2, xRatio: e2, invertedXRatio: i, baseLineInvertedY: h2, baseLineY: l2, baseLineX: c2 };
  } }, { key: "getLogSeries", value: function(t3) {
    var e2 = this, i = this.w;
    return i.globals.seriesLog = t3.map(function(t4, a2) {
      var s2 = i.globals.seriesYAxisReverseMap[a2];
      return i.config.yaxis[s2] && i.config.yaxis[s2].logarithmic ? t4.map(function(t5) {
        return null === t5 ? null : e2.getLogVal(i.config.yaxis[s2].logBase, t5, a2);
      }) : t4;
    }), i.globals.invalidLogScale ? t3 : i.globals.seriesLog;
  } }, { key: "getLogValAtSeriesIndex", value: function(t3, e2) {
    if (null === t3)
      return null;
    var i = this.w, a2 = i.globals.seriesYAxisReverseMap[e2];
    return i.config.yaxis[a2] && i.config.yaxis[a2].logarithmic ? this.getLogVal(i.config.yaxis[a2].logBase, t3, e2) : t3;
  } }, { key: "getBaseLog", value: function(t3, e2) {
    return Math.log(e2) / Math.log(t3);
  } }, { key: "getLogVal", value: function(t3, e2, i) {
    if (e2 <= 0)
      return 0;
    var a2 = this.w, s2 = 0 === a2.globals.minYArr[i] ? -1 : this.getBaseLog(t3, a2.globals.minYArr[i]), r2 = (0 === a2.globals.maxYArr[i] ? 0 : this.getBaseLog(t3, a2.globals.maxYArr[i])) - s2;
    return e2 < 1 ? e2 / r2 : (this.getBaseLog(t3, e2) - s2) / r2;
  } }, { key: "getLogYRatios", value: function(t3) {
    var e2 = this, i = this.w, a2 = this.w.globals;
    return a2.yLogRatio = t3.slice(), a2.logYRange = a2.yRange.map(function(t4, s2) {
      var r2 = i.globals.seriesYAxisReverseMap[s2];
      if (i.config.yaxis[r2] && e2.w.config.yaxis[r2].logarithmic) {
        var n2, o2 = -Number.MAX_VALUE, l2 = Number.MIN_VALUE;
        return a2.seriesLog.forEach(function(t5, e3) {
          t5.forEach(function(t6) {
            i.config.yaxis[e3] && i.config.yaxis[e3].logarithmic && (o2 = Math.max(t6, o2), l2 = Math.min(t6, l2));
          });
        }), n2 = Math.pow(a2.yRange[s2], Math.abs(l2 - o2) / a2.yRange[s2]), a2.yLogRatio[s2] = n2 / a2.gridHeight, n2;
      }
    }), a2.invalidLogScale ? t3.slice() : a2.yLogRatio;
  } }, { key: "drawSeriesByGroup", value: function(t3, e2, i, a2) {
    var s2 = this.w, r2 = [];
    return t3.series.length > 0 && e2.forEach(function(e3) {
      var n2 = [], o2 = [];
      t3.i.forEach(function(i2, a3) {
        s2.config.series[i2].group === e3 && (n2.push(t3.series[a3]), o2.push(i2));
      }), n2.length > 0 && r2.push(a2.draw(n2, i, o2));
    }), r2;
  } }], [{ key: "checkComboSeries", value: function(t3, e2) {
    var i = false, a2 = 0, s2 = 0;
    return void 0 === e2 && (e2 = "line"), t3.length && void 0 !== t3[0].type && t3.forEach(function(t4) {
      "bar" !== t4.type && "column" !== t4.type && "candlestick" !== t4.type && "boxPlot" !== t4.type || a2++, void 0 !== t4.type && t4.type !== e2 && s2++;
    }), s2 > 0 && (i = true), { comboBarCount: a2, comboCharts: i };
  } }, { key: "extendArrayProps", value: function(t3, e2, i) {
    var a2, s2, r2, n2, o2, l2;
    (null !== (a2 = e2) && void 0 !== a2 && a2.yaxis && (e2 = t3.extendYAxis(e2, i)), null !== (s2 = e2) && void 0 !== s2 && s2.annotations) && (e2.annotations.yaxis && (e2 = t3.extendYAxisAnnotations(e2)), null !== (r2 = e2) && void 0 !== r2 && null !== (n2 = r2.annotations) && void 0 !== n2 && n2.xaxis && (e2 = t3.extendXAxisAnnotations(e2)), null !== (o2 = e2) && void 0 !== o2 && null !== (l2 = o2.annotations) && void 0 !== l2 && l2.points && (e2 = t3.extendPointAnnotations(e2)));
    return e2;
  } }]), t2;
}(), Ii = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.annoCtx = e2;
  }
  return s(t2, [{ key: "setOrientations", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.w;
    if ("vertical" === t3.label.orientation) {
      var a2 = null !== e2 ? e2 : 0, s2 = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a2, "']"));
      if (null !== s2) {
        var r2 = s2.getBoundingClientRect();
        s2.setAttribute("x", parseFloat(s2.getAttribute("x")) - r2.height + 4);
        var n2 = "top" === t3.label.position ? r2.width : -r2.width;
        s2.setAttribute("y", parseFloat(s2.getAttribute("y")) + n2);
        var o2 = this.annoCtx.graphics.rotateAroundCenter(s2), l2 = o2.x, h2 = o2.y;
        s2.setAttribute("transform", "rotate(-90 ".concat(l2, " ").concat(h2, ")"));
      }
    }
  } }, { key: "addBackgroundToAnno", value: function(t3, e2) {
    var i = this.w;
    if (!t3 || !e2.label.text || !String(e2.label.text).trim())
      return null;
    var a2 = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(), s2 = t3.getBoundingClientRect(), r2 = e2.label.style.padding, n2 = r2.left, o2 = r2.right, l2 = r2.top, h2 = r2.bottom;
    if ("vertical" === e2.label.orientation) {
      var c2 = [n2, o2, l2, h2];
      l2 = c2[0], h2 = c2[1], n2 = c2[2], o2 = c2[3];
    }
    var d2 = s2.left - a2.left - n2, u2 = s2.top - a2.top - l2, g2 = this.annoCtx.graphics.drawRect(d2 - i.globals.barPadForNumericAxis, u2, s2.width + n2 + o2, s2.height + l2 + h2, e2.label.borderRadius, e2.label.style.background, 1, e2.label.borderWidth, e2.label.borderColor, 0);
    return e2.id && g2.node.classList.add(e2.id), g2;
  } }, { key: "annotationsBackground", value: function() {
    var t3 = this, e2 = this.w, i = function(i2, a2, s2) {
      var r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(a2, "']"));
      if (r2) {
        var n2 = r2.parentNode, o2 = t3.addBackgroundToAnno(r2, i2);
        o2 && (n2.insertBefore(o2.node, r2), i2.label.mouseEnter && o2.node.addEventListener("mouseenter", i2.label.mouseEnter.bind(t3, i2)), i2.label.mouseLeave && o2.node.addEventListener("mouseleave", i2.label.mouseLeave.bind(t3, i2)), i2.label.click && o2.node.addEventListener("click", i2.label.click.bind(t3, i2)));
      }
    };
    e2.config.annotations.xaxis.forEach(function(t4, e3) {
      return i(t4, e3, "xaxis");
    }), e2.config.annotations.yaxis.forEach(function(t4, e3) {
      return i(t4, e3, "yaxis");
    }), e2.config.annotations.points.forEach(function(t4, e3) {
      return i(t4, e3, "point");
    });
  } }, { key: "getY1Y2", value: function(t3, e2) {
    var i, a2 = this.w, s2 = "y1" === t3 ? e2.y : e2.y2, r2 = false;
    if (this.annoCtx.invertAxis) {
      var n2 = a2.config.xaxis.convertedCatToNumeric ? a2.globals.categoryLabels : a2.globals.labels, o2 = n2.indexOf(s2), l2 = a2.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(".concat(o2 + 1, ")"));
      i = l2 ? parseFloat(l2.getAttribute("y")) : (a2.globals.gridHeight / n2.length - 1) * (o2 + 1) - a2.globals.barHeight, void 0 !== e2.seriesIndex && a2.globals.barHeight && (i -= a2.globals.barHeight / 2 * (a2.globals.series.length - 1) - a2.globals.barHeight * e2.seriesIndex);
    } else {
      var h2, c2 = a2.globals.seriesYAxisMap[e2.yAxisIndex][0], d2 = a2.config.yaxis[e2.yAxisIndex].logarithmic ? new Pi(this.annoCtx.ctx).getLogVal(a2.config.yaxis[e2.yAxisIndex].logBase, s2, c2) / a2.globals.yLogRatio[c2] : (s2 - a2.globals.minYArr[c2]) / (a2.globals.yRange[c2] / a2.globals.gridHeight);
      i = a2.globals.gridHeight - Math.min(Math.max(d2, 0), a2.globals.gridHeight), r2 = d2 > a2.globals.gridHeight || d2 < 0, !e2.marker || void 0 !== e2.y && null !== e2.y || (i = 0), null !== (h2 = a2.config.yaxis[e2.yAxisIndex]) && void 0 !== h2 && h2.reversed && (i = d2);
    }
    return "string" == typeof s2 && s2.includes("px") && (i = parseFloat(s2)), { yP: i, clipped: r2 };
  } }, { key: "getX1X2", value: function(t3, e2) {
    var i = this.w, a2 = "x1" === t3 ? e2.x : e2.x2, s2 = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX, r2 = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX, n2 = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange, o2 = false, l2 = this.annoCtx.inversedReversedAxis ? (r2 - a2) / (n2 / i.globals.gridWidth) : (a2 - s2) / (n2 / i.globals.gridWidth);
    return "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || i.config.chart.sparkline.enabled || (l2 = this.getStringX(a2)), "string" == typeof a2 && a2.includes("px") && (l2 = parseFloat(a2)), null == a2 && e2.marker && (l2 = i.globals.gridWidth), void 0 !== e2.seriesIndex && i.globals.barWidth && !this.annoCtx.invertAxis && (l2 -= i.globals.barWidth / 2 * (i.globals.series.length - 1) - i.globals.barWidth * e2.seriesIndex), l2 > i.globals.gridWidth ? (l2 = i.globals.gridWidth, o2 = true) : l2 < 0 && (l2 = 0, o2 = true), { x: l2, clipped: o2 };
  } }, { key: "getStringX", value: function(t3) {
    var e2 = this.w, i = t3;
    e2.config.xaxis.convertedCatToNumeric && e2.globals.categoryLabels.length && (t3 = e2.globals.categoryLabels.indexOf(t3) + 1);
    var a2 = e2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    }).indexOf(t3), s2 = e2.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(".concat(a2 + 1, ")"));
    return s2 && (i = parseFloat(s2.getAttribute("x"))), i;
  } }]), t2;
}(), Ti = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.annoCtx = e2, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addXaxisAnnotation", value: function(t3, e2, i) {
    var a2, s2 = this.w, r2 = this.helpers.getX1X2("x1", t3), n2 = r2.x, o2 = r2.clipped, l2 = true, h2 = t3.label.text, c2 = t3.strokeDashArray;
    if (v.isNumber(n2)) {
      if (null === t3.x2 || void 0 === t3.x2) {
        if (!o2) {
          var d2 = this.annoCtx.graphics.drawLine(n2 + t3.offsetX, 0 + t3.offsetY, n2 + t3.offsetX, s2.globals.gridHeight + t3.offsetY, t3.borderColor, c2, t3.borderWidth);
          e2.appendChild(d2.node), t3.id && d2.node.classList.add(t3.id);
        }
      } else {
        var u2 = this.helpers.getX1X2("x2", t3);
        if (a2 = u2.x, l2 = u2.clipped, a2 < n2) {
          var g2 = n2;
          n2 = a2, a2 = g2;
        }
        var p2 = this.annoCtx.graphics.drawRect(n2 + t3.offsetX, 0 + t3.offsetY, a2 - n2, s2.globals.gridHeight + t3.offsetY, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, c2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
      if (!o2 || !l2) {
        var f2 = this.annoCtx.graphics.getTextRects(h2, parseFloat(t3.label.style.fontSize)), x2 = "top" === t3.label.position ? 4 : "center" === t3.label.position ? s2.globals.gridHeight / 2 + ("vertical" === t3.label.orientation ? f2.width / 2 : 0) : s2.globals.gridHeight, b2 = this.annoCtx.graphics.drawText({ x: n2 + t3.label.offsetX, y: x2 + t3.label.offsetY - ("vertical" === t3.label.orientation ? "top" === t3.label.position ? f2.width / 2 - 12 : -f2.width / 2 : 0), text: h2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-xaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        b2.attr({ rel: i }), e2.appendChild(b2.node), this.annoCtx.helpers.setOrientations(t3, i);
      }
    }
  } }, { key: "drawXAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-xaxis-annotations" });
    return e2.config.annotations.xaxis.map(function(e3, a2) {
      t3.addXaxisAnnotation(e3, i.node, a2);
    }), i;
  } }]), t2;
}(), zi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  }
  return s(t2, [{ key: "isValidDate", value: function(t3) {
    return "number" != typeof t3 && !isNaN(this.parseDate(t3));
  } }, { key: "getTimeStamp", value: function(t3) {
    return Date.parse(t3) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toISOString().substr(0, 25)).getTime() : new Date(t3).getTime() : t3;
  } }, { key: "getDate", value: function(t3) {
    return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t3).toUTCString()) : new Date(t3);
  } }, { key: "parseDate", value: function(t3) {
    var e2 = Date.parse(t3);
    if (!isNaN(e2))
      return this.getTimeStamp(t3);
    var i = Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
    return i = this.getTimeStamp(i);
  } }, { key: "parseDateWithTimezone", value: function(t3) {
    return Date.parse(t3.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
  } }, { key: "formatDate", value: function(t3, e2) {
    var i = this.w.globals.locale, a2 = this.w.config.xaxis.labels.datetimeUTC, s2 = ["\0"].concat(f(i.months)), r2 = [""].concat(f(i.shortMonths)), n2 = [""].concat(f(i.days)), o2 = [""].concat(f(i.shortDays));
    function l2(t4, e3) {
      var i2 = t4 + "";
      for (e3 = e3 || 2; i2.length < e3; )
        i2 = "0" + i2;
      return i2;
    }
    var h2 = a2 ? t3.getUTCFullYear() : t3.getFullYear();
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])yyyy+/g, "$1" + h2)).replace(/(^|[^\\])yy/g, "$1" + h2.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + h2);
    var c2 = (a2 ? t3.getUTCMonth() : t3.getMonth()) + 1;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])MMMM+/g, "$1" + s2[0])).replace(/(^|[^\\])MMM/g, "$1" + r2[0])).replace(/(^|[^\\])MM/g, "$1" + l2(c2))).replace(/(^|[^\\])M/g, "$1" + c2);
    var d2 = a2 ? t3.getUTCDate() : t3.getDate();
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])dddd+/g, "$1" + n2[0])).replace(/(^|[^\\])ddd/g, "$1" + o2[0])).replace(/(^|[^\\])dd/g, "$1" + l2(d2))).replace(/(^|[^\\])d/g, "$1" + d2);
    var u2 = a2 ? t3.getUTCHours() : t3.getHours(), g2 = u2 > 12 ? u2 - 12 : 0 === u2 ? 12 : u2;
    e2 = (e2 = (e2 = (e2 = e2.replace(/(^|[^\\])HH+/g, "$1" + l2(u2))).replace(/(^|[^\\])H/g, "$1" + u2)).replace(/(^|[^\\])hh+/g, "$1" + l2(g2))).replace(/(^|[^\\])h/g, "$1" + g2);
    var p2 = a2 ? t3.getUTCMinutes() : t3.getMinutes();
    e2 = (e2 = e2.replace(/(^|[^\\])mm+/g, "$1" + l2(p2))).replace(/(^|[^\\])m/g, "$1" + p2);
    var x2 = a2 ? t3.getUTCSeconds() : t3.getSeconds();
    e2 = (e2 = e2.replace(/(^|[^\\])ss+/g, "$1" + l2(x2))).replace(/(^|[^\\])s/g, "$1" + x2);
    var b2 = a2 ? t3.getUTCMilliseconds() : t3.getMilliseconds();
    e2 = e2.replace(/(^|[^\\])fff+/g, "$1" + l2(b2, 3)), b2 = Math.round(b2 / 10), e2 = e2.replace(/(^|[^\\])ff/g, "$1" + l2(b2)), b2 = Math.round(b2 / 10);
    var m2 = u2 < 12 ? "AM" : "PM";
    e2 = (e2 = (e2 = e2.replace(/(^|[^\\])f/g, "$1" + b2)).replace(/(^|[^\\])TT+/g, "$1" + m2)).replace(/(^|[^\\])T/g, "$1" + m2.charAt(0));
    var v2 = m2.toLowerCase();
    e2 = (e2 = e2.replace(/(^|[^\\])tt+/g, "$1" + v2)).replace(/(^|[^\\])t/g, "$1" + v2.charAt(0));
    var y2 = -t3.getTimezoneOffset(), w2 = a2 || !y2 ? "Z" : y2 > 0 ? "+" : "-";
    if (!a2) {
      var k2 = (y2 = Math.abs(y2)) % 60;
      w2 += l2(Math.floor(y2 / 60)) + ":" + l2(k2);
    }
    e2 = e2.replace(/(^|[^\\])K/g, "$1" + w2);
    var A2 = (a2 ? t3.getUTCDay() : t3.getDay()) + 1;
    return e2 = (e2 = (e2 = (e2 = (e2 = e2.replace(new RegExp(n2[0], "g"), n2[A2])).replace(new RegExp(o2[0], "g"), o2[A2])).replace(new RegExp(s2[0], "g"), s2[c2])).replace(new RegExp(r2[0], "g"), r2[c2])).replace(/\\(.)/g, "$1");
  } }, { key: "getTimeUnitsfromTimestamp", value: function(t3, e2, i) {
    var a2 = this.w;
    void 0 !== a2.config.xaxis.min && (t3 = a2.config.xaxis.min), void 0 !== a2.config.xaxis.max && (e2 = a2.config.xaxis.max);
    var s2 = this.getDate(t3), r2 = this.getDate(e2), n2 = this.formatDate(s2, "yyyy MM dd HH mm ss fff").split(" "), o2 = this.formatDate(r2, "yyyy MM dd HH mm ss fff").split(" ");
    return { minMillisecond: parseInt(n2[6], 10), maxMillisecond: parseInt(o2[6], 10), minSecond: parseInt(n2[5], 10), maxSecond: parseInt(o2[5], 10), minMinute: parseInt(n2[4], 10), maxMinute: parseInt(o2[4], 10), minHour: parseInt(n2[3], 10), maxHour: parseInt(o2[3], 10), minDate: parseInt(n2[2], 10), maxDate: parseInt(o2[2], 10), minMonth: parseInt(n2[1], 10) - 1, maxMonth: parseInt(o2[1], 10) - 1, minYear: parseInt(n2[0], 10), maxYear: parseInt(o2[0], 10) };
  } }, { key: "isLeapYear", value: function(t3) {
    return t3 % 4 == 0 && t3 % 100 != 0 || t3 % 400 == 0;
  } }, { key: "calculcateLastDaysOfMonth", value: function(t3, e2, i) {
    return this.determineDaysOfMonths(t3, e2) - i;
  } }, { key: "determineDaysOfYear", value: function(t3) {
    var e2 = 365;
    return this.isLeapYear(t3) && (e2 = 366), e2;
  } }, { key: "determineRemainingDaysOfYear", value: function(t3, e2, i) {
    var a2 = this.daysCntOfYear[e2] + i;
    return e2 > 1 && this.isLeapYear() && a2++, a2;
  } }, { key: "determineDaysOfMonths", value: function(t3, e2) {
    var i = 30;
    switch (t3 = v.monthMod(t3), true) {
      case this.months30.indexOf(t3) > -1:
        2 === t3 && (i = this.isLeapYear(e2) ? 29 : 28);
        break;
      case this.months31.indexOf(t3) > -1:
      default:
        i = 31;
    }
    return i;
  } }]), t2;
}(), Xi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.tooltipKeyFormat = "dd MMM";
  }
  return s(t2, [{ key: "xLabelFormat", value: function(t3, e2, i, a2) {
    var s2 = this.w;
    if ("datetime" === s2.config.xaxis.type && void 0 === s2.config.xaxis.labels.formatter && void 0 === s2.config.tooltip.x.formatter) {
      var r2 = new zi(this.ctx);
      return r2.formatDate(r2.getDate(e2), s2.config.tooltip.x.format);
    }
    return t3(e2, i, a2);
  } }, { key: "defaultGeneralFormatter", value: function(t3) {
    return Array.isArray(t3) ? t3.map(function(t4) {
      return t4;
    }) : t3;
  } }, { key: "defaultYFormatter", value: function(t3, e2, i) {
    var a2 = this.w;
    if (v.isNumber(t3))
      if (0 !== a2.globals.yValueDecimal)
        t3 = t3.toFixed(void 0 !== e2.decimalsInFloat ? e2.decimalsInFloat : a2.globals.yValueDecimal);
      else {
        var s2 = t3.toFixed(0);
        t3 = t3 == s2 ? s2 : t3.toFixed(1);
      }
    return t3;
  } }, { key: "setLabelFormatters", value: function() {
    var t3 = this, e2 = this.w;
    return e2.globals.xaxisTooltipFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttKeyFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, e2.globals.ttZFormatter = function(t4) {
      return t4;
    }, e2.globals.legendFormatter = function(e3) {
      return t3.defaultGeneralFormatter(e3);
    }, void 0 !== e2.config.xaxis.labels.formatter ? e2.globals.xLabelFormatter = e2.config.xaxis.labels.formatter : e2.globals.xLabelFormatter = function(t4) {
      if (v.isNumber(t4)) {
        if (!e2.config.xaxis.convertedCatToNumeric && "numeric" === e2.config.xaxis.type) {
          if (v.isNumber(e2.config.xaxis.decimalsInFloat))
            return t4.toFixed(e2.config.xaxis.decimalsInFloat);
          var i = e2.globals.maxX - e2.globals.minX;
          return i > 0 && i < 100 ? t4.toFixed(1) : t4.toFixed(0);
        }
        if (e2.globals.isBarHorizontal) {
          if (e2.globals.maxY - e2.globals.minYArr < 4)
            return t4.toFixed(1);
        }
        return t4.toFixed(0);
      }
      return t4;
    }, "function" == typeof e2.config.tooltip.x.formatter ? e2.globals.ttKeyFormatter = e2.config.tooltip.x.formatter : e2.globals.ttKeyFormatter = e2.globals.xLabelFormatter, "function" == typeof e2.config.xaxis.tooltip.formatter && (e2.globals.xaxisTooltipFormatter = e2.config.xaxis.tooltip.formatter), (Array.isArray(e2.config.tooltip.y) || void 0 !== e2.config.tooltip.y.formatter) && (e2.globals.ttVal = e2.config.tooltip.y), void 0 !== e2.config.tooltip.z.formatter && (e2.globals.ttZFormatter = e2.config.tooltip.z.formatter), void 0 !== e2.config.legend.formatter && (e2.globals.legendFormatter = e2.config.legend.formatter), e2.config.yaxis.forEach(function(i, a2) {
      void 0 !== i.labels.formatter ? e2.globals.yLabelFormatters[a2] = i.labels.formatter : e2.globals.yLabelFormatters[a2] = function(s2) {
        return e2.globals.xyCharts ? Array.isArray(s2) ? s2.map(function(e3) {
          return t3.defaultYFormatter(e3, i, a2);
        }) : t3.defaultYFormatter(s2, i, a2) : s2;
      };
    }), e2.globals;
  } }, { key: "heatmapLabelFormatters", value: function() {
    var t3 = this.w;
    if ("heatmap" === t3.config.chart.type) {
      t3.globals.yAxisScale[0].result = t3.globals.seriesNames.slice();
      var e2 = t3.globals.seriesNames.reduce(function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }, 0);
      t3.globals.yAxisScale[0].niceMax = e2, t3.globals.yAxisScale[0].niceMin = e2;
    }
  } }]), t2;
}(), Ri = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "getLabel", value: function(t3, e2, i, a2) {
    var s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [], r2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px", n2 = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6], o2 = this.w, l2 = void 0 === t3[a2] ? "" : t3[a2], h2 = l2, c2 = o2.globals.xLabelFormatter, d2 = o2.config.xaxis.labels.formatter, u2 = false, g2 = new Xi(this.ctx), p2 = l2;
    n2 && (h2 = g2.xLabelFormat(c2, l2, p2, { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 }), void 0 !== d2 && (h2 = d2(l2, t3[a2], { i: a2, dateFormatter: new zi(this.ctx).formatDate, w: o2 })));
    var f2, x2;
    e2.length > 0 ? (f2 = e2[a2].unit, x2 = null, e2.forEach(function(t4) {
      "month" === t4.unit ? x2 = "year" : "day" === t4.unit ? x2 = "month" : "hour" === t4.unit ? x2 = "day" : "minute" === t4.unit && (x2 = "hour");
    }), u2 = x2 === f2, i = e2[a2].position, h2 = e2[a2].value) : "datetime" === o2.config.xaxis.type && void 0 === d2 && (h2 = ""), void 0 === h2 && (h2 = ""), h2 = Array.isArray(h2) ? h2 : h2.toString();
    var b2 = new Mi(this.ctx), m2 = {};
    m2 = o2.globals.rotateXLabels && n2 ? b2.getTextRects(h2, parseInt(r2, 10), null, "rotate(".concat(o2.config.xaxis.labels.rotate, " 0 0)"), false) : b2.getTextRects(h2, parseInt(r2, 10));
    var v2 = !o2.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
    return !Array.isArray(h2) && ("NaN" === String(h2) || s2.indexOf(h2) >= 0 && v2) && (h2 = ""), { x: i, text: h2, textRect: m2, isBold: u2 };
  } }, { key: "checkLabelBasedOnTickamount", value: function(t3, e2, i) {
    var a2 = this.w, s2 = a2.config.xaxis.tickAmount;
    return "dataPoints" === s2 && (s2 = Math.round(a2.globals.gridWidth / 120)), s2 > i || t3 % Math.round(i / (s2 + 1)) == 0 || (e2.text = ""), e2;
  } }, { key: "checkForOverflowingLabels", value: function(t3, e2, i, a2, s2) {
    var r2 = this.w;
    if (0 === t3 && r2.globals.skipFirstTimelinelabel && (e2.text = ""), t3 === i - 1 && r2.globals.skipLastTimelinelabel && (e2.text = ""), r2.config.xaxis.labels.hideOverlappingLabels && a2.length > 0) {
      var n2 = s2[s2.length - 1];
      e2.x < n2.textRect.width / (r2.globals.rotateXLabels ? Math.abs(r2.config.xaxis.labels.rotate) / 12 : 1.01) + n2.x && (e2.text = "");
    }
    return e2;
  } }, { key: "checkForReversedLabels", value: function(t3, e2) {
    var i = this.w;
    return i.config.yaxis[t3] && i.config.yaxis[t3].reversed && e2.reverse(), e2;
  } }, { key: "yAxisAllSeriesCollapsed", value: function(t3) {
    var e2 = this.w.globals;
    return !e2.seriesYAxisMap[t3].some(function(t4) {
      return -1 === e2.collapsedSeriesIndices.indexOf(t4);
    });
  } }, { key: "translateYAxisIndex", value: function(t3) {
    var e2 = this.w, i = e2.globals, a2 = e2.config.yaxis;
    return i.series.length > a2.length || a2.some(function(t4) {
      return Array.isArray(t4.seriesName);
    }) ? t3 : i.seriesYAxisReverseMap[t3];
  } }, { key: "isYAxisHidden", value: function(t3) {
    var e2 = this.w, i = e2.config.yaxis[t3];
    if (!i.show || this.yAxisAllSeriesCollapsed(t3))
      return true;
    if (!i.showForNullSeries) {
      var a2 = e2.globals.seriesYAxisMap[t3], s2 = new Pi(this.ctx);
      return a2.every(function(t4) {
        return s2.isSeriesNull(t4);
      });
    }
    return false;
  } }, { key: "getYAxisForeColor", value: function(t3, e2) {
    var i = this.w;
    return Array.isArray(t3) && i.globals.yAxisScale[e2] && this.ctx.theme.pushExtraColors(t3, i.globals.yAxisScale[e2].result.length, false), t3;
  } }, { key: "drawYAxisTicks", value: function(t3, e2, i, a2, s2, r2, n2) {
    var o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.translateY + o2.config.yaxis[s2].labels.offsetY;
    if (o2.globals.isBarHorizontal ? h2 = 0 : "heatmap" === o2.config.chart.type && (h2 += r2 / 2), a2.show && e2 > 0) {
      true === o2.config.yaxis[s2].opposite && (t3 += a2.width);
      for (var c2 = e2; c2 >= 0; c2--) {
        var d2 = l2.drawLine(t3 + i.offsetX - a2.width + a2.offsetX, h2 + a2.offsetY, t3 + i.offsetX + a2.offsetX, h2 + a2.offsetY, a2.color);
        n2.add(d2), h2 += r2;
      }
    }
  } }]), t2;
}(), Ei = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx), this.axesUtils = new Ri(this.annoCtx);
  }
  return s(t2, [{ key: "addYaxisAnnotation", value: function(t3, e2, i) {
    var a2, s2 = this.w, r2 = t3.strokeDashArray, n2 = this.helpers.getY1Y2("y1", t3), o2 = n2.yP, l2 = n2.clipped, h2 = true, c2 = false, d2 = t3.label.text;
    if (null === t3.y2 || void 0 === t3.y2) {
      if (!l2) {
        c2 = true;
        var u2 = this.annoCtx.graphics.drawLine(0 + t3.offsetX, o2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 + t3.offsetY, t3.borderColor, r2, t3.borderWidth);
        e2.appendChild(u2.node), t3.id && u2.node.classList.add(t3.id);
      }
    } else {
      if (a2 = (n2 = this.helpers.getY1Y2("y2", t3)).yP, h2 = n2.clipped, a2 > o2) {
        var g2 = o2;
        o2 = a2, a2 = g2;
      }
      if (!l2 || !h2) {
        c2 = true;
        var p2 = this.annoCtx.graphics.drawRect(0 + t3.offsetX, a2 + t3.offsetY, this._getYAxisAnnotationWidth(t3), o2 - a2, 0, t3.fillColor, t3.opacity, 1, t3.borderColor, r2);
        p2.node.classList.add("apexcharts-annotation-rect"), p2.attr("clip-path", "url(#gridRectMask".concat(s2.globals.cuid, ")")), e2.appendChild(p2.node), t3.id && p2.node.classList.add(t3.id);
      }
    }
    if (c2) {
      var f2 = "right" === t3.label.position ? s2.globals.gridWidth : "center" === t3.label.position ? s2.globals.gridWidth / 2 : 0, x2 = this.annoCtx.graphics.drawText({ x: f2 + t3.label.offsetX, y: (null != a2 ? a2 : o2) + t3.label.offsetY - 3, text: d2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-yaxis-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
      x2.attr({ rel: i }), e2.appendChild(x2.node);
    }
  } }, { key: "_getYAxisAnnotationWidth", value: function(t3) {
    var e2 = this.w;
    e2.globals.gridWidth;
    return (t3.width.indexOf("%") > -1 ? e2.globals.gridWidth * parseInt(t3.width, 10) / 100 : parseInt(t3.width, 10)) + t3.offsetX;
  } }, { key: "drawYAxisAnnotations", value: function() {
    var t3 = this, e2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-yaxis-annotations" });
    return e2.config.annotations.yaxis.forEach(function(e3, a2) {
      e3.yAxisIndex = t3.axesUtils.translateYAxisIndex(e3.yAxisIndex), t3.axesUtils.isYAxisHidden(e3.yAxisIndex) && t3.axesUtils.yAxisAllSeriesCollapsed(e3.yAxisIndex) || t3.addYaxisAnnotation(e3, i.node, a2);
    }), i;
  } }]), t2;
}(), Yi = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.annoCtx = e2, this.helpers = new Ii(this.annoCtx);
  }
  return s(t2, [{ key: "addPointAnnotation", value: function(t3, e2, i) {
    if (!(this.w.globals.collapsedSeriesIndices.indexOf(t3.seriesIndex) > -1)) {
      var a2 = this.helpers.getX1X2("x1", t3), s2 = a2.x, r2 = a2.clipped, n2 = (a2 = this.helpers.getY1Y2("y1", t3)).yP, o2 = a2.clipped;
      if (v.isNumber(s2) && !o2 && !r2) {
        var l2 = { pSize: t3.marker.size, pointStrokeWidth: t3.marker.strokeWidth, pointFillColor: t3.marker.fillColor, pointStrokeColor: t3.marker.strokeColor, shape: t3.marker.shape, pRadius: t3.marker.radius, class: "apexcharts-point-annotation-marker ".concat(t3.marker.cssClass, " ").concat(t3.id ? t3.id : "") }, h2 = this.annoCtx.graphics.drawMarker(s2 + t3.marker.offsetX, n2 + t3.marker.offsetY, l2);
        e2.appendChild(h2.node);
        var c2 = t3.label.text ? t3.label.text : "", d2 = this.annoCtx.graphics.drawText({ x: s2 + t3.label.offsetX, y: n2 + t3.label.offsetY - t3.marker.size - parseFloat(t3.label.style.fontSize) / 1.6, text: c2, textAnchor: t3.label.textAnchor, fontSize: t3.label.style.fontSize, fontFamily: t3.label.style.fontFamily, fontWeight: t3.label.style.fontWeight, foreColor: t3.label.style.color, cssClass: "apexcharts-point-annotation-label ".concat(t3.label.style.cssClass, " ").concat(t3.id ? t3.id : "") });
        if (d2.attr({ rel: i }), e2.appendChild(d2.node), t3.customSVG.SVG) {
          var u2 = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations-custom-svg " + t3.customSVG.cssClass });
          u2.attr({ transform: "translate(".concat(s2 + t3.customSVG.offsetX, ", ").concat(n2 + t3.customSVG.offsetY, ")") }), u2.node.innerHTML = t3.customSVG.SVG, e2.appendChild(u2.node);
        }
        if (t3.image.path) {
          var g2 = t3.image.width ? t3.image.width : 20, p2 = t3.image.height ? t3.image.height : 20;
          h2 = this.annoCtx.addImage({ x: s2 + t3.image.offsetX - g2 / 2, y: n2 + t3.image.offsetY - p2 / 2, width: g2, height: p2, path: t3.image.path, appendTo: ".apexcharts-point-annotations" });
        }
        t3.mouseEnter && h2.node.addEventListener("mouseenter", t3.mouseEnter.bind(this, t3)), t3.mouseLeave && h2.node.addEventListener("mouseleave", t3.mouseLeave.bind(this, t3)), t3.click && h2.node.addEventListener("click", t3.click.bind(this, t3));
      }
    }
  } }, { key: "drawPointAnnotations", value: function() {
    var t3 = this, e2 = this.w, i = this.annoCtx.graphics.group({ class: "apexcharts-point-annotations" });
    return e2.config.annotations.points.map(function(e3, a2) {
      t3.addPointAnnotation(e3, i.node, a2);
    }), i;
  } }]), t2;
}();
var Hi = { name: "en", options: { months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], toolbar: { exportToSVG: "Download SVG", exportToPNG: "Download PNG", exportToCSV: "Download CSV", menu: "Menu", selection: "Selection", selectionZoom: "Selection Zoom", zoomIn: "Zoom In", zoomOut: "Zoom Out", pan: "Panning", reset: "Reset Zoom" } } }, Oi = function() {
  function t2() {
    i$1(this, t2), this.yAxis = { show: true, showAlways: false, showForNullSeries: true, seriesName: void 0, opposite: false, reversed: false, logarithmic: false, logBase: 10, tickAmount: void 0, stepSize: void 0, forceNiceScale: false, max: void 0, min: void 0, floating: false, decimalsInFloat: void 0, labels: { show: true, showDuplicates: false, minWidth: 0, maxWidth: 160, offsetX: 0, offsetY: 0, align: void 0, rotate: 0, padding: 20, style: { colors: [], fontSize: "11px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, formatter: void 0 }, axisBorder: { show: false, color: "#e0e0e0", width: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: false, color: "#e0e0e0", width: 6, offsetX: 0, offsetY: 0 }, title: { text: void 0, rotate: -90, offsetY: 0, offsetX: 0, style: { color: void 0, fontSize: "11px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, tooltip: { enabled: false, offsetX: 0 }, crosshairs: { show: true, position: "front", stroke: { color: "#b6b6b6", width: 1, dashArray: 0 } } }, this.pointAnnotation = { id: void 0, x: 0, y: null, yAxisIndex: 0, seriesIndex: void 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, marker: { size: 4, fillColor: "#fff", strokeWidth: 2, strokeColor: "#333", shape: "circle", offsetX: 0, offsetY: 0, cssClass: "" }, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } }, customSVG: { SVG: void 0, cssClass: void 0, offsetX: 0, offsetY: 0 }, image: { path: void 0, width: 20, height: 20, offsetX: 0, offsetY: 0 } }, this.yAxisAnnotation = { id: void 0, y: 0, y2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, width: "100%", yAxisIndex: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "end", position: "right", offsetX: 0, offsetY: -3, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.xAxisAnnotation = { id: void 0, x: 0, x2: null, strokeDashArray: 1, fillColor: "#c2c2c2", borderColor: "#c2c2c2", borderWidth: 1, opacity: 0.3, offsetX: 0, offsetY: 0, label: { borderColor: "#c2c2c2", borderWidth: 1, borderRadius: 2, text: void 0, textAnchor: "middle", orientation: "vertical", position: "top", offsetX: 0, offsetY: 0, mouseEnter: void 0, mouseLeave: void 0, click: void 0, style: { background: "#fff", color: void 0, fontSize: "11px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 5, right: 5, top: 2, bottom: 2 } } } }, this.text = { x: 0, y: 0, text: "", textAnchor: "start", foreColor: void 0, fontSize: "13px", fontFamily: void 0, fontWeight: 400, appendTo: ".apexcharts-annotations", backgroundColor: "transparent", borderColor: "#c2c2c2", borderRadius: 0, borderWidth: 0, paddingLeft: 4, paddingRight: 4, paddingTop: 2, paddingBottom: 2 };
  }
  return s(t2, [{ key: "init", value: function() {
    return { annotations: { yaxis: [this.yAxisAnnotation], xaxis: [this.xAxisAnnotation], points: [this.pointAnnotation], texts: [], images: [], shapes: [] }, chart: { animations: { enabled: true, speed: 800, animateGradually: { delay: 150, enabled: true }, dynamicAnimation: { enabled: true, speed: 350 } }, background: "", locales: [Hi], defaultLocale: "en", dropShadow: { enabled: false, enabledOnSeries: void 0, top: 2, left: 2, blur: 4, color: "#000", opacity: 0.7 }, events: { animationEnd: void 0, beforeMount: void 0, mounted: void 0, updated: void 0, click: void 0, mouseMove: void 0, mouseLeave: void 0, xAxisLabelClick: void 0, legendClick: void 0, markerClick: void 0, selection: void 0, dataPointSelection: void 0, dataPointMouseEnter: void 0, dataPointMouseLeave: void 0, beforeZoom: void 0, beforeResetZoom: void 0, zoomed: void 0, scrolled: void 0, brushScrolled: void 0 }, foreColor: "#373d3f", fontFamily: "Helvetica, Arial, sans-serif", height: "auto", parentHeightOffset: 15, redrawOnParentResize: true, redrawOnWindowResize: true, id: void 0, group: void 0, nonce: void 0, offsetX: 0, offsetY: 0, selection: { enabled: false, type: "x", fill: { color: "#24292e", opacity: 0.1 }, stroke: { width: 1, color: "#24292e", opacity: 0.4, dashArray: 3 }, xaxis: { min: void 0, max: void 0 }, yaxis: { min: void 0, max: void 0 } }, sparkline: { enabled: false }, brush: { enabled: false, autoScaleYaxis: true, target: void 0, targets: void 0 }, stacked: false, stackOnlyBar: true, stackType: "normal", toolbar: { show: true, offsetX: 0, offsetY: 0, tools: { download: true, selection: true, zoom: true, zoomin: true, zoomout: true, pan: true, reset: true, customIcons: [] }, export: { csv: { filename: void 0, columnDelimiter: ",", headerCategory: "category", headerValue: "value", categoryFormatter: void 0, valueFormatter: void 0 }, png: { filename: void 0 }, svg: { filename: void 0 }, scale: void 0, width: void 0 }, autoSelected: "zoom" }, type: "line", width: "100%", zoom: { enabled: true, type: "x", autoScaleYaxis: false, allowMouseWheelZoom: true, zoomedArea: { fill: { color: "#90CAF9", opacity: 0.4 }, stroke: { color: "#0D47A1", opacity: 0.4, width: 1 } } } }, plotOptions: { line: { isSlopeChart: false, colors: { threshold: 0, colorAboveThreshold: void 0, colorBelowThreshold: void 0 } }, area: { fillTo: "origin" }, bar: { horizontal: false, columnWidth: "70%", barHeight: "70%", distributed: false, borderRadius: 0, borderRadiusApplication: "around", borderRadiusWhenStacked: "last", rangeBarOverlap: true, rangeBarGroupRows: false, hideZeroBarsWhenGrouped: false, isDumbbell: false, dumbbellColors: void 0, isFunnel: false, isFunnel3d: true, colors: { ranges: [], backgroundBarColors: [], backgroundBarOpacity: 1, backgroundBarRadius: 0 }, dataLabels: { position: "top", maxItems: 100, hideOverflowingLabels: true, orientation: "horizontal", total: { enabled: false, formatter: void 0, offsetX: 0, offsetY: 0, style: { color: "#373d3f", fontSize: "12px", fontFamily: void 0, fontWeight: 600 } } } }, bubble: { zScaling: true, minBubbleRadius: void 0, maxBubbleRadius: void 0 }, candlestick: { colors: { upward: "#00B746", downward: "#EF403C" }, wick: { useFillColor: true } }, boxPlot: { colors: { upper: "#00E396", lower: "#008FFB" } }, heatmap: { radius: 2, enableShades: true, shadeIntensity: 0.5, reverseNegativeShade: false, distributed: false, useFillColorAsStroke: false, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 } }, treemap: { enableShades: true, shadeIntensity: 0.5, distributed: false, reverseNegativeShade: false, useFillColorAsStroke: false, borderRadius: 4, dataLabels: { format: "scale" }, colorScale: { inverse: false, ranges: [], min: void 0, max: void 0 }, seriesTitle: { show: true, offsetY: 1, offsetX: 1, borderColor: "#000", borderWidth: 1, borderRadius: 2, style: { background: "rgba(0, 0, 0, 0.6)", color: "#fff", fontSize: "12px", fontFamily: void 0, fontWeight: 400, cssClass: "", padding: { left: 6, right: 6, top: 2, bottom: 2 } } } }, radialBar: { inverseOrder: false, startAngle: 0, endAngle: 360, offsetX: 0, offsetY: 0, hollow: { margin: 5, size: "50%", background: "transparent", image: void 0, imageWidth: 150, imageHeight: 150, imageOffsetX: 0, imageOffsetY: 0, imageClipped: true, position: "front", dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, track: { show: true, startAngle: void 0, endAngle: void 0, background: "#f2f2f2", strokeWidth: "97%", opacity: 1, margin: 5, dropShadow: { enabled: false, top: 0, left: 0, blur: 3, color: "#000", opacity: 0.5 } }, dataLabels: { show: true, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: 0, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "14px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 16, formatter: function(t3) {
      return t3 + "%";
    } }, total: { show: false, label: "Total", fontSize: "16px", fontWeight: 600, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0) / t3.globals.series.length + "%";
    } } }, barLabels: { enabled: false, offsetX: 0, offsetY: 0, useSeriesColors: true, fontFamily: void 0, fontWeight: 600, fontSize: "16px", formatter: function(t3) {
      return t3;
    }, onClick: void 0 } }, pie: { customScale: 1, offsetX: 0, offsetY: 0, startAngle: 0, endAngle: 360, expandOnClick: true, dataLabels: { offset: 0, minAngleToShowLabel: 10 }, donut: { size: "65%", background: "transparent", labels: { show: false, name: { show: true, fontSize: "16px", fontFamily: void 0, fontWeight: 600, color: void 0, offsetY: -10, formatter: function(t3) {
      return t3;
    } }, value: { show: true, fontSize: "20px", fontFamily: void 0, fontWeight: 400, color: void 0, offsetY: 10, formatter: function(t3) {
      return t3;
    } }, total: { show: false, showAlways: false, label: "Total", fontSize: "16px", fontWeight: 400, fontFamily: void 0, color: void 0, formatter: function(t3) {
      return t3.globals.seriesTotals.reduce(function(t4, e2) {
        return t4 + e2;
      }, 0);
    } } } } }, polarArea: { rings: { strokeWidth: 1, strokeColor: "#e8e8e8" }, spokes: { strokeWidth: 1, connectorColors: "#e8e8e8" } }, radar: { size: void 0, offsetX: 0, offsetY: 0, polygons: { strokeWidth: 1, strokeColors: "#e8e8e8", connectorColors: "#e8e8e8", fill: { colors: void 0 } } } }, colors: void 0, dataLabels: { enabled: true, enabledOnSeries: void 0, formatter: function(t3) {
      return null !== t3 ? t3 : "";
    }, textAnchor: "middle", distributed: false, offsetX: 0, offsetY: 0, style: { fontSize: "12px", fontFamily: void 0, fontWeight: 600, colors: void 0 }, background: { enabled: true, foreColor: "#fff", borderRadius: 2, padding: 4, opacity: 0.9, borderWidth: 1, borderColor: "#fff", dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, dropShadow: { enabled: false, top: 1, left: 1, blur: 1, color: "#000", opacity: 0.8 } }, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] }, image: { src: [], width: void 0, height: void 0 }, pattern: { style: "squares", width: 6, height: 6, strokeWidth: 2 } }, forecastDataPoints: { count: 0, fillOpacity: 0.5, strokeWidth: void 0, dashArray: 4 }, grid: { show: true, borderColor: "#e0e0e0", strokeDashArray: 0, position: "back", xaxis: { lines: { show: false } }, yaxis: { lines: { show: true } }, row: { colors: void 0, opacity: 0.5 }, column: { colors: void 0, opacity: 0.5 }, padding: { top: 0, right: 10, bottom: 0, left: 12 } }, labels: [], legend: { show: true, showForSingleSeries: false, showForNullSeries: true, showForZeroSeries: true, floating: false, position: "bottom", horizontalAlign: "center", inverseOrder: false, fontSize: "12px", fontFamily: void 0, fontWeight: 400, width: void 0, height: void 0, formatter: void 0, tooltipHoverFormatter: void 0, offsetX: -20, offsetY: 4, customLegendItems: [], clusterGroupedSeries: true, clusterGroupedSeriesOrientation: "vertical", labels: { colors: void 0, useSeriesColors: false }, markers: { size: 7, fillColors: void 0, strokeWidth: 1, shape: void 0, offsetX: 0, offsetY: 0, customHTML: void 0, onClick: void 0 }, itemMargin: { horizontal: 5, vertical: 4 }, onItemClick: { toggleDataSeries: true }, onItemHover: { highlightDataSeries: true } }, markers: { discrete: [], size: 0, colors: void 0, strokeColors: "#fff", strokeWidth: 2, strokeOpacity: 0.9, strokeDashArray: 0, fillOpacity: 1, shape: "circle", offsetX: 0, offsetY: 0, showNullDataPoints: true, onClick: void 0, onDblClick: void 0, hover: { size: void 0, sizeOffset: 3 } }, noData: { text: void 0, align: "center", verticalAlign: "middle", offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "14px", fontFamily: void 0 } }, responsive: [], series: void 0, states: { hover: { filter: { type: "lighten" } }, active: { allowMultipleDataPointsSelection: false, filter: { type: "darken" } } }, title: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 0, floating: false, style: { fontSize: "14px", fontWeight: 900, fontFamily: void 0, color: void 0 } }, subtitle: { text: void 0, align: "left", margin: 5, offsetX: 0, offsetY: 30, floating: false, style: { fontSize: "12px", fontWeight: 400, fontFamily: void 0, color: void 0 } }, stroke: { show: true, curve: "smooth", lineCap: "butt", width: 2, colors: void 0, dashArray: 0, fill: { type: "solid", colors: void 0, opacity: 0.85, gradient: { shade: "dark", type: "horizontal", shadeIntensity: 0.5, gradientToColors: void 0, inverseColors: true, opacityFrom: 1, opacityTo: 1, stops: [0, 50, 100], colorStops: [] } } }, tooltip: { enabled: true, enabledOnSeries: void 0, shared: true, hideEmptySeries: false, followCursor: false, intersect: false, inverseOrder: false, custom: void 0, fillSeriesColor: false, theme: "light", cssClass: "", style: { fontSize: "12px", fontFamily: void 0 }, onDatasetHover: { highlightDataSeries: false }, x: { show: true, format: "dd MMM", formatter: void 0 }, y: { formatter: void 0, title: { formatter: function(t3) {
      return t3 ? t3 + ": " : "";
    } } }, z: { formatter: void 0, title: "Size: " }, marker: { show: true, fillColors: void 0 }, items: { display: "flex" }, fixed: { enabled: false, position: "topRight", offsetX: 0, offsetY: 0 } }, xaxis: { type: "category", categories: [], convertedCatToNumeric: false, offsetX: 0, offsetY: 0, overwriteCategories: void 0, labels: { show: true, rotate: -45, rotateAlways: false, hideOverlappingLabels: true, trim: false, minHeight: void 0, maxHeight: 120, showDuplicates: true, style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" }, offsetX: 0, offsetY: 0, format: void 0, formatter: void 0, datetimeUTC: true, datetimeFormatter: { year: "yyyy", month: "MMM 'yy", day: "dd MMM", hour: "HH:mm", minute: "HH:mm:ss", second: "HH:mm:ss" } }, group: { groups: [], style: { colors: [], fontSize: "12px", fontWeight: 400, fontFamily: void 0, cssClass: "" } }, axisBorder: { show: true, color: "#e0e0e0", width: "100%", height: 1, offsetX: 0, offsetY: 0 }, axisTicks: { show: true, color: "#e0e0e0", height: 6, offsetX: 0, offsetY: 0 }, stepSize: void 0, tickAmount: void 0, tickPlacement: "on", min: void 0, max: void 0, range: void 0, floating: false, decimalsInFloat: void 0, position: "bottom", title: { text: void 0, offsetX: 0, offsetY: 0, style: { color: void 0, fontSize: "12px", fontWeight: 900, fontFamily: void 0, cssClass: "" } }, crosshairs: { show: true, width: 1, position: "back", opacity: 0.9, stroke: { color: "#b6b6b6", width: 1, dashArray: 3 }, fill: { type: "solid", color: "#B1B9C4", gradient: { colorFrom: "#D8E3F0", colorTo: "#BED1E6", stops: [0, 100], opacityFrom: 0.4, opacityTo: 0.5 } }, dropShadow: { enabled: false, left: 0, top: 0, blur: 1, opacity: 0.8 } }, tooltip: { enabled: true, offsetY: 0, formatter: void 0, style: { fontSize: "12px", fontFamily: void 0 } } }, yaxis: this.yAxis, theme: { mode: "", palette: "palette1", monochrome: { enabled: false, color: "#008FFB", shadeTo: "light", shadeIntensity: 0.65 } } };
  } }]), t2;
}(), Fi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.graphics = new Mi(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = true), this.helpers = new Ii(this), this.xAxisAnnotations = new Ti(this), this.yAxisAnnotations = new Ei(this), this.pointsAnnotations = new Yi(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = true), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints;
  }
  return s(t2, [{ key: "drawAxesAnnotations", value: function() {
    var t3 = this.w;
    if (t3.globals.axisCharts && t3.globals.dataPoints) {
      for (var e2 = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a2 = this.pointsAnnotations.drawPointAnnotations(), s2 = t3.config.chart.animations.enabled, r2 = [e2, i, a2], n2 = [i.node, e2.node, a2.node], o2 = 0; o2 < 3; o2++)
        t3.globals.dom.elGraphical.add(r2[o2]), !s2 || t3.globals.resized || t3.globals.dataChanged || "scatter" !== t3.config.chart.type && "bubble" !== t3.config.chart.type && t3.globals.dataPoints > 1 && n2[o2].classList.add("apexcharts-element-hidden"), t3.globals.delayedElements.push({ el: n2[o2], index: 0 });
      this.helpers.annotationsBackground();
    }
  } }, { key: "drawImageAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.images.map(function(e2, i) {
      t3.addImage(e2, i);
    });
  } }, { key: "drawTextAnnos", value: function() {
    var t3 = this;
    this.w.config.annotations.texts.map(function(e2, i) {
      t3.addText(e2, i);
    });
  } }, { key: "addXaxisAnnotation", value: function(t3, e2, i) {
    this.xAxisAnnotations.addXaxisAnnotation(t3, e2, i);
  } }, { key: "addYaxisAnnotation", value: function(t3, e2, i) {
    this.yAxisAnnotations.addYaxisAnnotation(t3, e2, i);
  } }, { key: "addPointAnnotation", value: function(t3, e2, i) {
    this.pointsAnnotations.addPointAnnotation(t3, e2, i);
  } }, { key: "addText", value: function(t3, e2) {
    var i = t3.x, a2 = t3.y, s2 = t3.text, r2 = t3.textAnchor, n2 = t3.foreColor, o2 = t3.fontSize, l2 = t3.fontFamily, h2 = t3.fontWeight, c2 = t3.cssClass, d2 = t3.backgroundColor, u2 = t3.borderWidth, g2 = t3.strokeDashArray, p2 = t3.borderRadius, f2 = t3.borderColor, x2 = t3.appendTo, b2 = void 0 === x2 ? ".apexcharts-svg" : x2, m2 = t3.paddingLeft, v2 = void 0 === m2 ? 4 : m2, y2 = t3.paddingRight, w2 = void 0 === y2 ? 4 : y2, k2 = t3.paddingBottom, A2 = void 0 === k2 ? 2 : k2, C2 = t3.paddingTop, S2 = void 0 === C2 ? 2 : C2, L2 = this.w, M2 = this.graphics.drawText({ x: i, y: a2, text: s2, textAnchor: r2 || "start", fontSize: o2 || "12px", fontWeight: h2 || "regular", fontFamily: l2 || L2.config.chart.fontFamily, foreColor: n2 || L2.config.chart.foreColor, cssClass: c2 }), P2 = L2.globals.dom.baseEl.querySelector(b2);
    P2 && P2.appendChild(M2.node);
    var I2 = M2.bbox();
    if (s2) {
      var T2 = this.graphics.drawRect(I2.x - v2, I2.y - S2, I2.width + v2 + w2, I2.height + A2 + S2, p2, d2 || "transparent", 1, u2, f2, g2);
      P2.insertBefore(T2.node, M2.node);
    }
  } }, { key: "addImage", value: function(t3, e2) {
    var i = this.w, a2 = t3.path, s2 = t3.x, r2 = void 0 === s2 ? 0 : s2, n2 = t3.y, o2 = void 0 === n2 ? 0 : n2, l2 = t3.width, h2 = void 0 === l2 ? 20 : l2, c2 = t3.height, d2 = void 0 === c2 ? 20 : c2, u2 = t3.appendTo, g2 = void 0 === u2 ? ".apexcharts-svg" : u2, p2 = i.globals.dom.Paper.image(a2);
    p2.size(h2, d2).move(r2, o2);
    var f2 = i.globals.dom.baseEl.querySelector(g2);
    return f2 && f2.appendChild(p2.node), p2;
  } }, { key: "addXaxisAnnotationExternal", value: function(t3, e2, i) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i, type: "xaxis", contextMethod: i.addXaxisAnnotation }), i;
  } }, { key: "addYaxisAnnotationExternal", value: function(t3, e2, i) {
    return this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i, type: "yaxis", contextMethod: i.addYaxisAnnotation }), i;
  } }, { key: "addPointAnnotationExternal", value: function(t3, e2, i) {
    return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({ params: t3, pushToMemory: e2, context: i, type: "point", contextMethod: i.addPointAnnotation }), i;
  } }, { key: "addAnnotationExternal", value: function(t3) {
    var e2 = t3.params, i = t3.pushToMemory, a2 = t3.context, s2 = t3.type, r2 = t3.contextMethod, n2 = a2, o2 = n2.w, l2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations")), h2 = l2.childNodes.length + 1, c2 = new Oi(), d2 = Object.assign({}, "xaxis" === s2 ? c2.xAxisAnnotation : "yaxis" === s2 ? c2.yAxisAnnotation : c2.pointAnnotation), u2 = v.extend(d2, e2);
    switch (s2) {
      case "xaxis":
        this.addXaxisAnnotation(u2, l2, h2);
        break;
      case "yaxis":
        this.addYaxisAnnotation(u2, l2, h2);
        break;
      case "point":
        this.addPointAnnotation(u2, l2, h2);
    }
    var g2 = o2.globals.dom.baseEl.querySelector(".apexcharts-".concat(s2, "-annotations .apexcharts-").concat(s2, "-annotation-label[rel='").concat(h2, "']")), p2 = this.helpers.addBackgroundToAnno(g2, u2);
    return p2 && l2.insertBefore(p2.node, g2), i && o2.globals.memory.methodsToExec.push({ context: n2, id: u2.id ? u2.id : v.randomId(), method: r2, label: "addAnnotation", params: e2 }), a2;
  } }, { key: "clearAnnotations", value: function(t3) {
    for (var e2 = t3.w, i = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations"), a2 = e2.globals.memory.methodsToExec.length - 1; a2 >= 0; a2--)
      "addText" !== e2.globals.memory.methodsToExec[a2].label && "addAnnotation" !== e2.globals.memory.methodsToExec[a2].label || e2.globals.memory.methodsToExec.splice(a2, 1);
    i = v.listToArray(i), Array.prototype.forEach.call(i, function(t4) {
      for (; t4.firstChild; )
        t4.removeChild(t4.firstChild);
    });
  } }, { key: "removeAnnotation", value: function(t3, e2) {
    var i = t3.w, a2 = i.globals.dom.baseEl.querySelectorAll(".".concat(e2));
    a2 && (i.globals.memory.methodsToExec.map(function(t4, a3) {
      t4.id === e2 && i.globals.memory.methodsToExec.splice(a3, 1);
    }), Array.prototype.forEach.call(a2, function(t4) {
      t4.parentElement.removeChild(t4);
    }));
  } }]), t2;
}(), Di = function(t2) {
  var e2, i = t2.isTimeline, a2 = t2.ctx, s2 = t2.seriesIndex, r2 = t2.dataPointIndex, n2 = t2.y1, o2 = t2.y2, l2 = t2.w, h2 = l2.globals.seriesRangeStart[s2][r2], c2 = l2.globals.seriesRangeEnd[s2][r2], d2 = l2.globals.labels[r2], u2 = l2.config.series[s2].name ? l2.config.series[s2].name : "", g2 = l2.globals.ttKeyFormatter, p2 = l2.config.tooltip.y.title.formatter, f2 = { w: l2, seriesIndex: s2, dataPointIndex: r2, start: h2, end: c2 };
  ("function" == typeof p2 && (u2 = p2(u2, f2)), null !== (e2 = l2.config.series[s2].data[r2]) && void 0 !== e2 && e2.x && (d2 = l2.config.series[s2].data[r2].x), i) || "datetime" === l2.config.xaxis.type && (d2 = new Xi(a2).xLabelFormat(l2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(a2).formatDate, w: l2 }));
  "function" == typeof g2 && (d2 = g2(d2, f2)), Number.isFinite(n2) && Number.isFinite(o2) && (h2 = n2, c2 = o2);
  var x2 = "", b2 = "", m2 = l2.globals.colors[s2];
  if (void 0 === l2.config.tooltip.x.formatter)
    if ("datetime" === l2.config.xaxis.type) {
      var v2 = new zi(a2);
      x2 = v2.formatDate(v2.getDate(h2), l2.config.tooltip.x.format), b2 = v2.formatDate(v2.getDate(c2), l2.config.tooltip.x.format);
    } else
      x2 = h2, b2 = c2;
  else
    x2 = l2.config.tooltip.x.formatter(h2), b2 = l2.config.tooltip.x.formatter(c2);
  return { start: h2, end: c2, startVal: x2, endVal: b2, ylabel: d2, color: m2, seriesName: u2 };
}, _i = function(t2) {
  var e2 = t2.color, i = t2.seriesName, a2 = t2.ylabel, s2 = t2.start, r2 = t2.end, n2 = t2.seriesIndex, o2 = t2.dataPointIndex, l2 = t2.ctx.tooltip.tooltipLabels.getFormatters(n2);
  s2 = l2.yLbFormatter(s2), r2 = l2.yLbFormatter(r2);
  var h2 = l2.yLbFormatter(t2.w.globals.series[n2][o2]), c2 = '<span class="value start-value">\n  '.concat(s2, '\n  </span> <span class="separator">-</span> <span class="value end-value">\n  ').concat(r2, "\n  </span>");
  return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + e2 + '">' + (i || "") + '</span></div><div> <span class="category">' + a2 + ": </span> " + (t2.w.globals.comboCharts ? "rangeArea" === t2.w.config.series[n2].type || "rangeBar" === t2.w.config.series[n2].type ? c2 : "<span>".concat(h2, "</span>") : c2) + " </div></div>";
}, Ni = function() {
  function t2(e2) {
    i$1(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "hideYAxis", value: function() {
    this.opts.yaxis[0].show = false, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = false, this.opts.yaxis[0].axisTicks.show = false, this.opts.yaxis[0].floating = true;
  } }, { key: "line", value: function() {
    return { dataLabels: { enabled: false }, stroke: { width: 5, curve: "straight" }, markers: { size: 0, hover: { sizeOffset: 6 } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "sparkline", value: function(t3) {
    this.hideYAxis();
    return v.extend(t3, { grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, legend: { show: false }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } }, chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false } });
  } }, { key: "slope", value: function() {
    return this.hideYAxis(), { chart: { toolbar: { show: false }, zoom: { enabled: false } }, dataLabels: { enabled: true, formatter: function(t3, e2) {
      var i = e2.w.config.series[e2.seriesIndex].name;
      return null !== t3 ? i + ": " + t3 : "";
    }, background: { enabled: false }, offsetX: -5 }, grid: { xaxis: { lines: { show: true } }, yaxis: { lines: { show: false } } }, xaxis: { position: "top", labels: { style: { fontSize: 14, fontWeight: 900 } }, tooltip: { enabled: false }, crosshairs: { show: false } }, markers: { size: 8, hover: { sizeOffset: 1 } }, legend: { show: false }, tooltip: { shared: false, intersect: true, followCursor: true }, stroke: { width: 5, curve: "straight" } };
  } }, { key: "bar", value: function() {
    return { chart: { stacked: false }, plotOptions: { bar: { dataLabels: { position: "center" } } }, dataLabels: { style: { colors: ["#fff"] }, background: { enabled: false } }, stroke: { width: 0, lineCap: "square" }, fill: { opacity: 0.85 }, legend: { markers: { shape: "square" } }, tooltip: { shared: false, intersect: true }, xaxis: { tooltip: { enabled: false }, tickPlacement: "between", crosshairs: { width: "barWidth", position: "back", fill: { type: "gradient" }, dropShadow: { enabled: false }, stroke: { width: 0 } } } };
  } }, { key: "funnel", value: function() {
    return this.hideYAxis(), u(u({}, this.bar()), {}, { chart: { animations: { speed: 800, animateGradually: { enabled: false } } }, plotOptions: { bar: { horizontal: true, borderRadiusApplication: "around", borderRadius: 0, dataLabels: { position: "center" } } }, grid: { show: false, padding: { left: 0, right: 0 } }, xaxis: { labels: { show: false }, tooltip: { enabled: false }, axisBorder: { show: false }, axisTicks: { show: false } } });
  } }, { key: "candlestick", value: function() {
    var t3 = this;
    return { stroke: { width: 1, colors: ["#333"] }, fill: { opacity: 1 }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i, a2, ["Open", "High", "", "Low", "Close"], "candlestick");
    } }, states: { active: { filter: { type: "none" } } }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "boxPlot", value: function() {
    var t3 = this;
    return { chart: { animations: { dynamicAnimation: { enabled: false } } }, stroke: { width: 1, colors: ["#24292e"] }, dataLabels: { enabled: false }, tooltip: { shared: true, custom: function(e2) {
      var i = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w;
      return t3._getBoxTooltip(s2, i, a2, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot");
    } }, markers: { size: 7, strokeWidth: 1, strokeColors: "#111" }, xaxis: { crosshairs: { width: 1 } } };
  } }, { key: "rangeBar", value: function() {
    return { chart: { animations: { animateGradually: false } }, stroke: { width: 0, lineCap: "square" }, plotOptions: { bar: { borderRadius: 0, dataLabels: { position: "center" } } }, dataLabels: { enabled: false, formatter: function(t3, e2) {
      e2.ctx;
      var i = e2.seriesIndex, a2 = e2.dataPointIndex, s2 = e2.w, r2 = function() {
        var t4 = s2.globals.seriesRangeStart[i][a2];
        return s2.globals.seriesRangeEnd[i][a2] - t4;
      };
      return s2.globals.comboCharts ? "rangeBar" === s2.config.series[i].type || "rangeArea" === s2.config.series[i].type ? r2() : t3 : r2();
    }, background: { enabled: false }, style: { colors: ["#fff"] } }, markers: { size: 10 }, tooltip: { shared: false, followCursor: true, custom: function(t3) {
      return t3.w.config.plotOptions && t3.w.config.plotOptions.bar && t3.w.config.plotOptions.bar.horizontal ? function(t4) {
        var e2 = Di(u(u({}, t4), {}, { isTimeline: true })), i = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.startVal, n2 = e2.endVal;
        return _i(u(u({}, t4), {}, { color: i, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3) : function(t4) {
        var e2 = Di(t4), i = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } }, xaxis: { tickPlacement: "between", tooltip: { enabled: false }, crosshairs: { stroke: { width: 0 } } } };
  } }, { key: "dumbbell", value: function(t3) {
    var e2, i;
    return null !== (e2 = t3.plotOptions.bar) && void 0 !== e2 && e2.barHeight || (t3.plotOptions.bar.barHeight = 2), null !== (i = t3.plotOptions.bar) && void 0 !== i && i.columnWidth || (t3.plotOptions.bar.columnWidth = 2), t3;
  } }, { key: "area", value: function() {
    return { stroke: { width: 4, fill: { type: "solid", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } } }, fill: { type: "gradient", gradient: { inverseColors: false, shade: "light", type: "vertical", opacityFrom: 0.65, opacityTo: 0.5, stops: [0, 100, 100] } }, markers: { size: 0, hover: { sizeOffset: 6 } }, tooltip: { followCursor: false } };
  } }, { key: "rangeArea", value: function() {
    return { stroke: { curve: "straight", width: 0 }, fill: { type: "solid", opacity: 0.6 }, markers: { size: 0 }, states: { hover: { filter: { type: "none" } }, active: { filter: { type: "none" } } }, tooltip: { intersect: false, shared: true, followCursor: true, custom: function(t3) {
      return function(t4) {
        var e2 = Di(t4), i = e2.color, a2 = e2.seriesName, s2 = e2.ylabel, r2 = e2.start, n2 = e2.end;
        return _i(u(u({}, t4), {}, { color: i, seriesName: a2, ylabel: s2, start: r2, end: n2 }));
      }(t3);
    } } };
  } }, { key: "brush", value: function(t3) {
    return v.extend(t3, { chart: { toolbar: { autoSelected: "selection", show: false }, zoom: { enabled: false } }, dataLabels: { enabled: false }, stroke: { width: 1 }, tooltip: { enabled: false }, xaxis: { tooltip: { enabled: false } } });
  } }, { key: "stacked100", value: function(t3) {
    t3.dataLabels = t3.dataLabels || {}, t3.dataLabels.formatter = t3.dataLabels.formatter || void 0;
    var e2 = t3.dataLabels.formatter;
    return t3.yaxis.forEach(function(e3, i) {
      t3.yaxis[i].min = 0, t3.yaxis[i].max = 100;
    }), "bar" === t3.chart.type && (t3.dataLabels.formatter = e2 || function(t4) {
      return "number" == typeof t4 && t4 ? t4.toFixed(0) + "%" : t4;
    }), t3;
  } }, { key: "stackedBars", value: function() {
    var t3 = this.bar();
    return u(u({}, t3), {}, { plotOptions: u(u({}, t3.plotOptions), {}, { bar: u(u({}, t3.plotOptions.bar), {}, { borderRadiusApplication: "end", borderRadiusWhenStacked: "last" }) }) });
  } }, { key: "convertCatToNumeric", value: function(t3) {
    return t3.xaxis.convertedCatToNumeric = true, t3;
  } }, { key: "convertCatToNumericXaxis", value: function(t3, e2, i) {
    t3.xaxis.type = "numeric", t3.xaxis.labels = t3.xaxis.labels || {}, t3.xaxis.labels.formatter = t3.xaxis.labels.formatter || function(t4) {
      return v.isNumber(t4) ? Math.floor(t4) : t4;
    };
    var a2 = t3.xaxis.labels.formatter, s2 = t3.xaxis.categories && t3.xaxis.categories.length ? t3.xaxis.categories : t3.labels;
    return i && i.length && (s2 = i.map(function(t4) {
      return Array.isArray(t4) ? t4 : String(t4);
    })), s2 && s2.length && (t3.xaxis.labels.formatter = function(t4) {
      return v.isNumber(t4) ? a2(s2[Math.floor(t4) - 1]) : a2(t4);
    }), t3.xaxis.categories = [], t3.labels = [], t3.xaxis.tickAmount = t3.xaxis.tickAmount || "dataPoints", t3;
  } }, { key: "bubble", value: function() {
    return { dataLabels: { style: { colors: ["#fff"] } }, tooltip: { shared: false, intersect: true }, xaxis: { crosshairs: { width: 0 } }, fill: { type: "solid", gradient: { shade: "light", inverse: true, shadeIntensity: 0.55, opacityFrom: 0.4, opacityTo: 0.8 } } };
  } }, { key: "scatter", value: function() {
    return { dataLabels: { enabled: false }, tooltip: { shared: false, intersect: true }, markers: { size: 6, strokeWidth: 1, hover: { sizeOffset: 2 } } };
  } }, { key: "heatmap", value: function() {
    return { chart: { stacked: false }, fill: { opacity: 1 }, dataLabels: { style: { colors: ["#fff"] } }, stroke: { colors: ["#fff"] }, tooltip: { followCursor: true, marker: { show: false }, x: { show: false } }, legend: { position: "top", markers: { shape: "square" } }, grid: { padding: { right: 20 } } };
  } }, { key: "treemap", value: function() {
    return { chart: { zoom: { enabled: false } }, dataLabels: { style: { fontSize: 14, fontWeight: 600, colors: ["#fff"] } }, stroke: { show: true, width: 2, colors: ["#fff"] }, legend: { show: false }, fill: { opacity: 1, gradient: { stops: [0, 100] } }, tooltip: { followCursor: true, x: { show: false } }, grid: { padding: { left: 0, right: 0 } }, xaxis: { crosshairs: { show: false }, tooltip: { enabled: false } } };
  } }, { key: "pie", value: function() {
    return { chart: { toolbar: { show: false } }, plotOptions: { pie: { donut: { labels: { show: false } } } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", stops: [0, 100] } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "donut", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, style: { colors: ["#fff"] }, background: { enabled: false }, dropShadow: { enabled: true } }, stroke: { colors: ["#fff"] }, fill: { opacity: 1, gradient: { shade: "light", shadeIntensity: 0.35, stops: [80, 100], opacityFrom: 1, opacityTo: 1 } }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "polarArea", value: function() {
    return { chart: { toolbar: { show: false } }, dataLabels: { formatter: function(t3) {
      return t3.toFixed(1) + "%";
    }, enabled: false }, stroke: { show: true, width: 2 }, fill: { opacity: 0.7 }, tooltip: { theme: "dark", fillSeriesColor: true }, legend: { position: "right" }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "radar", value: function() {
    return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, { dataLabels: { enabled: false, style: { fontSize: "11px" } }, stroke: { width: 2 }, markers: { size: 5, strokeWidth: 1, strokeOpacity: 1 }, fill: { opacity: 0.2 }, tooltip: { shared: false, intersect: true, followCursor: true }, grid: { show: false, padding: { left: 0, right: 0, top: 0, bottom: 0 } }, xaxis: { labels: { formatter: function(t3) {
      return t3;
    }, style: { colors: ["#a8a8a8"], fontSize: "11px" } }, tooltip: { enabled: false }, crosshairs: { show: false } } };
  } }, { key: "radialBar", value: function() {
    return { chart: { animations: { dynamicAnimation: { enabled: true, speed: 800 } }, toolbar: { show: false } }, fill: { gradient: { shade: "dark", shadeIntensity: 0.4, inverseColors: false, type: "diagonal2", opacityFrom: 1, opacityTo: 1, stops: [70, 98, 100] } }, legend: { show: false, position: "right" }, tooltip: { enabled: false, fillSeriesColor: true }, grid: { padding: { left: 0, right: 0, top: 0, bottom: 0 } } };
  } }, { key: "_getBoxTooltip", value: function(t3, e2, i, a2, s2) {
    var r2 = t3.globals.seriesCandleO[e2][i], n2 = t3.globals.seriesCandleH[e2][i], o2 = t3.globals.seriesCandleM[e2][i], l2 = t3.globals.seriesCandleL[e2][i], h2 = t3.globals.seriesCandleC[e2][i];
    return t3.config.series[e2].type && t3.config.series[e2].type !== s2 ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t3.config.series[e2].name ? t3.config.series[e2].name : "series-" + (e2 + 1), ": <strong>").concat(t3.globals.series[e2][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t3.config.chart.type, '">') + "<div>".concat(a2[0], ': <span class="value">') + r2 + "</span></div>" + "<div>".concat(a2[1], ': <span class="value">') + n2 + "</span></div>" + (o2 ? "<div>".concat(a2[2], ': <span class="value">') + o2 + "</span></div>" : "") + "<div>".concat(a2[3], ': <span class="value">') + l2 + "</span></div>" + "<div>".concat(a2[4], ': <span class="value">') + h2 + "</span></div></div>";
  } }]), t2;
}(), Wi = function() {
  function t2(e2) {
    i$1(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function(t3) {
    var e2 = t3.responsiveOverride, i = this.opts, a2 = new Oi(), s2 = new Ni(i);
    this.chartType = i.chart.type, i = this.extendYAxis(i), i = this.extendAnnotations(i);
    var r2 = a2.init(), n2 = {};
    if (i && "object" === b(i)) {
      var o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, m2 = {};
      m2 = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "rangeArea", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? s2[i.chart.type]() : s2.line(), null !== (o2 = i.plotOptions) && void 0 !== o2 && null !== (l2 = o2.bar) && void 0 !== l2 && l2.isFunnel && (m2 = s2.funnel()), i.chart.stacked && "bar" === i.chart.type && (m2 = s2.stackedBars()), null !== (h2 = i.chart.brush) && void 0 !== h2 && h2.enabled && (m2 = s2.brush(m2)), null !== (c2 = i.plotOptions) && void 0 !== c2 && null !== (d2 = c2.line) && void 0 !== d2 && d2.isSlopeChart && (m2 = s2.slope()), i.chart.stacked && "100%" === i.chart.stackType && (i = s2.stacked100(i)), null !== (u2 = i.plotOptions) && void 0 !== u2 && null !== (g2 = u2.bar) && void 0 !== g2 && g2.isDumbbell && (i = s2.dumbbell(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, e2 || (i.xaxis.convertedCatToNumeric = false), (null !== (p2 = (i = this.checkForCatToNumericXAxis(this.chartType, m2, i)).chart.sparkline) && void 0 !== p2 && p2.enabled || null !== (f2 = window.Apex.chart) && void 0 !== f2 && null !== (x2 = f2.sparkline) && void 0 !== x2 && x2.enabled) && (m2 = s2.sparkline(m2)), n2 = v.extend(r2, m2);
    }
    var y2 = v.extend(n2, window.Apex);
    return r2 = v.extend(y2, i), r2 = this.handleUserInputErrors(r2);
  } }, { key: "checkForCatToNumericXAxis", value: function(t3, e2, i) {
    var a2, s2, r2 = new Ni(i), n2 = ("bar" === t3 || "boxPlot" === t3) && (null === (a2 = i.plotOptions) || void 0 === a2 || null === (s2 = a2.bar) || void 0 === s2 ? void 0 : s2.horizontal), o2 = "pie" === t3 || "polarArea" === t3 || "donut" === t3 || "radar" === t3 || "radialBar" === t3 || "heatmap" === t3, l2 = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type, h2 = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e2.xaxis && e2.xaxis.tickPlacement;
    return n2 || o2 || !l2 || "between" === h2 || (i = r2.convertCatToNumeric(i)), i;
  } }, { key: "extendYAxis", value: function(t3, e2) {
    var i = new Oi();
    (void 0 === t3.yaxis || !t3.yaxis || Array.isArray(t3.yaxis) && 0 === t3.yaxis.length) && (t3.yaxis = {}), t3.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t3.yaxis = v.extend(t3.yaxis, window.Apex.yaxis)), t3.yaxis.constructor !== Array ? t3.yaxis = [v.extend(i.yAxis, t3.yaxis)] : t3.yaxis = v.extendArray(t3.yaxis, i.yAxis);
    var a2 = false;
    t3.yaxis.forEach(function(t4) {
      t4.logarithmic && (a2 = true);
    });
    var s2 = t3.series;
    return e2 && !s2 && (s2 = e2.config.series), a2 && s2.length !== t3.yaxis.length && s2.length && (t3.yaxis = s2.map(function(e3, a3) {
      if (e3.name || (s2[a3].name = "series-".concat(a3 + 1)), t3.yaxis[a3])
        return t3.yaxis[a3].seriesName = s2[a3].name, t3.yaxis[a3];
      var r2 = v.extend(i.yAxis, t3.yaxis[0]);
      return r2.show = false, r2;
    })), a2 && s2.length > 1 && s2.length !== t3.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes"), t3;
  } }, { key: "extendAnnotations", value: function(t3) {
    return void 0 === t3.annotations && (t3.annotations = {}, t3.annotations.yaxis = [], t3.annotations.xaxis = [], t3.annotations.points = []), t3 = this.extendYAxisAnnotations(t3), t3 = this.extendXAxisAnnotations(t3), t3 = this.extendPointAnnotations(t3);
  } }, { key: "extendYAxisAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.yaxis = v.extendArray(void 0 !== t3.annotations.yaxis ? t3.annotations.yaxis : [], e2.yAxisAnnotation), t3;
  } }, { key: "extendXAxisAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.xaxis = v.extendArray(void 0 !== t3.annotations.xaxis ? t3.annotations.xaxis : [], e2.xAxisAnnotation), t3;
  } }, { key: "extendPointAnnotations", value: function(t3) {
    var e2 = new Oi();
    return t3.annotations.points = v.extendArray(void 0 !== t3.annotations.points ? t3.annotations.points : [], e2.pointAnnotation), t3;
  } }, { key: "checkForDarkTheme", value: function(t3) {
    t3.theme && "dark" === t3.theme.mode && (t3.tooltip || (t3.tooltip = {}), "light" !== t3.tooltip.theme && (t3.tooltip.theme = "dark"), t3.chart.foreColor || (t3.chart.foreColor = "#f6f7f8"), t3.theme.palette || (t3.theme.palette = "palette4"));
  } }, { key: "handleUserInputErrors", value: function(t3) {
    var e2 = t3;
    if (e2.tooltip.shared && e2.tooltip.intersect)
      throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
    if ("bar" === e2.chart.type && e2.plotOptions.bar.horizontal) {
      if (e2.yaxis.length > 1)
        throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
      e2.yaxis[0].reversed && (e2.yaxis[0].opposite = true), e2.xaxis.tooltip.enabled = false, e2.yaxis[0].tooltip.enabled = false, e2.chart.zoom.enabled = false;
    }
    return "bar" !== e2.chart.type && "rangeBar" !== e2.chart.type || e2.tooltip.shared && "barWidth" === e2.xaxis.crosshairs.width && e2.series.length > 1 && (e2.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e2.chart.type && "boxPlot" !== e2.chart.type || e2.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e2.chart.type, " chart is not supported.")), e2.yaxis[0].reversed = false), e2;
  } }]), t2;
}(), Bi = function() {
  function t2() {
    i$1(this, t2);
  }
  return s(t2, [{ key: "initGlobalVars", value: function(t3) {
    t3.series = [], t3.seriesCandleO = [], t3.seriesCandleH = [], t3.seriesCandleM = [], t3.seriesCandleL = [], t3.seriesCandleC = [], t3.seriesRangeStart = [], t3.seriesRangeEnd = [], t3.seriesRange = [], t3.seriesPercent = [], t3.seriesGoals = [], t3.seriesX = [], t3.seriesZ = [], t3.seriesNames = [], t3.seriesTotals = [], t3.seriesLog = [], t3.seriesColors = [], t3.stackedSeriesTotals = [], t3.seriesXvalues = [], t3.seriesYvalues = [], t3.labels = [], t3.hasXaxisGroups = false, t3.groups = [], t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], t3.hasSeriesGroups = false, t3.seriesGroups = [], t3.categoryLabels = [], t3.timescaleLabels = [], t3.noLabelsProvided = false, t3.resizeTimer = null, t3.selectionResizeTimer = null, t3.lastWheelExecution = 0, t3.delayedElements = [], t3.pointsArray = [], t3.dataLabelsRects = [], t3.isXNumeric = false, t3.skipLastTimelinelabel = false, t3.skipFirstTimelinelabel = false, t3.isDataXYZ = false, t3.isMultiLineX = false, t3.isMultipleYAxis = false, t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE, t3.minYArr = [], t3.maxYArr = [], t3.maxX = -Number.MAX_VALUE, t3.minX = Number.MAX_VALUE, t3.initialMaxX = -Number.MAX_VALUE, t3.initialMinX = Number.MAX_VALUE, t3.maxDate = 0, t3.minDate = Number.MAX_VALUE, t3.minZ = Number.MAX_VALUE, t3.maxZ = -Number.MAX_VALUE, t3.minXDiff = Number.MAX_VALUE, t3.yAxisScale = [], t3.xAxisScale = null, t3.xAxisTicksPositions = [], t3.yLabelsCoords = [], t3.yTitleCoords = [], t3.barPadForNumericAxis = 0, t3.padHorizontal = 0, t3.xRange = 0, t3.yRange = [], t3.zRange = 0, t3.dataPoints = 0, t3.xTickAmount = 0, t3.multiAxisTickAmount = 0;
  } }, { key: "globalVars", value: function(t3) {
    return { chartID: null, cuid: null, events: { beforeMount: [], mounted: [], updated: [], clicked: [], selection: [], dataPointSelection: [], zoomed: [], scrolled: [] }, colors: [], clientX: null, clientY: null, fill: { colors: [] }, stroke: { colors: [] }, dataLabels: { style: { colors: [] } }, radarPolygons: { fill: { colors: [] } }, markers: { colors: [], size: t3.markers.size, largestSize: 0 }, animationEnded: false, isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints, isDirty: false, isExecCalled: false, initialConfig: null, initialSeries: [], lastXAxis: [], lastYAxis: [], columnSeries: null, labels: [], timescaleLabels: [], noLabelsProvided: false, allSeriesCollapsed: false, collapsedSeries: [], collapsedSeriesIndices: [], ancillaryCollapsedSeries: [], ancillaryCollapsedSeriesIndices: [], risingSeries: [], dataFormatXNumeric: false, capturedSeriesIndex: -1, capturedDataPointIndex: -1, selectedDataPoints: [], invalidLogScale: false, ignoreYAxisIndexes: [], maxValsInArrayIndex: 0, radialSize: 0, selection: void 0, zoomEnabled: "zoom" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.zoom && t3.chart.zoom.enabled, panEnabled: "pan" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.pan, selectionEnabled: "selection" === t3.chart.toolbar.autoSelected && t3.chart.toolbar.tools.selection, yaxis: null, mousedown: false, lastClientPosition: {}, visibleXRange: void 0, yValueDecimal: 0, total: 0, SVGNS: "http://www.w3.org/2000/svg", svgWidth: 0, svgHeight: 0, noData: false, locale: {}, dom: {}, memory: { methodsToExec: [] }, shouldAnimate: true, skipLastTimelinelabel: false, skipFirstTimelinelabel: false, delayedElements: [], axisCharts: true, isDataXYZ: false, isSlopeChart: t3.plotOptions.line.isSlopeChart, resized: false, resizeTimer: null, comboCharts: false, dataChanged: false, previousPaths: [], allSeriesHasEqualX: true, pointsArray: [], dataLabelsRects: [], lastDrawnDataLabelsIndexes: [], hasNullValues: false, zoomed: false, gridWidth: 0, gridHeight: 0, rotateXLabels: false, defaultLabels: false, xLabelFormatter: void 0, yLabelFormatters: [], xaxisTooltipFormatter: void 0, ttKeyFormatter: void 0, ttVal: void 0, ttZFormatter: void 0, LINE_HEIGHT_RATIO: 1.618, xAxisLabelsHeight: 0, xAxisGroupLabelsHeight: 0, xAxisLabelsWidth: 0, yAxisLabelsWidth: 0, scaleX: 1, scaleY: 1, translateX: 0, translateY: 0, translateYAxisX: [], yAxisWidths: [], translateXAxisY: 0, translateXAxisX: 0, tooltip: null, niceScaleAllowedMagMsd: [[1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10], [1, 1, 2, 5, 5, 5, 10, 10, 10, 10, 10]], niceScaleDefaultTicks: [1, 2, 4, 4, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 12, 12, 12, 12, 12, 12, 12, 12, 12, 24], seriesYAxisMap: [], seriesYAxisReverseMap: [] };
  } }, { key: "init", value: function(t3) {
    var e2 = this.globalVars(t3);
    return this.initGlobalVars(e2), e2.initialConfig = v.extend({}, t3), e2.initialSeries = v.clone(t3.series), e2.lastXAxis = v.clone(e2.initialConfig.xaxis), e2.lastYAxis = v.clone(e2.initialConfig.yaxis), e2;
  } }]), t2;
}(), Gi = function() {
  function t2(e2) {
    i$1(this, t2), this.opts = e2;
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = new Wi(this.opts).init({ responsiveOverride: false });
    return { config: t3, globals: new Bi().init(t3) };
  } }]), t2;
}(), ji = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.opts = null, this.seriesIndex = 0, this.patternIDs = [];
  }
  return s(t2, [{ key: "clippedImgArea", value: function(t3) {
    var e2 = this.w, i = e2.config, a2 = parseInt(e2.globals.gridWidth, 10), s2 = parseInt(e2.globals.gridHeight, 10), r2 = a2 > s2 ? a2 : s2, n2 = t3.image, o2 = 0, l2 = 0;
    void 0 === t3.width && void 0 === t3.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o2 = i.fill.image.width + 1, l2 = i.fill.image.height) : (o2 = r2 + 1, l2 = r2) : (o2 = t3.width, l2 = t3.height);
    var h2 = document.createElementNS(e2.globals.SVGNS, "pattern");
    Mi.setAttrs(h2, { id: t3.patternID, patternUnits: t3.patternUnits ? t3.patternUnits : "userSpaceOnUse", width: o2 + "px", height: l2 + "px" });
    var c2 = document.createElementNS(e2.globals.SVGNS, "image");
    h2.appendChild(c2), c2.setAttributeNS(window.SVG.xlink, "href", n2), Mi.setAttrs(c2, { x: 0, y: 0, preserveAspectRatio: "none", width: o2 + "px", height: l2 + "px" }), c2.style.opacity = t3.opacity, e2.globals.dom.elDefs.node.appendChild(h2);
  } }, { key: "getSeriesIndex", value: function(t3) {
    var e2 = this.w, i = e2.config.chart.type;
    return ("bar" === i || "rangeBar" === i) && e2.config.plotOptions.bar.distributed || "heatmap" === i || "treemap" === i ? this.seriesIndex = t3.seriesNumber : this.seriesIndex = t3.seriesNumber % e2.globals.series.length, this.seriesIndex;
  } }, { key: "computeColorStops", value: function(t3, e2) {
    var i, a2 = this.w, s2 = null, n2 = null, o2 = r(t3);
    try {
      for (o2.s(); !(i = o2.n()).done; ) {
        var l2 = i.value;
        l2 >= e2.threshold ? (null === s2 || l2 > s2) && (s2 = l2) : (null === n2 || l2 < n2) && (n2 = l2);
      }
    } catch (t4) {
      o2.e(t4);
    } finally {
      o2.f();
    }
    null === s2 && (s2 = e2.threshold), null === n2 && (n2 = e2.threshold);
    var h2 = s2 - e2.threshold + (e2.threshold - n2);
    0 === h2 && (h2 = 1);
    var c2 = 100 - (e2.threshold - n2) / h2 * 100;
    return [{ offset: c2 = Math.max(0, Math.min(c2, 100)), color: e2.colorAboveThreshold, opacity: a2.config.fill.opacity }, { offset: 0, color: e2.colorBelowThreshold, opacity: a2.config.fill.opacity }];
  } }, { key: "fillPath", value: function(t3) {
    var e2, i, a2, s2 = this.w;
    this.opts = t3;
    var r2, n2, o2, l2 = this.w.config;
    this.seriesIndex = this.getSeriesIndex(t3);
    var h2 = l2.plotOptions.line.colors.colorAboveThreshold && l2.plotOptions.line.colors.colorBelowThreshold, c2 = this.getFillColors()[this.seriesIndex];
    void 0 !== s2.globals.seriesColors[this.seriesIndex] && (c2 = s2.globals.seriesColors[this.seriesIndex]), "function" == typeof c2 && (c2 = c2({ seriesIndex: this.seriesIndex, dataPointIndex: t3.dataPointIndex, value: t3.value, w: s2 }));
    var d2, u2, g2, p2 = t3.fillType ? t3.fillType : this.getFillType(this.seriesIndex), x2 = Array.isArray(l2.fill.opacity) ? l2.fill.opacity[this.seriesIndex] : l2.fill.opacity, b2 = "gradient" === p2 || h2;
    (t3.color && (c2 = t3.color), null !== (e2 = s2.config.series[this.seriesIndex]) && void 0 !== e2 && null !== (i = e2.data) && void 0 !== i && null !== (a2 = i[t3.dataPointIndex]) && void 0 !== a2 && a2.fillColor) && (c2 = null === (d2 = s2.config.series[this.seriesIndex]) || void 0 === d2 || null === (u2 = d2.data) || void 0 === u2 || null === (g2 = u2[t3.dataPointIndex]) || void 0 === g2 ? void 0 : g2.fillColor);
    c2 || (c2 = "#fff", console.warn("undefined color - ApexCharts"));
    var m2 = c2;
    if (-1 === c2.indexOf("rgb") ? -1 === c2.indexOf("#") ? m2 = c2 : c2.length < 9 && (m2 = v.hexToRgba(c2, x2)) : c2.indexOf("rgba") > -1 ? x2 = v.getOpacityFromRGBA(c2) : m2 = v.hexToRgba(v.rgb2hex(c2), x2), t3.opacity && (x2 = t3.opacity), "pattern" === p2 && (n2 = this.handlePatternFill({ fillConfig: t3.fillConfig, patternFill: n2, fillColor: c2, fillOpacity: x2, defaultColor: m2 })), b2) {
      var y2 = f(l2.fill.gradient.colorStops) || [], w2 = l2.fill.gradient.type;
      h2 && (y2[this.seriesIndex] = this.computeColorStops(s2.globals.series[this.seriesIndex], l2.plotOptions.line.colors), w2 = "vertical"), o2 = this.handleGradientFill({ type: w2, fillConfig: t3.fillConfig, fillColor: c2, fillOpacity: x2, colorStops: y2, i: this.seriesIndex });
    }
    if ("image" === p2) {
      var k2 = l2.fill.image.src, A2 = t3.patternID ? t3.patternID : "", C2 = "pattern".concat(s2.globals.cuid).concat(t3.seriesNumber + 1).concat(A2);
      -1 === this.patternIDs.indexOf(C2) && (this.clippedImgArea({ opacity: x2, image: Array.isArray(k2) ? t3.seriesNumber < k2.length ? k2[t3.seriesNumber] : k2[0] : k2, width: t3.width ? t3.width : void 0, height: t3.height ? t3.height : void 0, patternUnits: t3.patternUnits, patternID: C2 }), this.patternIDs.push(C2)), r2 = "url(#".concat(C2, ")");
    } else
      r2 = b2 ? o2 : "pattern" === p2 ? n2 : m2;
    return t3.solid && (r2 = m2), r2;
  } }, { key: "getFillType", value: function(t3) {
    var e2 = this.w;
    return Array.isArray(e2.config.fill.type) ? e2.config.fill.type[t3] : e2.config.fill.type;
  } }, { key: "getFillColors", value: function() {
    var t3 = this.w, e2 = t3.config, i = this.opts, a2 = [];
    return t3.globals.comboCharts ? "line" === t3.config.series[this.seriesIndex].type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors) : "line" === e2.chart.type ? Array.isArray(t3.globals.stroke.colors) ? a2 = t3.globals.stroke.colors : a2.push(t3.globals.stroke.colors) : Array.isArray(t3.globals.fill.colors) ? a2 = t3.globals.fill.colors : a2.push(t3.globals.fill.colors), void 0 !== i.fillColors && (a2 = [], Array.isArray(i.fillColors) ? a2 = i.fillColors.slice() : a2.push(i.fillColors)), a2;
  } }, { key: "handlePatternFill", value: function(t3) {
    var e2 = t3.fillConfig, i = t3.patternFill, a2 = t3.fillColor, s2 = t3.fillOpacity, r2 = t3.defaultColor, n2 = this.w.config.fill;
    e2 && (n2 = e2);
    var o2 = this.opts, l2 = new Mi(this.ctx), h2 = Array.isArray(n2.pattern.strokeWidth) ? n2.pattern.strokeWidth[this.seriesIndex] : n2.pattern.strokeWidth, c2 = a2;
    Array.isArray(n2.pattern.style) ? i = void 0 !== n2.pattern.style[o2.seriesNumber] ? l2.drawPattern(n2.pattern.style[o2.seriesNumber], n2.pattern.width, n2.pattern.height, c2, h2, s2) : r2 : i = l2.drawPattern(n2.pattern.style, n2.pattern.width, n2.pattern.height, c2, h2, s2);
    return i;
  } }, { key: "handleGradientFill", value: function(t3) {
    var e2 = t3.type, i = t3.fillColor, a2 = t3.fillOpacity, s2 = t3.fillConfig, r2 = t3.colorStops, n2 = t3.i, o2 = this.w.config.fill;
    s2 && (o2 = u(u({}, o2), s2));
    var l2 = this.opts, h2 = new Mi(this.ctx), c2 = new v();
    e2 = e2 || o2.gradient.type;
    var d2, g2 = i, p2 = void 0 === o2.gradient.opacityFrom ? a2 : Array.isArray(o2.gradient.opacityFrom) ? o2.gradient.opacityFrom[n2] : o2.gradient.opacityFrom;
    g2.indexOf("rgba") > -1 && (p2 = v.getOpacityFromRGBA(g2));
    var f2 = void 0 === o2.gradient.opacityTo ? a2 : Array.isArray(o2.gradient.opacityTo) ? o2.gradient.opacityTo[n2] : o2.gradient.opacityTo;
    if (void 0 === o2.gradient.gradientToColors || 0 === o2.gradient.gradientToColors.length)
      d2 = "dark" === o2.gradient.shade ? c2.shadeColor(-1 * parseFloat(o2.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? v.rgb2hex(i) : i) : c2.shadeColor(parseFloat(o2.gradient.shadeIntensity), i.indexOf("rgb") > -1 ? v.rgb2hex(i) : i);
    else if (o2.gradient.gradientToColors[l2.seriesNumber]) {
      var x2 = o2.gradient.gradientToColors[l2.seriesNumber];
      d2 = x2, x2.indexOf("rgba") > -1 && (f2 = v.getOpacityFromRGBA(x2));
    } else
      d2 = i;
    if (o2.gradient.gradientFrom && (g2 = o2.gradient.gradientFrom), o2.gradient.gradientTo && (d2 = o2.gradient.gradientTo), o2.gradient.inverseColors) {
      var b2 = g2;
      g2 = d2, d2 = b2;
    }
    return g2.indexOf("rgb") > -1 && (g2 = v.rgb2hex(g2)), d2.indexOf("rgb") > -1 && (d2 = v.rgb2hex(d2)), h2.drawGradient(e2, g2, d2, p2, f2, l2.size, o2.gradient.stops, r2, n2);
  } }]), t2;
}(), Vi = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setGlobalMarkerSize", value: function() {
    var t3 = this.w;
    if (t3.globals.markers.size = Array.isArray(t3.config.markers.size) ? t3.config.markers.size : [t3.config.markers.size], t3.globals.markers.size.length > 0) {
      if (t3.globals.markers.size.length < t3.globals.series.length + 1)
        for (var e2 = 0; e2 <= t3.globals.series.length; e2++)
          void 0 === t3.globals.markers.size[e2] && t3.globals.markers.size.push(t3.globals.markers.size[0]);
    } else
      t3.globals.markers.size = t3.config.series.map(function(e3) {
        return t3.config.markers.size;
      });
  } }, { key: "plotChartMarkers", value: function(t3) {
    var e2 = t3.pointsPos, i = t3.seriesIndex, a2 = t3.j, s2 = t3.pSize, r2 = t3.alwaysDrawMarker, n2 = void 0 !== r2 && r2, o2 = t3.isVirtualPoint, l2 = void 0 !== o2 && o2, h2 = this.w, c2 = i, d2 = e2, u2 = null, g2 = new Mi(this.ctx), p2 = h2.config.markers.discrete && h2.config.markers.discrete.length;
    if (Array.isArray(d2.x))
      for (var f2 = 0; f2 < d2.x.length; f2++) {
        var x2 = void 0, b2 = a2, m2 = !v.isNumber(d2.y[f2]);
        0 === h2.globals.markers.largestSize && h2.globals.hasNullValues && null !== h2.globals.series[c2][a2 + 1] && !l2 && (m2 = true), 1 === a2 && 0 === f2 && (b2 = 0), 1 === a2 && 1 === f2 && (b2 = 1);
        var y2 = "apexcharts-marker";
        if ("line" !== h2.config.chart.type && "area" !== h2.config.chart.type || h2.globals.comboCharts || h2.config.tooltip.intersect || (y2 += " no-pointer-events"), (Array.isArray(h2.config.markers.size) ? h2.globals.markers.size[i] > 0 : h2.config.markers.size > 0) || n2 || p2) {
          m2 || (y2 += " w".concat(v.randomId()));
          var w2 = this.getMarkerConfig({ cssClass: y2, seriesIndex: i, dataPointIndex: b2 });
          if (h2.config.series[c2].data[b2] && (h2.config.series[c2].data[b2].fillColor && (w2.pointFillColor = h2.config.series[c2].data[b2].fillColor), h2.config.series[c2].data[b2].strokeColor && (w2.pointStrokeColor = h2.config.series[c2].data[b2].strokeColor)), void 0 !== s2 && (w2.pSize = s2), (d2.x[f2] < -h2.globals.markers.largestSize || d2.x[f2] > h2.globals.gridWidth + h2.globals.markers.largestSize || d2.y[f2] < -h2.globals.markers.largestSize || d2.y[f2] > h2.globals.gridHeight + h2.globals.markers.largestSize) && (w2.pSize = 0), !m2)
            (h2.globals.markers.size[i] > 0 || n2 || p2) && !u2 && (u2 = g2.group({ class: n2 || p2 ? "" : "apexcharts-series-markers" })).attr("clip-path", "url(#gridRectMarkerMask".concat(h2.globals.cuid, ")")), (x2 = g2.drawMarker(d2.x[f2], d2.y[f2], w2)).attr("rel", b2), x2.attr("j", b2), x2.attr("index", i), x2.node.setAttribute("default-marker-size", w2.pSize), new Li(this.ctx).setSelectionFilter(x2, i, b2), this.addEvents(x2), u2 && u2.add(x2);
        } else
          void 0 === h2.globals.pointsArray[i] && (h2.globals.pointsArray[i] = []), h2.globals.pointsArray[i].push([d2.x[f2], d2.y[f2]]);
      }
    return u2;
  } }, { key: "getMarkerConfig", value: function(t3) {
    var e2 = t3.cssClass, i = t3.seriesIndex, a2 = t3.dataPointIndex, s2 = void 0 === a2 ? null : a2, r2 = t3.radius, n2 = void 0 === r2 ? null : r2, o2 = t3.size, l2 = void 0 === o2 ? null : o2, h2 = t3.strokeWidth, c2 = void 0 === h2 ? null : h2, d2 = this.w, u2 = this.getMarkerStyle(i), g2 = null === l2 ? d2.globals.markers.size[i] : l2, p2 = d2.config.markers;
    return null !== s2 && p2.discrete.length && p2.discrete.map(function(t4) {
      t4.seriesIndex === i && t4.dataPointIndex === s2 && (u2.pointStrokeColor = t4.strokeColor, u2.pointFillColor = t4.fillColor, g2 = t4.size, u2.pointShape = t4.shape);
    }), { pSize: null === n2 ? g2 : n2, pRadius: null !== n2 ? n2 : p2.radius, pointStrokeWidth: null !== c2 ? c2 : Array.isArray(p2.strokeWidth) ? p2.strokeWidth[i] : p2.strokeWidth, pointStrokeColor: u2.pointStrokeColor, pointFillColor: u2.pointFillColor, shape: u2.pointShape || (Array.isArray(p2.shape) ? p2.shape[i] : p2.shape), class: e2, pointStrokeOpacity: Array.isArray(p2.strokeOpacity) ? p2.strokeOpacity[i] : p2.strokeOpacity, pointStrokeDashArray: Array.isArray(p2.strokeDashArray) ? p2.strokeDashArray[i] : p2.strokeDashArray, pointFillOpacity: Array.isArray(p2.fillOpacity) ? p2.fillOpacity[i] : p2.fillOpacity, seriesIndex: i };
  } }, { key: "addEvents", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t3)), t3.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t3)), t3.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t3)), t3.node.addEventListener("click", e2.config.markers.onClick), t3.node.addEventListener("dblclick", e2.config.markers.onDblClick), t3.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t3), { passive: true });
  } }, { key: "getMarkerStyle", value: function(t3) {
    var e2 = this.w, i = e2.globals.markers.colors, a2 = e2.config.markers.strokeColor || e2.config.markers.strokeColors;
    return { pointStrokeColor: Array.isArray(a2) ? a2[t3] : a2, pointFillColor: Array.isArray(i) ? i[t3] : i };
  } }]), t2;
}(), Ui = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.initialAnim = this.w.config.chart.animations.enabled;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = i.realIndex, n2 = i.pointsPos, o2 = i.zRatio, l2 = i.elParent, h2 = s2.group({ class: "apexcharts-series-markers apexcharts-series-".concat(a2.config.chart.type) });
    if (h2.attr("clip-path", "url(#gridRectMarkerMask".concat(a2.globals.cuid, ")")), Array.isArray(n2.x))
      for (var c2 = 0; c2 < n2.x.length; c2++) {
        var d2 = e2 + 1, u2 = true;
        0 === e2 && 0 === c2 && (d2 = 0), 0 === e2 && 1 === c2 && (d2 = 1);
        var g2 = a2.globals.markers.size[r2];
        if (o2 !== 1 / 0) {
          var p2 = a2.config.plotOptions.bubble;
          g2 = a2.globals.seriesZ[r2][d2], p2.zScaling && (g2 /= o2), p2.minBubbleRadius && g2 < p2.minBubbleRadius && (g2 = p2.minBubbleRadius), p2.maxBubbleRadius && g2 > p2.maxBubbleRadius && (g2 = p2.maxBubbleRadius);
        }
        var f2 = n2.x[c2], x2 = n2.y[c2];
        if (g2 = g2 || 0, null !== x2 && void 0 !== a2.globals.series[r2][d2] || (u2 = false), u2) {
          var b2 = this.drawPoint(f2, x2, g2, r2, d2, e2);
          h2.add(b2);
        }
        l2.add(h2);
      }
  } }, { key: "drawPoint", value: function(t3, e2, i, a2, s2, r2) {
    var n2 = this.w, o2 = a2, l2 = new y(this.ctx), h2 = new Li(this.ctx), c2 = new ji(this.ctx), d2 = new Vi(this.ctx), u2 = new Mi(this.ctx), g2 = d2.getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: o2, dataPointIndex: s2, radius: "bubble" === n2.config.chart.type || n2.globals.comboCharts && n2.config.series[a2] && "bubble" === n2.config.series[a2].type ? i : null }), p2 = c2.fillPath({ seriesNumber: a2, dataPointIndex: s2, color: g2.pointFillColor, patternUnits: "objectBoundingBox", value: n2.globals.series[a2][r2] }), f2 = u2.drawMarker(t3, e2, g2);
    if (n2.config.series[o2].data[s2] && n2.config.series[o2].data[s2].fillColor && (p2 = n2.config.series[o2].data[s2].fillColor), f2.attr({ fill: p2 }), n2.config.chart.dropShadow.enabled) {
      var x2 = n2.config.chart.dropShadow;
      h2.dropShadow(f2, x2, a2);
    }
    if (!this.initialAnim || n2.globals.dataChanged || n2.globals.resized)
      n2.globals.animationEnded = true;
    else {
      var b2 = n2.config.chart.animations.speed;
      l2.animateMarker(f2, b2, n2.globals.easing, function() {
        window.setTimeout(function() {
          l2.animationCompleted(f2);
        }, 100);
      });
    }
    return f2.attr({ rel: s2, j: s2, index: a2, "default-marker-size": g2.pSize }), h2.setSelectionFilter(f2, a2, s2), d2.addEvents(f2), f2.node.classList.add("apexcharts-marker"), f2;
  } }, { key: "centerTextInBubble", value: function(t3) {
    var e2 = this.w;
    return { y: t3 += parseInt(e2.config.dataLabels.style.fontSize, 10) / 4 };
  } }]), t2;
}(), qi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "dataLabelsCorrection", value: function(t3, e2, i, a2, s2, r2, n2) {
    var o2 = this.w, l2 = false, h2 = new Mi(this.ctx).getTextRects(i, n2), c2 = h2.width, d2 = h2.height;
    e2 < 0 && (e2 = 0), e2 > o2.globals.gridHeight + d2 && (e2 = o2.globals.gridHeight + d2 / 2), void 0 === o2.globals.dataLabelsRects[a2] && (o2.globals.dataLabelsRects[a2] = []), o2.globals.dataLabelsRects[a2].push({ x: t3, y: e2, width: c2, height: d2 });
    var u2 = o2.globals.dataLabelsRects[a2].length - 2, g2 = void 0 !== o2.globals.lastDrawnDataLabelsIndexes[a2] ? o2.globals.lastDrawnDataLabelsIndexes[a2][o2.globals.lastDrawnDataLabelsIndexes[a2].length - 1] : 0;
    if (void 0 !== o2.globals.dataLabelsRects[a2][u2]) {
      var p2 = o2.globals.dataLabelsRects[a2][g2];
      (t3 > p2.x + p2.width || e2 > p2.y + p2.height || e2 + d2 < p2.y || t3 + c2 < p2.x) && (l2 = true);
    }
    return (0 === s2 || r2) && (l2 = true), { x: t3, y: e2, textRects: h2, drawnextLabel: l2 };
  } }, { key: "drawDataLabel", value: function(t3) {
    var e2 = this, i = t3.type, a2 = t3.pos, s2 = t3.i, r2 = t3.j, n2 = t3.isRangeStart, o2 = t3.strokeWidth, l2 = void 0 === o2 ? 2 : o2, h2 = this.w, c2 = new Mi(this.ctx), d2 = h2.config.dataLabels, u2 = 0, g2 = 0, p2 = r2, f2 = null;
    if (-1 !== h2.globals.collapsedSeriesIndices.indexOf(s2) || !d2.enabled || !Array.isArray(a2.x))
      return f2;
    f2 = c2.group({ class: "apexcharts-data-labels" });
    for (var x2 = 0; x2 < a2.x.length; x2++)
      if (u2 = a2.x[x2] + d2.offsetX, g2 = a2.y[x2] + d2.offsetY + l2, !isNaN(u2)) {
        1 === r2 && 0 === x2 && (p2 = 0), 1 === r2 && 1 === x2 && (p2 = 1);
        var b2 = h2.globals.series[s2][p2];
        "rangeArea" === i && (b2 = n2 ? h2.globals.seriesRangeStart[s2][p2] : h2.globals.seriesRangeEnd[s2][p2]);
        var m2 = "", v2 = function(t4) {
          return h2.config.dataLabels.formatter(t4, { ctx: e2.ctx, seriesIndex: s2, dataPointIndex: p2, w: h2 });
        };
        if ("bubble" === h2.config.chart.type)
          m2 = v2(b2 = h2.globals.seriesZ[s2][p2]), g2 = a2.y[x2], g2 = new Ui(this.ctx).centerTextInBubble(g2, s2, p2).y;
        else
          void 0 !== b2 && (m2 = v2(b2));
        var y2 = h2.config.dataLabels.textAnchor;
        h2.globals.isSlopeChart && (y2 = 0 === p2 ? "end" : p2 === h2.config.series[s2].data.length - 1 ? "start" : "middle"), this.plotDataLabelsText({ x: u2, y: g2, text: m2, i: s2, j: p2, parent: f2, offsetCorrection: true, dataLabelsConfig: h2.config.dataLabels, textAnchor: y2 });
      }
    return f2;
  } }, { key: "plotDataLabelsText", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.text, l2 = t3.textAnchor, h2 = t3.fontSize, c2 = t3.parent, d2 = t3.dataLabelsConfig, u2 = t3.color, g2 = t3.alwaysDrawDataLabel, p2 = t3.offsetCorrection, f2 = t3.className, x2 = null;
    if (Array.isArray(e2.config.dataLabels.enabledOnSeries) && e2.config.dataLabels.enabledOnSeries.indexOf(r2) < 0)
      return x2;
    var b2 = { x: a2, y: s2, drawnextLabel: true, textRects: null };
    p2 && (b2 = this.dataLabelsCorrection(a2, s2, o2, r2, n2, g2, parseInt(d2.style.fontSize, 10))), e2.globals.zoomed || (a2 = b2.x, s2 = b2.y), b2.textRects && (a2 < -20 - b2.textRects.width || a2 > e2.globals.gridWidth + b2.textRects.width + 30) && (o2 = "");
    var m2 = e2.globals.dataLabels.style.colors[r2];
    (("bar" === e2.config.chart.type || "rangeBar" === e2.config.chart.type) && e2.config.plotOptions.bar.distributed || e2.config.dataLabels.distributed) && (m2 = e2.globals.dataLabels.style.colors[n2]), "function" == typeof m2 && (m2 = m2({ series: e2.globals.series, seriesIndex: r2, dataPointIndex: n2, w: e2 })), u2 && (m2 = u2);
    var v2 = d2.offsetX, y2 = d2.offsetY;
    if ("bar" !== e2.config.chart.type && "rangeBar" !== e2.config.chart.type || (v2 = 0, y2 = 0), e2.globals.isSlopeChart && (0 !== n2 && (v2 = -2 * d2.offsetX + 5), 0 !== n2 && n2 !== e2.config.series[r2].data.length - 1 && (v2 = 0)), b2.drawnextLabel) {
      if ((x2 = i.drawText({ width: 100, height: parseInt(d2.style.fontSize, 10), x: a2 + v2, y: s2 + y2, foreColor: m2, textAnchor: l2 || d2.textAnchor, text: o2, fontSize: h2 || d2.style.fontSize, fontFamily: d2.style.fontFamily, fontWeight: d2.style.fontWeight || "normal" })).attr({ class: f2 || "apexcharts-datalabel", cx: a2, cy: s2 }), d2.dropShadow.enabled) {
        var w2 = d2.dropShadow;
        new Li(this.ctx).dropShadow(x2, w2);
      }
      c2.add(x2), void 0 === e2.globals.lastDrawnDataLabelsIndexes[r2] && (e2.globals.lastDrawnDataLabelsIndexes[r2] = []), e2.globals.lastDrawnDataLabelsIndexes[r2].push(n2);
    }
    return x2;
  } }, { key: "addBackgroundToDataLabel", value: function(t3, e2) {
    var i = this.w, a2 = i.config.dataLabels.background, s2 = a2.padding, r2 = a2.padding / 2, n2 = e2.width, o2 = e2.height, l2 = new Mi(this.ctx).drawRect(e2.x - s2, e2.y - r2 / 2, n2 + 2 * s2, o2 + r2, a2.borderRadius, "transparent" !== i.config.chart.background && i.config.chart.background ? i.config.chart.background : "#fff", a2.opacity, a2.borderWidth, a2.borderColor);
    a2.dropShadow.enabled && new Li(this.ctx).dropShadow(l2, a2.dropShadow);
    return l2;
  } }, { key: "dataLabelsBackground", value: function() {
    var t3 = this.w;
    if ("bubble" !== t3.config.chart.type)
      for (var e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e2.length; i++) {
        var a2 = e2[i], s2 = a2.getBBox(), r2 = null;
        if (s2.width && s2.height && (r2 = this.addBackgroundToDataLabel(a2, s2)), r2) {
          a2.parentNode.insertBefore(r2.node, a2);
          var n2 = a2.getAttribute("fill");
          t3.config.chart.animations.enabled && !t3.globals.resized && !t3.globals.dataChanged ? r2.animate().attr({ fill: n2 }) : r2.attr({ fill: n2 }), a2.setAttribute("fill", t3.config.dataLabels.background.foreColor);
        }
      }
  } }, { key: "bringForward", value: function() {
    for (var t3 = this.w, e2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t3.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a2 = 0; a2 < e2.length; a2++)
      i && i.insertBefore(e2[a2], i.nextSibling);
  } }]), t2;
}(), Zi = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.legendInactiveClass = "legend-mouseover-inactive";
  }
  return s(t2, [{ key: "getAllSeriesEls", value: function() {
    return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series");
  } }, { key: "getSeriesByName", value: function(t3) {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(v.escapeString(t3), "']"));
  } }, { key: "isSeriesHidden", value: function(t3) {
    var e2 = this.getSeriesByName(t3), i = parseInt(e2.getAttribute("data:realIndex"), 10);
    return { isHidden: e2.classList.contains("apexcharts-series-collapsed"), realIndex: i };
  } }, { key: "addCollapsedClassToSeries", value: function(t3, e2) {
    var i = this.w;
    function a2(i2) {
      for (var a3 = 0; a3 < i2.length; a3++)
        i2[a3].index === e2 && t3.node.classList.add("apexcharts-series-collapsed");
    }
    a2(i.globals.collapsedSeries), a2(i.globals.ancillaryCollapsedSeries);
  } }, { key: "toggleSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    return this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, e2.isHidden), e2.isHidden;
  } }, { key: "showSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, true);
  } }, { key: "hideSeries", value: function(t3) {
    var e2 = this.isSeriesHidden(t3);
    e2.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e2.realIndex, false);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w, s2 = v.clone(a2.globals.initialSeries);
    a2.globals.previousPaths = [], i ? (a2.globals.collapsedSeries = [], a2.globals.ancillaryCollapsedSeries = [], a2.globals.collapsedSeriesIndices = [], a2.globals.ancillaryCollapsedSeriesIndices = []) : s2 = this.emptyCollapsedSeries(s2), a2.config.series = s2, t3 && (e2 && (a2.globals.zoomed = false, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled));
  } }, { key: "emptyCollapsedSeries", value: function(t3) {
    for (var e2 = this.w, i = 0; i < t3.length; i++)
      e2.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t3[i].data = []);
    return t3;
  } }, { key: "highlightSeries", value: function(t3) {
    var e2 = this.w, i = this.getSeriesByName(t3), a2 = parseInt(null == i ? void 0 : i.getAttribute("data:realIndex"), 10), s2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis"), r2 = null, n2 = null, o2 = null;
    if (e2.globals.axisCharts || "radialBar" === e2.config.chart.type)
      if (e2.globals.axisCharts) {
        r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(a2, "']")), n2 = e2.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(a2, "']"));
        var l2 = e2.globals.seriesYAxisReverseMap[a2];
        o2 = e2.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(l2, "']"));
      } else
        r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "']"));
    else
      r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(a2 + 1, "'] path"));
    for (var h2 = 0; h2 < s2.length; h2++)
      s2[h2].classList.add(this.legendInactiveClass);
    if (r2)
      e2.globals.axisCharts || r2.parentNode.classList.remove(this.legendInactiveClass), r2.classList.remove(this.legendInactiveClass), null !== n2 && n2.classList.remove(this.legendInactiveClass), null !== o2 && o2.classList.remove(this.legendInactiveClass);
    else
      for (var c2 = 0; c2 < s2.length; c2++)
        s2[c2].classList.remove(this.legendInactiveClass);
  } }, { key: "toggleSeriesOnHover", value: function(t3, e2) {
    var i = this.w;
    e2 || (e2 = t3.target);
    var a2 = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels, .apexcharts-yaxis");
    if ("mousemove" === t3.type) {
      var s2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      this.highlightSeries(i.globals.seriesNames[s2]);
    } else if ("mouseout" === t3.type)
      for (var r2 = 0; r2 < a2.length; r2++)
        a2[r2].classList.remove(this.legendInactiveClass);
  } }, { key: "highlightRangeInSeries", value: function(t3, e2) {
    var i = this, a2 = this.w, s2 = a2.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"), r2 = function(t4) {
      for (var e3 = 0; e3 < s2.length; e3++)
        s2[e3].classList[t4](i.legendInactiveClass);
    };
    if ("mousemove" === t3.type) {
      var n2 = parseInt(e2.getAttribute("rel"), 10) - 1;
      r2("add");
      var o2 = a2.config.plotOptions.heatmap.colorScale.ranges;
      !function(t4, e3) {
        for (var a3 = 0; a3 < s2.length; a3++) {
          var r3 = Number(s2[a3].getAttribute("val"));
          r3 >= t4.from && (r3 < t4.to || t4.to === e3 && r3 === e3) && s2[a3].classList.remove(i.legendInactiveClass);
        }
      }(o2[n2], o2.reduce(function(t4, e3) {
        return Math.max(t4, e3.to);
      }, 0));
    } else
      "mouseout" === t3.type && r2("remove");
  } }, { key: "getActiveConfigSeriesIndex", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "asc", e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], i = this.w, a2 = 0;
    if (i.config.series.length > 1) {
      for (var s2 = i.config.series.map(function(t4, a3) {
        return t4.data && t4.data.length > 0 && -1 === i.globals.collapsedSeriesIndices.indexOf(a3) && (!i.globals.comboCharts || 0 === e2.length || e2.length && e2.indexOf(i.config.series[a3].type) > -1) ? a3 : -1;
      }), r2 = "asc" === t3 ? 0 : s2.length - 1; "asc" === t3 ? r2 < s2.length : r2 >= 0; "asc" === t3 ? r2++ : r2--)
        if (-1 !== s2[r2]) {
          a2 = s2[r2];
          break;
        }
    }
    return a2;
  } }, { key: "getBarSeriesIndices", value: function() {
    return this.w.globals.comboCharts ? this.w.config.series.map(function(t3, e2) {
      return "bar" === t3.type || "column" === t3.type ? e2 : -1;
    }).filter(function(t3) {
      return -1 !== t3;
    }) : this.w.config.series.map(function(t3, e2) {
      return e2;
    });
  } }, { key: "getPreviousPaths", value: function() {
    var t3 = this.w;
    function e2(e3, i2, a3) {
      for (var s3 = e3[i2].childNodes, r2 = { type: a3, paths: [], realIndex: e3[i2].getAttribute("data:realIndex") }, n2 = 0; n2 < s3.length; n2++)
        if (s3[n2].hasAttribute("pathTo")) {
          var o2 = s3[n2].getAttribute("pathTo");
          r2.paths.push({ d: o2 });
        }
      t3.globals.previousPaths.push(r2);
    }
    t3.globals.previousPaths = [];
    ["line", "area", "bar", "rangebar", "rangeArea", "candlestick", "radar"].forEach(function(i2) {
      for (var a3, s3 = (a3 = i2, t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a3, "-series .apexcharts-series"))), r2 = 0; r2 < s3.length; r2++)
        e2(s3, r2, i2);
    });
    var i = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series"));
    if (i.length > 0)
      for (var a2 = function(e3) {
        for (var i2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t3.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e3, "'] rect")), a3 = [], s3 = function(t4) {
          var e4 = function(e5) {
            return i2[t4].getAttribute(e5);
          }, s4 = { x: parseFloat(e4("x")), y: parseFloat(e4("y")), width: parseFloat(e4("width")), height: parseFloat(e4("height")) };
          a3.push({ rect: s4, color: i2[t4].getAttribute("color") });
        }, r2 = 0; r2 < i2.length; r2++)
          s3(r2);
        t3.globals.previousPaths.push(a3);
      }, s2 = 0; s2 < i.length; s2++)
        a2(s2);
    t3.globals.axisCharts || (t3.globals.previousPaths = t3.globals.series);
  } }, { key: "clearPreviousPaths", value: function() {
    var t3 = this.w;
    t3.globals.previousPaths = [], t3.globals.allSeriesCollapsed = false;
  } }, { key: "handleNoData", value: function() {
    var t3 = this.w, e2 = t3.config.noData, i = new Mi(this.ctx), a2 = t3.globals.svgWidth / 2, s2 = t3.globals.svgHeight / 2, r2 = "middle";
    if (t3.globals.noData = true, t3.globals.animationEnded = true, "left" === e2.align ? (a2 = 10, r2 = "start") : "right" === e2.align && (a2 = t3.globals.svgWidth - 10, r2 = "end"), "top" === e2.verticalAlign ? s2 = 50 : "bottom" === e2.verticalAlign && (s2 = t3.globals.svgHeight - 50), a2 += e2.offsetX, s2 = s2 + parseInt(e2.style.fontSize, 10) + 2 + e2.offsetY, void 0 !== e2.text && "" !== e2.text) {
      var n2 = i.drawText({ x: a2, y: s2, text: e2.text, textAnchor: r2, fontSize: e2.style.fontSize, fontFamily: e2.style.fontFamily, foreColor: e2.style.color, opacity: 1, class: "apexcharts-text-nodata" });
      t3.globals.dom.Paper.add(n2);
    }
  } }, { key: "setNullSeriesToZeroValues", value: function(t3) {
    for (var e2 = this.w, i = 0; i < t3.length; i++)
      if (0 === t3[i].length)
        for (var a2 = 0; a2 < t3[e2.globals.maxValsInArrayIndex].length; a2++)
          t3[i].push(0);
    return t3;
  } }, { key: "hasAllSeriesEqualX", value: function() {
    for (var t3 = true, e2 = this.w, i = this.filteredSeriesX(), a2 = 0; a2 < i.length - 1; a2++)
      if (i[a2][0] !== i[a2 + 1][0]) {
        t3 = false;
        break;
      }
    return e2.globals.allSeriesHasEqualX = t3, t3;
  } }, { key: "filteredSeriesX", value: function() {
    var t3 = this.w.globals.seriesX.map(function(t4) {
      return t4.length > 0 ? t4 : [];
    });
    return t3;
  } }]), t2;
}(), $i = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "isMultiFormat", value: function() {
    return this.isFormatXY() || this.isFormat2DArray();
  } }, { key: "isFormatXY", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && null !== t3[this.activeSeriesIndex].data[0] && void 0 !== t3[this.activeSeriesIndex].data[0].x && null !== t3[this.activeSeriesIndex].data[0])
      return true;
  } }, { key: "isFormat2DArray", value: function() {
    var t3 = this.w.config.series.slice(), e2 = new Zi(this.ctx);
    if (this.activeSeriesIndex = e2.getActiveConfigSeriesIndex(), void 0 !== t3[this.activeSeriesIndex].data && t3[this.activeSeriesIndex].data.length > 0 && void 0 !== t3[this.activeSeriesIndex].data[0] && null !== t3[this.activeSeriesIndex].data[0] && t3[this.activeSeriesIndex].data[0].constructor === Array)
      return true;
  } }, { key: "handleFormat2DArray", value: function(t3, e2) {
    for (var i = this.w.config, a2 = this.w.globals, s2 = "boxPlot" === i.chart.type || "boxPlot" === i.series[e2].type, r2 = 0; r2 < t3[e2].data.length; r2++)
      if (void 0 !== t3[e2].data[r2][1] && (Array.isArray(t3[e2].data[r2][1]) && 4 === t3[e2].data[r2][1].length && !s2 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1][3])) : t3[e2].data[r2].length >= 5 ? this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][4])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[r2][1])), a2.dataFormatXNumeric = true), "datetime" === i.xaxis.type) {
        var n2 = new Date(t3[e2].data[r2][0]);
        n2 = new Date(n2).getTime(), this.twoDSeriesX.push(n2);
      } else
        this.twoDSeriesX.push(t3[e2].data[r2][0]);
    for (var o2 = 0; o2 < t3[e2].data.length; o2++)
      void 0 !== t3[e2].data[o2][2] && (this.threeDSeries.push(t3[e2].data[o2][2]), a2.isDataXYZ = true);
  } }, { key: "handleFormatXY", value: function(t3, e2) {
    var i = this.w.config, a2 = this.w.globals, s2 = new zi(this.ctx), r2 = e2;
    a2.collapsedSeriesIndices.indexOf(e2) > -1 && (r2 = this.activeSeriesIndex);
    for (var n2 = 0; n2 < t3[e2].data.length; n2++)
      void 0 !== t3[e2].data[n2].y && (Array.isArray(t3[e2].data[n2].y) ? this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y[t3[e2].data[n2].y.length - 1])) : this.twoDSeries.push(v.parseNumber(t3[e2].data[n2].y))), void 0 !== t3[e2].data[n2].goals && Array.isArray(t3[e2].data[n2].goals) ? (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(t3[e2].data[n2].goals)) : (void 0 === this.seriesGoals[e2] && (this.seriesGoals[e2] = []), this.seriesGoals[e2].push(null));
    for (var o2 = 0; o2 < t3[r2].data.length; o2++) {
      var l2 = "string" == typeof t3[r2].data[o2].x, h2 = Array.isArray(t3[r2].data[o2].x), c2 = !h2 && !!s2.isValidDate(t3[r2].data[o2].x);
      if (l2 || c2)
        if (l2 || i.xaxis.convertedCatToNumeric) {
          var d2 = a2.isBarHorizontal && a2.isRangeData;
          "datetime" !== i.xaxis.type || d2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x), isNaN(t3[r2].data[o2].x) || "category" === this.w.config.xaxis.type || "string" == typeof t3[r2].data[o2].x || (a2.isXNumeric = true)) : this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x));
        } else
          "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s2.parseDate(t3[r2].data[o2].x.toString())) : (a2.dataFormatXNumeric = true, a2.isXNumeric = true, this.twoDSeriesX.push(parseFloat(t3[r2].data[o2].x)));
      else
        h2 ? (this.fallbackToCategory = true, this.twoDSeriesX.push(t3[r2].data[o2].x)) : (a2.isXNumeric = true, a2.dataFormatXNumeric = true, this.twoDSeriesX.push(t3[r2].data[o2].x));
    }
    if (t3[e2].data[0] && void 0 !== t3[e2].data[0].z) {
      for (var u2 = 0; u2 < t3[e2].data.length; u2++)
        this.threeDSeries.push(t3[e2].data[u2].z);
      a2.isDataXYZ = true;
    }
  } }, { key: "handleRangeData", value: function(t3, e2) {
    var i = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleRangeDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleRangeDataFormat("xy", t3, e2)), i.seriesRangeStart.push(void 0 === a2.start ? [] : a2.start), i.seriesRangeEnd.push(void 0 === a2.end ? [] : a2.end), i.seriesRange.push(a2.rangeUniques), i.seriesRange.forEach(function(t4, e3) {
      t4 && t4.forEach(function(t5, e4) {
        t5.y.forEach(function(e5, i2) {
          for (var a3 = 0; a3 < t5.y.length; a3++)
            if (i2 !== a3) {
              var s2 = e5.y1, r2 = e5.y2, n2 = t5.y[a3].y1;
              s2 <= t5.y[a3].y2 && n2 <= r2 && (t5.overlaps.indexOf(e5.rangeName) < 0 && t5.overlaps.push(e5.rangeName), t5.overlaps.indexOf(t5.y[a3].rangeName) < 0 && t5.overlaps.push(t5.y[a3].rangeName));
            }
        });
      });
    }), a2;
  } }, { key: "handleCandleStickBoxData", value: function(t3, e2) {
    var i = this.w.globals, a2 = {};
    return this.isFormat2DArray() ? a2 = this.handleCandleStickBoxDataFormat("array", t3, e2) : this.isFormatXY() && (a2 = this.handleCandleStickBoxDataFormat("xy", t3, e2)), i.seriesCandleO[e2] = a2.o, i.seriesCandleH[e2] = a2.h, i.seriesCandleM[e2] = a2.m, i.seriesCandleL[e2] = a2.l, i.seriesCandleC[e2] = a2.c, a2;
  } }, { key: "handleRangeDataFormat", value: function(t3, e2, i) {
    var a2 = [], s2 = [], r2 = e2[i].data.filter(function(t4, e3, i2) {
      return e3 === i2.findIndex(function(e4) {
        return e4.x === t4.x;
      });
    }).map(function(t4, e3) {
      return { x: t4.x, overlaps: [], y: [] };
    });
    if ("array" === t3)
      for (var n2 = 0; n2 < e2[i].data.length; n2++)
        Array.isArray(e2[i].data[n2]) ? (a2.push(e2[i].data[n2][1][0]), s2.push(e2[i].data[n2][1][1])) : (a2.push(e2[i].data[n2]), s2.push(e2[i].data[n2]));
    else if ("xy" === t3)
      for (var o2 = function(t4) {
        var n3 = Array.isArray(e2[i].data[t4].y), o3 = v.randomId(), l3 = e2[i].data[t4].x, h2 = { y1: n3 ? e2[i].data[t4].y[0] : e2[i].data[t4].y, y2: n3 ? e2[i].data[t4].y[1] : e2[i].data[t4].y, rangeName: o3 };
        e2[i].data[t4].rangeName = o3;
        var c2 = r2.findIndex(function(t5) {
          return t5.x === l3;
        });
        r2[c2].y.push(h2), a2.push(h2.y1), s2.push(h2.y2);
      }, l2 = 0; l2 < e2[i].data.length; l2++)
        o2(l2);
    return { start: a2, end: s2, rangeUniques: r2 };
  } }, { key: "handleCandleStickBoxDataFormat", value: function(t3, e2, i) {
    var a2 = this.w, s2 = "boxPlot" === a2.config.chart.type || "boxPlot" === a2.config.series[i].type, r2 = [], n2 = [], o2 = [], l2 = [], h2 = [];
    if ("array" === t3)
      if (s2 && 6 === e2[i].data[0].length || !s2 && 5 === e2[i].data[0].length)
        for (var c2 = 0; c2 < e2[i].data.length; c2++)
          r2.push(e2[i].data[c2][1]), n2.push(e2[i].data[c2][2]), s2 ? (o2.push(e2[i].data[c2][3]), l2.push(e2[i].data[c2][4]), h2.push(e2[i].data[c2][5])) : (l2.push(e2[i].data[c2][3]), h2.push(e2[i].data[c2][4]));
      else
        for (var d2 = 0; d2 < e2[i].data.length; d2++)
          Array.isArray(e2[i].data[d2][1]) && (r2.push(e2[i].data[d2][1][0]), n2.push(e2[i].data[d2][1][1]), s2 ? (o2.push(e2[i].data[d2][1][2]), l2.push(e2[i].data[d2][1][3]), h2.push(e2[i].data[d2][1][4])) : (l2.push(e2[i].data[d2][1][2]), h2.push(e2[i].data[d2][1][3])));
    else if ("xy" === t3)
      for (var u2 = 0; u2 < e2[i].data.length; u2++)
        Array.isArray(e2[i].data[u2].y) && (r2.push(e2[i].data[u2].y[0]), n2.push(e2[i].data[u2].y[1]), s2 ? (o2.push(e2[i].data[u2].y[2]), l2.push(e2[i].data[u2].y[3]), h2.push(e2[i].data[u2].y[4])) : (l2.push(e2[i].data[u2].y[2]), h2.push(e2[i].data[u2].y[3])));
    return { o: r2, h: n2, m: o2, l: l2, c: h2 };
  } }, { key: "parseDataAxisCharts", value: function(t3) {
    var e2 = this, i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx, a2 = this.w.config, s2 = this.w.globals, r2 = new zi(i), n2 = a2.labels.length > 0 ? a2.labels.slice() : a2.xaxis.categories.slice();
    s2.isRangeBar = "rangeBar" === a2.chart.type && s2.isBarHorizontal, s2.hasXaxisGroups = "category" === a2.xaxis.type && a2.xaxis.group.groups.length > 0, s2.hasXaxisGroups && (s2.groups = a2.xaxis.group.groups), t3.forEach(function(t4, e3) {
      void 0 !== t4.name ? s2.seriesNames.push(t4.name) : s2.seriesNames.push("series-" + parseInt(e3 + 1, 10));
    }), this.coreUtils.setSeriesYAxisMappings();
    var o2 = [], l2 = f(new Set(a2.series.map(function(t4) {
      return t4.group;
    })));
    a2.series.forEach(function(t4, e3) {
      var i2 = l2.indexOf(t4.group);
      o2[i2] || (o2[i2] = []), o2[i2].push(s2.seriesNames[e3]);
    }), s2.seriesGroups = o2;
    for (var h2 = function() {
      for (var t4 = 0; t4 < n2.length; t4++)
        if ("string" == typeof n2[t4]) {
          if (!r2.isValidDate(n2[t4]))
            throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
          e2.twoDSeriesX.push(r2.parseDate(n2[t4]));
        } else
          e2.twoDSeriesX.push(n2[t4]);
    }, c2 = 0; c2 < t3.length; c2++) {
      if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t3[c2].data)
        return void console.error("It is a possibility that you may have not included 'data' property in series.");
      if ("rangeBar" !== a2.chart.type && "rangeArea" !== a2.chart.type && "rangeBar" !== t3[c2].type && "rangeArea" !== t3[c2].type || (s2.isRangeData = true, "rangeBar" !== a2.chart.type && "rangeArea" !== a2.chart.type || this.handleRangeData(t3, c2)), this.isMultiFormat())
        this.isFormat2DArray() ? this.handleFormat2DArray(t3, c2) : this.isFormatXY() && this.handleFormatXY(t3, c2), "candlestick" !== a2.chart.type && "candlestick" !== t3[c2].type && "boxPlot" !== a2.chart.type && "boxPlot" !== t3[c2].type || this.handleCandleStickBoxData(t3, c2), s2.series.push(this.twoDSeries), s2.labels.push(this.twoDSeriesX), s2.seriesX.push(this.twoDSeriesX), s2.seriesGoals = this.seriesGoals, c2 !== this.activeSeriesIndex || this.fallbackToCategory || (s2.isXNumeric = true);
      else {
        "datetime" === a2.xaxis.type ? (s2.isXNumeric = true, h2(), s2.seriesX.push(this.twoDSeriesX)) : "numeric" === a2.xaxis.type && (s2.isXNumeric = true, n2.length > 0 && (this.twoDSeriesX = n2, s2.seriesX.push(this.twoDSeriesX))), s2.labels.push(this.twoDSeriesX);
        var d2 = t3[c2].data.map(function(t4) {
          return v.parseNumber(t4);
        });
        s2.series.push(d2);
      }
      s2.seriesZ.push(this.threeDSeries), void 0 !== t3[c2].color ? s2.seriesColors.push(t3[c2].color) : s2.seriesColors.push(void 0);
    }
    return this.w;
  } }, { key: "parseDataNonAxisCharts", value: function(t3) {
    var e2 = this.w.globals, i = this.w.config;
    e2.series = t3.slice(), e2.seriesNames = i.labels.slice();
    for (var a2 = 0; a2 < e2.series.length; a2++)
      void 0 === e2.seriesNames[a2] && e2.seriesNames.push("series-" + (a2 + 1));
    return this.w;
  } }, { key: "handleExternalLabelsData", value: function(t3) {
    var e2 = this.w.config, i = this.w.globals;
    if (e2.xaxis.categories.length > 0)
      i.labels = e2.xaxis.categories;
    else if (e2.labels.length > 0)
      i.labels = e2.labels.slice();
    else if (this.fallbackToCategory) {
      if (i.labels = i.labels[0], i.seriesRange.length && (i.seriesRange.map(function(t4) {
        t4.forEach(function(t5) {
          i.labels.indexOf(t5.x) < 0 && t5.x && i.labels.push(t5.x);
        });
      }), i.labels = Array.from(new Set(i.labels.map(JSON.stringify)), JSON.parse)), e2.xaxis.convertedCatToNumeric)
        new Ni(e2).convertCatToNumericXaxis(e2, this.ctx, i.seriesX[0]), this._generateExternalLabels(t3);
    } else
      this._generateExternalLabels(t3);
  } }, { key: "_generateExternalLabels", value: function(t3) {
    var e2 = this.w.globals, i = this.w.config, a2 = [];
    if (e2.axisCharts) {
      if (e2.series.length > 0)
        if (this.isFormatXY())
          for (var s2 = i.series.map(function(t4, e3) {
            return t4.data.filter(function(t5, e4, i2) {
              return i2.findIndex(function(e5) {
                return e5.x === t5.x;
              }) === e4;
            });
          }), r2 = s2.reduce(function(t4, e3, i2, a3) {
            return a3[t4].length > e3.length ? t4 : i2;
          }, 0), n2 = 0; n2 < s2[r2].length; n2++)
            a2.push(n2 + 1);
        else
          for (var o2 = 0; o2 < e2.series[e2.maxValsInArrayIndex].length; o2++)
            a2.push(o2 + 1);
      e2.seriesX = [];
      for (var l2 = 0; l2 < t3.length; l2++)
        e2.seriesX.push(a2);
      this.w.globals.isBarHorizontal || (e2.isXNumeric = true);
    }
    if (0 === a2.length) {
      a2 = e2.axisCharts ? [] : e2.series.map(function(t4, e3) {
        return e3 + 1;
      });
      for (var h2 = 0; h2 < t3.length; h2++)
        e2.seriesX.push(a2);
    }
    e2.labels = a2, i.xaxis.convertedCatToNumeric && (e2.categoryLabels = a2.map(function(t4) {
      return i.xaxis.labels.formatter(t4);
    })), e2.noLabelsProvided = true;
  } }, { key: "parseData", value: function(t3) {
    var e2 = this.w, i = e2.config, a2 = e2.globals;
    if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = false, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a2.axisCharts ? (this.parseDataAxisCharts(t3), this.coreUtils.getLargestSeries()) : this.parseDataNonAxisCharts(t3), i.chart.stacked) {
      var s2 = new Zi(this.ctx);
      a2.series = s2.setNullSeriesToZeroValues(a2.series);
    }
    this.coreUtils.getSeriesTotals(), a2.axisCharts && (a2.stackedSeriesTotals = this.coreUtils.getStackedSeriesTotals(), a2.stackedSeriesTotalsByGroups = this.coreUtils.getStackedSeriesTotalsByGroups()), this.coreUtils.getPercentSeries(), a2.dataFormatXNumeric || a2.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t3);
    for (var r2 = this.coreUtils.getCategoryLabels(a2.labels), n2 = 0; n2 < r2.length; n2++)
      if (Array.isArray(r2[n2])) {
        a2.isMultiLineX = true;
        break;
      }
  } }, { key: "excludeCollapsedSeriesInYAxis", value: function() {
    var t3 = this.w, e2 = [];
    t3.globals.seriesYAxisMap.forEach(function(i, a2) {
      var s2 = 0;
      i.forEach(function(e3) {
        -1 !== t3.globals.collapsedSeriesIndices.indexOf(e3) && s2++;
      }), s2 > 0 && s2 == i.length && e2.push(a2);
    }), t3.globals.ignoreYAxisIndexes = e2.map(function(t4) {
      return t4;
    });
  } }]), t2;
}(), Ji = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "svgStringToNode", value: function(t3) {
    return new DOMParser().parseFromString(t3, "image/svg+xml").documentElement;
  } }, { key: "scaleSvgNode", value: function(t3, e2) {
    var i = parseFloat(t3.getAttributeNS(null, "width")), a2 = parseFloat(t3.getAttributeNS(null, "height"));
    t3.setAttributeNS(null, "width", i * e2), t3.setAttributeNS(null, "height", a2 * e2), t3.setAttributeNS(null, "viewBox", "0 0 " + i + " " + a2);
  } }, { key: "getSvgString", value: function(t3) {
    var e2 = this;
    return new Promise(function(i) {
      var a2 = e2.w, s2 = t3 || a2.config.chart.toolbar.export.scale || a2.config.chart.toolbar.export.width / a2.globals.svgWidth;
      s2 || (s2 = 1);
      var r2 = a2.globals.svgWidth * s2, n2 = a2.globals.svgHeight * s2, o2 = a2.globals.dom.elWrap.cloneNode(true);
      o2.style.width = r2 + "px", o2.style.height = n2 + "px";
      var l2 = new XMLSerializer().serializeToString(o2), h2 = '\n        <svg xmlns="http://www.w3.org/2000/svg"\n          version="1.1"\n          xmlns:xlink="http://www.w3.org/1999/xlink"\n          class="apexcharts-svg"\n          xmlns:data="ApexChartsNS"\n          transform="translate(0, 0)"\n          width="'.concat(a2.globals.svgWidth, 'px" height="').concat(a2.globals.svgHeight, 'px">\n          <foreignObject width="100%" height="100%">\n            <div xmlns="http://www.w3.org/1999/xhtml" style="width:').concat(r2, "px; height:").concat(n2, 'px;">\n            <style type="text/css">\n              .apexcharts-tooltip, .apexcharts-toolbar, .apexcharts-xaxistooltip, .apexcharts-yaxistooltip, .apexcharts-xcrosshairs, .apexcharts-ycrosshairs, .apexcharts-zoom-rect, .apexcharts-selection-rect {\n                display: none;\n              }\n            </style>\n              ').concat(l2, "\n            </div>\n          </foreignObject>\n        </svg>\n      "), c2 = e2.svgStringToNode(h2);
      1 !== s2 && e2.scaleSvgNode(c2, s2), e2.convertImagesToBase64(c2).then(function() {
        h2 = new XMLSerializer().serializeToString(c2), i(h2.replace(/&nbsp;/g, "&#160;"));
      });
    });
  } }, { key: "convertImagesToBase64", value: function(t3) {
    var e2 = this, i = t3.getElementsByTagName("image"), a2 = Array.from(i).map(function(t4) {
      var i2 = t4.getAttributeNS("http://www.w3.org/1999/xlink", "href");
      return i2 && !i2.startsWith("data:") ? e2.getBase64FromUrl(i2).then(function(e3) {
        t4.setAttributeNS("http://www.w3.org/1999/xlink", "href", e3);
      }).catch(function(t5) {
        console.error("Error converting image to base64:", t5);
      }) : Promise.resolve();
    });
    return Promise.all(a2);
  } }, { key: "getBase64FromUrl", value: function(t3) {
    return new Promise(function(e2, i) {
      var a2 = new Image();
      a2.crossOrigin = "Anonymous", a2.onload = function() {
        var t4 = document.createElement("canvas");
        t4.width = a2.width, t4.height = a2.height, t4.getContext("2d").drawImage(a2, 0, 0), e2(t4.toDataURL());
      }, a2.onerror = i, a2.src = t3;
    });
  } }, { key: "svgUrl", value: function() {
    var t3 = this;
    return new Promise(function(e2) {
      t3.getSvgString().then(function(t4) {
        var i = new Blob([t4], { type: "image/svg+xml;charset=utf-8" });
        e2(URL.createObjectURL(i));
      });
    });
  } }, { key: "dataURI", value: function(t3) {
    var e2 = this;
    return new Promise(function(i) {
      var a2 = e2.w, s2 = t3 ? t3.scale || t3.width / a2.globals.svgWidth : 1, r2 = document.createElement("canvas");
      r2.width = a2.globals.svgWidth * s2, r2.height = parseInt(a2.globals.dom.elWrap.style.height, 10) * s2;
      var n2 = "transparent" !== a2.config.chart.background && a2.config.chart.background ? a2.config.chart.background : "#fff", o2 = r2.getContext("2d");
      o2.fillStyle = n2, o2.fillRect(0, 0, r2.width * s2, r2.height * s2), e2.getSvgString(s2).then(function(t4) {
        var e3 = "data:image/svg+xml," + encodeURIComponent(t4), a3 = new Image();
        a3.crossOrigin = "anonymous", a3.onload = function() {
          if (o2.drawImage(a3, 0, 0), r2.msToBlob) {
            var t5 = r2.msToBlob();
            i({ blob: t5 });
          } else {
            var e4 = r2.toDataURL("image/png");
            i({ imgURI: e4 });
          }
        }, a3.src = e3;
      });
    });
  } }, { key: "exportToSVG", value: function() {
    var t3 = this;
    this.svgUrl().then(function(e2) {
      t3.triggerDownload(e2, t3.w.config.chart.toolbar.export.svg.filename, ".svg");
    });
  } }, { key: "exportToPng", value: function() {
    var t3 = this, e2 = this.w.config.chart.toolbar.export.scale, i = this.w.config.chart.toolbar.export.width, a2 = e2 ? { scale: e2 } : i ? { width: i } : void 0;
    this.dataURI(a2).then(function(e3) {
      var i2 = e3.imgURI, a3 = e3.blob;
      a3 ? navigator.msSaveOrOpenBlob(a3, t3.w.globals.chartID + ".png") : t3.triggerDownload(i2, t3.w.config.chart.toolbar.export.png.filename, ".png");
    });
  } }, { key: "exportToCSV", value: function(t3) {
    var e2 = this, i = t3.series, a2 = t3.fileName, s2 = t3.columnDelimiter, r2 = void 0 === s2 ? "," : s2, n2 = t3.lineDelimiter, o2 = void 0 === n2 ? "\n" : n2, l2 = this.w;
    i || (i = l2.config.series);
    var h2 = [], c2 = [], d2 = "", u2 = l2.globals.series.map(function(t4, e3) {
      return -1 === l2.globals.collapsedSeriesIndices.indexOf(e3) ? t4 : [];
    }), g2 = function(t4) {
      return "function" == typeof l2.config.chart.toolbar.export.csv.categoryFormatter ? l2.config.chart.toolbar.export.csv.categoryFormatter(t4) : "datetime" === l2.config.xaxis.type && String(t4).length >= 10 ? new Date(t4).toDateString() : v.isNumber(t4) ? t4 : t4.split(r2).join("");
    }, p2 = function(t4) {
      return "function" == typeof l2.config.chart.toolbar.export.csv.valueFormatter ? l2.config.chart.toolbar.export.csv.valueFormatter(t4) : t4;
    }, x2 = Math.max.apply(Math, f(i.map(function(t4) {
      return t4.data ? t4.data.length : 0;
    }))), b2 = new $i(this.ctx), m2 = new Ri(this.ctx), y2 = function(t4) {
      var i2 = "";
      if (l2.globals.axisCharts) {
        if ("category" === l2.config.xaxis.type || l2.config.xaxis.convertedCatToNumeric)
          if (l2.globals.isBarHorizontal) {
            var a3 = l2.globals.yLabelFormatters[0], s3 = new Zi(e2.ctx).getActiveConfigSeriesIndex();
            i2 = a3(l2.globals.labels[t4], { seriesIndex: s3, dataPointIndex: t4, w: l2 });
          } else
            i2 = m2.getLabel(l2.globals.labels, l2.globals.timescaleLabels, 0, t4).text;
        "datetime" === l2.config.xaxis.type && (l2.config.xaxis.categories.length ? i2 = l2.config.xaxis.categories[t4] : l2.config.labels.length && (i2 = l2.config.labels[t4]));
      } else
        i2 = l2.config.labels[t4];
      return null === i2 ? "nullvalue" : (Array.isArray(i2) && (i2 = i2.join(" ")), v.isNumber(i2) ? i2 : i2.split(r2).join(""));
    }, w2 = function(t4, e3) {
      if (h2.length && 0 === e3 && c2.push(h2.join(r2)), t4.data) {
        t4.data = t4.data.length && t4.data || f(Array(x2)).map(function() {
          return "";
        });
        for (var a3 = 0; a3 < t4.data.length; a3++) {
          h2 = [];
          var s3 = y2(a3);
          if ("nullvalue" !== s3) {
            if (s3 || (b2.isFormatXY() ? s3 = i[e3].data[a3].x : b2.isFormat2DArray() && (s3 = i[e3].data[a3] ? i[e3].data[a3][0] : "")), 0 === e3) {
              h2.push(g2(s3));
              for (var n3 = 0; n3 < l2.globals.series.length; n3++) {
                var o3, d3 = b2.isFormatXY() ? null === (o3 = i[n3].data[a3]) || void 0 === o3 ? void 0 : o3.y : u2[n3][a3];
                h2.push(p2(d3));
              }
            }
            ("candlestick" === l2.config.chart.type || t4.type && "candlestick" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), ("boxPlot" === l2.config.chart.type || t4.type && "boxPlot" === t4.type) && (h2.pop(), h2.push(l2.globals.seriesCandleO[e3][a3]), h2.push(l2.globals.seriesCandleH[e3][a3]), h2.push(l2.globals.seriesCandleM[e3][a3]), h2.push(l2.globals.seriesCandleL[e3][a3]), h2.push(l2.globals.seriesCandleC[e3][a3])), "rangeBar" === l2.config.chart.type && (h2.pop(), h2.push(l2.globals.seriesRangeStart[e3][a3]), h2.push(l2.globals.seriesRangeEnd[e3][a3])), h2.length && c2.push(h2.join(r2));
          }
        }
      }
    };
    h2.push(l2.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l2.config.chart.type ? (h2.push("minimum"), h2.push("q1"), h2.push("median"), h2.push("q3"), h2.push("maximum")) : "candlestick" === l2.config.chart.type ? (h2.push("open"), h2.push("high"), h2.push("low"), h2.push("close")) : "rangeBar" === l2.config.chart.type ? (h2.push("minimum"), h2.push("maximum")) : i.map(function(t4, e3) {
      var i2 = (t4.name ? t4.name : "series-".concat(e3)) + "";
      l2.globals.axisCharts && h2.push(i2.split(r2).join("") ? i2.split(r2).join("") : "series-".concat(e3));
    }), l2.globals.axisCharts || (h2.push(l2.config.chart.toolbar.export.csv.headerValue), c2.push(h2.join(r2))), l2.globals.allSeriesHasEqualX || !l2.globals.axisCharts || l2.config.xaxis.categories.length || l2.config.labels.length ? i.map(function(t4, e3) {
      l2.globals.axisCharts ? w2(t4, e3) : ((h2 = []).push(g2(l2.globals.labels[e3])), h2.push(p2(u2[e3])), c2.push(h2.join(r2)));
    }) : function() {
      var t4 = /* @__PURE__ */ new Set(), e3 = {};
      i.forEach(function(a3, s3) {
        null == a3 || a3.data.forEach(function(a4) {
          var r3, n3;
          if (b2.isFormatXY())
            r3 = a4.x, n3 = a4.y;
          else {
            if (!b2.isFormat2DArray())
              return;
            r3 = a4[0], n3 = a4[1];
          }
          e3[r3] || (e3[r3] = Array(i.length).fill("")), e3[r3][s3] = p2(n3), t4.add(r3);
        });
      }), h2.length && c2.push(h2.join(r2)), Array.from(t4).sort().forEach(function(t5) {
        c2.push([g2(t5), e3[t5].join(r2)]);
      });
    }(), d2 += c2.join(o2), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\uFEFF" + d2), a2 || l2.config.chart.toolbar.export.csv.filename, ".csv");
  } }, { key: "triggerDownload", value: function(t3, e2, i) {
    var a2 = document.createElement("a");
    a2.href = t3, a2.download = (e2 || this.w.globals.chartID) + i, document.body.appendChild(a2), a2.click(), document.body.removeChild(a2);
  } }]), t2;
}(), Qi = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.axesUtils = new Ri(e2), this.xaxisLabels = s2.globals.labels.slice(), s2.globals.timescaleLabels.length > 0 && !s2.globals.isBarHorizontal && (this.xaxisLabels = s2.globals.timescaleLabels.slice()), s2.config.xaxis.overwriteCategories && (this.xaxisLabels = s2.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === s2.config.xaxis.position ? this.offY = 0 : this.offY = s2.globals.gridHeight, this.offY = this.offY + s2.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.xaxisBorderWidth = s2.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = s2.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = s2.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = s2.config.xaxis.axisBorder.height, this.yaxis = s2.config.yaxis[0];
  }
  return s(t2, [{ key: "drawXaxis", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i = e2.group({ class: "apexcharts-xaxis", transform: "translate(".concat(t3.config.xaxis.offsetX, ", ").concat(t3.config.xaxis.offsetY, ")") }), a2 = e2.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(t3.globals.translateXAxisX, ", ").concat(t3.globals.translateXAxisY, ")") });
    i.add(a2);
    for (var s2 = [], r2 = 0; r2 < this.xaxisLabels.length; r2++)
      s2.push(this.xaxisLabels[r2]);
    if (this.drawXAxisLabelAndGroup(true, e2, a2, s2, t3.globals.isXNumeric, function(t4, e3) {
      return e3;
    }), t3.globals.hasXaxisGroups) {
      var n2 = t3.globals.groups;
      s2 = [];
      for (var o2 = 0; o2 < n2.length; o2++)
        s2.push(n2[o2].title);
      var l2 = {};
      t3.config.xaxis.group.style && (l2.xaxisFontSize = t3.config.xaxis.group.style.fontSize, l2.xaxisFontFamily = t3.config.xaxis.group.style.fontFamily, l2.xaxisForeColors = t3.config.xaxis.group.style.colors, l2.fontWeight = t3.config.xaxis.group.style.fontWeight, l2.cssClass = t3.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(false, e2, a2, s2, false, function(t4, e3) {
        return n2[t4].cols * e3;
      }, l2);
    }
    if (void 0 !== t3.config.xaxis.title.text) {
      var h2 = e2.group({ class: "apexcharts-xaxis-title" }), c2 = e2.drawText({ x: t3.globals.gridWidth / 2 + t3.config.xaxis.title.offsetX, y: this.offY + parseFloat(this.xaxisFontSize) + ("bottom" === t3.config.xaxis.position ? t3.globals.xAxisLabelsHeight : -t3.globals.xAxisLabelsHeight - 10) + t3.config.xaxis.title.offsetY, text: t3.config.xaxis.title.text, textAnchor: "middle", fontSize: t3.config.xaxis.title.style.fontSize, fontFamily: t3.config.xaxis.title.style.fontFamily, fontWeight: t3.config.xaxis.title.style.fontWeight, foreColor: t3.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text " + t3.config.xaxis.title.style.cssClass });
      h2.add(c2), i.add(h2);
    }
    if (t3.config.xaxis.axisBorder.show) {
      var d2 = t3.globals.barPadForNumericAxis, u2 = e2.drawLine(t3.globals.padHorizontal + t3.config.xaxis.axisBorder.offsetX - d2, this.offY, this.xaxisBorderWidth + d2, this.offY, t3.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
      this.elgrid && this.elgrid.elGridBorders && t3.config.grid.show ? this.elgrid.elGridBorders.add(u2) : i.add(u2);
    }
    return i;
  } }, { key: "drawXAxisLabelAndGroup", value: function(t3, e2, i, a2, s2, r2) {
    var n2, o2 = this, l2 = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {}, h2 = [], c2 = [], d2 = this.w, u2 = l2.xaxisFontSize || this.xaxisFontSize, g2 = l2.xaxisFontFamily || this.xaxisFontFamily, p2 = l2.xaxisForeColors || this.xaxisForeColors, f2 = l2.fontWeight || d2.config.xaxis.labels.style.fontWeight, x2 = l2.cssClass || d2.config.xaxis.labels.style.cssClass, b2 = d2.globals.padHorizontal, m2 = a2.length, v2 = "category" === d2.config.xaxis.type ? d2.globals.dataPoints : m2;
    if (0 === v2 && m2 > v2 && (v2 = m2), s2) {
      var y2 = Math.max(Number(d2.config.xaxis.tickAmount) || 1, v2 > 1 ? v2 - 1 : v2);
      n2 = d2.globals.gridWidth / Math.min(y2, m2 - 1), b2 = b2 + r2(0, n2) / 2 + d2.config.xaxis.labels.offsetX;
    } else
      n2 = d2.globals.gridWidth / v2, b2 = b2 + r2(0, n2) + d2.config.xaxis.labels.offsetX;
    for (var w2 = function(s3) {
      var l3 = b2 - r2(s3, n2) / 2 + d2.config.xaxis.labels.offsetX;
      0 === s3 && 1 === m2 && n2 / 2 === b2 && 1 === v2 && (l3 = d2.globals.gridWidth / 2);
      var y3 = o2.axesUtils.getLabel(a2, d2.globals.timescaleLabels, l3, s3, h2, u2, t3), w3 = 28;
      d2.globals.rotateXLabels && t3 && (w3 = 22), d2.config.xaxis.title.text && "top" === d2.config.xaxis.position && (w3 += parseFloat(d2.config.xaxis.title.style.fontSize) + 2), t3 || (w3 = w3 + parseFloat(u2) + (d2.globals.xAxisLabelsHeight - d2.globals.xAxisGroupLabelsHeight) + (d2.globals.rotateXLabels ? 10 : 0)), y3 = void 0 !== d2.config.xaxis.tickAmount && "dataPoints" !== d2.config.xaxis.tickAmount && "datetime" !== d2.config.xaxis.type ? o2.axesUtils.checkLabelBasedOnTickamount(s3, y3, m2) : o2.axesUtils.checkForOverflowingLabels(s3, y3, m2, h2, c2);
      if (d2.config.xaxis.labels.show) {
        var k3 = e2.drawText({ x: y3.x, y: o2.offY + d2.config.xaxis.labels.offsetY + w3 - ("top" === d2.config.xaxis.position ? d2.globals.xAxisHeight + d2.config.xaxis.axisTicks.height - 2 : 0), text: y3.text, textAnchor: "middle", fontWeight: y3.isBold ? 600 : f2, fontSize: u2, fontFamily: g2, foreColor: Array.isArray(p2) ? t3 && d2.config.xaxis.convertedCatToNumeric ? p2[d2.globals.minX + s3 - 1] : p2[s3] : p2, isPlainText: false, cssClass: (t3 ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + x2 });
        if (i.add(k3), k3.on("click", function(t4) {
          if ("function" == typeof d2.config.chart.events.xAxisLabelClick) {
            var e3 = Object.assign({}, d2, { labelIndex: s3 });
            d2.config.chart.events.xAxisLabelClick(t4, o2.ctx, e3);
          }
        }), t3) {
          var A2 = document.createElementNS(d2.globals.SVGNS, "title");
          A2.textContent = Array.isArray(y3.text) ? y3.text.join(" ") : y3.text, k3.node.appendChild(A2), "" !== y3.text && (h2.push(y3.text), c2.push(y3));
        }
      }
      s3 < m2 - 1 && (b2 += r2(s3 + 1, n2));
    }, k2 = 0; k2 <= m2 - 1; k2++)
      w2(k2);
  } }, { key: "drawXaxisInversed", value: function(t3) {
    var e2, i, a2 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.config.yaxis[0].opposite ? s2.globals.translateYAxisX[t3] : 0, o2 = r2.group({ class: "apexcharts-yaxis apexcharts-xaxis-inversed", rel: t3 }), l2 = r2.group({ class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g", transform: "translate(" + n2 + ", 0)" });
    o2.add(l2);
    var h2 = [];
    if (s2.config.yaxis[t3].show)
      for (var c2 = 0; c2 < this.xaxisLabels.length; c2++)
        h2.push(this.xaxisLabels[c2]);
    e2 = s2.globals.gridHeight / h2.length, i = -e2 / 2.2;
    var d2 = s2.globals.yLabelFormatters[0], u2 = s2.config.yaxis[0].labels;
    if (u2.show)
      for (var g2 = function(n3) {
        var o3 = void 0 === h2[n3] ? "" : h2[n3];
        o3 = d2(o3, { seriesIndex: t3, dataPointIndex: n3, w: s2 });
        var c3 = a2.axesUtils.getYAxisForeColor(u2.style.colors, t3), g3 = 0;
        Array.isArray(o3) && (g3 = o3.length / 2 * parseInt(u2.style.fontSize, 10));
        var p3 = u2.offsetX - 15, f3 = "end";
        a2.yaxis.opposite && (f3 = "start"), "left" === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = "start") : "center" === s2.config.yaxis[0].labels.align ? (p3 = u2.offsetX, f3 = "middle") : "right" === s2.config.yaxis[0].labels.align && (f3 = "end");
        var x3 = r2.drawText({ x: p3, y: i + e2 + u2.offsetY - g3, text: o3, textAnchor: f3, foreColor: Array.isArray(c3) ? c3[n3] : c3, fontSize: u2.style.fontSize, fontFamily: u2.style.fontFamily, fontWeight: u2.style.fontWeight, isPlainText: false, cssClass: "apexcharts-yaxis-label " + u2.style.cssClass, maxWidth: u2.maxWidth });
        l2.add(x3), x3.on("click", function(t4) {
          if ("function" == typeof s2.config.chart.events.xAxisLabelClick) {
            var e3 = Object.assign({}, s2, { labelIndex: n3 });
            s2.config.chart.events.xAxisLabelClick(t4, a2.ctx, e3);
          }
        });
        var b3 = document.createElementNS(s2.globals.SVGNS, "title");
        if (b3.textContent = Array.isArray(o3) ? o3.join(" ") : o3, x3.node.appendChild(b3), 0 !== s2.config.yaxis[t3].labels.rotate) {
          var m3 = r2.rotateAroundCenter(x3.node);
          x3.node.setAttribute("transform", "rotate(".concat(s2.config.yaxis[t3].labels.rotate, " 0 ").concat(m3.y, ")"));
        }
        i += e2;
      }, p2 = 0; p2 <= h2.length - 1; p2++)
        g2(p2);
    if (void 0 !== s2.config.yaxis[0].title.text) {
      var f2 = r2.group({ class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed", transform: "translate(" + n2 + ", 0)" }), x2 = r2.drawText({ x: s2.config.yaxis[0].title.offsetX, y: s2.globals.gridHeight / 2 + s2.config.yaxis[0].title.offsetY, text: s2.config.yaxis[0].title.text, textAnchor: "middle", foreColor: s2.config.yaxis[0].title.style.color, fontSize: s2.config.yaxis[0].title.style.fontSize, fontWeight: s2.config.yaxis[0].title.style.fontWeight, fontFamily: s2.config.yaxis[0].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text " + s2.config.yaxis[0].title.style.cssClass });
      f2.add(x2), o2.add(f2);
    }
    var b2 = 0;
    this.isCategoryBarHorizontal && s2.config.yaxis[0].opposite && (b2 = s2.globals.gridWidth);
    var m2 = s2.config.xaxis.axisBorder;
    if (m2.show) {
      var v2 = r2.drawLine(s2.globals.padHorizontal + m2.offsetX + b2, 1 + m2.offsetY, s2.globals.padHorizontal + m2.offsetX + b2, s2.globals.gridHeight + m2.offsetY, m2.color, 0);
      this.elgrid && this.elgrid.elGridBorders && s2.config.grid.show ? this.elgrid.elGridBorders.add(v2) : o2.add(v2);
    }
    return s2.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(b2, h2.length, s2.config.yaxis[0].axisBorder, s2.config.yaxis[0].axisTicks, 0, e2, o2), o2;
  } }, { key: "drawXaxisTicks", value: function(t3, e2, i) {
    var a2 = this.w, s2 = t3;
    if (!(t3 < 0 || t3 - 2 > a2.globals.gridWidth)) {
      var r2 = this.offY + a2.config.xaxis.axisTicks.offsetY;
      if (e2 = e2 + r2 + a2.config.xaxis.axisTicks.height, "top" === a2.config.xaxis.position && (e2 = r2 - a2.config.xaxis.axisTicks.height), a2.config.xaxis.axisTicks.show) {
        var n2 = new Mi(this.ctx).drawLine(t3 + a2.config.xaxis.axisTicks.offsetX, r2 + a2.config.xaxis.offsetY, s2 + a2.config.xaxis.axisTicks.offsetX, e2 + a2.config.xaxis.offsetY, a2.config.xaxis.axisTicks.color);
        i.add(n2), n2.node.classList.add("apexcharts-xaxis-tick");
      }
    }
  } }, { key: "getXAxisTicksPositions", value: function() {
    var t3 = this.w, e2 = [], i = this.xaxisLabels.length, a2 = t3.globals.padHorizontal;
    if (t3.globals.timescaleLabels.length > 0)
      for (var s2 = 0; s2 < i; s2++)
        a2 = this.xaxisLabels[s2].position, e2.push(a2);
    else
      for (var r2 = i, n2 = 0; n2 < r2; n2++) {
        var o2 = r2;
        t3.globals.isXNumeric && "bar" !== t3.config.chart.type && (o2 -= 1), a2 += t3.globals.gridWidth / o2, e2.push(a2);
      }
    return e2;
  } }, { key: "xAxisLabelCorrections", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i = t3.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"), s2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"), r2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
    if (t3.globals.rotateXLabels || t3.config.xaxis.labels.rotateAlways)
      for (var n2 = 0; n2 < a2.length; n2++) {
        var o2 = e2.rotateAroundCenter(a2[n2]);
        o2.y = o2.y - 1, o2.x = o2.x + 1, a2[n2].setAttribute("transform", "rotate(".concat(t3.config.xaxis.labels.rotate, " ").concat(o2.x, " ").concat(o2.y, ")")), a2[n2].setAttribute("text-anchor", "end");
        i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
        var l2 = a2[n2].childNodes;
        t3.config.xaxis.labels.trim && Array.prototype.forEach.call(l2, function(i2) {
          e2.placeTextWithEllipsis(i2, i2.textContent, t3.globals.xAxisLabelsHeight - ("bottom" === t3.config.legend.position ? 20 : 10));
        });
      }
    else
      !function() {
        for (var i2 = t3.globals.gridWidth / (t3.globals.labels.length + 1), s3 = 0; s3 < a2.length; s3++) {
          var r3 = a2[s3].childNodes;
          t3.config.xaxis.labels.trim && "datetime" !== t3.config.xaxis.type && Array.prototype.forEach.call(r3, function(t4) {
            e2.placeTextWithEllipsis(t4, t4.textContent, i2);
          });
        }
      }();
    if (s2.length > 0) {
      var h2 = s2[s2.length - 1].getBBox(), c2 = s2[0].getBBox();
      h2.x < -20 && s2[s2.length - 1].parentNode.removeChild(s2[s2.length - 1]), c2.x + c2.width > t3.globals.gridWidth && !t3.globals.isBarHorizontal && s2[0].parentNode.removeChild(s2[0]);
      for (var d2 = 0; d2 < r2.length; d2++)
        e2.placeTextWithEllipsis(r2[d2], r2[d2].textContent, t3.config.yaxis[0].labels.maxWidth - (t3.config.yaxis[0].title.text ? 2 * parseFloat(t3.config.yaxis[0].title.style.fontSize) : 0) - 15);
    }
  } }]), t2;
}(), Ki = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.xaxisLabels = a2.globals.labels.slice(), this.axesUtils = new Ri(e2), this.isRangeBar = a2.globals.seriesRange.length && a2.globals.isBarHorizontal, a2.globals.timescaleLabels.length > 0 && (this.xaxisLabels = a2.globals.timescaleLabels.slice());
  }
  return s(t2, [{ key: "drawGridArea", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, e2 = this.w, i = new Mi(this.ctx);
    t3 || (t3 = i.group({ class: "apexcharts-grid" }));
    var a2 = i.drawLine(e2.globals.padHorizontal, 1, e2.globals.padHorizontal, e2.globals.gridHeight, "transparent"), s2 = i.drawLine(e2.globals.padHorizontal, e2.globals.gridHeight, e2.globals.gridWidth, e2.globals.gridHeight, "transparent");
    return t3.add(s2), t3.add(a2), t3;
  } }, { key: "drawGrid", value: function() {
    if (this.w.globals.axisCharts) {
      var t3 = this.renderGrid();
      return this.drawGridArea(t3.el), t3;
    }
    return null;
  } }, { key: "createGridMask", value: function() {
    var t3 = this.w, e2 = t3.globals, i = new Mi(this.ctx), a2 = Array.isArray(t3.config.stroke.width) ? Math.max.apply(Math, f(t3.config.stroke.width)) : t3.config.stroke.width, s2 = function(t4) {
      var i2 = document.createElementNS(e2.SVGNS, "clipPath");
      return i2.setAttribute("id", t4), i2;
    };
    e2.dom.elGridRectMask = s2("gridRectMask".concat(e2.cuid)), e2.dom.elGridRectBarMask = s2("gridRectBarMask".concat(e2.cuid)), e2.dom.elGridRectMarkerMask = s2("gridRectMarkerMask".concat(e2.cuid)), e2.dom.elForecastMask = s2("forecastMask".concat(e2.cuid)), e2.dom.elNonForecastMask = s2("nonForecastMask".concat(e2.cuid));
    var r2 = 0, n2 = 0;
    (["bar", "rangeBar", "candlestick", "boxPlot"].includes(t3.config.chart.type) || t3.globals.comboBarCount > 0) && t3.globals.isXNumeric && !t3.globals.isBarHorizontal && (r2 = Math.max(t3.config.grid.padding.left, e2.barPadForNumericAxis), n2 = Math.max(t3.config.grid.padding.right, e2.barPadForNumericAxis)), e2.dom.elGridRect = i.drawRect(-a2 / 2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + 4, e2.gridHeight + a2 + 4, 0, "#fff"), e2.dom.elGridRectBar = i.drawRect(-a2 / 2 - r2 - 2, -a2 / 2 - 2, e2.gridWidth + a2 + n2 + r2 + 4, e2.gridHeight + a2 + 4, 0, "#fff");
    var o2 = t3.globals.markers.largestSize;
    e2.dom.elGridRectMarker = i.drawRect(-o2, -o2, e2.gridWidth + 2 * o2, e2.gridHeight + 2 * o2, 0, "#fff"), e2.dom.elGridRectMask.appendChild(e2.dom.elGridRect.node), e2.dom.elGridRectBarMask.appendChild(e2.dom.elGridRectBar.node), e2.dom.elGridRectMarkerMask.appendChild(e2.dom.elGridRectMarker.node);
    var l2 = e2.dom.baseEl.querySelector("defs");
    l2.appendChild(e2.dom.elGridRectMask), l2.appendChild(e2.dom.elGridRectBarMask), l2.appendChild(e2.dom.elGridRectMarkerMask), l2.appendChild(e2.dom.elForecastMask), l2.appendChild(e2.dom.elNonForecastMask);
  } }, { key: "_drawGridLines", value: function(t3) {
    var e2 = t3.i, i = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w;
    if (!(0 === e2 && l2.globals.skipFirstTimelinelabel || e2 === n2 - 1 && l2.globals.skipLastTimelinelabel && !l2.config.xaxis.labels.formatter || "radar" === l2.config.chart.type)) {
      l2.config.grid.xaxis.lines.show && this._drawGridLine({ i: e2, x1: i, y1: a2, x2: s2, y2: r2, xCount: n2, parent: o2 });
      var h2 = 0;
      if (l2.globals.hasXaxisGroups && "between" === l2.config.xaxis.tickPlacement) {
        var c2 = l2.globals.groups;
        if (c2) {
          for (var d2 = 0, u2 = 0; d2 < e2 && u2 < c2.length; u2++)
            d2 += c2[u2].cols;
          d2 === e2 && (h2 = 0.6 * l2.globals.xAxisLabelsHeight);
        }
      }
      new Qi(this.ctx).drawXaxisTicks(i, h2, l2.globals.dom.elGraphical);
    }
  } }, { key: "_drawGridLine", value: function(t3) {
    var e2 = t3.i, i = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.xCount, o2 = t3.parent, l2 = this.w, h2 = o2.node.classList.contains("apexcharts-gridlines-horizontal"), c2 = l2.globals.barPadForNumericAxis, d2 = 0 === a2 && 0 === r2 || 0 === i && 0 === s2 || a2 === l2.globals.gridHeight && r2 === l2.globals.gridHeight || l2.globals.isBarHorizontal && (0 === e2 || e2 === n2 - 1), u2 = new Mi(this).drawLine(i - (h2 ? c2 : 0), a2, s2 + (h2 ? c2 : 0), r2, l2.config.grid.borderColor, l2.config.grid.strokeDashArray);
    u2.node.classList.add("apexcharts-gridline"), d2 && l2.config.grid.show ? this.elGridBorders.add(u2) : o2.add(u2);
  } }, { key: "_drawGridBandRect", value: function(t3) {
    var e2 = t3.c, i = t3.x1, a2 = t3.y1, s2 = t3.x2, r2 = t3.y2, n2 = t3.type, o2 = this.w, l2 = new Mi(this.ctx), h2 = o2.globals.barPadForNumericAxis, c2 = o2.config.grid[n2].colors[e2], d2 = l2.drawRect(i - ("row" === n2 ? h2 : 0), a2, s2 + ("row" === n2 ? 2 * h2 : 0), r2, 0, c2, o2.config.grid[n2].opacity);
    this.elg.add(d2), d2.attr("clip-path", "url(#gridRectMask".concat(o2.globals.cuid, ")")), d2.node.classList.add("apexcharts-grid-".concat(n2));
  } }, { key: "_drawXYLines", value: function(t3) {
    var e2 = this, i = t3.xCount, a2 = t3.tickAmount, s2 = this.w;
    if (s2.config.grid.xaxis.lines.show || s2.config.xaxis.axisTicks.show) {
      var r2, n2 = s2.globals.padHorizontal, o2 = s2.globals.gridHeight;
      s2.globals.timescaleLabels.length ? function(t4) {
        for (var a3 = t4.xC, s3 = t4.x1, r3 = t4.y1, n3 = t4.x2, o3 = t4.y2, l3 = 0; l3 < a3; l3++)
          s3 = e2.xaxisLabels[l3].position, n3 = e2.xaxisLabels[l3].position, e2._drawGridLines({ i: l3, x1: s3, y1: r3, x2: n3, y2: o3, xCount: i, parent: e2.elgridLinesV });
      }({ xC: i, x1: n2, y1: 0, x2: r2, y2: o2 }) : (s2.globals.isXNumeric && (i = s2.globals.xAxisScale.result.length), function(t4) {
        for (var a3 = t4.xC, r3 = t4.x1, n3 = t4.y1, o3 = t4.x2, l3 = t4.y2, h3 = 0; h3 < a3 + (s2.globals.isXNumeric ? 0 : 1); h3++)
          0 === h3 && 1 === a3 && 1 === s2.globals.dataPoints && (o3 = r3 = s2.globals.gridWidth / 2), e2._drawGridLines({ i: h3, x1: r3, y1: n3, x2: o3, y2: l3, xCount: i, parent: e2.elgridLinesV }), o3 = r3 += s2.globals.gridWidth / (s2.globals.isXNumeric ? a3 - 1 : a3);
      }({ xC: i, x1: n2, y1: 0, x2: r2, y2: o2 }));
    }
    if (s2.config.grid.yaxis.lines.show) {
      var l2 = 0, h2 = 0, c2 = s2.globals.gridWidth, d2 = a2 + 1;
      this.isRangeBar && (d2 = s2.globals.labels.length);
      for (var u2 = 0; u2 < d2 + (this.isRangeBar ? 1 : 0); u2++)
        this._drawGridLine({ i: u2, xCount: d2 + (this.isRangeBar ? 1 : 0), x1: 0, y1: l2, x2: c2, y2: h2, parent: this.elgridLinesH }), h2 = l2 += s2.globals.gridHeight / (this.isRangeBar ? d2 : a2);
    }
  } }, { key: "_drawInvertedXYLines", value: function(t3) {
    var e2 = t3.xCount, i = this.w;
    if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
      for (var a2, s2 = i.globals.padHorizontal, r2 = i.globals.gridHeight, n2 = 0; n2 < e2 + 1; n2++) {
        i.config.grid.xaxis.lines.show && this._drawGridLine({ i: n2, xCount: e2 + 1, x1: s2, y1: 0, x2: a2, y2: r2, parent: this.elgridLinesV }), new Qi(this.ctx).drawXaxisTicks(s2, 0, i.globals.dom.elGraphical), a2 = s2 += i.globals.gridWidth / e2;
      }
    if (i.config.grid.yaxis.lines.show)
      for (var o2 = 0, l2 = 0, h2 = i.globals.gridWidth, c2 = 0; c2 < i.globals.dataPoints + 1; c2++)
        this._drawGridLine({ i: c2, xCount: i.globals.dataPoints + 1, x1: 0, y1: o2, x2: h2, y2: l2, parent: this.elgridLinesH }), l2 = o2 += i.globals.gridHeight / i.globals.dataPoints;
  } }, { key: "renderGrid", value: function() {
    var t3 = this.w, e2 = t3.globals, i = new Mi(this.ctx);
    this.elg = i.group({ class: "apexcharts-grid" }), this.elgridLinesH = i.group({ class: "apexcharts-gridlines-horizontal" }), this.elgridLinesV = i.group({ class: "apexcharts-gridlines-vertical" }), this.elGridBorders = i.group({ class: "apexcharts-grid-borders" }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t3.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide(), this.elGridBorders.hide());
    for (var a2 = 0; a2 < e2.seriesYAxisMap.length && e2.ignoreYAxisIndexes.includes(a2); )
      a2++;
    a2 === e2.seriesYAxisMap.length && (a2 = 0);
    var s2, r2 = e2.yAxisScale[a2].result.length - 1;
    if (!e2.isBarHorizontal || this.isRangeBar) {
      var n2, o2, l2;
      if (s2 = this.xaxisLabels.length, this.isRangeBar)
        r2 = e2.labels.length, t3.config.xaxis.tickAmount && t3.config.xaxis.labels.formatter && (s2 = t3.config.xaxis.tickAmount), (null === (n2 = e2.yAxisScale) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.result) || void 0 === l2 ? void 0 : l2.length) > 0 && "datetime" !== t3.config.xaxis.type && (s2 = e2.yAxisScale[a2].result.length - 1);
      this._drawXYLines({ xCount: s2, tickAmount: r2 });
    } else
      s2 = r2, r2 = e2.xTickAmount, this._drawInvertedXYLines({ xCount: s2, tickAmount: r2 });
    return this.drawGridBands(s2, r2), { el: this.elg, elGridBorders: this.elGridBorders, xAxisTickWidth: e2.gridWidth / s2 };
  } }, { key: "drawGridBands", value: function(t3, e2) {
    var i, a2, s2 = this, r2 = this.w;
    if ((null === (i = r2.config.grid.row.colors) || void 0 === i ? void 0 : i.length) > 0 && function(t4, i2, a3, n3, o3, l3) {
      for (var h3 = 0, c3 = 0; h3 < i2; h3++, c3++)
        c3 >= r2.config.grid[t4].colors.length && (c3 = 0), s2._drawGridBandRect({ c: c3, x1: a3, y1: n3, x2: o3, y2: l3, type: t4 }), n3 += r2.globals.gridHeight / e2;
    }("row", e2, 0, 0, r2.globals.gridWidth, r2.globals.gridHeight / e2), (null === (a2 = r2.config.grid.column.colors) || void 0 === a2 ? void 0 : a2.length) > 0) {
      var n2 = r2.globals.isBarHorizontal || "on" !== r2.config.xaxis.tickPlacement || "category" !== r2.config.xaxis.type && !r2.config.xaxis.convertedCatToNumeric ? t3 : t3 - 1;
      r2.globals.isXNumeric && (n2 = r2.globals.xAxisScale.result.length - 1);
      for (var o2 = r2.globals.padHorizontal, l2 = r2.globals.padHorizontal + r2.globals.gridWidth / n2, h2 = r2.globals.gridHeight, c2 = 0, d2 = 0; c2 < t3; c2++, d2++) {
        var u2;
        if (d2 >= r2.config.grid.column.colors.length && (d2 = 0), "datetime" === r2.config.xaxis.type)
          o2 = this.xaxisLabels[c2].position, l2 = ((null === (u2 = this.xaxisLabels[c2 + 1]) || void 0 === u2 ? void 0 : u2.position) || r2.globals.gridWidth) - this.xaxisLabels[c2].position;
        this._drawGridBandRect({ c: d2, x1: o2, y1: 0, x2: l2, y2: h2, type: "column" }), o2 += r2.globals.gridWidth / n2;
      }
    }
  } }]), t2;
}(), ta = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.coreUtils = new Pi(this.ctx);
  }
  return s(t2, [{ key: "niceScale", value: function(t3, e2) {
    var i, a2, s2, r2, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, o2 = 1e-11, l2 = this.w, h2 = l2.globals;
    h2.isBarHorizontal ? (i = l2.config.xaxis, a2 = Math.max((h2.svgWidth - 100) / 25, 2)) : (i = l2.config.yaxis[n2], a2 = Math.max((h2.svgHeight - 100) / 15, 2)), v.isNumber(a2) || (a2 = 10), s2 = void 0 !== i.min && null !== i.min, r2 = void 0 !== i.max && null !== i.min;
    var c2 = void 0 !== i.stepSize && null !== i.stepSize, d2 = void 0 !== i.tickAmount && null !== i.tickAmount, u2 = d2 ? i.tickAmount : h2.niceScaleDefaultTicks[Math.min(Math.round(a2 / 2), h2.niceScaleDefaultTicks.length - 1)];
    if (h2.isMultipleYAxis && !d2 && h2.multiAxisTickAmount > 0 && (u2 = h2.multiAxisTickAmount, d2 = true), u2 = "dataPoints" === u2 ? h2.dataPoints - 1 : Math.abs(Math.round(u2)), (t3 === Number.MIN_VALUE && 0 === e2 || !v.isNumber(t3) && !v.isNumber(e2) || t3 === Number.MIN_VALUE && e2 === -Number.MAX_VALUE) && (t3 = v.isNumber(i.min) ? i.min : 0, e2 = v.isNumber(i.max) ? i.max : t3 + u2, h2.allSeriesCollapsed = false), t3 > e2) {
      console.warn("axis.min cannot be greater than axis.max: swapping min and max");
      var g2 = e2;
      e2 = t3, t3 = g2;
    } else
      t3 === e2 && (t3 = 0 === t3 ? 0 : t3 - 1, e2 = 0 === e2 ? 2 : e2 + 1);
    var p2 = [];
    u2 < 1 && (u2 = 1);
    var f2 = u2, x2 = Math.abs(e2 - t3);
    !s2 && t3 > 0 && t3 / x2 < 0.15 && (t3 = 0, s2 = true), !r2 && e2 < 0 && -e2 / x2 < 0.15 && (e2 = 0, r2 = true);
    var b2 = (x2 = Math.abs(e2 - t3)) / f2, m2 = b2, y2 = Math.floor(Math.log10(m2)), w2 = Math.pow(10, y2), k2 = Math.ceil(m2 / w2);
    if (b2 = m2 = (k2 = h2.niceScaleAllowedMagMsd[0 === h2.yValueDecimal ? 0 : 1][k2]) * w2, h2.isBarHorizontal && i.stepSize && "datetime" !== i.type ? (b2 = i.stepSize, c2 = true) : c2 && (b2 = i.stepSize), c2 && i.forceNiceScale) {
      var A2 = Math.floor(Math.log10(b2));
      b2 *= Math.pow(10, y2 - A2);
    }
    if (s2 && r2) {
      var C2 = x2 / f2;
      if (d2)
        if (c2)
          if (0 != v.mod(x2, b2)) {
            var S2 = v.getGCD(b2, C2);
            b2 = C2 / S2 < 10 ? S2 : C2;
          } else
            0 == v.mod(b2, C2) ? b2 = C2 : (C2 = b2, d2 = false);
        else
          b2 = C2;
      else if (c2)
        0 == v.mod(x2, b2) ? C2 = b2 : b2 = C2;
      else if (0 == v.mod(x2, b2))
        C2 = b2;
      else {
        C2 = x2 / (f2 = Math.ceil(x2 / b2));
        var L2 = v.getGCD(x2, b2);
        x2 / L2 < a2 && (C2 = L2), b2 = C2;
      }
      f2 = Math.round(x2 / b2);
    } else {
      if (s2 || r2) {
        if (r2)
          if (d2)
            t3 = e2 - b2 * f2;
          else {
            var M2 = t3;
            t3 = b2 * Math.floor(t3 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (t3 = e2 - b2 * u2, t3 += b2 * Math.floor((M2 - t3) / b2));
          }
        else if (s2)
          if (d2)
            e2 = t3 + b2 * f2;
          else {
            var P2 = e2;
            e2 = b2 * Math.ceil(e2 / b2), Math.abs(e2 - t3) / v.getGCD(x2, b2) > a2 && (e2 = t3 + b2 * u2, e2 += b2 * Math.ceil((P2 - e2) / b2));
          }
      } else if (h2.isMultipleYAxis && d2) {
        var I2 = b2 * Math.floor(t3 / b2), T2 = I2 + b2 * f2;
        T2 < e2 && (b2 *= 2), T2 = e2, e2 = (t3 = I2) + b2 * f2, x2 = Math.abs(e2 - t3), t3 > 0 && t3 < Math.abs(T2 - e2) && (t3 = 0, e2 = b2 * f2), e2 < 0 && -e2 < Math.abs(I2 - t3) && (e2 = 0, t3 = -b2 * f2);
      } else
        t3 = b2 * Math.floor(t3 / b2), e2 = b2 * Math.ceil(e2 / b2);
      x2 = Math.abs(e2 - t3), b2 = v.getGCD(x2, b2), f2 = Math.round(x2 / b2);
    }
    if (d2 || s2 || r2 || (f2 = Math.ceil((x2 - o2) / (b2 + o2))) > 16 && v.getPrimeFactors(f2).length < 2 && f2++, !d2 && i.forceNiceScale && 0 === h2.yValueDecimal && f2 > x2 && (f2 = x2, b2 = Math.round(x2 / f2)), f2 > a2 && (!d2 && !c2 || i.forceNiceScale)) {
      var z2 = v.getPrimeFactors(f2), X2 = z2.length - 1, R2 = f2;
      t:
        for (var E2 = 0; E2 < X2; E2++)
          for (var Y2 = 0; Y2 <= X2 - E2; Y2++) {
            for (var H2 = Math.min(Y2 + E2, X2), O2 = R2, F2 = 1, D2 = Y2; D2 <= H2; D2++)
              F2 *= z2[D2];
            if ((O2 /= F2) < a2) {
              R2 = O2;
              break t;
            }
          }
      b2 = R2 === f2 ? x2 : x2 / R2, f2 = Math.round(x2 / b2);
    }
    h2.isMultipleYAxis && 0 == h2.multiAxisTickAmount && h2.ignoreYAxisIndexes.indexOf(n2) < 0 && (h2.multiAxisTickAmount = f2);
    var _2 = t3 - b2, N2 = b2 * o2;
    do {
      _2 += b2, p2.push(v.stripNumber(_2, 7));
    } while (e2 - _2 > N2);
    return { result: p2, niceMin: p2[0], niceMax: p2[p2.length - 1] };
  } }, { key: "linearScale", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0, s2 = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0, r2 = Math.abs(e2 - t3), n2 = [];
    if (t3 === e2)
      return { result: n2 = [t3], niceMin: n2[0], niceMax: n2[n2.length - 1] };
    "dataPoints" === (i = this._adjustTicksForSmallRange(i, a2, r2)) && (i = this.w.globals.dataPoints - 1), s2 || (s2 = r2 / i), s2 = Math.round(100 * (s2 + Number.EPSILON)) / 100, i === Number.MAX_VALUE && (i = 5, s2 = 1);
    for (var o2 = t3; i >= 0; )
      n2.push(o2), o2 = v.preciseAddition(o2, s2), i -= 1;
    return { result: n2, niceMin: n2[0], niceMax: n2[n2.length - 1] };
  } }, { key: "logarithmicScaleNice", value: function(t3, e2, i) {
    e2 <= 0 && (e2 = Math.max(t3, i)), t3 <= 0 && (t3 = Math.min(e2, i));
    for (var a2 = [], s2 = Math.ceil(Math.log(e2) / Math.log(i) + 1), r2 = Math.floor(Math.log(t3) / Math.log(i)); r2 < s2; r2++)
      a2.push(Math.pow(i, r2));
    return { result: a2, niceMin: a2[0], niceMax: a2[a2.length - 1] };
  } }, { key: "logarithmicScale", value: function(t3, e2, i) {
    e2 <= 0 && (e2 = Math.max(t3, i)), t3 <= 0 && (t3 = Math.min(e2, i));
    for (var a2 = [], s2 = Math.log(e2) / Math.log(i), r2 = Math.log(t3) / Math.log(i), n2 = s2 - r2, o2 = Math.round(n2), l2 = n2 / o2, h2 = 0, c2 = r2; h2 < o2; h2++, c2 += l2)
      a2.push(Math.pow(i, c2));
    return a2.push(Math.pow(i, s2)), { result: a2, niceMin: t3, niceMax: e2 };
  } }, { key: "_adjustTicksForSmallRange", value: function(t3, e2, i) {
    var a2 = t3;
    if (void 0 !== e2 && this.w.config.yaxis[e2].labels.formatter && void 0 === this.w.config.yaxis[e2].tickAmount) {
      var s2 = Number(this.w.config.yaxis[e2].labels.formatter(1));
      v.isNumber(s2) && 0 === this.w.globals.yValueDecimal && (a2 = Math.ceil(i));
    }
    return a2 < t3 ? a2 : t3;
  } }, { key: "setYScaleForIndex", value: function(t3, e2, i) {
    var a2 = this.w.globals, s2 = this.w.config, r2 = a2.isBarHorizontal ? s2.xaxis : s2.yaxis[t3];
    void 0 === a2.yAxisScale[t3] && (a2.yAxisScale[t3] = []);
    var n2 = Math.abs(i - e2);
    r2.logarithmic && n2 <= 5 && (a2.invalidLogScale = true), r2.logarithmic && n2 > 5 ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = r2.forceNiceScale ? this.logarithmicScaleNice(e2, i, r2.logBase) : this.logarithmicScale(e2, i, r2.logBase)) : i !== -Number.MAX_VALUE && v.isNumber(i) && e2 !== Number.MAX_VALUE && v.isNumber(e2) ? (a2.allSeriesCollapsed = false, a2.yAxisScale[t3] = this.niceScale(e2, i, t3)) : a2.yAxisScale[t3] = this.niceScale(Number.MIN_VALUE, 0, t3);
  } }, { key: "setXScale", value: function(t3, e2) {
    var i = this.w, a2 = i.globals;
    if (e2 !== -Number.MAX_VALUE && v.isNumber(e2)) {
      var s2 = a2.xTickAmount;
      a2.xAxisScale = this.linearScale(t3, e2, s2, 0, i.config.xaxis.stepSize);
    } else
      a2.xAxisScale = this.linearScale(0, 10, 10);
    return a2.xAxisScale;
  } }, { key: "scaleMultipleYAxes", value: function() {
    var t3 = this, e2 = this.w.config, i = this.w.globals;
    this.coreUtils.setSeriesYAxisMappings();
    var a2 = i.seriesYAxisMap, s2 = i.minYArr, r2 = i.maxYArr;
    i.allSeriesCollapsed = true, i.barGroups = [], a2.forEach(function(a3, n2) {
      var o2 = [];
      a3.forEach(function(t4) {
        var i2, a4 = null === (i2 = e2.series[t4]) || void 0 === i2 ? void 0 : i2.group;
        o2.indexOf(a4) < 0 && o2.push(a4);
      }), a3.length > 0 ? function() {
        var l2, h2, c2 = Number.MAX_VALUE, d2 = -Number.MAX_VALUE, u2 = c2, g2 = d2;
        if (e2.chart.stacked)
          !function() {
            var t4 = new Array(i.dataPoints).fill(0), s3 = [], r3 = [], p3 = [];
            o2.forEach(function() {
              s3.push(t4.map(function() {
                return Number.MIN_VALUE;
              })), r3.push(t4.map(function() {
                return Number.MIN_VALUE;
              })), p3.push(t4.map(function() {
                return Number.MIN_VALUE;
              }));
            });
            for (var f3 = function(t5) {
              !l2 && e2.series[a3[t5]].type && (l2 = e2.series[a3[t5]].type);
              var c3 = a3[t5];
              h2 = e2.series[c3].group ? e2.series[c3].group : "axis-".concat(n2), !(i.collapsedSeriesIndices.indexOf(c3) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(c3) < 0) || (i.allSeriesCollapsed = false, o2.forEach(function(t6, a4) {
                if (e2.series[c3].group === t6)
                  for (var n3 = 0; n3 < i.series[c3].length; n3++) {
                    var o3 = i.series[c3][n3];
                    o3 >= 0 ? r3[a4][n3] += o3 : p3[a4][n3] += o3, s3[a4][n3] += o3, u2 = Math.min(u2, o3), g2 = Math.max(g2, o3);
                  }
              })), "bar" !== l2 && "column" !== l2 || i.barGroups.push(h2);
            }, x2 = 0; x2 < a3.length; x2++)
              f3(x2);
            l2 || (l2 = e2.chart.type), "bar" === l2 || "column" === l2 ? o2.forEach(function(t5, e3) {
              c2 = Math.min(c2, Math.min.apply(null, p3[e3])), d2 = Math.max(d2, Math.max.apply(null, r3[e3]));
            }) : (o2.forEach(function(t5, e3) {
              u2 = Math.min(u2, Math.min.apply(null, s3[e3])), g2 = Math.max(g2, Math.max.apply(null, s3[e3]));
            }), c2 = u2, d2 = g2), c2 === Number.MIN_VALUE && d2 === Number.MIN_VALUE && (d2 = -Number.MAX_VALUE);
          }();
        else
          for (var p2 = 0; p2 < a3.length; p2++) {
            var f2 = a3[p2];
            c2 = Math.min(c2, s2[f2]), d2 = Math.max(d2, r2[f2]), !(i.collapsedSeriesIndices.indexOf(f2) < 0 && i.ancillaryCollapsedSeriesIndices.indexOf(f2) < 0) || (i.allSeriesCollapsed = false);
          }
        void 0 !== e2.yaxis[n2].min && (c2 = "function" == typeof e2.yaxis[n2].min ? e2.yaxis[n2].min(c2) : e2.yaxis[n2].min), void 0 !== e2.yaxis[n2].max && (d2 = "function" == typeof e2.yaxis[n2].max ? e2.yaxis[n2].max(d2) : e2.yaxis[n2].max), i.barGroups = i.barGroups.filter(function(t4, e3, i2) {
          return i2.indexOf(t4) === e3;
        }), t3.setYScaleForIndex(n2, c2, d2), a3.forEach(function(t4) {
          s2[t4] = i.yAxisScale[n2].niceMin, r2[t4] = i.yAxisScale[n2].niceMax;
        });
      }() : t3.setYScaleForIndex(n2, 0, -Number.MAX_VALUE);
    });
  } }]), t2;
}(), ea = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.scales = new ta(e2);
  }
  return s(t2, [{ key: "init", value: function() {
    this.setYRange(), this.setXRange(), this.setZRange();
  } }, { key: "getMinYMaxY", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE, i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w.config, r2 = this.w.globals, n2 = -Number.MAX_VALUE, o2 = Number.MIN_VALUE;
    null === a2 && (a2 = t3 + 1);
    var l2 = r2.series, h2 = l2, c2 = l2;
    "candlestick" === s2.chart.type ? (h2 = r2.seriesCandleL, c2 = r2.seriesCandleH) : "boxPlot" === s2.chart.type ? (h2 = r2.seriesCandleO, c2 = r2.seriesCandleC) : r2.isRangeData && (h2 = r2.seriesRangeStart, c2 = r2.seriesRangeEnd);
    var d2 = false;
    if (r2.seriesX.length >= a2) {
      var u2, g2 = null === (u2 = r2.brushSource) || void 0 === u2 ? void 0 : u2.w.config.chart.brush;
      (s2.chart.zoom.enabled && s2.chart.zoom.autoScaleYaxis || null != g2 && g2.enabled && null != g2 && g2.autoScaleYaxis) && (d2 = true);
    }
    for (var p2 = t3; p2 < a2; p2++) {
      r2.dataPoints = Math.max(r2.dataPoints, l2[p2].length);
      var f2 = s2.series[p2].type;
      r2.categoryLabels.length && (r2.dataPoints = r2.categoryLabels.filter(function(t4) {
        return void 0 !== t4;
      }).length), r2.labels.length && "datetime" !== s2.xaxis.type && 0 !== r2.series.reduce(function(t4, e3) {
        return t4 + e3.length;
      }, 0) && (r2.dataPoints = Math.max(r2.dataPoints, r2.labels.length));
      var x2 = 0, b2 = l2[p2].length - 1;
      if (d2) {
        if (s2.xaxis.min)
          for (; x2 < b2 && r2.seriesX[p2][x2] < s2.xaxis.min; x2++)
            ;
        if (s2.xaxis.max)
          for (; b2 > x2 && r2.seriesX[p2][b2] > s2.xaxis.max; b2--)
            ;
      }
      for (var m2 = x2; m2 <= b2 && m2 < r2.series[p2].length; m2++) {
        var y2 = l2[p2][m2];
        if (null !== y2 && v.isNumber(y2)) {
          switch (void 0 !== c2[p2][m2] && (n2 = Math.max(n2, c2[p2][m2]), e2 = Math.min(e2, c2[p2][m2])), void 0 !== h2[p2][m2] && (e2 = Math.min(e2, h2[p2][m2]), i = Math.max(i, h2[p2][m2])), f2) {
            case "candlestick":
              void 0 !== r2.seriesCandleC[p2][m2] && (n2 = Math.max(n2, r2.seriesCandleH[p2][m2]), e2 = Math.min(e2, r2.seriesCandleL[p2][m2]));
              break;
            case "boxPlot":
              void 0 !== r2.seriesCandleC[p2][m2] && (n2 = Math.max(n2, r2.seriesCandleC[p2][m2]), e2 = Math.min(e2, r2.seriesCandleO[p2][m2]));
          }
          f2 && "candlestick" !== f2 && "boxPlot" !== f2 && "rangeArea" !== f2 && "rangeBar" !== f2 && (n2 = Math.max(n2, r2.series[p2][m2]), e2 = Math.min(e2, r2.series[p2][m2])), r2.seriesGoals[p2] && r2.seriesGoals[p2][m2] && Array.isArray(r2.seriesGoals[p2][m2]) && r2.seriesGoals[p2][m2].forEach(function(t4) {
            n2 = Math.max(n2, t4.value), e2 = Math.min(e2, t4.value);
          }), i = n2, y2 = v.noExponents(y2), v.isFloat(y2) && (r2.yValueDecimal = Math.max(r2.yValueDecimal, y2.toString().split(".")[1].length)), o2 > h2[p2][m2] && h2[p2][m2] < 0 && (o2 = h2[p2][m2]);
        } else
          r2.hasNullValues = true;
      }
      "bar" !== f2 && "column" !== f2 || (o2 < 0 && n2 < 0 && (n2 = 0, i = Math.max(i, 0)), o2 === Number.MIN_VALUE && (o2 = 0, e2 = Math.min(e2, 0)));
    }
    return "rangeBar" === s2.chart.type && r2.seriesRangeStart.length && r2.isBarHorizontal && (o2 = e2), "bar" === s2.chart.type && (o2 < 0 && n2 < 0 && (n2 = 0), o2 === Number.MIN_VALUE && (o2 = 0)), { minY: o2, maxY: n2, lowestY: e2, highestY: i };
  } }, { key: "setYRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    t3.maxY = -Number.MAX_VALUE, t3.minY = Number.MIN_VALUE;
    var i, a2 = Number.MAX_VALUE;
    if (t3.isMultipleYAxis) {
      a2 = Number.MAX_VALUE;
      for (var s2 = 0; s2 < t3.series.length; s2++)
        i = this.getMinYMaxY(s2), t3.minYArr[s2] = i.lowestY, t3.maxYArr[s2] = i.highestY, a2 = Math.min(a2, i.lowestY);
    }
    if (i = this.getMinYMaxY(0, a2, null, t3.series.length), "bar" === e2.chart.type ? (t3.minY = i.minY, t3.maxY = i.maxY) : (t3.minY = i.lowestY, t3.maxY = i.highestY), a2 = i.lowestY, e2.chart.stacked && this._setStackedMinMax(), "line" === e2.chart.type || "area" === e2.chart.type || "scatter" === e2.chart.type || "candlestick" === e2.chart.type || "boxPlot" === e2.chart.type || "rangeBar" === e2.chart.type && !t3.isBarHorizontal ? t3.minY === Number.MIN_VALUE && a2 !== -Number.MAX_VALUE && a2 !== t3.maxY && (t3.minY = a2) : t3.minY = t3.minY !== Number.MIN_VALUE ? Math.min(i.minY, t3.minY) : i.minY, e2.yaxis.forEach(function(e3, i2) {
      void 0 !== e3.max && ("number" == typeof e3.max ? t3.maxYArr[i2] = e3.max : "function" == typeof e3.max && (t3.maxYArr[i2] = e3.max(t3.isMultipleYAxis ? t3.maxYArr[i2] : t3.maxY)), t3.maxY = t3.maxYArr[i2]), void 0 !== e3.min && ("number" == typeof e3.min ? t3.minYArr[i2] = e3.min : "function" == typeof e3.min && (t3.minYArr[i2] = e3.min(t3.isMultipleYAxis ? t3.minYArr[i2] === Number.MIN_VALUE ? 0 : t3.minYArr[i2] : t3.minY)), t3.minY = t3.minYArr[i2]);
    }), t3.isBarHorizontal) {
      ["min", "max"].forEach(function(i2) {
        void 0 !== e2.xaxis[i2] && "number" == typeof e2.xaxis[i2] && ("min" === i2 ? t3.minY = e2.xaxis[i2] : t3.maxY = e2.xaxis[i2]);
      });
    }
    return t3.isMultipleYAxis ? (this.scales.scaleMultipleYAxes(), t3.minY = a2) : (this.scales.setYScaleForIndex(0, t3.minY, t3.maxY), t3.minY = t3.yAxisScale[0].niceMin, t3.maxY = t3.yAxisScale[0].niceMax, t3.minYArr[0] = t3.minY, t3.maxYArr[0] = t3.maxY), t3.barGroups = [], t3.lineGroups = [], t3.areaGroups = [], e2.series.forEach(function(i2) {
      switch (i2.type || e2.chart.type) {
        case "bar":
        case "column":
          t3.barGroups.push(i2.group);
          break;
        case "line":
          t3.lineGroups.push(i2.group);
          break;
        case "area":
          t3.areaGroups.push(i2.group);
      }
    }), t3.barGroups = t3.barGroups.filter(function(t4, e3, i2) {
      return i2.indexOf(t4) === e3;
    }), t3.lineGroups = t3.lineGroups.filter(function(t4, e3, i2) {
      return i2.indexOf(t4) === e3;
    }), t3.areaGroups = t3.areaGroups.filter(function(t4, e3, i2) {
      return i2.indexOf(t4) === e3;
    }), { minY: t3.minY, maxY: t3.maxY, minYArr: t3.minYArr, maxYArr: t3.maxYArr, yAxisScale: t3.yAxisScale };
  } }, { key: "setXRange", value: function() {
    var t3 = this.w.globals, e2 = this.w.config, i = "numeric" === e2.xaxis.type || "datetime" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided || t3.noLabelsProvided || t3.isXNumeric;
    if (t3.isXNumeric && function() {
      for (var e3 = 0; e3 < t3.series.length; e3++)
        if (t3.labels[e3])
          for (var i2 = 0; i2 < t3.labels[e3].length; i2++)
            null !== t3.labels[e3][i2] && v.isNumber(t3.labels[e3][i2]) && (t3.maxX = Math.max(t3.maxX, t3.labels[e3][i2]), t3.initialMaxX = Math.max(t3.maxX, t3.labels[e3][i2]), t3.minX = Math.min(t3.minX, t3.labels[e3][i2]), t3.initialMinX = Math.min(t3.minX, t3.labels[e3][i2]));
    }(), t3.noLabelsProvided && 0 === e2.xaxis.categories.length && (t3.maxX = t3.labels[t3.labels.length - 1], t3.initialMaxX = t3.labels[t3.labels.length - 1], t3.minX = 1, t3.initialMinX = 1), t3.isXNumeric || t3.noLabelsProvided || t3.dataFormatXNumeric) {
      var a2 = 10;
      if (void 0 === e2.xaxis.tickAmount)
        a2 = Math.round(t3.svgWidth / 150), "numeric" === e2.xaxis.type && t3.dataPoints < 30 && (a2 = t3.dataPoints - 1), a2 > t3.dataPoints && 0 !== t3.dataPoints && (a2 = t3.dataPoints - 1);
      else if ("dataPoints" === e2.xaxis.tickAmount) {
        if (t3.series.length > 1 && (a2 = t3.series[t3.maxValsInArrayIndex].length - 1), t3.isXNumeric) {
          var s2 = Math.round(t3.maxX - t3.minX);
          s2 < 30 && (a2 = s2 - 1);
        }
      } else
        a2 = e2.xaxis.tickAmount;
      if (t3.xTickAmount = a2, void 0 !== e2.xaxis.max && "number" == typeof e2.xaxis.max && (t3.maxX = e2.xaxis.max), void 0 !== e2.xaxis.min && "number" == typeof e2.xaxis.min && (t3.minX = e2.xaxis.min), void 0 !== e2.xaxis.range && (t3.minX = t3.maxX - e2.xaxis.range), t3.minX !== Number.MAX_VALUE && t3.maxX !== -Number.MAX_VALUE)
        if (e2.xaxis.convertedCatToNumeric && !t3.dataFormatXNumeric) {
          for (var r2 = [], n2 = t3.minX - 1; n2 < t3.maxX; n2++)
            r2.push(n2 + 1);
          t3.xAxisScale = { result: r2, niceMin: r2[0], niceMax: r2[r2.length - 1] };
        } else
          t3.xAxisScale = this.scales.setXScale(t3.minX, t3.maxX);
      else
        t3.xAxisScale = this.scales.linearScale(0, a2, a2, 0, e2.xaxis.stepSize), t3.noLabelsProvided && t3.labels.length > 0 && (t3.xAxisScale = this.scales.linearScale(1, t3.labels.length, a2 - 1, 0, e2.xaxis.stepSize), t3.seriesX = t3.labels.slice());
      i && (t3.labels = t3.xAxisScale.result.slice());
    }
    return t3.isBarHorizontal && t3.labels.length && (t3.xTickAmount = t3.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), { minX: t3.minX, maxX: t3.maxX };
  } }, { key: "setZRange", value: function() {
    var t3 = this.w.globals;
    if (t3.isDataXYZ) {
      for (var e2 = 0; e2 < t3.series.length; e2++)
        if (void 0 !== t3.seriesZ[e2])
          for (var i = 0; i < t3.seriesZ[e2].length; i++)
            null !== t3.seriesZ[e2][i] && v.isNumber(t3.seriesZ[e2][i]) && (t3.maxZ = Math.max(t3.maxZ, t3.seriesZ[e2][i]), t3.minZ = Math.min(t3.minZ, t3.seriesZ[e2][i]));
    }
  } }, { key: "_handleSingleDataPoint", value: function() {
    var t3 = this.w.globals, e2 = this.w.config;
    if (t3.minX === t3.maxX) {
      var i = new zi(this.ctx);
      if ("datetime" === e2.xaxis.type) {
        var a2 = i.getDate(t3.minX);
        e2.xaxis.labels.datetimeUTC ? a2.setUTCDate(a2.getUTCDate() - 2) : a2.setDate(a2.getDate() - 2), t3.minX = new Date(a2).getTime();
        var s2 = i.getDate(t3.maxX);
        e2.xaxis.labels.datetimeUTC ? s2.setUTCDate(s2.getUTCDate() + 2) : s2.setDate(s2.getDate() + 2), t3.maxX = new Date(s2).getTime();
      } else
        ("numeric" === e2.xaxis.type || "category" === e2.xaxis.type && !t3.noLabelsProvided) && (t3.minX = t3.minX - 2, t3.initialMinX = t3.minX, t3.maxX = t3.maxX + 2, t3.initialMaxX = t3.maxX);
    }
  } }, { key: "_getMinXDiff", value: function() {
    var t3 = this.w.globals;
    t3.isXNumeric && t3.seriesX.forEach(function(e2, i) {
      if (e2.length) {
        1 === e2.length && e2.push(t3.seriesX[t3.maxValsInArrayIndex][t3.seriesX[t3.maxValsInArrayIndex].length - 1]);
        var a2 = e2.slice();
        a2.sort(function(t4, e3) {
          return t4 - e3;
        }), a2.forEach(function(e3, i2) {
          if (i2 > 0) {
            var s2 = e3 - a2[i2 - 1];
            s2 > 0 && (t3.minXDiff = Math.min(s2, t3.minXDiff));
          }
        }), 1 !== t3.dataPoints && t3.minXDiff !== Number.MAX_VALUE || (t3.minXDiff = 0.5);
      }
    });
  } }, { key: "_setStackedMinMax", value: function() {
    var t3 = this, e2 = this.w.globals;
    if (e2.series.length) {
      var i = e2.seriesGroups;
      i.length || (i = [this.w.globals.seriesNames.map(function(t4) {
        return t4;
      })]);
      var a2 = {}, s2 = {};
      i.forEach(function(i2) {
        a2[i2] = [], s2[i2] = [], t3.w.config.series.map(function(t4, a3) {
          return i2.indexOf(e2.seriesNames[a3]) > -1 ? a3 : null;
        }).filter(function(t4) {
          return null !== t4;
        }).forEach(function(r2) {
          for (var n2 = 0; n2 < e2.series[e2.maxValsInArrayIndex].length; n2++) {
            var o2, l2, h2, c2;
            void 0 === a2[i2][n2] && (a2[i2][n2] = 0, s2[i2][n2] = 0), (t3.w.config.chart.stacked && !e2.comboCharts || t3.w.config.chart.stacked && e2.comboCharts && (!t3.w.config.chart.stackOnlyBar || "bar" === (null === (o2 = t3.w.config.series) || void 0 === o2 || null === (l2 = o2[r2]) || void 0 === l2 ? void 0 : l2.type) || "column" === (null === (h2 = t3.w.config.series) || void 0 === h2 || null === (c2 = h2[r2]) || void 0 === c2 ? void 0 : c2.type))) && null !== e2.series[r2][n2] && v.isNumber(e2.series[r2][n2]) && (e2.series[r2][n2] > 0 ? a2[i2][n2] += parseFloat(e2.series[r2][n2]) + 1e-4 : s2[i2][n2] += parseFloat(e2.series[r2][n2]));
          }
        });
      }), Object.entries(a2).forEach(function(t4) {
        var i2 = p(t4, 1)[0];
        a2[i2].forEach(function(t5, r2) {
          e2.maxY = Math.max(e2.maxY, a2[i2][r2]), e2.minY = Math.min(e2.minY, s2[i2][r2]);
        });
      });
    }
  } }]), t2;
}(), ia = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.elgrid = a2, this.w = e2.w;
    var s2 = this.w;
    this.xaxisFontSize = s2.config.xaxis.labels.style.fontSize, this.axisFontFamily = s2.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = s2.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === s2.config.chart.type && s2.config.plotOptions.bar.horizontal, this.xAxisoffX = "bottom" === s2.config.xaxis.position ? s2.globals.gridHeight : 0, this.drawnLabels = [], this.axesUtils = new Ri(e2);
  }
  return s(t2, [{ key: "drawYaxis", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a2 = e2.config.yaxis[t3].labels.style, s2 = a2.fontSize, r2 = a2.fontFamily, n2 = a2.fontWeight, o2 = i.group({ class: "apexcharts-yaxis", rel: t3, transform: "translate(".concat(e2.globals.translateYAxisX[t3], ", 0)") });
    if (this.axesUtils.isYAxisHidden(t3))
      return o2;
    var l2 = i.group({ class: "apexcharts-yaxis-texts-g" });
    o2.add(l2);
    var h2 = e2.globals.yAxisScale[t3].result.length - 1, c2 = e2.globals.gridHeight / h2, d2 = e2.globals.yLabelFormatters[t3], u2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice());
    if (e2.config.yaxis[t3].labels.show) {
      var g2 = e2.globals.translateY + e2.config.yaxis[t3].labels.offsetY;
      e2.globals.isBarHorizontal ? g2 = 0 : "heatmap" === e2.config.chart.type && (g2 -= c2 / 2), g2 += parseInt(s2, 10) / 3;
      for (var p2 = h2; p2 >= 0; p2--) {
        var f2 = d2(u2[p2], p2, e2), x2 = e2.config.yaxis[t3].labels.padding;
        e2.config.yaxis[t3].opposite && 0 !== e2.config.yaxis.length && (x2 *= -1);
        var b2 = this.getTextAnchor(e2.config.yaxis[t3].labels.align, e2.config.yaxis[t3].opposite), m2 = this.axesUtils.getYAxisForeColor(a2.colors, t3), y2 = Array.isArray(m2) ? m2[p2] : m2, w2 = v.listToArray(e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-label tspan"))).map(function(t4) {
          return t4.textContent;
        }), k2 = i.drawText({ x: x2, y: g2, text: w2.includes(f2) && !e2.config.yaxis[t3].labels.showDuplicates ? "" : f2, textAnchor: b2, fontSize: s2, fontFamily: r2, fontWeight: n2, maxWidth: e2.config.yaxis[t3].labels.maxWidth, foreColor: y2, isPlainText: false, cssClass: "apexcharts-yaxis-label ".concat(a2.cssClass) });
        l2.add(k2), this.addTooltip(k2, f2), 0 !== e2.config.yaxis[t3].labels.rotate && this.rotateLabel(i, k2, firstLabel, e2.config.yaxis[t3].labels.rotate), g2 += c2;
      }
    }
    return this.addYAxisTitle(i, o2, t3), this.addAxisBorder(i, o2, t3, h2, c2), o2;
  } }, { key: "getTextAnchor", value: function(t3, e2) {
    return "left" === t3 ? "start" : "center" === t3 ? "middle" : "right" === t3 ? "end" : e2 ? "start" : "end";
  } }, { key: "addTooltip", value: function(t3, e2) {
    var i = document.createElementNS(this.w.globals.SVGNS, "title");
    i.textContent = Array.isArray(e2) ? e2.join(" ") : e2, t3.node.appendChild(i);
  } }, { key: "rotateLabel", value: function(t3, e2, i, a2) {
    var s2 = t3.rotateAroundCenter(i.node), r2 = t3.rotateAroundCenter(e2.node);
    e2.node.setAttribute("transform", "rotate(".concat(a2, " ").concat(s2.x, " ").concat(r2.y, ")"));
  } }, { key: "addYAxisTitle", value: function(t3, e2, i) {
    var a2 = this.w;
    if (void 0 !== a2.config.yaxis[i].title.text) {
      var s2 = t3.group({ class: "apexcharts-yaxis-title" }), r2 = a2.config.yaxis[i].opposite ? a2.globals.translateYAxisX[i] : 0, n2 = t3.drawText({ x: r2, y: a2.globals.gridHeight / 2 + a2.globals.translateY + a2.config.yaxis[i].title.offsetY, text: a2.config.yaxis[i].title.text, textAnchor: "end", foreColor: a2.config.yaxis[i].title.style.color, fontSize: a2.config.yaxis[i].title.style.fontSize, fontWeight: a2.config.yaxis[i].title.style.fontWeight, fontFamily: a2.config.yaxis[i].title.style.fontFamily, cssClass: "apexcharts-yaxis-title-text ".concat(a2.config.yaxis[i].title.style.cssClass) });
      s2.add(n2), e2.add(s2);
    }
  } }, { key: "addAxisBorder", value: function(t3, e2, i, a2, s2) {
    var r2 = this.w, n2 = r2.config.yaxis[i].axisBorder, o2 = 31 + n2.offsetX;
    if (r2.config.yaxis[i].opposite && (o2 = -31 - n2.offsetX), n2.show) {
      var l2 = t3.drawLine(o2, r2.globals.translateY + n2.offsetY - 2, o2, r2.globals.gridHeight + r2.globals.translateY + n2.offsetY + 2, n2.color, 0, n2.width);
      e2.add(l2);
    }
    r2.config.yaxis[i].axisTicks.show && this.axesUtils.drawYAxisTicks(o2, a2, n2, r2.config.yaxis[i].axisTicks, i, s2, e2);
  } }, { key: "drawYaxisInversed", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a2 = i.group({ class: "apexcharts-xaxis apexcharts-yaxis-inversed" }), s2 = i.group({ class: "apexcharts-xaxis-texts-g", transform: "translate(".concat(e2.globals.translateXAxisX, ", ").concat(e2.globals.translateXAxisY, ")") });
    a2.add(s2);
    var r2 = e2.globals.yAxisScale[t3].result.length - 1, n2 = e2.globals.gridWidth / r2 + 0.1, o2 = n2 + e2.config.xaxis.labels.offsetX, l2 = e2.globals.xLabelFormatter, h2 = this.axesUtils.checkForReversedLabels(t3, e2.globals.yAxisScale[t3].result.slice()), c2 = e2.globals.timescaleLabels;
    if (c2.length > 0 && (this.xaxisLabels = c2.slice(), r2 = (h2 = c2.slice()).length), e2.config.xaxis.labels.show)
      for (var d2 = c2.length ? 0 : r2; c2.length ? d2 < c2.length : d2 >= 0; c2.length ? d2++ : d2--) {
        var u2 = l2(h2[d2], d2, e2), g2 = e2.globals.gridWidth + e2.globals.padHorizontal - (o2 - n2 + e2.config.xaxis.labels.offsetX);
        if (c2.length) {
          var p2 = this.axesUtils.getLabel(h2, c2, g2, d2, this.drawnLabels, this.xaxisFontSize);
          g2 = p2.x, u2 = p2.text, this.drawnLabels.push(p2.text), 0 === d2 && e2.globals.skipFirstTimelinelabel && (u2 = ""), d2 === h2.length - 1 && e2.globals.skipLastTimelinelabel && (u2 = "");
        }
        var f2 = i.drawText({ x: g2, y: this.xAxisoffX + e2.config.xaxis.labels.offsetY + 30 - ("top" === e2.config.xaxis.position ? e2.globals.xAxisHeight + e2.config.xaxis.axisTicks.height - 2 : 0), text: u2, textAnchor: "middle", foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t3] : this.xaxisForeColors, fontSize: this.xaxisFontSize, fontFamily: this.xaxisFontFamily, fontWeight: e2.config.xaxis.labels.style.fontWeight, isPlainText: false, cssClass: "apexcharts-xaxis-label ".concat(e2.config.xaxis.labels.style.cssClass) });
        s2.add(f2), f2.tspan(u2), this.addTooltip(f2, u2), o2 += n2;
      }
    return this.inversedYAxisTitleText(a2), this.inversedYAxisBorder(a2), a2;
  } }, { key: "inversedYAxisBorder", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a2 = e2.config.xaxis.axisBorder;
    if (a2.show) {
      var s2 = 0;
      "bar" === e2.config.chart.type && e2.globals.isXNumeric && (s2 -= 15);
      var r2 = i.drawLine(e2.globals.padHorizontal + s2 + a2.offsetX, this.xAxisoffX, e2.globals.gridWidth, this.xAxisoffX, a2.color, 0, a2.height);
      this.elgrid && this.elgrid.elGridBorders && e2.config.grid.show ? this.elgrid.elGridBorders.add(r2) : t3.add(r2);
    }
  } }, { key: "inversedYAxisTitleText", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx);
    if (void 0 !== e2.config.xaxis.title.text) {
      var a2 = i.group({ class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed" }), s2 = i.drawText({ x: e2.globals.gridWidth / 2 + e2.config.xaxis.title.offsetX, y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e2.config.xaxis.title.style.fontSize) + e2.config.xaxis.title.offsetY + 20, text: e2.config.xaxis.title.text, textAnchor: "middle", fontSize: e2.config.xaxis.title.style.fontSize, fontFamily: e2.config.xaxis.title.style.fontFamily, fontWeight: e2.config.xaxis.title.style.fontWeight, foreColor: e2.config.xaxis.title.style.color, cssClass: "apexcharts-xaxis-title-text ".concat(e2.config.xaxis.title.style.cssClass) });
      a2.add(s2), t3.add(a2);
    }
  } }, { key: "yAxisTitleRotate", value: function(t3, e2) {
    var i = this.w, a2 = new Mi(this.ctx), s2 = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-texts-g")), r2 = s2 ? s2.getBoundingClientRect() : { width: 0, height: 0 }, n2 = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t3, "'] .apexcharts-yaxis-title text")), o2 = n2 ? n2.getBoundingClientRect() : { width: 0, height: 0 };
    if (n2) {
      var l2 = this.xPaddingForYAxisTitle(t3, r2, o2, e2);
      n2.setAttribute("x", l2.xPos - (e2 ? 10 : 0));
      var h2 = a2.rotateAroundCenter(n2);
      n2.setAttribute("transform", "rotate(".concat(e2 ? -1 * i.config.yaxis[t3].title.rotate : i.config.yaxis[t3].title.rotate, " ").concat(h2.x, " ").concat(h2.y, ")"));
    }
  } }, { key: "xPaddingForYAxisTitle", value: function(t3, e2, i, a2) {
    var s2 = this.w, r2 = 0, n2 = 10;
    return void 0 === s2.config.yaxis[t3].title.text || t3 < 0 ? { xPos: r2, padd: 0 } : (a2 ? r2 = e2.width + s2.config.yaxis[t3].title.offsetX + i.width / 2 + n2 / 2 : (r2 = -1 * e2.width + s2.config.yaxis[t3].title.offsetX + n2 / 2 + i.width / 2, s2.globals.isBarHorizontal && (n2 = 25, r2 = -1 * e2.width - s2.config.yaxis[t3].title.offsetX - n2)), { xPos: r2, padd: n2 });
  } }, { key: "setYAxisXPosition", value: function(t3, e2) {
    var i = this.w, a2 = 0, s2 = 0, r2 = 18, n2 = 1;
    i.config.yaxis.length > 1 && (this.multipleYs = true), i.config.yaxis.forEach(function(o2, l2) {
      var h2 = i.globals.ignoreYAxisIndexes.includes(l2) || !o2.show || o2.floating || 0 === t3[l2].width, c2 = t3[l2].width + e2[l2].width;
      o2.opposite ? i.globals.isBarHorizontal ? (s2 = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX) : (s2 = i.globals.gridWidth + i.globals.translateX + n2, h2 || (n2 += c2 + 20), i.globals.translateYAxisX[l2] = s2 - o2.labels.offsetX + 20) : (a2 = i.globals.translateX - r2, h2 || (r2 += c2 + 20), i.globals.translateYAxisX[l2] = a2 + o2.labels.offsetX);
    });
  } }, { key: "setYAxisTextAlignments", value: function() {
    var t3 = this.w;
    v.listToArray(t3.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis")).forEach(function(e2, i) {
      var a2 = t3.config.yaxis[i];
      if (a2 && !a2.floating && void 0 !== a2.labels.align) {
        var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")), r2 = v.listToArray(t3.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"))), n2 = s2.getBoundingClientRect();
        r2.forEach(function(t4) {
          t4.setAttribute("text-anchor", a2.labels.align);
        }), "left" !== a2.labels.align || a2.opposite ? "center" === a2.labels.align ? s2.setAttribute("transform", "translate(".concat(n2.width / 2 * (a2.opposite ? 1 : -1), ", 0)")) : "right" === a2.labels.align && a2.opposite && s2.setAttribute("transform", "translate(".concat(n2.width, ", 0)")) : s2.setAttribute("transform", "translate(-".concat(n2.width, ", 0)"));
      }
    });
  } }]), t2;
}(), aa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.documentEvent = v.bind(this.documentEvent, this);
  }
  return s(t2, [{ key: "addEventListener", value: function(t3, e2) {
    var i = this.w;
    i.globals.events.hasOwnProperty(t3) ? i.globals.events[t3].push(e2) : i.globals.events[t3] = [e2];
  } }, { key: "removeEventListener", value: function(t3, e2) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(t3)) {
      var a2 = i.globals.events[t3].indexOf(e2);
      -1 !== a2 && i.globals.events[t3].splice(a2, 1);
    }
  } }, { key: "fireEvent", value: function(t3, e2) {
    var i = this.w;
    if (i.globals.events.hasOwnProperty(t3)) {
      e2 && e2.length || (e2 = []);
      for (var a2 = i.globals.events[t3], s2 = a2.length, r2 = 0; r2 < s2; r2++)
        a2[r2].apply(null, e2);
    }
  } }, { key: "setupEventHandlers", value: function() {
    var t3 = this, e2 = this.w, i = this.ctx, a2 = e2.globals.dom.baseEl.querySelector(e2.globals.chartClass);
    this.ctx.eventList.forEach(function(t4) {
      a2.addEventListener(t4, function(t5) {
        var a3 = Object.assign({}, e2, { seriesIndex: e2.globals.axisCharts ? e2.globals.capturedSeriesIndex : 0, dataPointIndex: e2.globals.capturedDataPointIndex });
        "mousemove" === t5.type || "touchmove" === t5.type ? "function" == typeof e2.config.chart.events.mouseMove && e2.config.chart.events.mouseMove(t5, i, a3) : "mouseleave" === t5.type || "touchleave" === t5.type ? "function" == typeof e2.config.chart.events.mouseLeave && e2.config.chart.events.mouseLeave(t5, i, a3) : ("mouseup" === t5.type && 1 === t5.which || "touchend" === t5.type) && ("function" == typeof e2.config.chart.events.click && e2.config.chart.events.click(t5, i, a3), i.ctx.events.fireEvent("click", [t5, i, a3]));
      }, { capture: false, passive: true });
    }), this.ctx.eventList.forEach(function(i2) {
      e2.globals.dom.baseEl.addEventListener(i2, t3.documentEvent, { passive: true });
    }), this.ctx.core.setupBrushHandler();
  } }, { key: "documentEvent", value: function(t3) {
    var e2 = this.w, i = t3.target.className;
    if ("click" === t3.type) {
      var a2 = e2.globals.dom.baseEl.querySelector(".apexcharts-menu");
      a2 && a2.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && a2.classList.remove("apexcharts-menu-open");
    }
    e2.globals.clientX = "touchmove" === t3.type ? t3.touches[0].clientX : t3.clientX, e2.globals.clientY = "touchmove" === t3.type ? t3.touches[0].clientY : t3.clientY;
  } }]), t2;
}(), sa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "setCurrentLocaleValues", value: function(t3) {
    var e2 = this.w.config.chart.locales;
    window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e2 = this.w.config.chart.locales.concat(window.Apex.chart.locales));
    var i = e2.filter(function(e3) {
      return e3.name === t3;
    })[0];
    if (!i)
      throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
    var a2 = v.extend(Hi, i);
    this.w.globals.locale = a2.options;
  } }]), t2;
}(), ra = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawAxis", value: function(t3, e2) {
    var i, a2, s2 = this, r2 = this.w.globals, n2 = this.w.config, o2 = new Qi(this.ctx, e2), l2 = new ia(this.ctx, e2);
    r2.axisCharts && "radar" !== t3 && (r2.isBarHorizontal ? (a2 = l2.drawYaxisInversed(0), i = o2.drawXaxisInversed(0), r2.dom.elGraphical.add(i), r2.dom.elGraphical.add(a2)) : (i = o2.drawXaxis(), r2.dom.elGraphical.add(i), n2.yaxis.map(function(t4, e3) {
      if (-1 === r2.ignoreYAxisIndexes.indexOf(e3) && (a2 = l2.drawYaxis(e3), r2.dom.Paper.add(a2), "back" === s2.w.config.grid.position)) {
        var i2 = r2.dom.Paper.children()[1];
        i2.remove(), r2.dom.Paper.add(i2);
      }
    })));
  } }]), t2;
}(), na = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawXCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i = new Li(this.ctx), a2 = t3.config.xaxis.crosshairs.fill.gradient, s2 = t3.config.xaxis.crosshairs.dropShadow, r2 = t3.config.xaxis.crosshairs.fill.type, n2 = a2.colorFrom, o2 = a2.colorTo, l2 = a2.opacityFrom, h2 = a2.opacityTo, c2 = a2.stops, d2 = s2.enabled, u2 = s2.left, g2 = s2.top, p2 = s2.blur, f2 = s2.color, x2 = s2.opacity, b2 = t3.config.xaxis.crosshairs.fill.color;
    if (t3.config.xaxis.crosshairs.show) {
      "gradient" === r2 && (b2 = e2.drawGradient("vertical", n2, o2, l2, h2, null, c2, null));
      var m2 = e2.drawRect();
      1 === t3.config.xaxis.crosshairs.width && (m2 = e2.drawLine());
      var y2 = t3.globals.gridHeight;
      (!v.isNumber(y2) || y2 < 0) && (y2 = 0);
      var w2 = t3.config.xaxis.crosshairs.width;
      (!v.isNumber(w2) || w2 < 0) && (w2 = 0), m2.attr({ class: "apexcharts-xcrosshairs", x: 0, y: 0, y2, width: w2, height: y2, fill: b2, filter: "none", "fill-opacity": t3.config.xaxis.crosshairs.opacity, stroke: t3.config.xaxis.crosshairs.stroke.color, "stroke-width": t3.config.xaxis.crosshairs.stroke.width, "stroke-dasharray": t3.config.xaxis.crosshairs.stroke.dashArray }), d2 && (m2 = i.dropShadow(m2, { left: u2, top: g2, blur: p2, color: f2, opacity: x2 })), t3.globals.dom.elGraphical.add(m2);
    }
  } }, { key: "drawYCrosshairs", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i = t3.config.yaxis[0].crosshairs, a2 = t3.globals.barPadForNumericAxis;
    if (t3.config.yaxis[0].crosshairs.show) {
      var s2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
      s2.attr({ class: "apexcharts-ycrosshairs" }), t3.globals.dom.elGraphical.add(s2);
    }
    var r2 = e2.drawLine(-a2, 0, t3.globals.gridWidth + a2, 0, i.stroke.color, 0, 0);
    r2.attr({ class: "apexcharts-ycrosshairs-hidden" }), t3.globals.dom.elGraphical.add(r2);
  } }]), t2;
}(), oa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkResponsiveConfig", value: function(t3) {
    var e2 = this, i = this.w, a2 = i.config;
    if (0 !== a2.responsive.length) {
      var s2 = a2.responsive.slice();
      s2.sort(function(t4, e3) {
        return t4.breakpoint > e3.breakpoint ? 1 : e3.breakpoint > t4.breakpoint ? -1 : 0;
      }).reverse();
      var r2 = new Wi({}), n2 = function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, a3 = s2[0].breakpoint, n3 = window.innerWidth > 0 ? window.innerWidth : screen.width;
        if (n3 > a3) {
          var o3 = v.clone(i.globals.initialConfig);
          o3.series = v.clone(i.config.series);
          var l2 = Pi.extendArrayProps(r2, o3, i);
          t4 = v.extend(l2, t4), t4 = v.extend(i.config, t4), e2.overrideResponsiveOptions(t4);
        } else
          for (var h2 = 0; h2 < s2.length; h2++)
            n3 < s2[h2].breakpoint && (t4 = Pi.extendArrayProps(r2, s2[h2].options, i), t4 = v.extend(i.config, t4), e2.overrideResponsiveOptions(t4));
      };
      if (t3) {
        var o2 = Pi.extendArrayProps(r2, t3, i);
        o2 = v.extend(i.config, o2), n2(o2 = v.extend(o2, t3));
      } else
        n2({});
    }
  } }, { key: "overrideResponsiveOptions", value: function(t3) {
    var e2 = new Wi(t3).init({ responsiveOverride: true });
    this.w.config = e2;
  } }]), t2;
}(), la = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.colors = [], this.isColorFn = false, this.isHeatmapDistributed = this.checkHeatmapDistributed(), this.isBarDistributed = this.checkBarDistributed();
  }
  return s(t2, [{ key: "checkHeatmapDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i = t3.plotOptions;
    return "treemap" === e2.type && i.treemap && i.treemap.distributed || "heatmap" === e2.type && i.heatmap && i.heatmap.distributed;
  } }, { key: "checkBarDistributed", value: function() {
    var t3 = this.w.config, e2 = t3.chart, i = t3.plotOptions;
    return i.bar && i.bar.distributed && ("bar" === e2.type || "rangeBar" === e2.type);
  } }, { key: "init", value: function() {
    this.setDefaultColors();
  } }, { key: "setDefaultColors", value: function() {
    var t3 = this.w, e2 = new v();
    t3.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(t3.config.theme.mode));
    var i = f(t3.config.colors || t3.config.fill.colors || []);
    t3.globals.colors = this.getColors(i), this.applySeriesColors(t3.globals.seriesColors, t3.globals.colors), t3.config.theme.monochrome.enabled && (t3.globals.colors = this.getMonochromeColors(t3.config.theme.monochrome, t3.globals.series, e2));
    var a2 = t3.globals.colors.slice();
    this.pushExtraColors(t3.globals.colors), this.applyColorTypes(["fill", "stroke"], a2), this.applyDataLabelsColors(a2), this.applyRadarPolygonsColors(), this.applyMarkersColors(a2);
  } }, { key: "getColors", value: function(t3) {
    var e2 = this, i = this.w;
    return t3 && 0 !== t3.length ? Array.isArray(t3) && t3.length > 0 && "function" == typeof t3[0] ? (this.isColorFn = true, i.config.series.map(function(a2, s2) {
      var r2 = t3[s2] || t3[0];
      return "function" == typeof r2 ? r2({ value: i.globals.axisCharts ? i.globals.series[s2][0] || 0 : i.globals.series[s2], seriesIndex: s2, dataPointIndex: s2, w: e2.w }) : r2;
    })) : t3 : this.predefined();
  } }, { key: "applySeriesColors", value: function(t3, e2) {
    t3.forEach(function(t4, i) {
      t4 && (e2[i] = t4);
    });
  } }, { key: "getMonochromeColors", value: function(t3, e2, i) {
    var a2 = t3.color, s2 = t3.shadeIntensity, r2 = t3.shadeTo, n2 = this.isBarDistributed || this.isHeatmapDistributed ? e2[0].length * e2.length : e2.length, o2 = 1 / (n2 / s2), l2 = 0;
    return Array.from({ length: n2 }, function() {
      var t4 = "dark" === r2 ? i.shadeColor(-1 * l2, a2) : i.shadeColor(l2, a2);
      return l2 += o2, t4;
    });
  } }, { key: "applyColorTypes", value: function(t3, e2) {
    var i = this, a2 = this.w;
    t3.forEach(function(t4) {
      a2.globals[t4].colors = void 0 === a2.config[t4].colors ? i.isColorFn ? a2.config.colors : e2 : a2.config[t4].colors.slice(), i.pushExtraColors(a2.globals[t4].colors);
    });
  } }, { key: "applyDataLabelsColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.dataLabels.style.colors = void 0 === e2.config.dataLabels.style.colors ? t3 : e2.config.dataLabels.style.colors.slice(), this.pushExtraColors(e2.globals.dataLabels.style.colors, 50);
  } }, { key: "applyRadarPolygonsColors", value: function() {
    var t3 = this.w;
    t3.globals.radarPolygons.fill.colors = void 0 === t3.config.plotOptions.radar.polygons.fill.colors ? ["dark" === t3.config.theme.mode ? "#424242" : "none"] : t3.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(t3.globals.radarPolygons.fill.colors, 20);
  } }, { key: "applyMarkersColors", value: function(t3) {
    var e2 = this.w;
    e2.globals.markers.colors = void 0 === e2.config.markers.colors ? t3 : e2.config.markers.colors.slice(), this.pushExtraColors(e2.globals.markers.colors);
  } }, { key: "pushExtraColors", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = e2 || a2.globals.series.length;
    if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a2.config.chart.type && a2.config.plotOptions.heatmap && a2.config.plotOptions.heatmap.colorScale.inverse), i && a2.globals.series.length && (s2 = a2.globals.series[a2.globals.maxValsInArrayIndex].length * a2.globals.series.length), t3.length < s2)
      for (var r2 = s2 - t3.length, n2 = 0; n2 < r2; n2++)
        t3.push(t3[n2]);
  } }, { key: "updateThemeOptions", value: function(t3) {
    t3.chart = t3.chart || {}, t3.tooltip = t3.tooltip || {};
    var e2 = t3.theme.mode, i = "dark" === e2 ? "palette4" : "light" === e2 ? "palette1" : t3.theme.palette || "palette1", a2 = "dark" === e2 ? "#f6f7f8" : "light" === e2 ? "#373d3f" : t3.chart.foreColor || "#373d3f";
    return t3.tooltip.theme = e2 || "light", t3.chart.foreColor = a2, t3.theme.palette = i, t3;
  } }, { key: "predefined", value: function() {
    var t3 = { palette1: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"], palette2: ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"], palette3: ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"], palette4: ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"], palette5: ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"], palette6: ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"], palette7: ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"], palette8: ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"], palette9: ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"], palette10: ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"], default: ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"] };
    return t3[this.w.config.theme.palette] || t3.default;
  } }]), t2;
}(), ha = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "draw", value: function() {
    this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle");
  } }, { key: "drawTitleSubtitle", value: function(t3) {
    var e2 = this.w, i = "title" === t3 ? e2.config.title : e2.config.subtitle, a2 = e2.globals.svgWidth / 2, s2 = i.offsetY, r2 = "middle";
    if ("left" === i.align ? (a2 = 10, r2 = "start") : "right" === i.align && (a2 = e2.globals.svgWidth - 10, r2 = "end"), a2 += i.offsetX, s2 = s2 + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
      var n2 = new Mi(this.ctx).drawText({ x: a2, y: s2, text: i.text, textAnchor: r2, fontSize: i.style.fontSize, fontFamily: i.style.fontFamily, fontWeight: i.style.fontWeight, foreColor: i.style.color, opacity: 1 });
      n2.node.setAttribute("class", "apexcharts-".concat(t3, "-text")), e2.globals.dom.Paper.add(n2);
    }
  } }]), t2;
}(), ca = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getTitleSubtitleCoords", value: function(t3) {
    var e2 = this.w, i = 0, a2 = 0, s2 = "title" === t3 ? e2.config.title.floating : e2.config.subtitle.floating, r2 = e2.globals.dom.baseEl.querySelector(".apexcharts-".concat(t3, "-text"));
    if (null !== r2 && !s2) {
      var n2 = r2.getBoundingClientRect();
      i = n2.width, a2 = e2.globals.axisCharts ? n2.height + 5 : n2.height;
    }
    return { width: i, height: a2 };
  } }, { key: "getLegendsRect", value: function() {
    var t3 = this.w, e2 = t3.globals.dom.elLegendWrap;
    t3.config.legend.height || "top" !== t3.config.legend.position && "bottom" !== t3.config.legend.position || (e2.style.maxHeight = t3.globals.svgHeight / 2 + "px");
    var i = Object.assign({}, v.getBoundingClientRect(e2));
    return null !== e2 && !t3.config.legend.floating && t3.config.legend.show ? this.dCtx.lgRect = { x: i.x, y: i.y, height: i.height, width: 0 === i.height ? 0 : i.width } : this.dCtx.lgRect = { x: 0, y: 0, height: 0, width: 0 }, "left" !== t3.config.legend.position && "right" !== t3.config.legend.position || 1.5 * this.dCtx.lgRect.width > t3.globals.svgWidth && (this.dCtx.lgRect.width = t3.globals.svgWidth / 1.5), this.dCtx.lgRect;
  } }, { key: "getDatalabelsRect", value: function() {
    var t3 = this, e2 = this.w, i = [];
    e2.config.series.forEach(function(s3, r3) {
      s3.data.forEach(function(s4, n3) {
        var o2;
        o2 = e2.globals.series[r3][n3], a2 = e2.config.dataLabels.formatter(o2, { ctx: t3.dCtx.ctx, seriesIndex: r3, dataPointIndex: n3, w: e2 }), i.push(a2);
      });
    });
    var a2 = v.getLargestStringFromArr(i), s2 = new Mi(this.dCtx.ctx), r2 = e2.config.dataLabels.style, n2 = s2.getTextRects(a2, parseInt(r2.fontSize), r2.fontFamily);
    return { width: 1.05 * n2.width, height: n2.height };
  } }, { key: "getLargestStringFromMultiArr", value: function(t3, e2) {
    var i = t3;
    if (this.w.globals.isMultiLineX) {
      var a2 = e2.map(function(t4, e3) {
        return Array.isArray(t4) ? t4.length : 1;
      }), s2 = Math.max.apply(Math, f(a2));
      i = e2[a2.indexOf(s2)];
    }
    return i;
  } }]), t2;
}(), da = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getxAxisLabelsCoords", value: function() {
    var t3, e2 = this.w, i = e2.globals.labels.slice();
    if (e2.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e2.globals.categoryLabels), e2.globals.timescaleLabels.length > 0) {
      var a2 = this.getxAxisTimeScaleLabelsCoords();
      t3 = { width: a2.width, height: a2.height }, e2.globals.rotateXLabels = false;
    } else {
      this.dCtx.lgWidthForSideLegends = "left" !== e2.config.legend.position && "right" !== e2.config.legend.position || e2.config.legend.floating ? 0 : this.dCtx.lgRect.width;
      var s2 = e2.globals.xLabelFormatter, r2 = v.getLargestStringFromArr(i), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, i);
      e2.globals.isBarHorizontal && (n2 = r2 = e2.globals.yAxisScale[0].result.reduce(function(t4, e3) {
        return t4.length > e3.length ? t4 : e3;
      }, 0));
      var o2 = new Xi(this.dCtx.ctx), l2 = r2;
      r2 = o2.xLabelFormat(s2, r2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), n2 = o2.xLabelFormat(s2, n2, l2, { i: void 0, dateFormatter: new zi(this.dCtx.ctx).formatDate, w: e2 }), (e2.config.xaxis.convertedCatToNumeric && void 0 === r2 || "" === String(r2).trim()) && (n2 = r2 = "1");
      var h2 = new Mi(this.dCtx.ctx), c2 = h2.getTextRects(r2, e2.config.xaxis.labels.style.fontSize), d2 = c2;
      if (r2 !== n2 && (d2 = h2.getTextRects(n2, e2.config.xaxis.labels.style.fontSize)), (t3 = { width: c2.width >= d2.width ? c2.width : d2.width, height: c2.height >= d2.height ? c2.height : d2.height }).width * i.length > e2.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e2.config.xaxis.labels.rotate || e2.config.xaxis.labels.rotateAlways) {
        if (!e2.globals.isBarHorizontal) {
          e2.globals.rotateXLabels = true;
          var u2 = function(t4) {
            return h2.getTextRects(t4, e2.config.xaxis.labels.style.fontSize, e2.config.xaxis.labels.style.fontFamily, "rotate(".concat(e2.config.xaxis.labels.rotate, " 0 0)"), false);
          };
          c2 = u2(r2), r2 !== n2 && (d2 = u2(n2)), t3.height = (c2.height > d2.height ? c2.height : d2.height) / 1.5, t3.width = c2.width > d2.width ? c2.width : d2.width;
        }
      } else
        e2.globals.rotateXLabels = false;
    }
    return e2.config.xaxis.labels.show || (t3 = { width: 0, height: 0 }), { width: t3.width, height: t3.height };
  } }, { key: "getxAxisGroupLabelsCoords", value: function() {
    var t3, e2 = this.w;
    if (!e2.globals.hasXaxisGroups)
      return { width: 0, height: 0 };
    var i, a2 = (null === (t3 = e2.config.xaxis.group.style) || void 0 === t3 ? void 0 : t3.fontSize) || e2.config.xaxis.labels.style.fontSize, s2 = e2.globals.groups.map(function(t4) {
      return t4.title;
    }), r2 = v.getLargestStringFromArr(s2), n2 = this.dCtx.dimHelpers.getLargestStringFromMultiArr(r2, s2), o2 = new Mi(this.dCtx.ctx), l2 = o2.getTextRects(r2, a2), h2 = l2;
    return r2 !== n2 && (h2 = o2.getTextRects(n2, a2)), i = { width: l2.width >= h2.width ? l2.width : h2.width, height: l2.height >= h2.height ? l2.height : h2.height }, e2.config.xaxis.labels.show || (i = { width: 0, height: 0 }), { width: i.width, height: i.height };
  } }, { key: "getxAxisTitleCoords", value: function() {
    var t3 = this.w, e2 = 0, i = 0;
    if (void 0 !== t3.config.xaxis.title.text) {
      var a2 = new Mi(this.dCtx.ctx).getTextRects(t3.config.xaxis.title.text, t3.config.xaxis.title.style.fontSize);
      e2 = a2.width, i = a2.height;
    }
    return { width: e2, height: i };
  } }, { key: "getxAxisTimeScaleLabelsCoords", value: function() {
    var t3, e2 = this.w;
    this.dCtx.timescaleLabels = e2.globals.timescaleLabels.slice();
    var i = this.dCtx.timescaleLabels.map(function(t4) {
      return t4.value;
    }), a2 = i.reduce(function(t4, e3) {
      return void 0 === t4 ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t4.length > e3.length ? t4 : e3;
    }, 0);
    return 1.05 * (t3 = new Mi(this.dCtx.ctx).getTextRects(a2, e2.config.xaxis.labels.style.fontSize)).width * i.length > e2.globals.gridWidth && 0 !== e2.config.xaxis.labels.rotate && (e2.globals.overlappingXLabels = true), t3;
  } }, { key: "additionalPaddingXLabels", value: function(t3) {
    var e2 = this, i = this.w, a2 = i.globals, s2 = i.config, r2 = s2.xaxis.type, n2 = t3.width;
    a2.skipLastTimelinelabel = false, a2.skipFirstTimelinelabel = false;
    var o2 = i.config.yaxis[0].opposite && i.globals.isBarHorizontal, l2 = function(t4, o3) {
      s2.yaxis.length > 1 && function(t5) {
        return -1 !== a2.collapsedSeriesIndices.indexOf(t5);
      }(o3) || function(t5) {
        if (e2.dCtx.timescaleLabels && e2.dCtx.timescaleLabels.length) {
          var o4 = e2.dCtx.timescaleLabels[0], l3 = e2.dCtx.timescaleLabels[e2.dCtx.timescaleLabels.length - 1].position + n2 / 1.75 - e2.dCtx.yAxisWidthRight, h2 = o4.position - n2 / 1.75 + e2.dCtx.yAxisWidthLeft, c2 = "right" === i.config.legend.position && e2.dCtx.lgRect.width > 0 ? e2.dCtx.lgRect.width : 0;
          l3 > a2.svgWidth - a2.translateX - c2 && (a2.skipLastTimelinelabel = true), h2 < -(t5.show && !t5.floating || "bar" !== s2.chart.type && "candlestick" !== s2.chart.type && "rangeBar" !== s2.chart.type && "boxPlot" !== s2.chart.type ? 10 : n2 / 1.75) && (a2.skipFirstTimelinelabel = true);
        } else
          "datetime" === r2 ? e2.dCtx.gridPad.right < n2 && !a2.rotateXLabels && (a2.skipLastTimelinelabel = true) : "datetime" !== r2 && e2.dCtx.gridPad.right < n2 / 2 - e2.dCtx.yAxisWidthRight && !a2.rotateXLabels && !i.config.xaxis.labels.trim && (e2.dCtx.xPadRight = n2 / 2 + 1);
      }(t4);
    };
    s2.yaxis.forEach(function(t4, i2) {
      o2 ? (e2.dCtx.gridPad.left < n2 && (e2.dCtx.xPadLeft = n2 / 2 + 1), e2.dCtx.xPadRight = n2 / 2 + 1) : l2(t4, i2);
    });
  } }]), t2;
}(), ua = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "getyAxisLabelsCoords", value: function() {
    var t3 = this, e2 = this.w, i = [], a2 = 10, s2 = new Ri(this.dCtx.ctx);
    return e2.config.yaxis.map(function(r2, n2) {
      var o2 = { seriesIndex: n2, dataPointIndex: -1, w: e2 }, l2 = e2.globals.yAxisScale[n2], h2 = 0;
      if (!s2.isYAxisHidden(n2) && r2.labels.show && void 0 !== r2.labels.minWidth && (h2 = r2.labels.minWidth), !s2.isYAxisHidden(n2) && r2.labels.show && l2.result.length) {
        var c2 = e2.globals.yLabelFormatters[n2], d2 = l2.niceMin === Number.MIN_VALUE ? 0 : l2.niceMin, u2 = l2.result.reduce(function(t4, e3) {
          var i2, a3;
          return (null === (i2 = String(c2(t4, o2))) || void 0 === i2 ? void 0 : i2.length) > (null === (a3 = String(c2(e3, o2))) || void 0 === a3 ? void 0 : a3.length) ? t4 : e3;
        }, d2), g2 = u2 = c2(u2, o2);
        if (void 0 !== u2 && 0 !== u2.length || (u2 = l2.niceMax), e2.globals.isBarHorizontal) {
          a2 = 0;
          var p2 = e2.globals.labels.slice();
          u2 = v.getLargestStringFromArr(p2), u2 = c2(u2, { seriesIndex: n2, dataPointIndex: -1, w: e2 }), g2 = t3.dCtx.dimHelpers.getLargestStringFromMultiArr(u2, p2);
        }
        var f2 = new Mi(t3.dCtx.ctx), x2 = "rotate(".concat(r2.labels.rotate, " 0 0)"), b2 = f2.getTextRects(u2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false), m2 = b2;
        u2 !== g2 && (m2 = f2.getTextRects(g2, r2.labels.style.fontSize, r2.labels.style.fontFamily, x2, false)), i.push({ width: (h2 > m2.width || h2 > b2.width ? h2 : m2.width > b2.width ? m2.width : b2.width) + a2, height: m2.height > b2.height ? m2.height : b2.height });
      } else
        i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getyAxisTitleCoords", value: function() {
    var t3 = this, e2 = this.w, i = [];
    return e2.config.yaxis.map(function(e3, a2) {
      if (e3.show && void 0 !== e3.title.text) {
        var s2 = new Mi(t3.dCtx.ctx), r2 = "rotate(".concat(e3.title.rotate, " 0 0)"), n2 = s2.getTextRects(e3.title.text, e3.title.style.fontSize, e3.title.style.fontFamily, r2, false);
        i.push({ width: n2.width, height: n2.height });
      } else
        i.push({ width: 0, height: 0 });
    }), i;
  } }, { key: "getTotalYAxisWidth", value: function() {
    var t3 = this.w, e2 = 0, i = 0, a2 = 0, s2 = t3.globals.yAxisScale.length > 1 ? 10 : 0, r2 = new Ri(this.dCtx.ctx), n2 = function(n3, o2) {
      var l2 = t3.config.yaxis[o2].floating, h2 = 0;
      n3.width > 0 && !l2 ? (h2 = n3.width + s2, function(e3) {
        return t3.globals.ignoreYAxisIndexes.indexOf(e3) > -1;
      }(o2) && (h2 = h2 - n3.width - s2)) : h2 = l2 || r2.isYAxisHidden(o2) ? 0 : 5, t3.config.yaxis[o2].opposite ? a2 += h2 : i += h2, e2 += h2;
    };
    return t3.globals.yLabelsCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.yTitleCoords.map(function(t4, e3) {
      n2(t4, e3);
    }), t3.globals.isBarHorizontal && !t3.config.yaxis[0].floating && (e2 = t3.globals.yLabelsCoords[0].width + t3.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a2, e2;
  } }]), t2;
}(), ga = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.dCtx = e2;
  }
  return s(t2, [{ key: "gridPadForColumnsInNumericAxis", value: function(t3) {
    var e2 = this.w, i = e2.config, a2 = e2.globals;
    if (a2.noData || a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i.series.length)
      return 0;
    var s2 = function(t4) {
      return ["bar", "rangeBar", "candlestick", "boxPlot"].includes(t4);
    }, r2 = i.chart.type, n2 = 0, o2 = s2(r2) ? i.series.length : 1;
    a2.comboBarCount > 0 && (o2 = a2.comboBarCount), a2.collapsedSeries.forEach(function(t4) {
      s2(t4.type) && (o2 -= 1);
    }), i.chart.stacked && (o2 = 1);
    var l2 = s2(r2) || a2.comboBarCount > 0, h2 = Math.abs(a2.initialMaxX - a2.initialMinX);
    if (l2 && a2.isXNumeric && !a2.isBarHorizontal && o2 > 0 && 0 !== h2) {
      h2 <= 3 && (h2 = a2.dataPoints);
      var c2 = h2 / t3, d2 = a2.minXDiff && a2.minXDiff / c2 > 0 ? a2.minXDiff / c2 : 0;
      d2 > t3 / 2 && (d2 /= 2), (n2 = d2 * parseInt(i.plotOptions.bar.columnWidth, 10) / 100) < 1 && (n2 = 1), a2.barPadForNumericAxis = n2;
    }
    return n2;
  } }, { key: "gridPadFortitleSubtitle", value: function() {
    var t3 = this, e2 = this.w, i = e2.globals, a2 = this.dCtx.isSparkline || !i.axisCharts ? 0 : 10;
    ["title", "subtitle"].forEach(function(s3) {
      void 0 !== e2.config[s3].text ? a2 += e2.config[s3].margin : a2 += t3.dCtx.isSparkline || !i.axisCharts ? 0 : 5;
    }), !e2.config.legend.show || "bottom" !== e2.config.legend.position || e2.config.legend.floating || i.axisCharts || (a2 += 10);
    var s2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"), r2 = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
    i.gridHeight -= s2.height + r2.height + a2, i.translateY += s2.height + r2.height + a2;
  } }, { key: "setGridXPosForDualYAxis", value: function(t3, e2) {
    var i = this.w, a2 = new Ri(this.dCtx.ctx);
    i.config.yaxis.forEach(function(s2, r2) {
      -1 !== i.globals.ignoreYAxisIndexes.indexOf(r2) || s2.floating || a2.isYAxisHidden(r2) || (s2.opposite && (i.globals.translateX -= e2[r2].width + t3[r2].width + parseInt(s2.labels.style.fontSize, 10) / 1.2 + 12), i.globals.translateX < 2 && (i.globals.translateX = 2));
    });
  } }]), t2;
}(), pa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ca(this), this.dimYAxis = new ua(this), this.dimXAxis = new da(this), this.dimGrid = new ga(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0;
  }
  return s(t2, [{ key: "plotCoords", value: function() {
    var t3 = this, e2 = this.w, i = e2.globals;
    this.lgRect = this.dimHelpers.getLegendsRect(), this.datalabelsCoords = { width: 0, height: 0 };
    var a2 = Array.isArray(e2.config.stroke.width) ? Math.max.apply(Math, f(e2.config.stroke.width)) : e2.config.stroke.width;
    this.isSparkline && ((e2.config.markers.discrete.length > 0 || e2.config.markers.size > 0) && Object.entries(this.gridPad).forEach(function(e3) {
      var i2 = p(e3, 2), a3 = i2[0], s3 = i2[1];
      t3.gridPad[a3] = Math.max(s3, t3.w.globals.markers.largestSize / 1.5);
    }), this.gridPad.top = Math.max(a2 / 2, this.gridPad.top), this.gridPad.bottom = Math.max(a2 / 2, this.gridPad.bottom)), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
    var s2 = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
    i.gridWidth = i.gridWidth - 2 * s2, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (s2 > 0 ? s2 : 0), i.translateY = i.translateY + this.gridPad.top;
  } }, { key: "setDimensionsForAxisCharts", value: function() {
    var t3 = this, e2 = this.w, i = e2.globals, a2 = this.dimYAxis.getyAxisLabelsCoords(), s2 = this.dimYAxis.getyAxisTitleCoords();
    i.isSlopeChart && (this.datalabelsCoords = this.dimHelpers.getDatalabelsRect()), e2.globals.yLabelsCoords = [], e2.globals.yTitleCoords = [], e2.config.yaxis.map(function(t4, i2) {
      e2.globals.yLabelsCoords.push({ width: a2[i2].width, index: i2 }), e2.globals.yTitleCoords.push({ width: s2[i2].width, index: i2 });
    }), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
    var r2 = this.dimXAxis.getxAxisLabelsCoords(), n2 = this.dimXAxis.getxAxisGroupLabelsCoords(), o2 = this.dimXAxis.getxAxisTitleCoords();
    this.conditionalChecksForAxisCoords(r2, o2, n2), i.translateXAxisY = e2.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e2.globals.rotateXLabels && e2.globals.isXNumeric && e2.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e2.globals.isBarHorizontal && (i.rotateXLabels = false, i.translateXAxisY = parseInt(e2.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e2.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e2.config.xaxis.labels.offsetX;
    var l2 = this.yAxisWidth, h2 = this.xAxisHeight;
    i.xAxisLabelsHeight = this.xAxisHeight - o2.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - r2.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
    var c2 = 10;
    ("radar" === e2.config.chart.type || this.isSparkline) && (l2 = 0, h2 = 0), this.isSparkline && (this.lgRect = { height: 0, width: 0 }), (this.isSparkline || "treemap" === e2.config.chart.type) && (l2 = 0, h2 = 0, c2 = 0), this.isSparkline || "treemap" === e2.config.chart.type || this.dimXAxis.additionalPaddingXLabels(r2);
    var d2 = function() {
      i.translateX = l2 + t3.datalabelsCoords.width, i.gridHeight = i.svgHeight - t3.lgRect.height - h2 - (t3.isSparkline || "treemap" === e2.config.chart.type ? 0 : e2.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - l2 - 2 * t3.datalabelsCoords.width;
    };
    switch ("top" === e2.config.xaxis.position && (c2 = i.xAxisHeight - e2.config.xaxis.axisTicks.height - 5), e2.config.legend.position) {
      case "bottom":
        i.translateY = c2, d2();
        break;
      case "top":
        i.translateY = this.lgRect.height + c2, d2();
        break;
      case "left":
        i.translateY = c2, i.translateX = this.lgRect.width + l2 + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h2 - 12, i.gridWidth = i.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width;
        break;
      case "right":
        i.translateY = c2, i.translateX = l2 + this.datalabelsCoords.width, i.gridHeight = i.svgHeight - h2 - 12, i.gridWidth = i.svgWidth - this.lgRect.width - l2 - 2 * this.datalabelsCoords.width - 5;
        break;
      default:
        throw new Error("Legend position not supported");
    }
    this.dimGrid.setGridXPosForDualYAxis(s2, a2), new ia(this.ctx).setYAxisXPosition(a2, s2);
  } }, { key: "setDimensionsForNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i = t3.config, a2 = 0;
    t3.config.legend.show && !t3.config.legend.floating && (a2 = 20);
    var s2 = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar", r2 = i.plotOptions[s2].offsetY, n2 = i.plotOptions[s2].offsetX;
    if (!i.legend.show || i.legend.floating) {
      e2.gridHeight = e2.svgHeight;
      var o2 = e2.dom.elWrap.getBoundingClientRect().width;
      return e2.gridWidth = Math.min(o2, e2.gridHeight), e2.translateY = r2, void (e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2);
    }
    switch (i.legend.position) {
      case "bottom":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = r2 - 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "top":
        e2.gridHeight = e2.svgHeight - this.lgRect.height, e2.gridWidth = e2.svgWidth, e2.translateY = this.lgRect.height + r2 + 10, e2.translateX = n2 + (e2.svgWidth - e2.gridWidth) / 2;
        break;
      case "left":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2, e2.gridHeight = "auto" !== i.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + this.lgRect.width + a2;
        break;
      case "right":
        e2.gridWidth = e2.svgWidth - this.lgRect.width - a2 - 5, e2.gridHeight = "auto" !== i.chart.height ? e2.svgHeight : e2.gridWidth, e2.translateY = r2, e2.translateX = n2 + 10;
        break;
      default:
        throw new Error("Legend position not supported");
    }
  } }, { key: "conditionalChecksForAxisCoords", value: function(t3, e2, i) {
    var a2 = this.w, s2 = a2.globals.hasXaxisGroups ? 2 : 1, r2 = i.height + t3.height + e2.height, n2 = a2.globals.isMultiLineX ? 1.2 : a2.globals.LINE_HEIGHT_RATIO, o2 = a2.globals.rotateXLabels ? 22 : 10, l2 = a2.globals.rotateXLabels && "bottom" === a2.config.legend.position ? 10 : 0;
    this.xAxisHeight = r2 * n2 + s2 * o2 + l2, this.xAxisWidth = t3.width, this.xAxisHeight - e2.height > a2.config.xaxis.labels.maxHeight && (this.xAxisHeight = a2.config.xaxis.labels.maxHeight), a2.config.xaxis.labels.minHeight && this.xAxisHeight < a2.config.xaxis.labels.minHeight && (this.xAxisHeight = a2.config.xaxis.labels.minHeight), a2.config.xaxis.floating && (this.xAxisHeight = 0);
    var h2 = 0, c2 = 0;
    a2.config.yaxis.forEach(function(t4) {
      h2 += t4.labels.minWidth, c2 += t4.labels.maxWidth;
    }), this.yAxisWidth < h2 && (this.yAxisWidth = h2), this.yAxisWidth > c2 && (this.yAxisWidth = c2);
  } }]), t2;
}(), fa = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.lgCtx = e2;
  }
  return s(t2, [{ key: "getLegendStyles", value: function() {
    var t3, e2, i, a2 = document.createElement("style");
    a2.setAttribute("type", "text/css");
    var s2 = (null === (t3 = this.lgCtx.ctx) || void 0 === t3 || null === (e2 = t3.opts) || void 0 === e2 || null === (i = e2.chart) || void 0 === i ? void 0 : i.nonce) || this.w.config.chart.nonce;
    s2 && a2.setAttribute("nonce", s2);
    var r2 = document.createTextNode("\n      .apexcharts-flip-y {\n        transform: scaleY(-1) translateY(-100%);\n        transform-origin: top;\n        transform-box: fill-box;\n      }\n      .apexcharts-flip-x {\n        transform: scaleX(-1);\n        transform-origin: center;\n        transform-box: fill-box;\n      }\n      .apexcharts-legend {\n        display: flex;\n        overflow: auto;\n        padding: 0 10px;\n      }\n      .apexcharts-legend.apexcharts-legend-group-horizontal {\n        flex-direction: column;\n      }\n      .apexcharts-legend-group {\n        display: flex;\n      }\n      .apexcharts-legend-group-vertical {\n        flex-direction: column-reverse;\n      }\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\n        flex-wrap: wrap\n      }\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        flex-direction: column;\n        bottom: 0;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\n        justify-content: flex-start;\n        align-items: flex-start;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\n        justify-content: center;\n        align-items: center;\n      }\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\n        justify-content: flex-end;\n        align-items: flex-end;\n      }\n      .apexcharts-legend-series {\n        cursor: pointer;\n        line-height: normal;\n        display: flex;\n        align-items: center;\n      }\n      .apexcharts-legend-text {\n        position: relative;\n        font-size: 14px;\n      }\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\n        pointer-events: none;\n      }\n      .apexcharts-legend-marker {\n        position: relative;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        cursor: pointer;\n        margin-right: 1px;\n      }\n\n      .apexcharts-legend-series.apexcharts-no-click {\n        cursor: auto;\n      }\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\n        display: none !important;\n      }\n      .apexcharts-inactive-legend {\n        opacity: 0.45;\n      }\n\n    ");
    return a2.appendChild(r2), a2;
  } }, { key: "getLegendDimensions", value: function() {
    var t3 = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(), e2 = t3.width;
    return { clwh: t3.height, clww: e2 };
  } }, { key: "appendToForeignObject", value: function() {
    this.w.globals.dom.elLegendForeign.appendChild(this.getLegendStyles());
  } }, { key: "toggleDataSeries", value: function(t3, e2) {
    var i = this, a2 = this.w;
    if (a2.globals.axisCharts || "radialBar" === a2.config.chart.type) {
      a2.globals.resized = true;
      var s2 = null, r2 = null;
      if (a2.globals.risingSeries = [], a2.globals.axisCharts ? (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t3, "']")), r2 = parseInt(s2.getAttribute("data:realIndex"), 10)) : (s2 = a2.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t3 + 1, "']")), r2 = parseInt(s2.getAttribute("rel"), 10) - 1), e2)
        [{ cs: a2.globals.collapsedSeries, csi: a2.globals.collapsedSeriesIndices }, { cs: a2.globals.ancillaryCollapsedSeries, csi: a2.globals.ancillaryCollapsedSeriesIndices }].forEach(function(t4) {
          i.riseCollapsedSeries(t4.cs, t4.csi, r2);
        });
      else
        this.hideSeries({ seriesEl: s2, realIndex: r2 });
    } else {
      var n2 = a2.globals.dom.Paper.findOne(" .apexcharts-series[rel='".concat(t3 + 1, "'] path")), o2 = a2.config.chart.type;
      if ("pie" === o2 || "polarArea" === o2 || "donut" === o2) {
        var l2 = a2.config.plotOptions.pie.donut.labels;
        new Mi(this.lgCtx.ctx).pathMouseDown(n2, null), this.lgCtx.ctx.pie.printDataLabelsInner(n2.node, l2);
      }
      n2.fire("click");
    }
  } }, { key: "getSeriesAfterCollapsing", value: function(t3) {
    var e2 = t3.realIndex, i = this.w, a2 = i.globals, s2 = v.clone(i.config.series);
    if (a2.axisCharts) {
      var r2 = i.config.yaxis[a2.seriesYAxisReverseMap[e2]], n2 = { index: e2, data: s2[e2].data.slice(), type: s2[e2].type || i.config.chart.type };
      if (r2 && r2.show && r2.showAlways)
        a2.ancillaryCollapsedSeriesIndices.indexOf(e2) < 0 && (a2.ancillaryCollapsedSeries.push(n2), a2.ancillaryCollapsedSeriesIndices.push(e2));
      else if (a2.collapsedSeriesIndices.indexOf(e2) < 0) {
        a2.collapsedSeries.push(n2), a2.collapsedSeriesIndices.push(e2);
        var o2 = a2.risingSeries.indexOf(e2);
        a2.risingSeries.splice(o2, 1);
      }
    } else
      a2.collapsedSeries.push({ index: e2, data: s2[e2] }), a2.collapsedSeriesIndices.push(e2);
    return a2.allSeriesCollapsed = a2.collapsedSeries.length + a2.ancillaryCollapsedSeries.length === i.config.series.length, this._getSeriesBasedOnCollapsedState(s2);
  } }, { key: "hideSeries", value: function(t3) {
    for (var e2 = t3.seriesEl, i = t3.realIndex, a2 = this.w, s2 = this.getSeriesAfterCollapsing({ realIndex: i }), r2 = e2.childNodes, n2 = 0; n2 < r2.length; n2++)
      r2[n2].classList.contains("apexcharts-series-markers-wrap") && (r2[n2].classList.contains("apexcharts-hide") ? r2[n2].classList.remove("apexcharts-hide") : r2[n2].classList.add("apexcharts-hide"));
    this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
  } }, { key: "riseCollapsedSeries", value: function(t3, e2, i) {
    var a2 = this.w, s2 = v.clone(a2.config.series);
    if (t3.length > 0) {
      for (var r2 = 0; r2 < t3.length; r2++)
        t3[r2].index === i && (a2.globals.axisCharts ? s2[i].data = t3[r2].data.slice() : s2[i] = t3[r2].data, "number" != typeof s2[i] && (s2[i].hidden = false), t3.splice(r2, 1), e2.splice(r2, 1), a2.globals.risingSeries.push(i));
      s2 = this._getSeriesBasedOnCollapsedState(s2), this.lgCtx.ctx.updateHelpers._updateSeries(s2, a2.config.chart.animations.dynamicAnimation.enabled);
    }
  } }, { key: "_getSeriesBasedOnCollapsedState", value: function(t3) {
    var e2 = this.w, i = 0;
    return e2.globals.axisCharts ? t3.forEach(function(a2, s2) {
      e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2) < 0 || (t3[s2].data = [], i++);
    }) : t3.forEach(function(a2, s2) {
      !e2.globals.collapsedSeriesIndices.indexOf(s2) < 0 && (t3[s2] = 0, i++);
    }), e2.globals.allSeriesCollapsed = i === t3.length, t3;
  } }]), t2;
}(), xa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new fa(this);
  }
  return s(t2, [{ key: "init", value: function() {
    var t3 = this.w, e2 = t3.globals, i = t3.config, a2 = i.legend.showForSingleSeries && 1 === e2.series.length || this.isBarsDistributed || e2.series.length > 1;
    if (this.legendHelpers.appendToForeignObject(), (a2 || !e2.axisCharts) && i.legend.show) {
      for (; e2.dom.elLegendWrap.firstChild; )
        e2.dom.elLegendWrap.removeChild(e2.dom.elLegendWrap.firstChild);
      this.drawLegends(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical();
    }
  } }, { key: "createLegendMarker", value: function(t3) {
    var e2 = t3.i, i = t3.fillcolor, a2 = this.w, s2 = document.createElement("span");
    s2.classList.add("apexcharts-legend-marker");
    var r2 = a2.config.legend.markers.shape || a2.config.markers.shape, n2 = r2;
    Array.isArray(r2) && (n2 = r2[e2]);
    var o2 = Array.isArray(a2.config.legend.markers.size) ? parseFloat(a2.config.legend.markers.size[e2]) : parseFloat(a2.config.legend.markers.size), l2 = Array.isArray(a2.config.legend.markers.offsetX) ? parseFloat(a2.config.legend.markers.offsetX[e2]) : parseFloat(a2.config.legend.markers.offsetX), h2 = Array.isArray(a2.config.legend.markers.offsetY) ? parseFloat(a2.config.legend.markers.offsetY[e2]) : parseFloat(a2.config.legend.markers.offsetY), c2 = Array.isArray(a2.config.legend.markers.strokeWidth) ? parseFloat(a2.config.legend.markers.strokeWidth[e2]) : parseFloat(a2.config.legend.markers.strokeWidth), d2 = s2.style;
    if (d2.height = 2 * (o2 + c2) + "px", d2.width = 2 * (o2 + c2) + "px", d2.left = l2 + "px", d2.top = h2 + "px", a2.config.legend.markers.customHTML)
      d2.background = "transparent", d2.color = i[e2], Array.isArray(a2.config.legend.markers.customHTML) ? a2.config.legend.markers.customHTML[e2] && (s2.innerHTML = a2.config.legend.markers.customHTML[e2]()) : s2.innerHTML = a2.config.legend.markers.customHTML();
    else {
      var g2 = new Vi(this.ctx).getMarkerConfig({ cssClass: "apexcharts-legend-marker apexcharts-marker apexcharts-marker-".concat(n2), seriesIndex: e2, strokeWidth: c2, size: o2 }), p2 = window.SVG().addTo(s2).size("100%", "100%"), f2 = new Mi(this.ctx).drawMarker(0, 0, u(u({}, g2), {}, { pointFillColor: Array.isArray(i) ? i[e2] : g2.pointFillColor, shape: n2 }));
      a2.globals.dom.Paper.find(".apexcharts-legend-marker.apexcharts-marker").forEach(function(t4) {
        t4.node.classList.contains("apexcharts-marker-triangle") ? t4.node.style.transform = "translate(50%, 45%)" : t4.node.style.transform = "translate(50%, 50%)";
      }), p2.add(f2);
    }
    return s2;
  } }, { key: "drawLegends", value: function() {
    var t3 = this, e2 = this, i = this.w, a2 = i.config.legend.fontFamily, s2 = i.globals.seriesNames, r2 = i.config.legend.markers.fillColors ? i.config.legend.markers.fillColors.slice() : i.globals.colors.slice();
    if ("heatmap" === i.config.chart.type) {
      var n2 = i.config.plotOptions.heatmap.colorScale.ranges;
      s2 = n2.map(function(t4) {
        return t4.name ? t4.name : t4.from + " - " + t4.to;
      }), r2 = n2.map(function(t4) {
        return t4.color;
      });
    } else
      this.isBarsDistributed && (s2 = i.globals.labels.slice());
    i.config.legend.customLegendItems.length && (s2 = i.config.legend.customLegendItems);
    var o2 = i.globals.legendFormatter, l2 = i.config.legend.inverseOrder, h2 = [];
    i.globals.seriesGroups.length > 1 && i.config.legend.clusterGroupedSeries && i.globals.seriesGroups.forEach(function(t4, e3) {
      h2[e3] = document.createElement("div"), h2[e3].classList.add("apexcharts-legend-group", "apexcharts-legend-group-".concat(e3)), "horizontal" === i.config.legend.clusterGroupedSeriesOrientation ? i.globals.dom.elLegendWrap.classList.add("apexcharts-legend-group-horizontal") : h2[e3].classList.add("apexcharts-legend-group-vertical");
    });
    for (var c2 = function(e3) {
      var n3, l3 = o2(s2[e3], { seriesIndex: e3, w: i }), c3 = false, d3 = false;
      if (i.globals.collapsedSeries.length > 0)
        for (var u2 = 0; u2 < i.globals.collapsedSeries.length; u2++)
          i.globals.collapsedSeries[u2].index === e3 && (c3 = true);
      if (i.globals.ancillaryCollapsedSeriesIndices.length > 0)
        for (var g2 = 0; g2 < i.globals.ancillaryCollapsedSeriesIndices.length; g2++)
          i.globals.ancillaryCollapsedSeriesIndices[g2] === e3 && (d3 = true);
      var p2 = t3.createLegendMarker({ i: e3, fillcolor: r2 });
      Mi.setAttrs(p2, { rel: e3 + 1, "data:collapsed": c3 || d3 }), (c3 || d3) && p2.classList.add("apexcharts-inactive-legend");
      var f2 = document.createElement("div"), x2 = document.createElement("span");
      x2.classList.add("apexcharts-legend-text"), x2.innerHTML = Array.isArray(l3) ? l3.join(" ") : l3;
      var b2 = i.config.legend.labels.useSeriesColors ? i.globals.colors[e3] : Array.isArray(i.config.legend.labels.colors) ? null === (n3 = i.config.legend.labels.colors) || void 0 === n3 ? void 0 : n3[e3] : i.config.legend.labels.colors;
      b2 || (b2 = i.config.chart.foreColor), x2.style.color = b2, x2.style.fontSize = parseFloat(i.config.legend.fontSize) + "px", x2.style.fontWeight = i.config.legend.fontWeight, x2.style.fontFamily = a2 || i.config.chart.fontFamily, Mi.setAttrs(x2, { rel: e3 + 1, i: e3, "data:default-text": encodeURIComponent(l3), "data:collapsed": c3 || d3 }), f2.appendChild(p2), f2.appendChild(x2);
      var m2 = new Pi(t3.ctx);
      i.config.legend.showForZeroSeries || 0 === m2.getSeriesTotalByIndex(e3) && m2.seriesHaveSameValues(e3) && !m2.isSeriesNull(e3) && -1 === i.globals.collapsedSeriesIndices.indexOf(e3) && -1 === i.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) && f2.classList.add("apexcharts-hidden-zero-series");
      i.config.legend.showForNullSeries || m2.isSeriesNull(e3) && -1 === i.globals.collapsedSeriesIndices.indexOf(e3) && -1 === i.globals.ancillaryCollapsedSeriesIndices.indexOf(e3) && f2.classList.add("apexcharts-hidden-null-series"), h2.length ? i.globals.seriesGroups.forEach(function(t4, a3) {
        var s3;
        t4.includes(null === (s3 = i.config.series[e3]) || void 0 === s3 ? void 0 : s3.name) && (i.globals.dom.elLegendWrap.appendChild(h2[a3]), h2[a3].appendChild(f2));
      }) : i.globals.dom.elLegendWrap.appendChild(f2), i.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(i.config.legend.horizontalAlign)), i.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + i.config.legend.position), f2.classList.add("apexcharts-legend-series"), f2.style.margin = "".concat(i.config.legend.itemMargin.vertical, "px ").concat(i.config.legend.itemMargin.horizontal, "px"), i.globals.dom.elLegendWrap.style.width = i.config.legend.width ? i.config.legend.width + "px" : "", i.globals.dom.elLegendWrap.style.height = i.config.legend.height ? i.config.legend.height + "px" : "", Mi.setAttrs(f2, { rel: e3 + 1, seriesName: v.escapeString(s2[e3]), "data:collapsed": c3 || d3 }), (c3 || d3) && f2.classList.add("apexcharts-inactive-legend"), i.config.legend.onItemClick.toggleDataSeries || f2.classList.add("apexcharts-no-click");
    }, d2 = l2 ? s2.length - 1 : 0; l2 ? d2 >= 0 : d2 <= s2.length - 1; l2 ? d2-- : d2++)
      c2(d2);
    i.globals.dom.elWrap.addEventListener("click", e2.onLegendClick, true), i.config.legend.onItemHover.highlightDataSeries && 0 === i.config.legend.customLegendItems.length && (i.globals.dom.elWrap.addEventListener("mousemove", e2.onLegendHovered, true), i.globals.dom.elWrap.addEventListener("mouseout", e2.onLegendHovered, true));
  } }, { key: "setLegendWrapXY", value: function(t3, e2) {
    var i = this.w, a2 = i.globals.dom.elLegendWrap, s2 = a2.clientHeight, r2 = 0, n2 = 0;
    if ("bottom" === i.config.legend.position)
      n2 = i.globals.svgHeight - Math.min(s2, i.globals.svgHeight / 2) - 5;
    else if ("top" === i.config.legend.position) {
      var o2 = new pa(this.ctx), l2 = o2.dimHelpers.getTitleSubtitleCoords("title").height, h2 = o2.dimHelpers.getTitleSubtitleCoords("subtitle").height;
      n2 = (l2 > 0 ? l2 - 10 : 0) + (h2 > 0 ? h2 - 10 : 0);
    }
    a2.style.position = "absolute", r2 = r2 + t3 + i.config.legend.offsetX, n2 = n2 + e2 + i.config.legend.offsetY, a2.style.left = r2 + "px", a2.style.top = n2 + "px", "right" === i.config.legend.position && (a2.style.left = "auto", a2.style.right = 25 + i.config.legend.offsetX + "px");
    ["width", "height"].forEach(function(t4) {
      a2.style[t4] && (a2.style[t4] = parseInt(i.config.legend[t4], 10) + "px");
    });
  } }, { key: "legendAlignHorizontal", value: function() {
    var t3 = this.w;
    t3.globals.dom.elLegendWrap.style.right = 0;
    var e2 = new pa(this.ctx), i = e2.dimHelpers.getTitleSubtitleCoords("title"), a2 = e2.dimHelpers.getTitleSubtitleCoords("subtitle"), s2 = 0;
    "top" === t3.config.legend.position && (s2 = i.height + a2.height + t3.config.title.margin + t3.config.subtitle.margin - 10), this.setLegendWrapXY(20, s2);
  } }, { key: "legendAlignVertical", value: function() {
    var t3 = this.w, e2 = this.legendHelpers.getLegendDimensions(), i = 0;
    "left" === t3.config.legend.position && (i = 20), "right" === t3.config.legend.position && (i = t3.globals.svgWidth - e2.clww - 10), this.setLegendWrapXY(i, 20);
  } }, { key: "onLegendHovered", value: function(t3) {
    var e2 = this.w, i = t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker");
    if ("heatmap" === e2.config.chart.type || this.isBarsDistributed) {
      if (i) {
        var a2 = parseInt(t3.target.getAttribute("rel"), 10) - 1;
        this.ctx.events.fireEvent("legendHover", [this.ctx, a2, this.w]), new Zi(this.ctx).highlightRangeInSeries(t3, t3.target);
      }
    } else
      !t3.target.classList.contains("apexcharts-inactive-legend") && i && new Zi(this.ctx).toggleSeriesOnHover(t3, t3.target);
  } }, { key: "onLegendClick", value: function(t3) {
    var e2 = this.w;
    if (!e2.config.legend.customLegendItems.length && (t3.target.classList.contains("apexcharts-legend-series") || t3.target.classList.contains("apexcharts-legend-text") || t3.target.classList.contains("apexcharts-legend-marker"))) {
      var i = parseInt(t3.target.getAttribute("rel"), 10) - 1, a2 = "true" === t3.target.getAttribute("data:collapsed"), s2 = this.w.config.chart.events.legendClick;
      "function" == typeof s2 && s2(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
      var r2 = this.w.config.legend.markers.onClick;
      "function" == typeof r2 && t3.target.classList.contains("apexcharts-legend-marker") && (r2(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), "treemap" !== e2.config.chart.type && "heatmap" !== e2.config.chart.type && !this.isBarsDistributed && e2.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, a2);
    }
  } }]), t2;
}(), ba = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = a2.globals.minX, this.maxX = a2.globals.maxX;
  }
  return s(t2, [{ key: "createToolbar", value: function() {
    var t3 = this, e2 = this.w, i = function() {
      return document.createElement("div");
    }, a2 = i();
    if (a2.setAttribute("class", "apexcharts-toolbar"), a2.style.top = e2.config.chart.toolbar.offsetY + "px", a2.style.right = 3 - e2.config.chart.toolbar.offsetX + "px", e2.globals.dom.elWrap.appendChild(a2), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e2.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
      for (var s2 = 0; s2 < this.t.customIcons.length; s2++)
        this.elCustomIcons.push(i());
    var r2 = [], n2 = function(i2, a3, s3) {
      var n3 = i2.toLowerCase();
      t3.t[n3] && e2.config.chart.zoom.enabled && r2.push({ el: a3, icon: "string" == typeof t3.t[n3] ? t3.t[n3] : s3, title: t3.localeValues[i2], class: "apexcharts-".concat(n3, "-icon") });
    };
    n2("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), n2("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
    var o2 = function(i2) {
      t3.t[i2] && e2.config.chart[i2].enabled && r2.push({ el: "zoom" === i2 ? t3.elZoom : t3.elSelection, icon: "string" == typeof t3.t[i2] ? t3.t[i2] : "zoom" === i2 ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>', title: t3.localeValues["zoom" === i2 ? "selectionZoom" : "selection"], class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i2, "-icon") });
    };
    o2("zoom"), o2("selection"), this.t.pan && e2.config.chart.zoom.enabled && r2.push({ el: this.elPan, icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>', title: this.localeValues.pan, class: e2.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon" }), n2("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && r2.push({ el: this.elMenuIcon, icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>', title: this.localeValues.menu, class: "apexcharts-menu-icon" });
    for (var l2 = 0; l2 < this.elCustomIcons.length; l2++)
      r2.push({ el: this.elCustomIcons[l2], icon: this.t.customIcons[l2].icon, title: this.t.customIcons[l2].title, index: this.t.customIcons[l2].index, class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l2].class });
    r2.forEach(function(t4, e3) {
      t4.index && v.moveIndexInArray(r2, e3, t4.index);
    });
    for (var h2 = 0; h2 < r2.length; h2++)
      Mi.setAttrs(r2[h2].el, { class: r2[h2].class, title: r2[h2].title }), r2[h2].el.innerHTML = r2[h2].icon, a2.appendChild(r2[h2].el);
    this._createHamburgerMenu(a2), e2.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e2.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e2.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners();
  } }, { key: "_createHamburgerMenu", value: function(t3) {
    this.elMenuItems = [], t3.appendChild(this.elMenu), Mi.setAttrs(this.elMenu, { class: "apexcharts-menu" });
    for (var e2 = [{ name: "exportSVG", title: this.localeValues.exportToSVG }, { name: "exportPNG", title: this.localeValues.exportToPNG }, { name: "exportCSV", title: this.localeValues.exportToCSV }], i = 0; i < e2.length; i++)
      this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e2[i].title, Mi.setAttrs(this.elMenuItems[i], { class: "apexcharts-menu-item ".concat(e2[i].name), title: e2[i].title }), this.elMenu.appendChild(this.elMenuItems[i]);
  } }, { key: "addToolbarEventListeners", value: function() {
    var t3 = this;
    this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach(function(e3) {
      e3.classList.contains("exportSVG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "svg")) : e3.classList.contains("exportPNG") ? e3.addEventListener("click", t3.handleDownload.bind(t3, "png")) : e3.classList.contains("exportCSV") && e3.addEventListener("click", t3.handleDownload.bind(t3, "csv"));
    });
    for (var e2 = 0; e2 < this.t.customIcons.length; e2++)
      this.elCustomIcons[e2].addEventListener("click", this.t.customIcons[e2].click.bind(this, this.ctx, this.ctx.w));
  } }, { key: "toggleZoomSelection", value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(e2) {
      e2.ctx.toolbar.toggleOtherControls();
      var i = "selection" === t3 ? e2.ctx.toolbar.elSelection : e2.ctx.toolbar.elZoom, a2 = "selection" === t3 ? "selectionEnabled" : "zoomEnabled";
      e2.w.globals[a2] = !e2.w.globals[a2], i.classList.contains(e2.ctx.toolbar.selectedClass) ? i.classList.remove(e2.ctx.toolbar.selectedClass) : i.classList.add(e2.ctx.toolbar.selectedClass);
    });
  } }, { key: "getToolbarIconsReference", value: function() {
    var t3 = this.w;
    this.elZoom || (this.elZoom = t3.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t3.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t3.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"));
  } }, { key: "enableZoomPanFromToolbar", value: function(t3) {
    this.toggleOtherControls(), "pan" === t3 ? this.w.globals.panEnabled = true : this.w.globals.zoomEnabled = true;
    var e2 = "pan" === t3 ? this.elPan : this.elZoom, i = "pan" === t3 ? this.elZoom : this.elPan;
    e2 && e2.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass);
  } }, { key: "togglePanning", value: function() {
    this.ctx.getSyncedCharts().forEach(function(t3) {
      t3.ctx.toolbar.toggleOtherControls(), t3.w.globals.panEnabled = !t3.w.globals.panEnabled, t3.ctx.toolbar.elPan.classList.contains(t3.ctx.toolbar.selectedClass) ? t3.ctx.toolbar.elPan.classList.remove(t3.ctx.toolbar.selectedClass) : t3.ctx.toolbar.elPan.classList.add(t3.ctx.toolbar.selectedClass);
    });
  } }, { key: "toggleOtherControls", value: function() {
    var t3 = this, e2 = this.w;
    e2.globals.panEnabled = false, e2.globals.zoomEnabled = false, e2.globals.selectionEnabled = false, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach(function(e3) {
      e3 && e3.classList.remove(t3.selectedClass);
    });
  } }, { key: "handleZoomIn", value: function() {
    var t3 = this.w;
    t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY);
    var e2 = (this.minX + this.maxX) / 2, i = (this.minX + e2) / 2, a2 = (this.maxX + e2) / 2, s2 = this._getNewMinXMaxX(i, a2);
    t3.globals.disableZoomIn || this.zoomUpdateOptions(s2.minX, s2.maxX);
  } }, { key: "handleZoomOut", value: function() {
    var t3 = this.w;
    if (t3.globals.isRangeBar && (this.minX = t3.globals.minY, this.maxX = t3.globals.maxY), !("datetime" === t3.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
      var e2 = (this.minX + this.maxX) / 2, i = this.minX - (e2 - this.minX), a2 = this.maxX - (e2 - this.maxX), s2 = this._getNewMinXMaxX(i, a2);
      t3.globals.disableZoomOut || this.zoomUpdateOptions(s2.minX, s2.maxX);
    }
  } }, { key: "_getNewMinXMaxX", value: function(t3, e2) {
    var i = this.w.config.xaxis.convertedCatToNumeric;
    return { minX: i ? Math.floor(t3) : t3, maxX: i ? Math.floor(e2) : e2 };
  } }, { key: "zoomUpdateOptions", value: function(t3, e2) {
    var i = this.w;
    if (void 0 !== t3 || void 0 !== e2) {
      if (!(i.config.xaxis.convertedCatToNumeric && (t3 < 1 && (t3 = 1, e2 = i.globals.dataPoints), e2 - t3 < 2))) {
        var a2 = { min: t3, max: e2 }, s2 = this.getBeforeZoomRange(a2);
        s2 && (a2 = s2.xaxis);
        var r2 = { xaxis: a2 }, n2 = v.clone(i.globals.initialConfig.yaxis);
        i.config.chart.group || (r2.yaxis = n2), this.w.globals.zoomed = true, this.ctx.updateHelpers._updateOptions(r2, false, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a2, n2);
      }
    } else
      this.handleZoomReset();
  } }, { key: "zoomCallback", value: function(t3, e2) {
    "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, { xaxis: t3, yaxis: e2 });
  } }, { key: "getBeforeZoomRange", value: function(t3, e2) {
    var i = null;
    return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, { xaxis: t3, yaxis: e2 })), i;
  } }, { key: "toggleMenu", value: function() {
    var t3 = this;
    window.setTimeout(function() {
      t3.elMenu.classList.contains("apexcharts-menu-open") ? t3.elMenu.classList.remove("apexcharts-menu-open") : t3.elMenu.classList.add("apexcharts-menu-open");
    }, 0);
  } }, { key: "handleDownload", value: function(t3) {
    var e2 = this.w, i = new Ji(this.ctx);
    switch (t3) {
      case "svg":
        i.exportToSVG(this.ctx);
        break;
      case "png":
        i.exportToPng(this.ctx);
        break;
      case "csv":
        i.exportToCSV({ series: e2.config.series, columnDelimiter: e2.config.chart.toolbar.export.csv.columnDelimiter });
    }
  } }, { key: "handleZoomReset", value: function(t3) {
    this.ctx.getSyncedCharts().forEach(function(t4) {
      var e2 = t4.w;
      if (e2.globals.lastXAxis.min = e2.globals.initialConfig.xaxis.min, e2.globals.lastXAxis.max = e2.globals.initialConfig.xaxis.max, t4.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e2.config.chart.events.beforeResetZoom) {
        var i = e2.config.chart.events.beforeResetZoom(t4, e2);
        i && t4.updateHelpers.revertDefaultAxisMinMax(i);
      }
      "function" == typeof e2.config.chart.events.zoomed && t4.ctx.toolbar.zoomCallback({ min: e2.config.xaxis.min, max: e2.config.xaxis.max }), e2.globals.zoomed = false;
      var a2 = t4.ctx.series.emptyCollapsedSeries(v.clone(e2.globals.initialSeries));
      t4.updateHelpers._updateSeries(a2, e2.config.chart.animations.dynamicAnimation.enabled);
    });
  } }, { key: "destroy", value: function() {
    this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null;
  } }]), t2;
}(), ma = function(t2) {
  h(a2, ba);
  var e2 = n(a2);
  function a2(t3) {
    var s2;
    return i$1(this, a2), (s2 = e2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.dragged = false, s2.graphics = new Mi(s2.ctx), s2.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend", "wheel"], s2.clientX = 0, s2.clientY = 0, s2.startX = 0, s2.endX = 0, s2.dragX = 0, s2.startY = 0, s2.endY = 0, s2.dragY = 0, s2.moveDirection = "none", s2.debounceTimer = null, s2.debounceDelay = 100, s2.wheelDelay = 400, s2;
  }
  return s(a2, [{ key: "init", value: function(t3) {
    var e3 = this, i = t3.xyRatios, a3 = this.w, s2 = this;
    this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a3.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.constraints = new kt(0, 0, a3.globals.gridWidth, a3.globals.gridHeight), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a3.globals.dom.Paper.add(this.zoomRect), a3.globals.dom.Paper.add(this.selectionRect), "x" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, minY: 0, maxX: a3.globals.gridWidth, maxY: a3.globals.gridHeight }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : "y" === a3.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({ minX: 0, maxX: a3.globals.gridWidth }).on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove.namespace", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a3.globals.dom.baseEl.querySelector("".concat(a3.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach(function(t4) {
      e3.hoverArea.addEventListener(t4, s2.svgMouseEvents.bind(s2, i), { capture: false, passive: true });
    }), a3.config.chart.zoom.enabled && a3.config.chart.zoom.allowMouseWheelZoom && this.hoverArea.addEventListener("wheel", s2.mouseWheelEvent.bind(s2), { capture: false, passive: false });
  } }, { key: "destroy", value: function() {
    this.slDraggableRect && (this.slDraggableRect.draggable(false), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null;
  } }, { key: "svgMouseEvents", value: function(t3, e3) {
    var i = this.w, a3 = this.ctx.toolbar, s2 = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type, r2 = i.config.chart.toolbar.autoSelected;
    if (e3.shiftKey ? (this.shiftWasPressed = true, a3.enableZoomPanFromToolbar("pan" === r2 ? "zoom" : "pan")) : this.shiftWasPressed && (a3.enableZoomPanFromToolbar(r2), this.shiftWasPressed = false), e3.target) {
      var n2, o2 = e3.target.classList;
      if (e3.target.parentNode && null !== e3.target.parentNode && (n2 = e3.target.parentNode.classList), !(o2.contains("apexcharts-legend-marker") || o2.contains("apexcharts-legend-text") || n2 && n2.contains("apexcharts-toolbar"))) {
        if (this.clientX = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientX : "touchend" === e3.type ? e3.changedTouches[0].clientX : e3.clientX, this.clientY = "touchmove" === e3.type || "touchstart" === e3.type ? e3.touches[0].clientY : "touchend" === e3.type ? e3.changedTouches[0].clientY : e3.clientY, "mousedown" === e3.type && 1 === e3.which || "touchstart" === e3.type) {
          var l2 = this.gridRect.getBoundingClientRect();
          this.startX = this.clientX - l2.left - i.globals.barPadForNumericAxis, this.startY = this.clientY - l2.top, this.dragged = false, this.w.globals.mousedown = true;
        }
        ("mousemove" === e3.type && 1 === e3.which || "touchmove" === e3.type) && (this.dragged = true, i.globals.panEnabled ? (i.globals.selection = null, this.w.globals.mousedown && this.panDragging({ context: this, zoomtype: s2, xyRatios: t3 })) : (this.w.globals.mousedown && i.globals.zoomEnabled || this.w.globals.mousedown && i.globals.selectionEnabled) && (this.selection = this.selectionDrawing({ context: this, zoomtype: s2 }))), "mouseup" !== e3.type && "touchend" !== e3.type && "mouseleave" !== e3.type || this.handleMouseUp({ zoomtype: s2 }), this.makeSelectionRectDraggable();
      }
    }
  } }, { key: "handleMouseUp", value: function(t3) {
    var e3, i = t3.zoomtype, a3 = t3.isResized, s2 = this.w, r2 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    r2 && (this.w.globals.mousedown || a3) && (this.endX = this.clientX - r2.left - s2.globals.barPadForNumericAxis, this.endY = this.clientY - r2.top, this.dragX = Math.abs(this.endX - this.startX), this.dragY = Math.abs(this.endY - this.startY), (s2.globals.zoomEnabled || s2.globals.selectionEnabled) && this.selectionDrawn({ context: this, zoomtype: i }), s2.globals.panEnabled && s2.config.xaxis.convertedCatToNumeric && this.delayedPanScrolled()), s2.globals.zoomEnabled && this.hideSelectionRect(this.selectionRect), this.dragged = false, this.w.globals.mousedown = false;
  } }, { key: "mouseWheelEvent", value: function(t3) {
    var e3 = this, i = this.w;
    t3.preventDefault();
    var a3 = Date.now();
    a3 - i.globals.lastWheelExecution > this.wheelDelay && (this.executeMouseWheelZoom(t3), i.globals.lastWheelExecution = a3), this.debounceTimer && clearTimeout(this.debounceTimer), this.debounceTimer = setTimeout(function() {
      a3 - i.globals.lastWheelExecution > e3.wheelDelay && (e3.executeMouseWheelZoom(t3), i.globals.lastWheelExecution = a3);
    }, this.debounceDelay);
  } }, { key: "executeMouseWheelZoom", value: function(t3) {
    var e3, i = this.w;
    this.minX = i.globals.isRangeBar ? i.globals.minY : i.globals.minX, this.maxX = i.globals.isRangeBar ? i.globals.maxY : i.globals.maxX;
    var a3 = null === (e3 = this.gridRect) || void 0 === e3 ? void 0 : e3.getBoundingClientRect();
    if (a3) {
      var s2, r2, n2, o2 = (t3.clientX - a3.left) / a3.width, l2 = this.minX, h2 = this.maxX, c2 = h2 - l2;
      if (t3.deltaY < 0) {
        var d2 = l2 + o2 * c2;
        r2 = d2 - (s2 = 0.5 * c2) / 2, n2 = d2 + s2 / 2;
      } else
        r2 = l2 - (s2 = 1.5 * c2) / 2, n2 = h2 + s2 / 2;
      if (!i.globals.isRangeBar) {
        r2 = Math.max(r2, i.globals.initialMinX), n2 = Math.min(n2, i.globals.initialMaxX);
        var u2 = 0.01 * (i.globals.initialMaxX - i.globals.initialMinX);
        if (n2 - r2 < u2) {
          var g2 = (r2 + n2) / 2;
          r2 = g2 - u2 / 2, n2 = g2 + u2 / 2;
        }
      }
      var p2 = this._getNewMinXMaxX(r2, n2);
      isNaN(p2.minX) || isNaN(p2.maxX) || this.zoomUpdateOptions(p2.minX, p2.maxX);
    }
  } }, { key: "makeSelectionRectDraggable", value: function() {
    var t3 = this, e3 = this.w;
    if (this.selectionRect) {
      var i = this.selectionRect.node.getBoundingClientRect();
      i.width > 0 && i.height > 0 && (this.selectionRect.select(false).resize(false), this.selectionRect.select({ createRot: function() {
      }, updateRot: function() {
      }, createHandle: function(t4, e4, i2, a3, s2) {
        return "l" === s2 || "r" === s2 ? t4.circle(8).css({ "stroke-width": 1, stroke: "#333", fill: "#fff" }) : t4.circle(0);
      }, updateHandle: function(t4, e4) {
        return t4.center(e4[0], e4[1]);
      } }).resize().on("resize", function() {
        var i2 = e3.globals.zoomEnabled ? e3.config.chart.zoom.type : e3.config.chart.selection.type;
        t3.handleMouseUp({ zoomtype: i2, isResized: true });
      }));
    }
  } }, { key: "preselectedSelection", value: function() {
    var t3 = this.w, e3 = this.xyRatios;
    if (!t3.globals.zoomEnabled) {
      if (void 0 !== t3.globals.selection && null !== t3.globals.selection)
        this.drawSelectionRect(u(u({}, t3.globals.selection), {}, { translateX: t3.globals.translateX, translateY: t3.globals.translateY }));
      else if (void 0 !== t3.config.chart.selection.xaxis.min && void 0 !== t3.config.chart.selection.xaxis.max) {
        var i = (t3.config.chart.selection.xaxis.min - t3.globals.minX) / e3.xRatio, a3 = t3.globals.gridWidth - (t3.globals.maxX - t3.config.chart.selection.xaxis.max) / e3.xRatio - i;
        t3.globals.isRangeBar && (i = (t3.config.chart.selection.xaxis.min - t3.globals.yAxisScale[0].niceMin) / e3.invertedYRatio, a3 = (t3.config.chart.selection.xaxis.max - t3.config.chart.selection.xaxis.min) / e3.invertedYRatio);
        var s2 = { x: i, y: 0, width: a3, height: t3.globals.gridHeight, translateX: t3.globals.translateX, translateY: t3.globals.translateY, selectionEnabled: true };
        this.drawSelectionRect(s2), this.makeSelectionRectDraggable(), "function" == typeof t3.config.chart.events.selection && t3.config.chart.events.selection(this.ctx, { xaxis: { min: t3.config.chart.selection.xaxis.min, max: t3.config.chart.selection.xaxis.max }, yaxis: {} });
      }
    }
  } }, { key: "drawSelectionRect", value: function(t3) {
    var e3 = t3.x, i = t3.y, a3 = t3.width, s2 = t3.height, r2 = t3.translateX, n2 = void 0 === r2 ? 0 : r2, o2 = t3.translateY, l2 = void 0 === o2 ? 0 : o2, h2 = this.w, c2 = this.zoomRect, d2 = this.selectionRect;
    if (this.dragged || null !== h2.globals.selection) {
      var u2 = { transform: "translate(" + n2 + ", " + l2 + ")" };
      h2.globals.zoomEnabled && this.dragged && (a3 < 0 && (a3 = 1), c2.attr({ x: e3, y: i, width: a3, height: s2, fill: h2.config.chart.zoom.zoomedArea.fill.color, "fill-opacity": h2.config.chart.zoom.zoomedArea.fill.opacity, stroke: h2.config.chart.zoom.zoomedArea.stroke.color, "stroke-width": h2.config.chart.zoom.zoomedArea.stroke.width, "stroke-opacity": h2.config.chart.zoom.zoomedArea.stroke.opacity }), Mi.setAttrs(c2.node, u2)), h2.globals.selectionEnabled && (d2.attr({ x: e3, y: i, width: a3 > 0 ? a3 : 0, height: s2 > 0 ? s2 : 0, fill: h2.config.chart.selection.fill.color, "fill-opacity": h2.config.chart.selection.fill.opacity, stroke: h2.config.chart.selection.stroke.color, "stroke-width": h2.config.chart.selection.stroke.width, "stroke-dasharray": h2.config.chart.selection.stroke.dashArray, "stroke-opacity": h2.config.chart.selection.stroke.opacity }), Mi.setAttrs(d2.node, u2));
    }
  } }, { key: "hideSelectionRect", value: function(t3) {
    t3 && t3.attr({ x: 0, y: 0, width: 0, height: 0 });
  } }, { key: "selectionDrawing", value: function(t3) {
    var e3 = t3.context, i = t3.zoomtype, a3 = this.w, s2 = e3, r2 = this.gridRect.getBoundingClientRect(), n2 = s2.startX - 1, o2 = s2.startY, l2 = false, h2 = false, c2 = s2.clientX - r2.left - a3.globals.barPadForNumericAxis, d2 = s2.clientY - r2.top, g2 = c2 - n2, p2 = d2 - o2, f2 = { translateX: a3.globals.translateX, translateY: a3.globals.translateY };
    return Math.abs(g2 + n2) > a3.globals.gridWidth ? g2 = a3.globals.gridWidth - n2 : c2 < 0 && (g2 = n2), n2 > c2 && (l2 = true, g2 = Math.abs(g2)), o2 > d2 && (h2 = true, p2 = Math.abs(p2)), f2 = u(u({}, f2 = "x" === i ? { x: l2 ? n2 - g2 : n2, y: 0, width: g2, height: a3.globals.gridHeight } : "y" === i ? { x: 0, y: h2 ? o2 - p2 : o2, width: a3.globals.gridWidth, height: p2 } : { x: l2 ? n2 - g2 : n2, y: h2 ? o2 - p2 : o2, width: g2, height: p2 }), {}, { translateX: a3.globals.translateX, translateY: a3.globals.translateY }), s2.drawSelectionRect(f2), s2.selectionDragging("resizing"), f2;
  } }, { key: "selectionDragging", value: function(t3, e3) {
    var i = this, a3 = this.w;
    if (e3) {
      e3.preventDefault();
      var s2 = e3.detail, r2 = s2.handler, n2 = s2.box, o2 = n2.x, l2 = n2.y;
      o2 < this.constraints.x && (o2 = this.constraints.x), l2 < this.constraints.y && (l2 = this.constraints.y), n2.x2 > this.constraints.x2 && (o2 = this.constraints.x2 - n2.w), n2.y2 > this.constraints.y2 && (l2 = this.constraints.y2 - n2.h), r2.move(o2, l2);
      var h2 = this.xyRatios, c2 = this.selectionRect, d2 = 0;
      "resizing" === t3 && (d2 = 30);
      var u2 = function(t4) {
        return parseFloat(c2.node.getAttribute(t4));
      }, g2 = { x: u2("x"), y: u2("y"), width: u2("width"), height: u2("height") };
      a3.globals.selection = g2, "function" == typeof a3.config.chart.events.selection && a3.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout(function() {
        var t4, e4, s3, r3, n3 = i.gridRect.getBoundingClientRect(), o3 = c2.node.getBoundingClientRect();
        a3.globals.isRangeBar ? (t4 = a3.globals.yAxisScale[0].niceMin + (o3.left - n3.left) * h2.invertedYRatio, e4 = a3.globals.yAxisScale[0].niceMin + (o3.right - n3.left) * h2.invertedYRatio, s3 = 0, r3 = 1) : (t4 = a3.globals.xAxisScale.niceMin + (o3.left - n3.left) * h2.xRatio, e4 = a3.globals.xAxisScale.niceMin + (o3.right - n3.left) * h2.xRatio, s3 = a3.globals.yAxisScale[0].niceMin + (n3.bottom - o3.bottom) * h2.yRatio[0], r3 = a3.globals.yAxisScale[0].niceMax - (o3.top - n3.top) * h2.yRatio[0]);
        var l3 = { xaxis: { min: t4, max: e4 }, yaxis: { min: s3, max: r3 } };
        a3.config.chart.events.selection(i.ctx, l3), a3.config.chart.brush.enabled && void 0 !== a3.config.chart.events.brushScrolled && a3.config.chart.events.brushScrolled(i.ctx, l3);
      }, d2));
    }
  } }, { key: "selectionDrawn", value: function(t3) {
    var e3, i, a3 = t3.context, s2 = t3.zoomtype, r2 = this.w, n2 = a3, o2 = this.xyRatios, l2 = this.ctx.toolbar, h2 = r2.globals.zoomEnabled ? n2.zoomRect.node.getBoundingClientRect() : n2.selectionRect.node.getBoundingClientRect(), c2 = n2.gridRect.getBoundingClientRect(), d2 = h2.left - c2.left - r2.globals.barPadForNumericAxis, u2 = h2.right - c2.left - r2.globals.barPadForNumericAxis, g2 = h2.top - c2.top, p2 = h2.bottom - c2.top;
    r2.globals.isRangeBar ? (e3 = r2.globals.yAxisScale[0].niceMin + d2 * o2.invertedYRatio, i = r2.globals.yAxisScale[0].niceMin + u2 * o2.invertedYRatio) : (e3 = r2.globals.xAxisScale.niceMin + d2 * o2.xRatio, i = r2.globals.xAxisScale.niceMin + u2 * o2.xRatio);
    var f2 = [], x2 = [];
    if (r2.config.yaxis.forEach(function(t4, e4) {
      var i2 = r2.globals.seriesYAxisMap[e4][0], a4 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i2] * g2, s3 = r2.globals.yAxisScale[e4].niceMax - o2.yRatio[i2] * p2;
      f2.push(a4), x2.push(s3);
    }), n2.dragged && (n2.dragX > 10 || n2.dragY > 10) && e3 !== i) {
      if (r2.globals.zoomEnabled) {
        var b2 = v.clone(r2.globals.initialConfig.yaxis), m2 = v.clone(r2.globals.initialConfig.xaxis);
        if (r2.globals.zoomed = true, r2.config.xaxis.convertedCatToNumeric && (e3 = Math.floor(e3), i = Math.floor(i), e3 < 1 && (e3 = 1, i = r2.globals.dataPoints), i - e3 < 2 && (i = e3 + 1)), "xy" !== s2 && "x" !== s2 || (m2 = { min: e3, max: i }), "xy" !== s2 && "y" !== s2 || b2.forEach(function(t4, e4) {
          b2[e4].min = x2[e4], b2[e4].max = f2[e4];
        }), l2) {
          var y2 = l2.getBeforeZoomRange(m2, b2);
          y2 && (m2 = y2.xaxis ? y2.xaxis : m2, b2 = y2.yaxis ? y2.yaxis : b2);
        }
        var w2 = { xaxis: m2 };
        r2.config.chart.group || (w2.yaxis = b2), n2.ctx.updateHelpers._updateOptions(w2, false, n2.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof r2.config.chart.events.zoomed && l2.zoomCallback(m2, b2);
      } else if (r2.globals.selectionEnabled) {
        var k2, A2 = null;
        k2 = { min: e3, max: i }, "xy" !== s2 && "y" !== s2 || (A2 = v.clone(r2.config.yaxis)).forEach(function(t4, e4) {
          A2[e4].min = x2[e4], A2[e4].max = f2[e4];
        }), r2.globals.selection = n2.selection, "function" == typeof r2.config.chart.events.selection && r2.config.chart.events.selection(n2.ctx, { xaxis: k2, yaxis: A2 });
      }
    }
  } }, { key: "panDragging", value: function(t3) {
    var e3 = t3.context, i = this.w, a3 = e3;
    if (void 0 !== i.globals.lastClientPosition.x) {
      var s2 = i.globals.lastClientPosition.x - a3.clientX, r2 = i.globals.lastClientPosition.y - a3.clientY;
      Math.abs(s2) > Math.abs(r2) && s2 > 0 ? this.moveDirection = "left" : Math.abs(s2) > Math.abs(r2) && s2 < 0 ? this.moveDirection = "right" : Math.abs(r2) > Math.abs(s2) && r2 > 0 ? this.moveDirection = "up" : Math.abs(r2) > Math.abs(s2) && r2 < 0 && (this.moveDirection = "down");
    }
    i.globals.lastClientPosition = { x: a3.clientX, y: a3.clientY };
    var n2 = i.globals.isRangeBar ? i.globals.minY : i.globals.minX, o2 = i.globals.isRangeBar ? i.globals.maxY : i.globals.maxX;
    i.config.xaxis.convertedCatToNumeric || a3.panScrolled(n2, o2);
  } }, { key: "delayedPanScrolled", value: function() {
    var t3 = this.w, e3 = t3.globals.minX, i = t3.globals.maxX, a3 = (t3.globals.maxX - t3.globals.minX) / 2;
    "left" === this.moveDirection ? (e3 = t3.globals.minX + a3, i = t3.globals.maxX + a3) : "right" === this.moveDirection && (e3 = t3.globals.minX - a3, i = t3.globals.maxX - a3), e3 = Math.floor(e3), i = Math.floor(i), this.updateScrolledChart({ xaxis: { min: e3, max: i } }, e3, i);
  } }, { key: "panScrolled", value: function(t3, e3) {
    var i = this.w, a3 = this.xyRatios, s2 = v.clone(i.globals.initialConfig.yaxis), r2 = a3.xRatio, n2 = i.globals.minX, o2 = i.globals.maxX;
    i.globals.isRangeBar && (r2 = a3.invertedYRatio, n2 = i.globals.minY, o2 = i.globals.maxY), "left" === this.moveDirection ? (t3 = n2 + i.globals.gridWidth / 15 * r2, e3 = o2 + i.globals.gridWidth / 15 * r2) : "right" === this.moveDirection && (t3 = n2 - i.globals.gridWidth / 15 * r2, e3 = o2 - i.globals.gridWidth / 15 * r2), i.globals.isRangeBar || (t3 < i.globals.initialMinX || e3 > i.globals.initialMaxX) && (t3 = n2, e3 = o2);
    var l2 = { xaxis: { min: t3, max: e3 } };
    i.config.chart.group || (l2.yaxis = s2), this.updateScrolledChart(l2, t3, e3);
  } }, { key: "updateScrolledChart", value: function(t3, e3, i) {
    var a3 = this.w;
    this.ctx.updateHelpers._updateOptions(t3, false, false), "function" == typeof a3.config.chart.events.scrolled && a3.config.chart.events.scrolled(this.ctx, { xaxis: { min: e3, max: i } });
  } }]), a2;
}(), va = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx;
  }
  return s(t2, [{ key: "getNearestValues", value: function(t3) {
    var e2 = t3.hoverArea, i = t3.elGrid, a2 = t3.clientX, s2 = t3.clientY, r2 = this.w, n2 = i.getBoundingClientRect(), o2 = n2.width, l2 = n2.height, h2 = o2 / (r2.globals.dataPoints - 1), c2 = l2 / r2.globals.dataPoints, d2 = this.hasBars();
    !r2.globals.comboCharts && !d2 || r2.config.xaxis.convertedCatToNumeric || (h2 = o2 / r2.globals.dataPoints);
    var u2 = a2 - n2.left - r2.globals.barPadForNumericAxis, g2 = s2 - n2.top;
    u2 < 0 || g2 < 0 || u2 > o2 || g2 > l2 ? (e2.classList.remove("hovering-zoom"), e2.classList.remove("hovering-pan")) : r2.globals.zoomEnabled ? (e2.classList.remove("hovering-pan"), e2.classList.add("hovering-zoom")) : r2.globals.panEnabled && (e2.classList.remove("hovering-zoom"), e2.classList.add("hovering-pan"));
    var p2 = Math.round(u2 / h2), f2 = Math.floor(g2 / c2);
    d2 && !r2.config.xaxis.convertedCatToNumeric && (p2 = Math.ceil(u2 / h2), p2 -= 1);
    var x2 = null, b2 = null, m2 = r2.globals.seriesXvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    }), y2 = r2.globals.seriesYvalues.map(function(t4) {
      return t4.filter(function(t5) {
        return v.isNumber(t5);
      });
    });
    if (r2.globals.isXNumeric) {
      var w2 = this.ttCtx.getElGrid().getBoundingClientRect(), k2 = u2 * (w2.width / o2), A2 = g2 * (w2.height / l2);
      x2 = (b2 = this.closestInMultiArray(k2, A2, m2, y2)).index, p2 = b2.j, null !== x2 && r2.globals.hasNullValues && (m2 = r2.globals.seriesXvalues[x2], p2 = (b2 = this.closestInArray(k2, m2)).j);
    }
    return r2.globals.capturedSeriesIndex = null === x2 ? -1 : x2, (!p2 || p2 < 1) && (p2 = 0), r2.globals.isBarHorizontal ? r2.globals.capturedDataPointIndex = f2 : r2.globals.capturedDataPointIndex = p2, { capturedSeries: x2, j: r2.globals.isBarHorizontal ? f2 : p2, hoverX: u2, hoverY: g2 };
  } }, { key: "getFirstActiveXArray", value: function(t3) {
    for (var e2 = this.w, i = 0, a2 = t3.map(function(t4, e3) {
      return t4.length > 0 ? e3 : -1;
    }), s2 = 0; s2 < a2.length; s2++)
      if (-1 !== a2[s2] && -1 === e2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === e2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2)) {
        i = a2[s2];
        break;
      }
    return i;
  } }, { key: "closestInMultiArray", value: function(t3, e2, i, a2) {
    for (var s2, r2 = this.w, n2 = 1 / 0, o2 = null, l2 = null, h2 = 0; h2 < i.length; h2++)
      if (s2 = h2, -1 === r2.globals.collapsedSeriesIndices.indexOf(s2) && -1 === r2.globals.ancillaryCollapsedSeriesIndices.indexOf(s2))
        for (var c2 = i[h2], d2 = a2[h2], u2 = Math.min(c2.length, d2.length), g2 = 0; g2 < u2; g2++) {
          var p2 = t3 - c2[g2], f2 = Math.sqrt(p2 * p2);
          if (!r2.globals.allSeriesHasEqualX) {
            var x2 = e2 - d2[g2];
            f2 = Math.sqrt(p2 * p2 + x2 * x2);
          }
          f2 < n2 && (n2 = f2, o2 = h2, l2 = g2);
        }
    return { index: o2, j: l2 };
  } }, { key: "closestInArray", value: function(t3, e2) {
    for (var i = e2[0], a2 = null, s2 = Math.abs(t3 - i), r2 = 0; r2 < e2.length; r2++) {
      var n2 = Math.abs(t3 - e2[r2]);
      n2 < s2 && (s2 = n2, a2 = r2);
    }
    return { j: a2 };
  } }, { key: "isXoverlap", value: function(t3) {
    var e2 = [], i = this.w.globals.seriesX.filter(function(t4) {
      return void 0 !== t4[0];
    });
    if (i.length > 0)
      for (var a2 = 0; a2 < i.length - 1; a2++)
        void 0 !== i[a2][t3] && void 0 !== i[a2 + 1][t3] && i[a2][t3] !== i[a2 + 1][t3] && e2.push("unEqual");
    return 0 === e2.length;
  } }, { key: "isInitialSeriesSameLen", value: function() {
    for (var t3 = true, e2 = this.w.globals.initialSeries, i = 0; i < e2.length - 1; i++)
      if (e2[i].data.length !== e2[i + 1].data.length) {
        t3 = false;
        break;
      }
    return t3;
  } }, { key: "getBarsHeight", value: function(t3) {
    return f(t3).reduce(function(t4, e2) {
      return t4 + e2.getBBox().height;
    }, 0);
  } }, { key: "getElMarkers", value: function(t3) {
    return "number" == typeof t3 ? this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-series-markers-wrap > *")) : this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap > *");
  } }, { key: "getAllMarkers", value: function() {
    var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] && arguments[0], i = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
    i = f(i), e2 && (i = i.filter(function(e3) {
      var i2 = Number(e3.getAttribute("data:realIndex"));
      return -1 === t3.w.globals.collapsedSeriesIndices.indexOf(i2);
    })), i.sort(function(t4, e3) {
      var i2 = Number(t4.getAttribute("data:realIndex")), a3 = Number(e3.getAttribute("data:realIndex"));
      return a3 < i2 ? 1 : a3 > i2 ? -1 : 0;
    });
    var a2 = [];
    return i.forEach(function(t4) {
      a2.push(t4.querySelector(".apexcharts-marker"));
    }), a2;
  } }, { key: "hasMarkers", value: function(t3) {
    return this.getElMarkers(t3).length > 0;
  } }, { key: "getPathFromPoint", value: function(t3, e2) {
    var i = Number(t3.getAttribute("cx")), a2 = Number(t3.getAttribute("cy")), s2 = t3.getAttribute("shape");
    return new Mi(this.ctx).getMarkerPath(i, a2, s2, e2);
  } }, { key: "getElBars", value: function() {
    return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series");
  } }, { key: "hasBars", value: function() {
    return this.getElBars().length > 0;
  } }, { key: "getHoverMarkerSize", value: function(t3) {
    var e2 = this.w, i = e2.config.markers.hover.size;
    return void 0 === i && (i = e2.globals.markers.size[t3] + e2.config.markers.hover.sizeOffset), i;
  } }, { key: "toggleAllTooltipSeriesGroups", value: function(t3) {
    var e2 = this.w, i = this.ttCtx;
    0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
    for (var a2 = i.allTooltipSeriesGroups, s2 = 0; s2 < a2.length; s2++)
      "enable" === t3 ? (a2[s2].classList.add("apexcharts-active"), a2[s2].style.display = e2.config.tooltip.items.display) : (a2[s2].classList.remove("apexcharts-active"), a2[s2].style.display = "none");
  } }]), t2;
}(), ya = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.ctx = e2.ctx, this.ttCtx = e2, this.tooltipUtil = new va(e2);
  }
  return s(t2, [{ key: "drawSeriesTexts", value: function(t3) {
    var e2 = t3.shared, i = void 0 === e2 || e2, a2 = t3.ttItems, s2 = t3.i, r2 = void 0 === s2 ? 0 : s2, n2 = t3.j, o2 = void 0 === n2 ? null : n2, l2 = t3.y1, h2 = t3.y2, c2 = t3.e, d2 = this.w;
    void 0 !== d2.config.tooltip.custom ? this.handleCustomTooltip({ i: r2, j: o2, y1: l2, y2: h2, w: d2 }) : this.toggleActiveInactiveSeries(i, r2);
    var u2 = this.getValuesToPrint({ i: r2, j: o2 });
    this.printLabels({ i: r2, j: o2, values: u2, ttItems: a2, shared: i, e: c2 });
    var g2 = this.ttCtx.getElTooltip();
    this.ttCtx.tooltipRect.ttWidth = g2.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = g2.getBoundingClientRect().height;
  } }, { key: "printLabels", value: function(t3) {
    var e2, i = this, a2 = t3.i, s2 = t3.j, r2 = t3.values, n2 = t3.ttItems, o2 = t3.shared, l2 = t3.e, h2 = this.w, c2 = [], d2 = function(t4) {
      return h2.globals.seriesGoals[t4] && h2.globals.seriesGoals[t4][s2] && Array.isArray(h2.globals.seriesGoals[t4][s2]);
    }, g2 = r2.xVal, p2 = r2.zVal, f2 = r2.xAxisTTVal, x2 = "", b2 = h2.globals.colors[a2];
    null !== s2 && h2.config.plotOptions.bar.distributed && (b2 = h2.globals.colors[s2]);
    for (var m2 = function(t4, r3) {
      var m3 = i.getFormatters(a2);
      x2 = i.getSeriesName({ fn: m3.yLbTitleFormatter, index: a2, seriesIndex: a2, j: s2 }), "treemap" === h2.config.chart.type && (x2 = m3.yLbTitleFormatter(String(h2.config.series[a2].data[s2].x), { series: h2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: h2 }));
      var v3 = h2.config.tooltip.inverseOrder ? r3 : t4;
      if (h2.globals.axisCharts) {
        var y3 = function(t5) {
          var e3, i2, a3, r4;
          return h2.globals.isRangeData ? m3.yLbFormatter(null === (e3 = h2.globals.seriesRangeStart) || void 0 === e3 || null === (i2 = e3[t5]) || void 0 === i2 ? void 0 : i2[s2], { series: h2.globals.seriesRangeStart, seriesIndex: t5, dataPointIndex: s2, w: h2 }) + " - " + m3.yLbFormatter(null === (a3 = h2.globals.seriesRangeEnd) || void 0 === a3 || null === (r4 = a3[t5]) || void 0 === r4 ? void 0 : r4[s2], { series: h2.globals.seriesRangeEnd, seriesIndex: t5, dataPointIndex: s2, w: h2 }) : m3.yLbFormatter(h2.globals.series[t5][s2], { series: h2.globals.series, seriesIndex: t5, dataPointIndex: s2, w: h2 });
        };
        if (o2)
          m3 = i.getFormatters(v3), x2 = i.getSeriesName({ fn: m3.yLbTitleFormatter, index: v3, seriesIndex: a2, j: s2 }), b2 = h2.globals.colors[v3], e2 = y3(v3), d2(v3) && (c2 = h2.globals.seriesGoals[v3][s2].map(function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: v3, dataPointIndex: s2, w: h2 }) };
          }));
        else {
          var w2, k2 = null == l2 || null === (w2 = l2.target) || void 0 === w2 ? void 0 : w2.getAttribute("fill");
          k2 && (-1 !== k2.indexOf("url") ? -1 !== k2.indexOf("Pattern") && (b2 = h2.globals.dom.baseEl.querySelector(k2.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke")) : b2 = k2), e2 = y3(a2), d2(a2) && Array.isArray(h2.globals.seriesGoals[a2][s2]) && (c2 = h2.globals.seriesGoals[a2][s2].map(function(t5) {
            return { attrs: t5, val: m3.yLbFormatter(t5.value, { seriesIndex: a2, dataPointIndex: s2, w: h2 }) };
          }));
        }
      }
      null === s2 && (e2 = m3.yLbFormatter(h2.globals.series[a2], u(u({}, h2), {}, { seriesIndex: a2, dataPointIndex: a2 }))), i.DOMHandling({ i: a2, t: v3, j: s2, ttItems: n2, values: { val: e2, goalVals: c2, xVal: g2, xAxisTTVal: f2, zVal: p2 }, seriesName: x2, shared: o2, pColor: b2 });
    }, v2 = 0, y2 = h2.globals.series.length - 1; v2 < h2.globals.series.length; v2++, y2--)
      m2(v2, y2);
  } }, { key: "getFormatters", value: function(t3) {
    var e2, i = this.w, a2 = i.globals.yLabelFormatters[t3];
    return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a2 = i.globals.ttVal[t3] && i.globals.ttVal[t3].formatter, e2 = i.globals.ttVal[t3] && i.globals.ttVal[t3].title && i.globals.ttVal[t3].title.formatter) : (a2 = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e2 = i.globals.ttVal.title.formatter)) : e2 = i.config.tooltip.y.title.formatter, "function" != typeof a2 && (a2 = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(t4) {
      return t4;
    }), "function" != typeof e2 && (e2 = function(t4) {
      return t4 ? t4 + ": " : "";
    }), { yLbFormatter: a2, yLbTitleFormatter: e2 };
  } }, { key: "getSeriesName", value: function(t3) {
    var e2 = t3.fn, i = t3.index, a2 = t3.seriesIndex, s2 = t3.j, r2 = this.w;
    return e2(String(r2.globals.seriesNames[i]), { series: r2.globals.series, seriesIndex: a2, dataPointIndex: s2, w: r2 });
  } }, { key: "DOMHandling", value: function(t3) {
    t3.i;
    var e2 = t3.t, i = t3.j, a2 = t3.ttItems, s2 = t3.values, r2 = t3.seriesName, n2 = t3.shared, o2 = t3.pColor, l2 = this.w, h2 = this.ttCtx, c2 = s2.val, d2 = s2.goalVals, u2 = s2.xVal, g2 = s2.xAxisTTVal, p2 = s2.zVal, f2 = null;
    f2 = a2[e2].children, l2.config.tooltip.fillSeriesColor && (a2[e2].style.backgroundColor = o2, f2[0].style.display = "none"), h2.showTooltipTitle && (null === h2.tooltipTitle && (h2.tooltipTitle = l2.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), h2.tooltipTitle.innerHTML = u2), h2.isXAxisTooltipEnabled && (h2.xaxisTooltipText.innerHTML = "" !== g2 ? g2 : u2);
    var x2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-label");
    x2 && (x2.innerHTML = r2 || "");
    var b2 = a2[e2].querySelector(".apexcharts-tooltip-text-y-value");
    b2 && (b2.innerHTML = void 0 !== c2 ? c2 : ""), f2[0] && f2[0].classList.contains("apexcharts-tooltip-marker") && (l2.config.tooltip.marker.fillColors && Array.isArray(l2.config.tooltip.marker.fillColors) && (o2 = l2.config.tooltip.marker.fillColors[e2]), l2.config.tooltip.fillSeriesColor ? f2[0].style.backgroundColor = o2 : f2[0].style.color = o2), l2.config.tooltip.marker.show || (f2[0].style.display = "none");
    var m2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-label"), v2 = a2[e2].querySelector(".apexcharts-tooltip-text-goals-value");
    if (d2.length && l2.globals.seriesGoals[e2]) {
      var y2 = function() {
        var t4 = "<div>", e3 = "<div>";
        d2.forEach(function(i2, a3) {
          t4 += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i2.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i2.attrs.name, "</div>"), e3 += "<div>".concat(i2.val, "</div>");
        }), m2.innerHTML = t4 + "</div>", v2.innerHTML = e3 + "</div>";
      };
      n2 ? l2.globals.seriesGoals[e2][i] && Array.isArray(l2.globals.seriesGoals[e2][i]) ? y2() : (m2.innerHTML = "", v2.innerHTML = "") : y2();
    } else
      m2.innerHTML = "", v2.innerHTML = "";
    null !== p2 && (a2[e2].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l2.config.tooltip.z.title, a2[e2].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== p2 ? p2 : "");
    if (n2 && f2[0]) {
      if (l2.config.tooltip.hideEmptySeries) {
        var w2 = a2[e2].querySelector(".apexcharts-tooltip-marker"), k2 = a2[e2].querySelector(".apexcharts-tooltip-text");
        0 == parseFloat(c2) ? (w2.style.display = "none", k2.style.display = "none") : (w2.style.display = "block", k2.style.display = "block");
      }
      null == c2 || l2.globals.ancillaryCollapsedSeriesIndices.indexOf(e2) > -1 || l2.globals.collapsedSeriesIndices.indexOf(e2) > -1 || Array.isArray(h2.tConfig.enabledOnSeries) && -1 === h2.tConfig.enabledOnSeries.indexOf(e2) ? f2[0].parentNode.style.display = "none" : f2[0].parentNode.style.display = l2.config.tooltip.items.display;
    } else
      Array.isArray(h2.tConfig.enabledOnSeries) && -1 === h2.tConfig.enabledOnSeries.indexOf(e2) && (f2[0].parentNode.style.display = "none");
  } }, { key: "toggleActiveInactiveSeries", value: function(t3, e2) {
    var i = this.w;
    if (t3)
      this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
    else {
      this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
      var a2 = i.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group-".concat(e2));
      a2 && (a2.classList.add("apexcharts-active"), a2.style.display = i.config.tooltip.items.display);
    }
  } }, { key: "getValuesToPrint", value: function(t3) {
    var e2 = t3.i, i = t3.j, a2 = this.w, s2 = this.ctx.series.filteredSeriesX(), r2 = "", n2 = "", o2 = null, l2 = null, h2 = { series: a2.globals.series, seriesIndex: e2, dataPointIndex: i, w: a2 }, c2 = a2.globals.ttZFormatter;
    null === i ? l2 = a2.globals.series[e2] : a2.globals.isXNumeric && "treemap" !== a2.config.chart.type ? (r2 = s2[e2][i], 0 === s2[e2].length && (r2 = s2[this.tooltipUtil.getFirstActiveXArray(s2)][i])) : r2 = new $i(this.ctx).isFormatXY() ? void 0 !== a2.config.series[e2].data[i] ? a2.config.series[e2].data[i].x : "" : void 0 !== a2.globals.labels[i] ? a2.globals.labels[i] : "";
    var d2 = r2;
    a2.globals.isXNumeric && "datetime" === a2.config.xaxis.type ? r2 = new Xi(this.ctx).xLabelFormat(a2.globals.ttKeyFormatter, d2, d2, { i: void 0, dateFormatter: new zi(this.ctx).formatDate, w: this.w }) : r2 = a2.globals.isBarHorizontal ? a2.globals.yLabelFormatters[0](d2, h2) : a2.globals.xLabelFormatter(d2, h2);
    return void 0 !== a2.config.tooltip.x.formatter && (r2 = a2.globals.ttKeyFormatter(d2, h2)), a2.globals.seriesZ.length > 0 && a2.globals.seriesZ[e2].length > 0 && (o2 = c2(a2.globals.seriesZ[e2][i], a2)), n2 = "function" == typeof a2.config.xaxis.tooltip.formatter ? a2.globals.xaxisTooltipFormatter(d2, h2) : r2, { val: Array.isArray(l2) ? l2.join(" ") : l2, xVal: Array.isArray(r2) ? r2.join(" ") : r2, xAxisTTVal: Array.isArray(n2) ? n2.join(" ") : n2, zVal: o2 };
  } }, { key: "handleCustomTooltip", value: function(t3) {
    var e2 = t3.i, i = t3.j, a2 = t3.y1, s2 = t3.y2, r2 = t3.w, n2 = this.ttCtx.getElTooltip(), o2 = r2.config.tooltip.custom;
    Array.isArray(o2) && o2[e2] && (o2 = o2[e2]);
    var l2 = o2({ ctx: this.ctx, series: r2.globals.series, seriesIndex: e2, dataPointIndex: i, y1: a2, y2: s2, w: r2 });
    "string" == typeof l2 ? n2.innerHTML = l2 : (l2 instanceof Element || "string" == typeof l2.nodeName) && (n2.innerHTML = "", n2.appendChild(l2.cloneNode(true)));
  } }]), t2;
}(), wa = function() {
  function t2(e2) {
    i$1(this, t2), this.ttCtx = e2, this.ctx = e2.ctx, this.w = e2.w;
  }
  return s(t2, [{ key: "moveXCrosshairs", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, i = this.ttCtx, a2 = this.w, s2 = i.getElXCrosshairs(), r2 = t3 - i.xcrosshairsWidth / 2, n2 = a2.globals.labels.slice().length;
    if (null !== e2 && (r2 = a2.globals.gridWidth / n2 * e2), null === s2 || a2.globals.isBarHorizontal || (s2.setAttribute("x", r2), s2.setAttribute("x1", r2), s2.setAttribute("x2", r2), s2.setAttribute("y2", a2.globals.gridHeight), s2.classList.add("apexcharts-active")), r2 < 0 && (r2 = 0), r2 > a2.globals.gridWidth && (r2 = a2.globals.gridWidth), i.isXAxisTooltipEnabled) {
      var o2 = r2;
      "tickWidth" !== a2.config.xaxis.crosshairs.width && "barWidth" !== a2.config.xaxis.crosshairs.width || (o2 = r2 + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o2);
    }
  } }, { key: "moveYCrosshairs", value: function(t3) {
    var e2 = this.ttCtx;
    null !== e2.ycrosshairs && Mi.setAttrs(e2.ycrosshairs, { y1: t3, y2: t3 }), null !== e2.ycrosshairsHidden && Mi.setAttrs(e2.ycrosshairsHidden, { y1: t3, y2: t3 });
  } }, { key: "moveXAxisTooltip", value: function(t3) {
    var e2 = this.w, i = this.ttCtx;
    if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
      i.xaxisTooltip.classList.add("apexcharts-active");
      var a2 = i.xaxisOffY + e2.config.xaxis.tooltip.offsetY + e2.globals.translateY + 1 + e2.config.xaxis.offsetY;
      if (t3 -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t3)) {
        t3 += e2.globals.translateX;
        var s2;
        s2 = new Mi(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = s2.width + "px", i.xaxisTooltip.style.left = t3 + "px", i.xaxisTooltip.style.top = a2 + "px";
      }
    }
  } }, { key: "moveYAxisTooltip", value: function(t3) {
    var e2 = this.w, i = this.ttCtx;
    null === i.yaxisTTEls && (i.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
    var a2 = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10), s2 = e2.globals.translateY + a2, r2 = i.yaxisTTEls[t3].getBoundingClientRect().height, n2 = e2.globals.translateYAxisX[t3] - 2;
    e2.config.yaxis[t3].opposite && (n2 -= 26), s2 -= r2 / 2, -1 === e2.globals.ignoreYAxisIndexes.indexOf(t3) ? (i.yaxisTTEls[t3].classList.add("apexcharts-active"), i.yaxisTTEls[t3].style.top = s2 + "px", i.yaxisTTEls[t3].style.left = n2 + e2.config.yaxis[t3].tooltip.offsetX + "px") : i.yaxisTTEls[t3].classList.remove("apexcharts-active");
  } }, { key: "moveTooltip", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = this.w, s2 = this.ttCtx, r2 = s2.getElTooltip(), n2 = s2.tooltipRect, o2 = null !== i ? parseFloat(i) : 1, l2 = parseFloat(t3) + o2 + 5, h2 = parseFloat(e2) + o2 / 2;
    if (l2 > a2.globals.gridWidth / 2 && (l2 = l2 - n2.ttWidth - o2 - 10), l2 > a2.globals.gridWidth - n2.ttWidth - 10 && (l2 = a2.globals.gridWidth - n2.ttWidth), l2 < -20 && (l2 = -20), a2.config.tooltip.followCursor) {
      var c2 = s2.getElGrid().getBoundingClientRect();
      (l2 = s2.e.clientX - c2.left) > a2.globals.gridWidth / 2 && (l2 -= s2.tooltipRect.ttWidth), (h2 = s2.e.clientY + a2.globals.translateY - c2.top) > a2.globals.gridHeight / 2 && (h2 -= s2.tooltipRect.ttHeight);
    } else
      a2.globals.isBarHorizontal || n2.ttHeight / 2 + h2 > a2.globals.gridHeight && (h2 = a2.globals.gridHeight - n2.ttHeight + a2.globals.translateY);
    isNaN(l2) || (l2 += a2.globals.translateX, r2.style.left = l2 + "px", r2.style.top = h2 + "px");
  } }, { key: "moveMarkers", value: function(t3, e2) {
    var i = this.w, a2 = this.ttCtx;
    if (i.globals.markers.size[t3] > 0)
      for (var s2 = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t3, "'] .apexcharts-marker")), r2 = 0; r2 < s2.length; r2++)
        parseInt(s2[r2].getAttribute("rel"), 10) === e2 && (a2.marker.resetPointsSize(), a2.marker.enlargeCurrentPoint(e2, s2[r2]));
    else
      a2.marker.resetPointsSize(), this.moveDynamicPointOnHover(e2, t3);
  } }, { key: "moveDynamicPointOnHover", value: function(t3, e2) {
    var i, a2, s2, r2, n2 = this.w, o2 = this.ttCtx, l2 = new Mi(this.ctx), h2 = n2.globals.pointsArray, c2 = o2.tooltipUtil.getHoverMarkerSize(e2), d2 = n2.config.series[e2].type;
    if (!d2 || "column" !== d2 && "candlestick" !== d2 && "boxPlot" !== d2) {
      s2 = null === (i = h2[e2][t3]) || void 0 === i ? void 0 : i[0], r2 = (null === (a2 = h2[e2][t3]) || void 0 === a2 ? void 0 : a2[1]) || 0;
      var u2 = n2.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e2, "'] .apexcharts-series-markers path"));
      if (u2 && r2 < n2.globals.gridHeight && r2 > 0) {
        var g2 = u2.getAttribute("shape"), p2 = l2.getMarkerPath(s2, r2, g2, 1.5 * c2);
        u2.setAttribute("d", p2);
      }
      this.moveXCrosshairs(s2), o2.fixedTooltip || this.moveTooltip(s2, r2, c2);
    }
  } }, { key: "moveDynamicPointsOnHover", value: function(t3) {
    var e2, i = this.ttCtx, a2 = i.w, s2 = 0, r2 = 0, n2 = a2.globals.pointsArray, o2 = new Zi(this.ctx), l2 = new Mi(this.ctx);
    e2 = o2.getActiveConfigSeriesIndex("asc", ["line", "area", "scatter", "bubble"]);
    var h2 = i.tooltipUtil.getHoverMarkerSize(e2);
    if (n2[e2] && (s2 = n2[e2][t3][0], r2 = n2[e2][t3][1]), !isNaN(s2)) {
      var c2 = i.tooltipUtil.getAllMarkers();
      if (c2.length)
        for (var d2 = 0; d2 < a2.globals.series.length; d2++) {
          var u2 = n2[d2];
          if (a2.globals.comboCharts && void 0 === u2 && c2.splice(d2, 0, null), u2 && u2.length) {
            var g2 = n2[d2][t3][1], p2 = void 0;
            c2[d2].setAttribute("cx", s2);
            var f2 = c2[d2].getAttribute("shape");
            if ("rangeArea" === a2.config.chart.type && !a2.globals.comboCharts) {
              var x2 = t3 + a2.globals.series[d2].length;
              p2 = n2[d2][x2][1], g2 -= Math.abs(g2 - p2) / 2;
            }
            if (null !== g2 && !isNaN(g2) && g2 < a2.globals.gridHeight + h2 && g2 + h2 > 0) {
              var b2 = l2.getMarkerPath(s2, g2, f2, h2);
              c2[d2].setAttribute("d", b2);
            } else
              c2[d2].setAttribute("d", "");
          }
        }
      this.moveXCrosshairs(s2), i.fixedTooltip || this.moveTooltip(s2, r2 || a2.globals.gridHeight, h2);
    }
  } }, { key: "moveStickyTooltipOverBars", value: function(t3, e2) {
    var i = this.w, a2 = this.ttCtx, s2 = i.globals.columnSeries ? i.globals.columnSeries.length : i.globals.series.length;
    i.config.chart.stacked && (s2 = i.globals.barGroups.length);
    var r2 = s2 >= 2 && s2 % 2 == 0 ? Math.floor(s2 / 2) : Math.floor(s2 / 2) + 1;
    i.globals.isBarHorizontal && (r2 = new Zi(this.ctx).getActiveConfigSeriesIndex("desc") + 1);
    var n2 = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(r2, "'] path[j='").concat(t3, "']"));
    n2 || "number" != typeof e2 || (n2 = i.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[data\\:realIndex='".concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-candlestick-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-boxPlot-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "'],\n        .apexcharts-rangebar-series .apexcharts-series[data\\:realIndex='").concat(e2, "'] path[j='").concat(t3, "']")));
    var o2 = n2 ? parseFloat(n2.getAttribute("cx")) : 0, l2 = n2 ? parseFloat(n2.getAttribute("cy")) : 0, h2 = n2 ? parseFloat(n2.getAttribute("barWidth")) : 0, c2 = a2.getElGrid().getBoundingClientRect(), d2 = n2 && (n2.classList.contains("apexcharts-candlestick-area") || n2.classList.contains("apexcharts-boxPlot-area"));
    i.globals.isXNumeric ? (n2 && !d2 && (o2 -= s2 % 2 != 0 ? h2 / 2 : 0), n2 && d2 && (o2 -= h2 / 2)) : i.globals.isBarHorizontal || (o2 = a2.xAxisTicksPositions[t3 - 1] + a2.dataPointsDividedWidth / 2, isNaN(o2) && (o2 = a2.xAxisTicksPositions[t3] - a2.dataPointsDividedWidth / 2)), i.globals.isBarHorizontal ? l2 -= a2.tooltipRect.ttHeight : i.config.tooltip.followCursor ? l2 = a2.e.clientY - c2.top - a2.tooltipRect.ttHeight / 2 : l2 + a2.tooltipRect.ttHeight + 15 > i.globals.gridHeight && (l2 = i.globals.gridHeight), i.globals.isBarHorizontal || this.moveXCrosshairs(o2), a2.fixedTooltip || this.moveTooltip(o2, l2 || i.globals.gridHeight);
  } }]), t2;
}(), ka = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.ttCtx = e2, this.ctx = e2.ctx, this.tooltipPosition = new wa(e2);
  }
  return s(t2, [{ key: "drawDynamicPoints", value: function() {
    var t3 = this.w, e2 = new Mi(this.ctx), i = new Vi(this.ctx), a2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
    a2 = f(a2), t3.config.chart.stacked && a2.sort(function(t4, e3) {
      return parseFloat(t4.getAttribute("data:realIndex")) - parseFloat(e3.getAttribute("data:realIndex"));
    });
    for (var s2 = 0; s2 < a2.length; s2++) {
      var r2 = a2[s2].querySelector(".apexcharts-series-markers-wrap");
      if (null !== r2) {
        var n2 = void 0, o2 = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
        "line" !== t3.config.chart.type && "area" !== t3.config.chart.type || t3.globals.comboCharts || t3.config.tooltip.intersect || (o2 += " no-pointer-events");
        var l2 = i.getMarkerConfig({ cssClass: o2, seriesIndex: Number(r2.getAttribute("data:realIndex")) });
        (n2 = e2.drawMarker(0, 0, l2)).node.setAttribute("default-marker-size", 0);
        var h2 = document.createElementNS(t3.globals.SVGNS, "g");
        h2.classList.add("apexcharts-series-markers"), h2.appendChild(n2.node), r2.appendChild(h2);
      }
    }
  } }, { key: "enlargeCurrentPoint", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null, a2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null, s2 = this.w;
    "bubble" !== s2.config.chart.type && this.newPointSize(t3, e2);
    var r2 = e2.getAttribute("cx"), n2 = e2.getAttribute("cy");
    if (null !== i && null !== a2 && (r2 = i, n2 = a2), this.tooltipPosition.moveXCrosshairs(r2), !this.fixedTooltip) {
      if ("radar" === s2.config.chart.type) {
        var o2 = this.ttCtx.getElGrid().getBoundingClientRect();
        r2 = this.ttCtx.e.clientX - o2.left;
      }
      this.tooltipPosition.moveTooltip(r2, n2, s2.config.markers.hover.size);
    }
  } }, { key: "enlargePoints", value: function(t3) {
    for (var e2 = this.w, i = this, a2 = this.ttCtx, s2 = t3, r2 = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), n2 = e2.config.markers.hover.size, o2 = 0; o2 < r2.length; o2++) {
      var l2 = r2[o2].getAttribute("rel"), h2 = r2[o2].getAttribute("index");
      if (void 0 === n2 && (n2 = e2.globals.markers.size[h2] + e2.config.markers.hover.sizeOffset), s2 === parseInt(l2, 10)) {
        i.newPointSize(s2, r2[o2]);
        var c2 = r2[o2].getAttribute("cx"), d2 = r2[o2].getAttribute("cy");
        i.tooltipPosition.moveXCrosshairs(c2), a2.fixedTooltip || i.tooltipPosition.moveTooltip(c2, d2, n2);
      } else
        i.oldPointSize(r2[o2]);
    }
  } }, { key: "newPointSize", value: function(t3, e2) {
    var i = this.w, a2 = i.config.markers.hover.size, s2 = 0 === t3 ? e2.parentNode.firstChild : e2.parentNode.lastChild;
    if ("0" !== s2.getAttribute("default-marker-size")) {
      var r2 = parseInt(s2.getAttribute("index"), 10);
      void 0 === a2 && (a2 = i.globals.markers.size[r2] + i.config.markers.hover.sizeOffset), a2 < 0 && (a2 = 0);
      var n2 = this.ttCtx.tooltipUtil.getPathFromPoint(e2, a2);
      e2.setAttribute("d", n2);
    }
  } }, { key: "oldPointSize", value: function(t3) {
    var e2 = parseFloat(t3.getAttribute("default-marker-size")), i = this.ttCtx.tooltipUtil.getPathFromPoint(t3, e2);
    t3.setAttribute("d", i);
  } }, { key: "resetPointsSize", value: function() {
    for (var t3 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e2 = 0; e2 < t3.length; e2++) {
      var i = parseFloat(t3[e2].getAttribute("default-marker-size"));
      if (v.isNumber(i) && i > 0) {
        var a2 = this.ttCtx.tooltipUtil.getPathFromPoint(t3[e2], i);
        t3[e2].setAttribute("d", a2);
      } else
        t3[e2].setAttribute("d", "M0,0");
    }
  } }]), t2;
}(), Aa = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w;
    var a2 = this.w;
    this.ttCtx = e2, this.isVerticalGroupedRangeBar = !a2.globals.isBarHorizontal && "rangeBar" === a2.config.chart.type && a2.config.plotOptions.bar.rangeBarGroupRows;
  }
  return s(t2, [{ key: "getAttr", value: function(t3, e2) {
    return parseFloat(t3.target.getAttribute(e2));
  } }, { key: "handleHeatTreeTooltip", value: function(t3) {
    var e2 = t3.e, i = t3.opt, a2 = t3.x, s2 = t3.y, r2 = t3.type, n2 = this.ttCtx, o2 = this.w;
    if (e2.target.classList.contains("apexcharts-".concat(r2, "-rect"))) {
      var l2 = this.getAttr(e2, "i"), h2 = this.getAttr(e2, "j"), c2 = this.getAttr(e2, "cx"), d2 = this.getAttr(e2, "cy"), u2 = this.getAttr(e2, "width"), g2 = this.getAttr(e2, "height");
      if (n2.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: l2, j: h2, shared: false, e: e2 }), o2.globals.capturedSeriesIndex = l2, o2.globals.capturedDataPointIndex = h2, a2 = c2 + n2.tooltipRect.ttWidth / 2 + u2, s2 = d2 + n2.tooltipRect.ttHeight / 2 - g2 / 2, n2.tooltipPosition.moveXCrosshairs(c2 + u2 / 2), a2 > o2.globals.gridWidth / 2 && (a2 = c2 - n2.tooltipRect.ttWidth / 2 + u2), n2.w.config.tooltip.followCursor) {
        var p2 = o2.globals.dom.elWrap.getBoundingClientRect();
        a2 = o2.globals.clientX - p2.left - (a2 > o2.globals.gridWidth / 2 ? n2.tooltipRect.ttWidth : 0), s2 = o2.globals.clientY - p2.top - (s2 > o2.globals.gridHeight / 2 ? n2.tooltipRect.ttHeight : 0);
      }
    }
    return { x: a2, y: s2 };
  } }, { key: "handleMarkerTooltip", value: function(t3) {
    var e2, i, a2 = t3.e, s2 = t3.opt, r2 = t3.x, n2 = t3.y, o2 = this.w, l2 = this.ttCtx;
    if (a2.target.classList.contains("apexcharts-marker")) {
      var h2 = parseInt(s2.paths.getAttribute("cx"), 10), c2 = parseInt(s2.paths.getAttribute("cy"), 10), d2 = parseFloat(s2.paths.getAttribute("val"));
      if (i = parseInt(s2.paths.getAttribute("rel"), 10), e2 = parseInt(s2.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l2.intersect) {
        var u2 = v.findAncestor(s2.paths, "apexcharts-series");
        u2 && (e2 = parseInt(u2.getAttribute("data:realIndex"), 10));
      }
      if (l2.tooltipLabels.drawSeriesTexts({ ttItems: s2.ttItems, i: e2, j: i, shared: !l2.showOnIntersect && o2.config.tooltip.shared, e: a2 }), "mouseup" === a2.type && l2.markerClick(a2, e2, i), o2.globals.capturedSeriesIndex = e2, o2.globals.capturedDataPointIndex = i, r2 = h2, n2 = c2 + o2.globals.translateY - 1.4 * l2.tooltipRect.ttHeight, l2.w.config.tooltip.followCursor) {
        var g2 = l2.getElGrid().getBoundingClientRect();
        n2 = l2.e.clientY + o2.globals.translateY - g2.top;
      }
      d2 < 0 && (n2 = c2), l2.marker.enlargeCurrentPoint(i, s2.paths, r2, n2);
    }
    return { x: r2, y: n2 };
  } }, { key: "handleBarTooltip", value: function(t3) {
    var e2, i, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = this.ttCtx, o2 = n2.getElTooltip(), l2 = 0, h2 = 0, c2 = 0, d2 = this.getBarTooltipXY({ e: a2, opt: s2 });
    if (null !== d2.j || 0 !== d2.barHeight || 0 !== d2.barWidth) {
      e2 = d2.i;
      var u2 = d2.j;
      if (r2.globals.capturedSeriesIndex = e2, r2.globals.capturedDataPointIndex = u2, r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars() || !r2.config.tooltip.shared ? (h2 = d2.x, c2 = d2.y, i = Array.isArray(r2.config.stroke.width) ? r2.config.stroke.width[e2] : r2.config.stroke.width, l2 = h2) : r2.globals.comboCharts || r2.config.tooltip.shared || (l2 /= 2), isNaN(c2) && (c2 = r2.globals.svgHeight - n2.tooltipRect.ttHeight), parseInt(s2.paths.parentNode.getAttribute("data:realIndex"), 10), h2 + n2.tooltipRect.ttWidth > r2.globals.gridWidth ? h2 -= n2.tooltipRect.ttWidth : h2 < 0 && (h2 = 0), n2.w.config.tooltip.followCursor) {
        var g2 = n2.getElGrid().getBoundingClientRect();
        c2 = n2.e.clientY - g2.top;
      }
      null === n2.tooltip && (n2.tooltip = r2.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), r2.config.tooltip.shared || (r2.globals.comboBarCount > 0 ? n2.tooltipPosition.moveXCrosshairs(l2 + i / 2) : n2.tooltipPosition.moveXCrosshairs(l2)), !n2.fixedTooltip && (!r2.config.tooltip.shared || r2.globals.isBarHorizontal && n2.tooltipUtil.hasBars()) && (c2 = c2 + r2.globals.translateY - n2.tooltipRect.ttHeight / 2, o2.style.left = h2 + r2.globals.translateX + "px", o2.style.top = c2 + "px");
    }
  } }, { key: "getBarTooltipXY", value: function(t3) {
    var e2 = this, i = t3.e, a2 = t3.opt, s2 = this.w, r2 = null, n2 = this.ttCtx, o2 = 0, l2 = 0, h2 = 0, c2 = 0, d2 = 0, u2 = i.target.classList;
    if (u2.contains("apexcharts-bar-area") || u2.contains("apexcharts-candlestick-area") || u2.contains("apexcharts-boxPlot-area") || u2.contains("apexcharts-rangebar-area")) {
      var g2 = i.target, p2 = g2.getBoundingClientRect(), f2 = a2.elGrid.getBoundingClientRect(), x2 = p2.height;
      d2 = p2.height;
      var b2 = p2.width, m2 = parseInt(g2.getAttribute("cx"), 10), v2 = parseInt(g2.getAttribute("cy"), 10);
      c2 = parseFloat(g2.getAttribute("barWidth"));
      var y2 = "touchmove" === i.type ? i.touches[0].clientX : i.clientX;
      r2 = parseInt(g2.getAttribute("j"), 10), o2 = parseInt(g2.parentNode.getAttribute("rel"), 10) - 1;
      var w2 = g2.getAttribute("data-range-y1"), k2 = g2.getAttribute("data-range-y2");
      s2.globals.comboCharts && (o2 = parseInt(g2.parentNode.getAttribute("data:realIndex"), 10));
      var A2 = function(t4) {
        return s2.globals.isXNumeric ? m2 - b2 / 2 : e2.isVerticalGroupedRangeBar ? m2 + b2 / 2 : m2 - n2.dataPointsDividedWidth + b2 / 2;
      }, C2 = function() {
        return v2 - n2.dataPointsDividedHeight + x2 / 2 - n2.tooltipRect.ttHeight / 2;
      };
      n2.tooltipLabels.drawSeriesTexts({ ttItems: a2.ttItems, i: o2, j: r2, y1: w2 ? parseInt(w2, 10) : null, y2: k2 ? parseInt(k2, 10) : null, shared: !n2.showOnIntersect && s2.config.tooltip.shared, e: i }), s2.config.tooltip.followCursor ? s2.globals.isBarHorizontal ? (l2 = y2 - f2.left + 15, h2 = C2()) : (l2 = A2(), h2 = i.clientY - f2.top - n2.tooltipRect.ttHeight / 2 - 15) : s2.globals.isBarHorizontal ? ((l2 = m2) < n2.xyRatios.baseLineInvertedY && (l2 = m2 - n2.tooltipRect.ttWidth), h2 = C2()) : (l2 = A2(), h2 = v2);
    }
    return { x: l2, y: h2, barHeight: d2, barWidth: c2, i: o2, j: r2 };
  } }]), t2;
}(), Ca = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.ttCtx = e2;
  }
  return s(t2, [{ key: "drawXaxisTooltip", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i = "bottom" === t3.config.xaxis.position;
    e2.xaxisOffY = i ? t3.globals.gridHeight + 1 : -t3.globals.xAxisHeight - t3.config.xaxis.axisTicks.height + 3;
    var a2 = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top", s2 = t3.globals.dom.elWrap;
    e2.isXAxisTooltipEnabled && (null === t3.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e2.xaxisTooltip = document.createElement("div"), e2.xaxisTooltip.setAttribute("class", a2 + " apexcharts-theme-" + t3.config.tooltip.theme), s2.appendChild(e2.xaxisTooltip), e2.xaxisTooltipText = document.createElement("div"), e2.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e2.xaxisTooltipText.style.fontFamily = t3.config.xaxis.tooltip.style.fontFamily || t3.config.chart.fontFamily, e2.xaxisTooltipText.style.fontSize = t3.config.xaxis.tooltip.style.fontSize, e2.xaxisTooltip.appendChild(e2.xaxisTooltipText)));
  } }, { key: "drawYaxisTooltip", value: function() {
    for (var t3 = this.w, e2 = this.ttCtx, i = 0; i < t3.config.yaxis.length; i++) {
      var a2 = t3.config.yaxis[i].opposite || t3.config.yaxis[i].crosshairs.opposite;
      e2.yaxisOffX = a2 ? t3.globals.gridWidth + 1 : 1;
      var s2 = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, a2 ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left"), r2 = t3.globals.dom.elWrap;
      null === t3.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) && (e2.yaxisTooltip = document.createElement("div"), e2.yaxisTooltip.setAttribute("class", s2 + " apexcharts-theme-" + t3.config.tooltip.theme), r2.appendChild(e2.yaxisTooltip), 0 === i && (e2.yaxisTooltipText = []), e2.yaxisTooltipText[i] = document.createElement("div"), e2.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), e2.yaxisTooltip.appendChild(e2.yaxisTooltipText[i]));
    }
  } }, { key: "setXCrosshairWidth", value: function() {
    var t3 = this.w, e2 = this.ttCtx, i = e2.getElXCrosshairs();
    if (e2.xcrosshairsWidth = parseInt(t3.config.xaxis.crosshairs.width, 10), t3.globals.comboCharts) {
      var a2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== a2 && "barWidth" === t3.config.xaxis.crosshairs.width) {
        var s2 = parseFloat(a2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = s2;
      } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
        var r2 = t3.globals.labels.length;
        e2.xcrosshairsWidth = t3.globals.gridWidth / r2;
      }
    } else if ("tickWidth" === t3.config.xaxis.crosshairs.width) {
      var n2 = t3.globals.labels.length;
      e2.xcrosshairsWidth = t3.globals.gridWidth / n2;
    } else if ("barWidth" === t3.config.xaxis.crosshairs.width) {
      var o2 = t3.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
      if (null !== o2) {
        var l2 = parseFloat(o2.getAttribute("barWidth"));
        e2.xcrosshairsWidth = l2;
      } else
        e2.xcrosshairsWidth = 1;
    }
    t3.globals.isBarHorizontal && (e2.xcrosshairsWidth = 0), null !== i && e2.xcrosshairsWidth > 0 && i.setAttribute("width", e2.xcrosshairsWidth);
  } }, { key: "handleYCrosshair", value: function() {
    var t3 = this.w, e2 = this.ttCtx;
    e2.ycrosshairs = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e2.ycrosshairsHidden = t3.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden");
  } }, { key: "drawYaxisTooltipText", value: function(t3, e2, i) {
    var a2 = this.ttCtx, s2 = this.w, r2 = s2.globals, n2 = r2.seriesYAxisMap[t3];
    if (a2.yaxisTooltips[t3] && n2.length > 0) {
      var o2 = r2.yLabelFormatters[t3], l2 = a2.getElGrid().getBoundingClientRect(), h2 = n2[0], c2 = 0;
      i.yRatio.length > 1 && (c2 = h2);
      var d2 = (e2 - l2.top) * i.yRatio[c2], u2 = r2.maxYArr[h2] - r2.minYArr[h2], g2 = r2.minYArr[h2] + (u2 - d2);
      s2.config.yaxis[t3].reversed && (g2 = r2.maxYArr[h2] - (u2 - d2)), a2.tooltipPosition.moveYCrosshairs(e2 - l2.top), a2.yaxisTooltipText[t3].innerHTML = o2(g2), a2.tooltipPosition.moveYAxisTooltip(t3);
    }
  } }]), t2;
}(), Sa = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.tConfig = a2.config.tooltip, this.tooltipUtil = new va(this), this.tooltipLabels = new ya(this), this.tooltipPosition = new wa(this), this.marker = new ka(this), this.intersect = new Aa(this), this.axesTooltip = new Ca(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !a2.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now();
  }
  return s(t2, [{ key: "getElTooltip", value: function(t3) {
    return t3 || (t3 = this), t3.w.globals.dom.baseEl ? t3.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null;
  } }, { key: "getElXCrosshairs", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs");
  } }, { key: "getElGrid", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid");
  } }, { key: "drawTooltip", value: function(t3) {
    var e2 = this.w;
    this.xyRatios = t3, this.isXAxisTooltipEnabled = e2.config.xaxis.tooltip.enabled && e2.globals.axisCharts, this.yaxisTooltips = e2.config.yaxis.map(function(t4, i2) {
      return !!(t4.show && t4.tooltip.enabled && e2.globals.axisCharts);
    }), this.allTooltipSeriesGroups = [], e2.globals.axisCharts || (this.showTooltipTitle = false);
    var i = document.createElement("div");
    if (i.classList.add("apexcharts-tooltip"), e2.config.tooltip.cssClass && i.classList.add(e2.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e2.globals.dom.elWrap.appendChild(i), e2.globals.axisCharts) {
      this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
      var a2 = new Qi(this.ctx);
      this.xAxisTicksPositions = a2.getXAxisTicksPositions();
    }
    if (!e2.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e2.config.chart.type || this.tConfig.shared || (this.showOnIntersect = true), 0 !== e2.config.markers.size && 0 !== e2.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e2.globals.collapsedSeries.length !== e2.globals.series.length) {
      this.dataPointsDividedHeight = e2.globals.gridHeight / e2.globals.dataPoints, this.dataPointsDividedWidth = e2.globals.gridWidth / e2.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e2.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
      var s2 = e2.globals.series.length;
      (e2.globals.xyCharts || e2.globals.comboCharts) && this.tConfig.shared && (s2 = this.showOnIntersect ? 1 : e2.globals.series.length), this.legendLabels = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s2), this.addSVGEvents();
    }
  } }, { key: "createTTElements", value: function(t3) {
    for (var e2 = this, i = this.w, a2 = [], s2 = this.getElTooltip(), r2 = function(r3) {
      var n3 = document.createElement("div");
      n3.classList.add("apexcharts-tooltip-series-group", "apexcharts-tooltip-series-group-".concat(r3)), n3.style.order = i.config.tooltip.inverseOrder ? t3 - r3 : r3 + 1;
      var o2 = document.createElement("span");
      o2.classList.add("apexcharts-tooltip-marker"), i.config.tooltip.fillSeriesColor ? o2.style.backgroundColor = i.globals.colors[r3] : o2.style.color = i.globals.colors[r3];
      var l2 = i.config.markers.shape, h2 = l2;
      Array.isArray(l2) && (h2 = l2[r3]), o2.setAttribute("shape", h2), n3.appendChild(o2);
      var c2 = document.createElement("div");
      c2.classList.add("apexcharts-tooltip-text"), c2.style.fontFamily = e2.tConfig.style.fontFamily || i.config.chart.fontFamily, c2.style.fontSize = e2.tConfig.style.fontSize, ["y", "goals", "z"].forEach(function(t4) {
        var e3 = document.createElement("div");
        e3.classList.add("apexcharts-tooltip-".concat(t4, "-group"));
        var i2 = document.createElement("span");
        i2.classList.add("apexcharts-tooltip-text-".concat(t4, "-label")), e3.appendChild(i2);
        var a3 = document.createElement("span");
        a3.classList.add("apexcharts-tooltip-text-".concat(t4, "-value")), e3.appendChild(a3), c2.appendChild(e3);
      }), n3.appendChild(c2), s2.appendChild(n3), a2.push(n3);
    }, n2 = 0; n2 < t3; n2++)
      r2(n2);
    return a2;
  } }, { key: "addSVGEvents", value: function() {
    var t3 = this.w, e2 = t3.config.chart.type, i = this.getElTooltip(), a2 = !("bar" !== e2 && "candlestick" !== e2 && "boxPlot" !== e2 && "rangeBar" !== e2), s2 = "area" === e2 || "line" === e2 || "scatter" === e2 || "bubble" === e2 || "radar" === e2, r2 = t3.globals.dom.Paper.node, n2 = this.getElGrid();
    n2 && (this.seriesBound = n2.getBoundingClientRect());
    var o2, l2 = [], h2 = [], c2 = { hoverArea: r2, elGrid: n2, tooltipEl: i, tooltipY: l2, tooltipX: h2, ttItems: this.ttItems };
    if (t3.globals.axisCharts && (s2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a2 ? o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e2 && "treemap" !== e2 || (o2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o2 && o2.length))
      for (var d2 = 0; d2 < o2.length; d2++)
        l2.push(o2[d2].getAttribute("cy")), h2.push(o2[d2].getAttribute("cx"));
    if (t3.globals.xyCharts && !this.showOnIntersect || t3.globals.comboCharts && !this.showOnIntersect || a2 && this.tooltipUtil.hasBars() && this.tConfig.shared)
      this.addPathsEventListeners([r2], c2);
    else if (a2 && !t3.globals.comboCharts || s2 && this.showOnIntersect)
      this.addDatapointEventsListeners(c2);
    else if (!t3.globals.axisCharts || "heatmap" === e2 || "treemap" === e2) {
      var u2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
      this.addPathsEventListeners(u2, c2);
    }
    if (this.showOnIntersect) {
      var g2 = t3.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
      g2.length > 0 && this.addPathsEventListeners(g2, c2), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(c2);
    }
  } }, { key: "drawFixedTooltipRect", value: function() {
    var t3 = this.w, e2 = this.getElTooltip(), i = e2.getBoundingClientRect(), a2 = i.width + 10, s2 = i.height + 10, r2 = this.tConfig.fixed.offsetX, n2 = this.tConfig.fixed.offsetY, o2 = this.tConfig.fixed.position.toLowerCase();
    return o2.indexOf("right") > -1 && (r2 = r2 + t3.globals.svgWidth - a2 + 10), o2.indexOf("bottom") > -1 && (n2 = n2 + t3.globals.svgHeight - s2 - 10), e2.style.left = r2 + "px", e2.style.top = n2 + "px", { x: r2, y: n2, ttWidth: a2, ttHeight: s2 };
  } }, { key: "addDatapointEventsListeners", value: function(t3) {
    var e2 = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
    this.addPathsEventListeners(e2, t3);
  } }, { key: "addPathsEventListeners", value: function(t3, e2) {
    for (var i = this, a2 = function(a3) {
      var s3 = { paths: t3[a3], tooltipEl: e2.tooltipEl, tooltipY: e2.tooltipY, tooltipX: e2.tooltipX, elGrid: e2.elGrid, hoverArea: e2.hoverArea, ttItems: e2.ttItems };
      ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map(function(e3) {
        return t3[a3].addEventListener(e3, i.onSeriesHover.bind(i, s3), { capture: false, passive: true });
      });
    }, s2 = 0; s2 < t3.length; s2++)
      a2(s2);
  } }, { key: "onSeriesHover", value: function(t3, e2) {
    var i = this, a2 = Date.now() - this.lastHoverTime;
    a2 >= 20 ? this.seriesHover(t3, e2) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout(function() {
      i.seriesHover(t3, e2);
    }, 20 - a2));
  } }, { key: "seriesHover", value: function(t3, e2) {
    var i = this;
    this.lastHoverTime = Date.now();
    var a2 = [], s2 = this.w;
    s2.config.chart.group && (a2 = this.ctx.getGroupedCharts()), s2.globals.axisCharts && (s2.globals.minX === -1 / 0 && s2.globals.maxX === 1 / 0 || 0 === s2.globals.dataPoints) || (a2.length ? a2.forEach(function(a3) {
      var s3 = i.getElTooltip(a3), r2 = { paths: t3.paths, tooltipEl: s3, tooltipY: t3.tooltipY, tooltipX: t3.tooltipX, elGrid: t3.elGrid, hoverArea: t3.hoverArea, ttItems: a3.w.globals.tooltip.ttItems };
      a3.w.globals.minX === i.w.globals.minX && a3.w.globals.maxX === i.w.globals.maxX && a3.w.globals.tooltip.seriesHoverByContext({ chartCtx: a3, ttCtx: a3.w.globals.tooltip, opt: r2, e: e2 });
    }) : this.seriesHoverByContext({ chartCtx: this.ctx, ttCtx: this.w.globals.tooltip, opt: t3, e: e2 }));
  } }, { key: "seriesHoverByContext", value: function(t3) {
    var e2 = t3.chartCtx, i = t3.ttCtx, a2 = t3.opt, s2 = t3.e, r2 = e2.w, n2 = this.getElTooltip(e2);
    if (n2) {
      if (i.tooltipRect = { x: 0, y: 0, ttWidth: n2.getBoundingClientRect().width, ttHeight: n2.getBoundingClientRect().height }, i.e = s2, i.tooltipUtil.hasBars() && !r2.globals.comboCharts && !i.isBarShared) {
        if (this.tConfig.onDatasetHover.highlightDataSeries)
          new Zi(e2).toggleSeriesOnHover(s2, s2.target.parentNode);
      }
      i.fixedTooltip && i.drawFixedTooltipRect(), r2.globals.axisCharts ? i.axisChartsTooltips({ e: s2, opt: a2, tooltipRect: i.tooltipRect }) : i.nonAxisChartsTooltips({ e: s2, opt: a2, tooltipRect: i.tooltipRect });
    }
  } }, { key: "axisChartsTooltips", value: function(t3) {
    var e2, i, a2 = t3.e, s2 = t3.opt, r2 = this.w, n2 = s2.elGrid.getBoundingClientRect(), o2 = "touchmove" === a2.type ? a2.touches[0].clientX : a2.clientX, l2 = "touchmove" === a2.type ? a2.touches[0].clientY : a2.clientY;
    if (this.clientY = l2, this.clientX = o2, r2.globals.capturedSeriesIndex = -1, r2.globals.capturedDataPointIndex = -1, l2 < n2.top || l2 > n2.top + n2.height)
      this.handleMouseOut(s2);
    else {
      if (Array.isArray(this.tConfig.enabledOnSeries) && !r2.config.tooltip.shared) {
        var h2 = parseInt(s2.paths.getAttribute("index"), 10);
        if (this.tConfig.enabledOnSeries.indexOf(h2) < 0)
          return void this.handleMouseOut(s2);
      }
      var c2 = this.getElTooltip(), d2 = this.getElXCrosshairs(), u2 = [];
      r2.config.chart.group && (u2 = this.ctx.getSyncedCharts());
      var g2 = r2.globals.xyCharts || "bar" === r2.config.chart.type && !r2.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || r2.globals.comboCharts && this.tooltipUtil.hasBars();
      if ("mousemove" === a2.type || "touchmove" === a2.type || "mouseup" === a2.type) {
        if (r2.globals.collapsedSeries.length + r2.globals.ancillaryCollapsedSeries.length === r2.globals.series.length)
          return;
        null !== d2 && d2.classList.add("apexcharts-active");
        var p2 = this.yaxisTooltips.filter(function(t4) {
          return true === t4;
        });
        if (null !== this.ycrosshairs && p2.length && this.ycrosshairs.classList.add("apexcharts-active"), g2 && !this.showOnIntersect || u2.length > 1)
          this.handleStickyTooltip(a2, o2, l2, s2);
        else if ("heatmap" === r2.config.chart.type || "treemap" === r2.config.chart.type) {
          var f2 = this.intersect.handleHeatTreeTooltip({ e: a2, opt: s2, x: e2, y: i, type: r2.config.chart.type });
          e2 = f2.x, i = f2.y, c2.style.left = e2 + "px", c2.style.top = i + "px";
        } else
          this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({ e: a2, opt: s2 }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({ e: a2, opt: s2, x: e2, y: i });
        if (this.yaxisTooltips.length)
          for (var x2 = 0; x2 < r2.config.yaxis.length; x2++)
            this.axesTooltip.drawYaxisTooltipText(x2, l2, this.xyRatios);
        r2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), s2.tooltipEl.classList.add("apexcharts-active");
      } else
        "mouseout" !== a2.type && "touchend" !== a2.type || this.handleMouseOut(s2);
    }
  } }, { key: "nonAxisChartsTooltips", value: function(t3) {
    var e2 = t3.e, i = t3.opt, a2 = t3.tooltipRect, s2 = this.w, r2 = i.paths.getAttribute("rel"), n2 = this.getElTooltip(), o2 = s2.globals.dom.elWrap.getBoundingClientRect();
    if ("mousemove" === e2.type || "touchmove" === e2.type) {
      s2.globals.dom.baseEl.classList.add("apexcharts-tooltip-active"), n2.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({ ttItems: i.ttItems, i: parseInt(r2, 10) - 1, shared: false });
      var l2 = s2.globals.clientX - o2.left - a2.ttWidth / 2, h2 = s2.globals.clientY - o2.top - a2.ttHeight - 10;
      if (n2.style.left = l2 + "px", n2.style.top = h2 + "px", s2.config.legend.tooltipHoverFormatter) {
        var c2 = r2 - 1, d2 = (0, s2.config.legend.tooltipHoverFormatter)(this.legendLabels[c2].getAttribute("data:default-text"), { seriesIndex: c2, dataPointIndex: c2, w: s2 });
        this.legendLabels[c2].innerHTML = d2;
      }
    } else
      "mouseout" !== e2.type && "touchend" !== e2.type || (n2.classList.remove("apexcharts-active"), s2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), s2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      }));
  } }, { key: "handleStickyTooltip", value: function(t3, e2, i, a2) {
    var s2 = this.w, r2 = this.tooltipUtil.getNearestValues({ context: this, hoverArea: a2.hoverArea, elGrid: a2.elGrid, clientX: e2, clientY: i }), n2 = r2.j, o2 = r2.capturedSeries;
    s2.globals.collapsedSeriesIndices.includes(o2) && (o2 = null);
    var l2 = a2.elGrid.getBoundingClientRect();
    if (r2.hoverX < 0 || r2.hoverX > l2.width)
      this.handleMouseOut(a2);
    else if (null !== o2)
      this.handleStickyCapturedSeries(t3, o2, a2, n2);
    else if (this.tooltipUtil.isXoverlap(n2) || s2.globals.isBarHorizontal) {
      var h2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, h2, n2, a2.ttItems);
    }
  } }, { key: "handleStickyCapturedSeries", value: function(t3, e2, i, a2) {
    var s2 = this.w;
    if (!this.tConfig.shared && null === s2.globals.series[e2][a2])
      return void this.handleMouseOut(i);
    if (void 0 !== s2.globals.series[e2][a2])
      this.tConfig.shared && this.tooltipUtil.isXoverlap(a2) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t3, this, e2, a2, i.ttItems) : this.create(t3, this, e2, a2, i.ttItems, false);
    else if (this.tooltipUtil.isXoverlap(a2)) {
      var r2 = s2.globals.series.findIndex(function(t4, e3) {
        return !s2.globals.collapsedSeriesIndices.includes(e3);
      });
      this.create(t3, this, r2, a2, i.ttItems);
    }
  } }, { key: "deactivateHoverFilter", value: function() {
    for (var t3 = this.w, e2 = new Mi(this.ctx), i = t3.globals.dom.Paper.find(".apexcharts-bar-area"), a2 = 0; a2 < i.length; a2++)
      e2.pathMouseLeave(i[a2]);
  } }, { key: "handleMouseOut", value: function(t3) {
    var e2 = this.w, i = this.getElXCrosshairs();
    if (e2.globals.dom.baseEl.classList.remove("apexcharts-tooltip-active"), t3.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e2.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
      null === this.yaxisTTEls && (this.yaxisTTEls = e2.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
      for (var a2 = 0; a2 < this.yaxisTTEls.length; a2++)
        this.yaxisTTEls[a2].classList.remove("apexcharts-active");
    }
    e2.config.legend.tooltipHoverFormatter && this.legendLabels.forEach(function(t4) {
      var e3 = t4.getAttribute("data:default-text");
      t4.innerHTML = decodeURIComponent(e3);
    });
  } }, { key: "markerClick", value: function(t3, e2, i) {
    var a2 = this.w;
    "function" == typeof a2.config.chart.events.markerClick && a2.config.chart.events.markerClick(t3, this.ctx, { seriesIndex: e2, dataPointIndex: i, w: a2 }), this.ctx.events.fireEvent("markerClick", [t3, this.ctx, { seriesIndex: e2, dataPointIndex: i, w: a2 }]);
  } }, { key: "create", value: function(t3, e2, i, a2, s2) {
    var r2, n2, o2, l2, h2, c2, d2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2 = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null, A2 = this.w, C2 = e2;
    "mouseup" === t3.type && this.markerClick(t3, i, a2), null === k2 && (k2 = this.tConfig.shared);
    var S2 = this.tooltipUtil.hasMarkers(i), L2 = this.tooltipUtil.getElBars(), M2 = function() {
      A2.globals.markers.largestSize > 0 ? C2.marker.enlargePoints(a2) : C2.tooltipPosition.moveDynamicPointsOnHover(a2);
    };
    if (A2.config.legend.tooltipHoverFormatter) {
      var P2 = A2.config.legend.tooltipHoverFormatter, I2 = Array.from(this.legendLabels);
      I2.forEach(function(t4) {
        var e3 = t4.getAttribute("data:default-text");
        t4.innerHTML = decodeURIComponent(e3);
      });
      for (var T2 = 0; T2 < I2.length; T2++) {
        var z2 = I2[T2], X2 = parseInt(z2.getAttribute("i"), 10), R2 = decodeURIComponent(z2.getAttribute("data:default-text")), E2 = P2(R2, { seriesIndex: k2 ? X2 : i, dataPointIndex: a2, w: A2 });
        if (k2)
          z2.innerHTML = A2.globals.collapsedSeriesIndices.indexOf(X2) < 0 ? E2 : R2;
        else if (z2.innerHTML = X2 === i ? E2 : R2, i === X2)
          break;
      }
    }
    var Y2 = u(u({ ttItems: s2, i, j: a2 }, void 0 !== (null === (r2 = A2.globals.seriesRange) || void 0 === r2 || null === (n2 = r2[i]) || void 0 === n2 || null === (o2 = n2[a2]) || void 0 === o2 || null === (l2 = o2.y[0]) || void 0 === l2 ? void 0 : l2.y1) && { y1: null === (h2 = A2.globals.seriesRange) || void 0 === h2 || null === (c2 = h2[i]) || void 0 === c2 || null === (d2 = c2[a2]) || void 0 === d2 || null === (g2 = d2.y[0]) || void 0 === g2 ? void 0 : g2.y1 }), void 0 !== (null === (p2 = A2.globals.seriesRange) || void 0 === p2 || null === (f2 = p2[i]) || void 0 === f2 || null === (x2 = f2[a2]) || void 0 === x2 || null === (b2 = x2.y[0]) || void 0 === b2 ? void 0 : b2.y2) && { y2: null === (m2 = A2.globals.seriesRange) || void 0 === m2 || null === (v2 = m2[i]) || void 0 === v2 || null === (y2 = v2[a2]) || void 0 === y2 || null === (w2 = y2.y[0]) || void 0 === w2 ? void 0 : w2.y2 });
    if (k2) {
      if (C2.tooltipLabels.drawSeriesTexts(u(u({}, Y2), {}, { shared: !this.showOnIntersect && this.tConfig.shared })), S2)
        M2();
      else if (this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(L2), this.barSeriesHeight > 0)) {
        var H2 = new Mi(this.ctx), O2 = A2.globals.dom.Paper.find(".apexcharts-bar-area[j='".concat(a2, "']"));
        this.deactivateHoverFilter(), C2.tooltipPosition.moveStickyTooltipOverBars(a2, i), C2.tooltipUtil.getAllMarkers(true).length && M2();
        for (var F2 = 0; F2 < O2.length; F2++)
          H2.pathMouseEnter(O2[F2]);
      }
    } else
      C2.tooltipLabels.drawSeriesTexts(u({ shared: false }, Y2)), this.tooltipUtil.hasBars() && C2.tooltipPosition.moveStickyTooltipOverBars(a2, i), S2 && C2.tooltipPosition.moveMarkers(i, a2);
  } }]), t2;
}(), La = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.barCtx = e2, this.totalFormatter = this.w.config.plotOptions.bar.dataLabels.total.formatter, this.totalFormatter || (this.totalFormatter = this.w.config.dataLabels.formatter);
  }
  return s(t2, [{ key: "handleBarDataLabels", value: function(t3) {
    var e2, i, a2 = t3.x, s2 = t3.y, r2 = t3.y1, n2 = t3.y2, o2 = t3.i, l2 = t3.j, h2 = t3.realIndex, c2 = t3.columnGroupIndex, d2 = t3.series, g2 = t3.barHeight, p2 = t3.barWidth, f2 = t3.barXPosition, x2 = t3.barYPosition, b2 = t3.visibleSeries, m2 = t3.renderedPath, v2 = this.w, y2 = new Mi(this.barCtx.ctx), w2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[h2] : this.barCtx.strokeWidth;
    v2.globals.isXNumeric && !v2.globals.isBarHorizontal ? (e2 = a2 + parseFloat(p2 * (b2 + 1)), i = s2 + parseFloat(g2 * (b2 + 1)) - w2) : (e2 = a2 + parseFloat(p2 * b2), i = s2 + parseFloat(g2 * b2));
    var k2, A2 = null, C2 = a2, S2 = s2, L2 = {}, M2 = v2.config.dataLabels, P2 = this.barCtx.barOptions.dataLabels, I2 = this.barCtx.barOptions.dataLabels.total;
    void 0 !== x2 && this.barCtx.isRangeBar && (i = x2, S2 = x2), void 0 !== f2 && this.barCtx.isVerticalGroupedRangeBar && (e2 = f2, C2 = f2);
    var T2 = M2.offsetX, z2 = M2.offsetY, X2 = { width: 0, height: 0 };
    if (v2.config.dataLabels.enabled) {
      var R2 = v2.globals.series[o2][l2];
      X2 = y2.getTextRects(v2.config.dataLabels.formatter ? v2.config.dataLabels.formatter(R2, u(u({}, v2), {}, { seriesIndex: o2, dataPointIndex: l2, w: v2 })) : v2.globals.yLabelFormatters[0](R2), parseFloat(M2.style.fontSize));
    }
    var E2 = { x: a2, y: s2, i: o2, j: l2, realIndex: h2, columnGroupIndex: c2, renderedPath: m2, bcx: e2, bcy: i, barHeight: g2, barWidth: p2, textRects: X2, strokeWidth: w2, dataLabelsX: C2, dataLabelsY: S2, dataLabelsConfig: M2, barDataLabelsConfig: P2, barTotalDataLabelsConfig: I2, offX: T2, offY: z2 };
    return L2 = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(E2) : this.calculateColumnsDataLabelsPosition(E2), m2.attr({ cy: L2.bcy, cx: L2.bcx, j: l2, val: v2.globals.series[o2][l2], barHeight: g2, barWidth: p2 }), k2 = this.drawCalculatedDataLabels({ x: L2.dataLabelsX, y: L2.dataLabelsY, val: this.barCtx.isRangeBar ? [r2, n2] : "100%" === v2.config.chart.stackType ? d2[h2][l2] : v2.globals.series[h2][l2], i: h2, j: l2, barWidth: p2, barHeight: g2, textRects: X2, dataLabelsConfig: M2 }), v2.config.chart.stacked && I2.enabled && (A2 = this.drawTotalDataLabels({ x: L2.totalDataLabelsX, y: L2.totalDataLabelsY, barWidth: p2, barHeight: g2, realIndex: h2, textAnchor: L2.totalDataLabelsAnchor, val: this.getStackedTotalDataLabel({ realIndex: h2, j: l2 }), dataLabelsConfig: M2, barTotalDataLabelsConfig: I2 })), { dataLabels: k2, totalDataLabels: A2 };
  } }, { key: "getStackedTotalDataLabel", value: function(t3) {
    var e2 = t3.realIndex, i = t3.j, a2 = this.w, s2 = this.barCtx.stackedSeriesTotals[i];
    return this.totalFormatter && (s2 = this.totalFormatter(s2, u(u({}, a2), {}, { seriesIndex: e2, dataPointIndex: i, w: a2 }))), s2;
  } }, { key: "calculateColumnsDataLabelsPosition", value: function(t3) {
    var e2 = this, i = this.w, a2 = t3.i, s2 = t3.j, r2 = t3.realIndex;
    t3.columnGroupIndex;
    var n2, o2, l2 = t3.y, h2 = t3.bcx, c2 = t3.barWidth, d2 = t3.barHeight, u2 = t3.textRects, g2 = t3.dataLabelsX, p2 = t3.dataLabelsY, f2 = t3.dataLabelsConfig, x2 = t3.barDataLabelsConfig, b2 = t3.barTotalDataLabelsConfig, m2 = t3.strokeWidth, v2 = t3.offX, y2 = t3.offY, w2 = h2;
    d2 = Math.abs(d2);
    var k2 = "vertical" === i.config.plotOptions.bar.dataLabels.orientation, A2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: a2, j: s2 }).zeroEncounters;
    h2 -= m2 / 2;
    var C2 = i.globals.gridWidth / i.globals.dataPoints;
    if (this.barCtx.isVerticalGroupedRangeBar ? g2 += c2 / 2 : (g2 = i.globals.isXNumeric ? h2 - c2 / 2 + v2 : h2 - C2 + c2 / 2 + v2, !i.config.chart.stacked && A2 > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (g2 -= c2 * A2)), k2) {
      g2 = g2 + u2.height / 2 - m2 / 2 - 2;
    }
    var S2 = i.globals.series[a2][s2] < 0, L2 = l2;
    switch (this.barCtx.isReversed && (L2 = l2 + (S2 ? d2 : -d2)), x2.position) {
      case "center":
        p2 = k2 ? S2 ? L2 - d2 / 2 + y2 : L2 + d2 / 2 - y2 : S2 ? L2 - d2 / 2 + u2.height / 2 + y2 : L2 + d2 / 2 + u2.height / 2 - y2;
        break;
      case "bottom":
        p2 = k2 ? S2 ? L2 - d2 + y2 : L2 + d2 - y2 : S2 ? L2 - d2 + u2.height + m2 + y2 : L2 + d2 - u2.height / 2 + m2 - y2;
        break;
      case "top":
        p2 = k2 ? S2 ? L2 + y2 : L2 - y2 : S2 ? L2 - u2.height / 2 - y2 : L2 + u2.height + y2;
    }
    var M2 = L2;
    if (i.globals.seriesGroups.forEach(function(t4) {
      var i2;
      null === (i2 = e2.barCtx[t4.join(",")]) || void 0 === i2 || i2.prevY.forEach(function(t5) {
        M2 = S2 ? Math.max(t5[s2], M2) : Math.min(t5[s2], M2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === r2 && b2.enabled) {
      var P2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: r2, j: s2 }), f2.fontSize);
      n2 = S2 ? M2 - P2.height / 2 - y2 - b2.offsetY + 18 : M2 + P2.height + y2 + b2.offsetY - 18;
      var I2 = C2;
      o2 = w2 + (i.globals.isXNumeric ? -c2 * i.globals.barGroups.length / 2 : i.globals.barGroups.length * c2 / 2 - (i.globals.barGroups.length - 1) * c2 - I2) + b2.offsetX;
    }
    return i.config.chart.stacked || (p2 < 0 ? p2 = 0 + m2 : p2 + u2.height / 3 > i.globals.gridHeight && (p2 = i.globals.gridHeight - m2)), { bcx: h2, bcy: l2, dataLabelsX: g2, dataLabelsY: p2, totalDataLabelsX: o2, totalDataLabelsY: n2, totalDataLabelsAnchor: "middle" };
  } }, { key: "calculateBarsDataLabelsPosition", value: function(t3) {
    var e2 = this, i = this.w, a2 = t3.x, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = t3.bcy, l2 = t3.barHeight, h2 = t3.barWidth, c2 = t3.textRects, d2 = t3.dataLabelsX, u2 = t3.strokeWidth, g2 = t3.dataLabelsConfig, p2 = t3.barDataLabelsConfig, f2 = t3.barTotalDataLabelsConfig, x2 = t3.offX, b2 = t3.offY, m2 = i.globals.gridHeight / i.globals.dataPoints, v2 = this.barCtx.barHelpers.getZeroValueEncounters({ i: s2, j: r2 }).zeroEncounters;
    h2 = Math.abs(h2);
    var y2, w2, k2 = o2 - (this.barCtx.isRangeBar ? 0 : m2) + l2 / 2 + c2.height / 2 + b2 - 3;
    !i.config.chart.stacked && v2 > 0 && i.config.plotOptions.bar.hideZeroBarsWhenGrouped && (k2 -= l2 * v2);
    var A2 = "start", C2 = i.globals.series[s2][r2] < 0, S2 = a2;
    switch (this.barCtx.isReversed && (S2 = a2 + (C2 ? -h2 : h2), A2 = C2 ? "start" : "end"), p2.position) {
      case "center":
        d2 = C2 ? S2 + h2 / 2 - x2 : Math.max(c2.width / 2, S2 - h2 / 2) + x2;
        break;
      case "bottom":
        d2 = C2 ? S2 + h2 - u2 - x2 : S2 - h2 + u2 + x2;
        break;
      case "top":
        d2 = C2 ? S2 - u2 - x2 : S2 - u2 + x2;
    }
    var L2 = S2;
    if (i.globals.seriesGroups.forEach(function(t4) {
      var i2;
      null === (i2 = e2.barCtx[t4.join(",")]) || void 0 === i2 || i2.prevX.forEach(function(t5) {
        L2 = C2 ? Math.min(t5[r2], L2) : Math.max(t5[r2], L2);
      });
    }), this.barCtx.lastActiveBarSerieIndex === n2 && f2.enabled) {
      var M2 = new Mi(this.barCtx.ctx).getTextRects(this.getStackedTotalDataLabel({ realIndex: n2, j: r2 }), g2.fontSize);
      C2 ? (y2 = L2 - u2 - x2 - f2.offsetX, A2 = "end") : y2 = L2 + x2 + f2.offsetX + (this.barCtx.isReversed ? -(h2 + u2) : u2), w2 = k2 - c2.height / 2 + M2.height / 2 + f2.offsetY + u2, i.globals.barGroups.length > 1 && (w2 -= i.globals.barGroups.length / 2 * (l2 / 2));
    }
    return i.config.chart.stacked || ("start" === g2.textAnchor ? d2 - c2.width < 0 ? d2 = C2 ? c2.width + u2 : u2 : d2 + c2.width > i.globals.gridWidth && (d2 = C2 ? i.globals.gridWidth - u2 : i.globals.gridWidth - c2.width - u2) : "middle" === g2.textAnchor ? d2 - c2.width / 2 < 0 ? d2 = c2.width / 2 + u2 : d2 + c2.width / 2 > i.globals.gridWidth && (d2 = i.globals.gridWidth - c2.width / 2 - u2) : "end" === g2.textAnchor && (d2 < 1 ? d2 = c2.width + u2 : d2 + 1 > i.globals.gridWidth && (d2 = i.globals.gridWidth - c2.width - u2))), { bcx: a2, bcy: o2, dataLabelsX: d2, dataLabelsY: k2, totalDataLabelsX: y2, totalDataLabelsY: w2, totalDataLabelsAnchor: A2 };
  } }, { key: "drawCalculatedDataLabels", value: function(t3) {
    var e2 = t3.x, i = t3.y, a2 = t3.val, s2 = t3.i, r2 = t3.j, n2 = t3.textRects, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.dataLabelsConfig, c2 = this.w, d2 = "rotate(0)";
    "vertical" === c2.config.plotOptions.bar.dataLabels.orientation && (d2 = "rotate(-90, ".concat(e2, ", ").concat(i, ")"));
    var g2 = new qi(this.barCtx.ctx), p2 = new Mi(this.barCtx.ctx), f2 = h2.formatter, x2 = null, b2 = c2.globals.collapsedSeriesIndices.indexOf(s2) > -1;
    if (h2.enabled && !b2) {
      x2 = p2.group({ class: "apexcharts-data-labels", transform: d2 });
      var m2 = "";
      void 0 !== a2 && (m2 = f2(a2, u(u({}, c2), {}, { seriesIndex: s2, dataPointIndex: r2, w: c2 }))), !a2 && c2.config.plotOptions.bar.hideZeroBarsWhenGrouped && (m2 = "");
      var v2 = c2.globals.series[s2][r2] < 0, y2 = c2.config.plotOptions.bar.dataLabels.position;
      if ("vertical" === c2.config.plotOptions.bar.dataLabels.orientation && ("top" === y2 && (h2.textAnchor = v2 ? "end" : "start"), "center" === y2 && (h2.textAnchor = "middle"), "bottom" === y2 && (h2.textAnchor = v2 ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels)
        l2 < p2.getTextRects(m2, parseFloat(h2.style.fontSize)).width && (m2 = "");
      c2.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? n2.width / 1.6 > Math.abs(l2) && (m2 = "") : n2.height / 1.6 > Math.abs(o2) && (m2 = ""));
      var w2 = u({}, h2);
      this.barCtx.isHorizontal && a2 < 0 && ("start" === h2.textAnchor ? w2.textAnchor = "end" : "end" === h2.textAnchor && (w2.textAnchor = "start")), g2.plotDataLabelsText({ x: e2, y: i, text: m2, i: s2, j: r2, parent: x2, dataLabelsConfig: w2, alwaysDrawDataLabel: true, offsetCorrection: true });
    }
    return x2;
  } }, { key: "drawTotalDataLabels", value: function(t3) {
    var e2 = t3.x, i = t3.y, a2 = t3.val, s2 = t3.realIndex, r2 = t3.textAnchor, n2 = t3.barTotalDataLabelsConfig;
    this.w;
    var o2, l2 = new Mi(this.barCtx.ctx);
    return n2.enabled && void 0 !== e2 && void 0 !== i && this.barCtx.lastActiveBarSerieIndex === s2 && (o2 = l2.drawText({ x: e2, y: i, foreColor: n2.style.color, text: a2, textAnchor: r2, fontFamily: n2.style.fontFamily, fontSize: n2.style.fontSize, fontWeight: n2.style.fontWeight })), o2;
  } }]), t2;
}(), Ma = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.barCtx = e2;
  }
  return s(t2, [{ key: "initVariables", value: function(t3) {
    var e2 = this.w;
    this.barCtx.series = t3, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
    for (var i = 0; i < t3.length; i++)
      if (t3[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t3[i].length), e2.globals.isXNumeric)
        for (var a2 = 0; a2 < t3[i].length; a2++)
          e2.globals.seriesX[i][a2] > e2.globals.minX && e2.globals.seriesX[i][a2] < e2.globals.maxX && this.barCtx.visibleItems++;
      else
        this.barCtx.visibleItems = e2.globals.dataPoints;
    this.arrBorderRadius = this.createBorderRadiusArr(e2.globals.series), 0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], e2.globals.comboCharts || this.checkZeroSeries({ series: t3 });
  } }, { key: "initialPositions", value: function(t3) {
    var e2, i, a2, s2, r2, n2, o2, l2, h2 = this.w, c2 = h2.globals.dataPoints;
    this.barCtx.isRangeBar && (c2 = h2.globals.labels.length);
    var d2 = this.barCtx.seriesLen;
    if (h2.config.plotOptions.bar.rangeBarGroupRows && (d2 = 1), this.barCtx.isHorizontal)
      r2 = (a2 = h2.globals.gridHeight / c2) / d2, h2.globals.isXNumeric && (r2 = (a2 = h2.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), r2 = r2 * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, -1 === String(this.barCtx.barOptions.barHeight).indexOf("%") && (r2 = parseInt(this.barCtx.barOptions.barHeight, 10)), l2 = this.barCtx.baseLineInvertedY + h2.globals.padHorizontal + (this.barCtx.isReversed ? h2.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), this.barCtx.isFunnel && (l2 = h2.globals.gridWidth / 2), i = (a2 - r2 * this.barCtx.seriesLen) / 2;
    else {
      if (s2 = h2.globals.gridWidth / this.barCtx.visibleItems, h2.config.xaxis.convertedCatToNumeric && (s2 = h2.globals.gridWidth / h2.globals.dataPoints), n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, h2.globals.isXNumeric) {
        var u2 = this.barCtx.xRatio;
        h2.globals.minXDiff && 0.5 !== h2.globals.minXDiff && h2.globals.minXDiff / u2 > 0 && (s2 = h2.globals.minXDiff / u2), (n2 = s2 / d2 * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (n2 = 1);
      }
      if (-1 === String(this.barCtx.barOptions.columnWidth).indexOf("%") && (n2 = parseInt(this.barCtx.barOptions.columnWidth, 10)), o2 = h2.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.translationsIndex] - (this.barCtx.isReversed ? h2.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.translationsIndex] : 0), h2.globals.isXNumeric)
        e2 = this.barCtx.getBarXForNumericXAxis({ x: e2, j: 0, realIndex: t3, barWidth: n2 }).x;
      else
        e2 = h2.globals.padHorizontal + v.noExponents(s2 - n2 * this.barCtx.seriesLen) / 2;
    }
    return h2.globals.barHeight = r2, h2.globals.barWidth = n2, { x: e2, y: i, yDivision: a2, xDivision: s2, barHeight: r2, barWidth: n2, zeroH: o2, zeroW: l2 };
  } }, { key: "initializeStackedPrevVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].prevY = [], t3[e2].prevX = [], t3[e2].prevYF = [], t3[e2].prevXF = [], t3[e2].prevYVal = [], t3[e2].prevXVal = [];
    });
  } }, { key: "initializeStackedXYVars", value: function(t3) {
    t3.w.globals.seriesGroups.forEach(function(e2) {
      t3[e2] || (t3[e2] = {}), t3[e2].xArrj = [], t3[e2].xArrjF = [], t3[e2].xArrjVal = [], t3[e2].yArrj = [], t3[e2].yArrjF = [], t3[e2].yArrjVal = [];
    });
  } }, { key: "getPathFillColor", value: function(t3, e2, i, a2) {
    var s2, r2, n2, o2, l2 = this.w, h2 = this.barCtx.ctx.fill, c2 = null, d2 = this.barCtx.barOptions.distributed ? i : e2, u2 = false;
    this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map(function(a3) {
      t3[e2][i] >= a3.from && t3[e2][i] <= a3.to && (c2 = a3.color, u2 = true);
    });
    return { color: h2.fillPath({ seriesNumber: this.barCtx.barOptions.distributed ? d2 : a2, dataPointIndex: i, color: c2, value: t3[e2][i], fillConfig: null === (s2 = l2.config.series[e2].data[i]) || void 0 === s2 ? void 0 : s2.fill, fillType: null !== (r2 = l2.config.series[e2].data[i]) && void 0 !== r2 && null !== (n2 = r2.fill) && void 0 !== n2 && n2.type ? null === (o2 = l2.config.series[e2].data[i]) || void 0 === o2 ? void 0 : o2.fill.type : Array.isArray(l2.config.fill.type) ? l2.config.fill.type[a2] : l2.config.fill.type }), useRangeColor: u2 };
  } }, { key: "getStrokeWidth", value: function(t3, e2, i) {
    var a2 = 0, s2 = this.w;
    return this.barCtx.series[t3][e2] ? this.barCtx.isNullValue = false : this.barCtx.isNullValue = true, s2.config.stroke.show && (this.barCtx.isNullValue || (a2 = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a2;
  } }, { key: "createBorderRadiusArr", value: function(t3) {
    var e2, i = this.w, a2 = !this.w.config.chart.stacked || i.config.plotOptions.bar.borderRadius <= 0, s2 = t3.length, n2 = 0 | (null === (e2 = t3[0]) || void 0 === e2 ? void 0 : e2.length), o2 = Array.from({ length: s2 }, function() {
      return Array(n2).fill(a2 ? "top" : "none");
    });
    if (a2)
      return o2;
    for (var l2 = 0; l2 < n2; l2++) {
      for (var h2 = [], c2 = [], d2 = 0, u2 = 0; u2 < s2; u2++) {
        var g2 = t3[u2][l2];
        g2 > 0 ? (h2.push(u2), d2++) : g2 < 0 && (c2.push(u2), d2++);
      }
      if (h2.length > 0 && 0 === c2.length)
        if (1 === h2.length)
          o2[h2[0]][l2] = "both";
        else {
          var p2, f2 = h2[0], x2 = h2[h2.length - 1], b2 = r(h2);
          try {
            for (b2.s(); !(p2 = b2.n()).done; ) {
              var m2 = p2.value;
              o2[m2][l2] = m2 === f2 ? "bottom" : m2 === x2 ? "top" : "none";
            }
          } catch (t4) {
            b2.e(t4);
          } finally {
            b2.f();
          }
        }
      else if (c2.length > 0 && 0 === h2.length)
        if (1 === c2.length)
          o2[c2[0]][l2] = "both";
        else {
          var v2, y2 = Math.max.apply(Math, c2), w2 = Math.min.apply(Math, c2), k2 = r(c2);
          try {
            for (k2.s(); !(v2 = k2.n()).done; ) {
              var A2 = v2.value;
              o2[A2][l2] = A2 === y2 ? "bottom" : A2 === w2 ? "top" : "none";
            }
          } catch (t4) {
            k2.e(t4);
          } finally {
            k2.f();
          }
        }
      else if (h2.length > 0 && c2.length > 0) {
        var C2, S2 = h2[h2.length - 1], L2 = r(h2);
        try {
          for (L2.s(); !(C2 = L2.n()).done; ) {
            var M2 = C2.value;
            o2[M2][l2] = M2 === S2 ? "top" : "none";
          }
        } catch (t4) {
          L2.e(t4);
        } finally {
          L2.f();
        }
        var P2, I2 = Math.max.apply(Math, c2), T2 = r(c2);
        try {
          for (T2.s(); !(P2 = T2.n()).done; ) {
            var z2 = P2.value;
            o2[z2][l2] = z2 === I2 ? "bottom" : "none";
          }
        } catch (t4) {
          T2.e(t4);
        } finally {
          T2.f();
        }
      } else if (1 === d2) {
        o2[h2[0] || c2[0]][l2] = "both";
      }
    }
    return o2;
  } }, { key: "barBackground", value: function(t3) {
    var e2 = t3.j, i = t3.i, a2 = t3.x1, s2 = t3.x2, r2 = t3.y1, n2 = t3.y2, o2 = t3.elSeries, l2 = this.w, h2 = new Mi(this.barCtx.ctx), c2 = new Zi(this.barCtx.ctx).getActiveConfigSeriesIndex();
    if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && c2 === i) {
      e2 >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e2 %= this.barCtx.barOptions.colors.backgroundBarColors.length);
      var d2 = this.barCtx.barOptions.colors.backgroundBarColors[e2], u2 = h2.drawRect(void 0 !== a2 ? a2 : 0, void 0 !== r2 ? r2 : 0, void 0 !== s2 ? s2 : l2.globals.gridWidth, void 0 !== n2 ? n2 : l2.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d2, this.barCtx.barOptions.colors.backgroundBarOpacity);
      o2.add(u2), u2.node.classList.add("apexcharts-backgroundBar");
    }
  } }, { key: "getColumnPaths", value: function(t3) {
    var e2, i = t3.barWidth, a2 = t3.barXPosition, s2 = t3.y1, r2 = t3.y2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) && void 0 !== e2 && e2.columnWidthOffset && (x2 = a2 - g2.config.series[c2].data[u2].columnWidthOffset / 2, f2 = i + g2.config.series[c2].data[u2].columnWidthOffset);
    var b2 = n2 / 2, m2 = x2 + b2, v2 = x2 + f2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 - b2 * y2, r2 += 1e-3 + b2 * y2;
    var w2 = p2.move(m2, s2), k2 = p2.move(m2, s2), A2 = p2.line(v2, s2);
    if (g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false)), w2 = w2 + p2.line(m2, r2) + p2.line(v2, r2) + A2 + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), k2 = k2 + p2.line(m2, s2) + A2 + A2 + A2 + A2 + A2 + p2.line(m2, s2) + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), "none" !== this.arrBorderRadius[c2][u2] && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).yArrj.push(r2 - b2 * y2), C2.yArrjF.push(Math.abs(s2 - r2 + n2 * y2)), C2.yArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "getBarpaths", value: function(t3) {
    var e2, i = t3.barYPosition, a2 = t3.barHeight, s2 = t3.x1, r2 = t3.x2, n2 = t3.strokeWidth, o2 = t3.isReversed, l2 = t3.series, h2 = t3.seriesGroup, c2 = t3.realIndex, d2 = t3.i, u2 = t3.j, g2 = t3.w, p2 = new Mi(this.barCtx.ctx);
    (n2 = Array.isArray(n2) ? n2[c2] : n2) || (n2 = 0);
    var f2 = i, x2 = a2;
    null !== (e2 = g2.config.series[c2].data[u2]) && void 0 !== e2 && e2.barHeightOffset && (f2 = i - g2.config.series[c2].data[u2].barHeightOffset / 2, x2 = a2 + g2.config.series[c2].data[u2].barHeightOffset);
    var b2 = n2 / 2, m2 = f2 + b2, v2 = f2 + x2 - b2, y2 = (l2[d2][u2] >= 0 ? 1 : -1) * (o2 ? -1 : 1);
    s2 += 1e-3 + b2 * y2, r2 += 1e-3 - b2 * y2;
    var w2 = p2.move(s2, m2), k2 = p2.move(s2, m2);
    g2.globals.previousPaths.length > 0 && (k2 = this.barCtx.getPreviousPath(c2, u2, false));
    var A2 = p2.line(s2, v2);
    if (w2 = w2 + p2.line(r2, m2) + p2.line(r2, v2) + A2 + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), k2 = k2 + p2.line(s2, m2) + A2 + A2 + A2 + A2 + A2 + p2.line(s2, m2) + ("around" === g2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[c2][u2] ? " Z" : " z"), "none" !== this.arrBorderRadius[c2][u2] && (w2 = p2.roundPathCorners(w2, g2.config.plotOptions.bar.borderRadius)), g2.config.chart.stacked) {
      var C2 = this.barCtx;
      (C2 = this.barCtx[h2]).xArrj.push(r2 + b2 * y2), C2.xArrjF.push(Math.abs(s2 - r2 - n2 * y2)), C2.xArrjVal.push(this.barCtx.series[d2][u2]);
    }
    return { pathTo: w2, pathFrom: k2 };
  } }, { key: "checkZeroSeries", value: function(t3) {
    for (var e2 = t3.series, i = this.w, a2 = 0; a2 < e2.length; a2++) {
      for (var s2 = 0, r2 = 0; r2 < e2[i.globals.maxValsInArrayIndex].length; r2++)
        s2 += e2[a2][r2];
      0 === s2 && this.barCtx.zeroSerieses.push(a2);
    }
  } }, { key: "getXForValue", value: function(t3, e2) {
    var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2] ? e2 : null;
    return null != t3 && (i = e2 + t3 / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t3 / this.barCtx.invertedYRatio : 0)), i;
  } }, { key: "getYForValue", value: function(t3, e2, i) {
    var a2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3] ? e2 : null;
    return null != t3 && (a2 = e2 - t3 / this.barCtx.yRatio[i] + 2 * (this.barCtx.isReversed ? t3 / this.barCtx.yRatio[i] : 0)), a2;
  } }, { key: "getGoalValues", value: function(t3, e2, i, a2, s2, r2) {
    var n2 = this, l2 = this.w, h2 = [], c2 = function(a3, s3) {
      var l3;
      h2.push((o(l3 = {}, t3, "x" === t3 ? n2.getXForValue(a3, e2, false) : n2.getYForValue(a3, i, r2, false)), o(l3, "attrs", s3), l3));
    };
    if (l2.globals.seriesGoals[a2] && l2.globals.seriesGoals[a2][s2] && Array.isArray(l2.globals.seriesGoals[a2][s2]) && l2.globals.seriesGoals[a2][s2].forEach(function(t4) {
      c2(t4.value, t4);
    }), this.barCtx.barOptions.isDumbbell && l2.globals.seriesRange.length) {
      var d2 = this.barCtx.barOptions.dumbbellColors ? this.barCtx.barOptions.dumbbellColors : l2.globals.colors, g2 = { strokeHeight: "x" === t3 ? 0 : l2.globals.markers.size[a2], strokeWidth: "x" === t3 ? l2.globals.markers.size[a2] : 0, strokeDashArray: 0, strokeLineCap: "round", strokeColor: Array.isArray(d2[a2]) ? d2[a2][0] : d2[a2] };
      c2(l2.globals.seriesRangeStart[a2][s2], g2), c2(l2.globals.seriesRangeEnd[a2][s2], u(u({}, g2), {}, { strokeColor: Array.isArray(d2[a2]) ? d2[a2][1] : d2[a2] }));
    }
    return h2;
  } }, { key: "drawGoalLine", value: function(t3) {
    var e2 = t3.barXPosition, i = t3.barYPosition, a2 = t3.goalX, s2 = t3.goalY, r2 = t3.barWidth, n2 = t3.barHeight, o2 = new Mi(this.barCtx.ctx), l2 = o2.group({ className: "apexcharts-bar-goals-groups" });
    l2.node.classList.add("apexcharts-element-hidden"), this.barCtx.w.globals.delayedElements.push({ el: l2.node }), l2.attr("clip-path", "url(#gridRectMarkerMask".concat(this.barCtx.w.globals.cuid, ")"));
    var h2 = null;
    return this.barCtx.isHorizontal ? Array.isArray(a2) && a2.forEach(function(t4) {
      if (t4.x >= -1 && t4.x <= o2.w.globals.gridWidth + 1) {
        var e3 = void 0 !== t4.attrs.strokeHeight ? t4.attrs.strokeHeight : n2 / 2, a3 = i + e3 + n2 / 2;
        h2 = o2.drawLine(t4.x, a3 - 2 * e3, t4.x, a3, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeWidth ? t4.attrs.strokeWidth : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }) : Array.isArray(s2) && s2.forEach(function(t4) {
      if (t4.y >= -1 && t4.y <= o2.w.globals.gridHeight + 1) {
        var i2 = void 0 !== t4.attrs.strokeWidth ? t4.attrs.strokeWidth : r2 / 2, a3 = e2 + i2 + r2 / 2;
        h2 = o2.drawLine(a3 - 2 * i2, t4.y, a3, t4.y, t4.attrs.strokeColor ? t4.attrs.strokeColor : void 0, t4.attrs.strokeDashArray, t4.attrs.strokeHeight ? t4.attrs.strokeHeight : 2, t4.attrs.strokeLineCap), l2.add(h2);
      }
    }), l2;
  } }, { key: "drawBarShadow", value: function(t3) {
    var e2 = t3.prevPaths, i = t3.currPaths, a2 = t3.color, s2 = this.w, r2 = e2.x, n2 = e2.x1, o2 = e2.barYPosition, l2 = i.x, h2 = i.x1, c2 = i.barYPosition, d2 = o2 + i.barHeight, u2 = new Mi(this.barCtx.ctx), g2 = new v(), p2 = u2.move(n2, d2) + u2.line(r2, d2) + u2.line(l2, c2) + u2.line(h2, c2) + u2.line(n2, d2) + ("around" === s2.config.plotOptions.bar.borderRadiusApplication || "both" === this.arrBorderRadius[realIndex][j] ? " Z" : " z");
    return u2.drawPath({ d: p2, fill: g2.shadeColor(0.5, v.rgb2hex(a2)), stroke: "none", strokeWidth: 0, fillOpacity: 1, classes: "apexcharts-bar-shadow apexcharts-decoration-element" });
  } }, { key: "getZeroValueEncounters", value: function(t3) {
    var e2, i = t3.i, a2 = t3.j, s2 = this.w, r2 = 0, n2 = 0;
    return (s2.config.plotOptions.bar.horizontal ? s2.globals.series.map(function(t4, e3) {
      return e3;
    }) : (null === (e2 = s2.globals.columnSeries) || void 0 === e2 ? void 0 : e2.i.map(function(t4) {
      return t4;
    })) || []).forEach(function(t4) {
      var e3 = s2.globals.seriesPercent[t4][a2];
      e3 && r2++, t4 < i && 0 === e3 && n2++;
    }), { nonZeroColumns: r2, zeroEncounters: n2 };
  } }, { key: "getGroupIndex", value: function(t3) {
    var e2 = this.w, i = e2.globals.seriesGroups.findIndex(function(i2) {
      return i2.indexOf(e2.globals.seriesNames[t3]) > -1;
    }), a2 = this.barCtx.columnGroupIndices, s2 = a2.indexOf(i);
    return s2 < 0 && (a2.push(i), s2 = a2.length - 1), { groupIndex: i, columnGroupIndex: s2 };
  } }]), t2;
}(), Pa = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
    var s2 = this.w;
    this.barOptions = s2.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = s2.config.stroke.width, this.isNullValue = false, this.isRangeBar = s2.globals.seriesRange.length && this.isHorizontal, this.isVerticalGroupedRangeBar = !s2.globals.isBarHorizontal && s2.globals.seriesRange.length && s2.config.plotOptions.bar.rangeBarGroupRows, this.isFunnel = this.barOptions.isFunnel, this.xyRatios = a2, null !== this.xyRatios && (this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.invertedXRatio = a2.invertedXRatio, this.invertedYRatio = a2.invertedYRatio, this.baseLineY = a2.baseLineY, this.baseLineInvertedY = a2.baseLineInvertedY), this.yaxisIndex = 0, this.translationsIndex = 0, this.seriesLen = 0, this.pathArr = [];
    var r2 = new Zi(this.ctx);
    this.lastActiveBarSerieIndex = r2.getActiveConfigSeriesIndex("desc", ["bar", "column"]), this.columnGroupIndices = [];
    var n2 = r2.getBarSeriesIndices(), o2 = new Pi(this.ctx);
    this.stackedSeriesTotals = o2.getStackedSeriesTotals(this.w.config.series.map(function(t3, e3) {
      return -1 === n2.indexOf(e3) ? e3 : -1;
    }).filter(function(t3) {
      return -1 !== t3;
    })), this.barHelpers = new Ma(this);
  }
  return s(t2, [{ key: "draw", value: function(t3, e2) {
    var i = this.w, a2 = new Mi(this.ctx), s2 = new Pi(this.ctx, i);
    t3 = s2.getLogSeries(t3), this.series = t3, this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    var r2 = a2.group({ class: "apexcharts-bar-series apexcharts-plot-series" });
    i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering - ApexCharts");
    for (var n2 = 0, o2 = 0; n2 < t3.length; n2++, o2++) {
      var l2, h2, c2, d2, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = i.globals.comboCharts ? e2[n2] : n2, m2 = this.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = a2.group({ class: "apexcharts-series", rel: n2 + 1, seriesName: v.escapeString(i.globals.seriesNames[b2]), "data:realIndex": b2 });
      this.ctx.series.addCollapsedClassToSeries(y2, b2), t3[n2].length > 0 && (this.visibleI = this.visibleI + 1);
      var w2 = 0, k2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[b2], this.translationsIndex = b2);
      var A2 = this.translationsIndex;
      this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
      var C2 = this.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, h2 = C2.yDivision, d2 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, l2 = C2.xDivision, c2 = C2.zeroH, this.isHorizontal || x2.push(g2 + k2 / 2);
      var S2 = a2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 });
      i.globals.delayedElements.push({ el: S2.node }), S2.node.classList.add("apexcharts-element-hidden");
      var L2 = a2.group({ class: "apexcharts-bar-goals-markers" }), M2 = a2.group({ class: "apexcharts-bar-shadows" });
      i.globals.delayedElements.push({ el: M2.node }), M2.node.classList.add("apexcharts-element-hidden");
      for (var P2 = 0; P2 < t3[n2].length; P2++) {
        var I2 = this.barHelpers.getStrokeWidth(n2, P2, b2), T2 = null, z2 = { indexes: { i: n2, j: P2, realIndex: b2, translationsIndex: A2, bc: o2 }, x: g2, y: p2, strokeWidth: I2, elSeries: y2 };
        this.isHorizontal ? (T2 = this.drawBarPaths(u(u({}, z2), {}, { barHeight: w2, zeroW: d2, yDivision: h2 })), k2 = this.series[n2][P2] / this.invertedYRatio) : (T2 = this.drawColumnPaths(u(u({}, z2), {}, { xDivision: l2, barWidth: k2, zeroH: c2 })), w2 = this.series[n2][P2] / this.yRatio[A2]);
        var X2 = this.barHelpers.getPathFillColor(t3, n2, P2, b2);
        if (this.isFunnel && this.barOptions.isFunnel3d && this.pathArr.length && P2 > 0) {
          var R2, E2 = this.barHelpers.drawBarShadow({ color: "string" == typeof X2.color && -1 === (null === (R2 = X2.color) || void 0 === R2 ? void 0 : R2.indexOf("url")) ? X2.color : v.hexToRgba(i.globals.colors[n2]), prevPaths: this.pathArr[this.pathArr.length - 1], currPaths: T2 });
          if (M2.add(E2), i.config.chart.dropShadow.enabled)
            new Li(this.ctx).dropShadow(E2, i.config.chart.dropShadow, b2);
        }
        this.pathArr.push(T2);
        var Y2 = this.barHelpers.drawGoalLine({ barXPosition: T2.barXPosition, barYPosition: T2.barYPosition, goalX: T2.goalX, goalY: T2.goalY, barHeight: w2, barWidth: k2 });
        Y2 && L2.add(Y2), p2 = T2.y, g2 = T2.x, P2 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), this.renderSeries(u(u({ realIndex: b2, pathFill: X2.color }, X2.useRangeColor ? { lineFill: X2.color } : {}), {}, { j: P2, i: n2, columnGroupIndex: m2, pathFrom: T2.pathFrom, pathTo: T2.pathTo, strokeWidth: I2, elSeries: y2, x: g2, y: p2, series: t3, barHeight: Math.abs(T2.barHeight ? T2.barHeight : w2), barWidth: Math.abs(T2.barWidth ? T2.barWidth : k2), elDataLabelsWrap: S2, elGoalsMarkers: L2, elBarShadows: M2, visibleSeries: this.visibleI, type: "bar" }));
      }
      i.globals.seriesXvalues[b2] = x2, i.globals.seriesYvalues[b2] = f2, r2.add(y2);
    }
    return r2;
  } }, { key: "renderSeries", value: function(t3) {
    var e2 = t3.realIndex, i = t3.pathFill, a2 = t3.lineFill, s2 = t3.j, r2 = t3.i, n2 = t3.columnGroupIndex, o2 = t3.pathFrom, l2 = t3.pathTo, h2 = t3.strokeWidth, c2 = t3.elSeries, d2 = t3.x, u2 = t3.y, g2 = t3.y1, p2 = t3.y2, f2 = t3.series, x2 = t3.barHeight, b2 = t3.barWidth, m2 = t3.barXPosition, v2 = t3.barYPosition, y2 = t3.elDataLabelsWrap, w2 = t3.elGoalsMarkers, k2 = t3.elBarShadows, A2 = t3.visibleSeries, C2 = t3.type, S2 = t3.classes, L2 = this.w, M2 = new Mi(this.ctx);
    if (!a2) {
      var P2 = "function" == typeof L2.globals.stroke.colors[e2] ? function(t4) {
        var e3, i2 = L2.config.stroke.colors;
        return Array.isArray(i2) && i2.length > 0 && ((e3 = i2[t4]) || (e3 = ""), "function" == typeof e3) ? e3({ value: L2.globals.series[t4][s2], dataPointIndex: s2, w: L2 }) : e3;
      }(e2) : L2.globals.stroke.colors[e2];
      a2 = this.barOptions.distributed ? L2.globals.stroke.colors[s2] : P2;
    }
    L2.config.series[r2].data[s2] && L2.config.series[r2].data[s2].strokeColor && (a2 = L2.config.series[r2].data[s2].strokeColor), this.isNullValue && (i = "none");
    var I2 = s2 / L2.config.chart.animations.animateGradually.delay * (L2.config.chart.animations.speed / L2.globals.dataPoints) / 2.4, T2 = M2.renderPaths({ i: r2, j: s2, realIndex: e2, pathFrom: o2, pathTo: l2, stroke: a2, strokeWidth: h2, strokeLineCap: L2.config.stroke.lineCap, fill: i, animationDelay: I2, initialSpeed: L2.config.chart.animations.speed, dataChangeSpeed: L2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(C2, "-area ").concat(S2), chartType: C2 });
    T2.attr("clip-path", "url(#gridRectBarMask".concat(L2.globals.cuid, ")"));
    var z2 = L2.config.forecastDataPoints;
    z2.count > 0 && s2 >= L2.globals.dataPoints - z2.count && (T2.node.setAttribute("stroke-dasharray", z2.dashArray), T2.node.setAttribute("stroke-width", z2.strokeWidth), T2.node.setAttribute("fill-opacity", z2.fillOpacity)), void 0 !== g2 && void 0 !== p2 && (T2.attr("data-range-y1", g2), T2.attr("data-range-y2", p2)), new Li(this.ctx).setSelectionFilter(T2, e2, s2), c2.add(T2);
    var X2 = new La(this).handleBarDataLabels({ x: d2, y: u2, y1: g2, y2: p2, i: r2, j: s2, series: f2, realIndex: e2, columnGroupIndex: n2, barHeight: x2, barWidth: b2, barXPosition: m2, barYPosition: v2, renderedPath: T2, visibleSeries: A2 });
    return null !== X2.dataLabels && y2.add(X2.dataLabels), X2.totalDataLabels && y2.add(X2.totalDataLabels), c2.add(y2), w2 && c2.add(w2), k2 && c2.add(k2), c2;
  } }, { key: "drawBarPaths", value: function(t3) {
    var e2, i = t3.indexes, a2 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.yDivision, h2 = t3.elSeries, c2 = this.w, d2 = i.i, u2 = i.j;
    if (c2.globals.isXNumeric)
      e2 = (o2 = (c2.globals.seriesX[d2][u2] - c2.globals.minX) / this.invertedXRatio - a2) + a2 * this.visibleI;
    else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var g2 = this.barHelpers.getZeroValueEncounters({ i: d2, j: u2 }), p2 = g2.nonZeroColumns, f2 = g2.zeroEncounters;
      p2 > 0 && (a2 = this.seriesLen * a2 / p2), e2 = o2 + a2 * this.visibleI, e2 -= a2 * f2;
    } else
      e2 = o2 + a2 * this.visibleI;
    this.isFunnel && (r2 -= (this.barHelpers.getXForValue(this.series[d2][u2], r2) - r2) / 2), n2 = this.barHelpers.getXForValue(this.series[d2][u2], r2);
    var x2 = this.barHelpers.getBarpaths({ barYPosition: e2, barHeight: a2, x1: r2, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i.realIndex, i: d2, j: u2, w: c2 });
    return c2.globals.isXNumeric || (o2 += l2), this.barHelpers.barBackground({ j: u2, i: d2, y1: e2 - a2 * this.visibleI, y2: a2 * this.seriesLen, elSeries: h2 }), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, x1: r2, x: n2, y: o2, goalX: this.barHelpers.getGoalValues("x", r2, null, d2, u2), barYPosition: e2, barHeight: a2 };
  } }, { key: "drawColumnPaths", value: function(t3) {
    var e2, i = t3.indexes, a2 = t3.x, s2 = t3.y, r2 = t3.xDivision, n2 = t3.barWidth, o2 = t3.zeroH, l2 = t3.strokeWidth, h2 = t3.elSeries, c2 = this.w, d2 = i.realIndex, u2 = i.translationsIndex, g2 = i.i, p2 = i.j, f2 = i.bc;
    if (c2.globals.isXNumeric) {
      var x2 = this.getBarXForNumericXAxis({ x: a2, j: p2, realIndex: d2, barWidth: n2 });
      a2 = x2.x, e2 = x2.barXPosition;
    } else if (c2.config.plotOptions.bar.hideZeroBarsWhenGrouped) {
      var b2 = this.barHelpers.getZeroValueEncounters({ i: g2, j: p2 }), m2 = b2.nonZeroColumns, v2 = b2.zeroEncounters;
      m2 > 0 && (n2 = this.seriesLen * n2 / m2), e2 = a2 + n2 * this.visibleI, e2 -= n2 * v2;
    } else
      e2 = a2 + n2 * this.visibleI;
    s2 = this.barHelpers.getYForValue(this.series[g2][p2], o2, u2);
    var y2 = this.barHelpers.getColumnPaths({ barXPosition: e2, barWidth: n2, y1: o2, y2: s2, strokeWidth: l2, isReversed: this.isReversed, series: this.series, realIndex: d2, i: g2, j: p2, w: c2 });
    return c2.globals.isXNumeric || (a2 += r2), this.barHelpers.barBackground({ bc: f2, j: p2, i: g2, x1: e2 - l2 / 2 - n2 * this.visibleI, x2: n2 * this.seriesLen + l2 / 2, elSeries: h2 }), { pathTo: y2.pathTo, pathFrom: y2.pathFrom, x: a2, y: s2, goalY: this.barHelpers.getGoalValues("y", null, o2, g2, p2, u2), barXPosition: e2, barWidth: n2 };
  } }, { key: "getBarXForNumericXAxis", value: function(t3) {
    var e2 = t3.x, i = t3.barWidth, a2 = t3.realIndex, s2 = t3.j, r2 = this.w, n2 = a2;
    return r2.globals.seriesX[a2].length || (n2 = r2.globals.maxValsInArrayIndex), v.isNumber(r2.globals.seriesX[n2][s2]) && (e2 = (r2.globals.seriesX[n2][s2] - r2.globals.minX) / this.xRatio - i * this.seriesLen / 2), { barXPosition: e2 + i * this.visibleI, x: e2 };
  } }, { key: "getPreviousPath", value: function(t3, e2) {
    for (var i, a2 = this.w, s2 = 0; s2 < a2.globals.previousPaths.length; s2++) {
      var r2 = a2.globals.previousPaths[s2];
      r2.paths && r2.paths.length > 0 && parseInt(r2.realIndex, 10) === parseInt(t3, 10) && void 0 !== a2.globals.previousPaths[s2].paths[e2] && (i = a2.globals.previousPaths[s2].paths[e2].d);
    }
    return i;
  } }]), t2;
}(), Ia = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i$1(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i = this, a3 = this.w;
    this.graphics = new Mi(this.ctx), this.bar = new Pa(this.ctx, this.xyRatios);
    var s2 = new Pi(this.ctx, a3);
    t3 = s2.getLogSeries(t3), this.yRatio = s2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3), "100%" === a3.config.chart.stackType && (t3 = a3.globals.comboCharts ? e3.map(function(t4) {
      return a3.globals.seriesPercent[t4];
    }) : a3.globals.seriesPercent.slice()), this.series = t3, this.barHelpers.initializeStackedPrevVars(this);
    for (var r2 = this.graphics.group({ class: "apexcharts-bar-series apexcharts-plot-series" }), n2 = 0, o2 = 0, l2 = function(s3, l3) {
      var h3 = void 0, c3 = void 0, d2 = void 0, g2 = void 0, p2 = a3.globals.comboCharts ? e3[s3] : s3, f2 = i.barHelpers.getGroupIndex(p2), x2 = f2.groupIndex, b2 = f2.columnGroupIndex;
      i.groupCtx = i[a3.globals.seriesGroups[x2]];
      var m2 = [], y2 = [], w2 = 0;
      i.yRatio.length > 1 && (i.yaxisIndex = a3.globals.seriesYAxisReverseMap[p2][0], w2 = p2), i.isReversed = a3.config.yaxis[i.yaxisIndex] && a3.config.yaxis[i.yaxisIndex].reversed;
      var k2 = i.graphics.group({ class: "apexcharts-series", seriesName: v.escapeString(a3.globals.seriesNames[p2]), rel: s3 + 1, "data:realIndex": p2 });
      i.ctx.series.addCollapsedClassToSeries(k2, p2);
      var A2 = i.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": p2 }), C2 = i.graphics.group({ class: "apexcharts-bar-goals-markers" }), S2 = 0, L2 = 0, M2 = i.initialPositions(n2, o2, h3, c3, d2, g2, w2);
      o2 = M2.y, S2 = M2.barHeight, c3 = M2.yDivision, g2 = M2.zeroW, n2 = M2.x, L2 = M2.barWidth, h3 = M2.xDivision, d2 = M2.zeroH, a3.globals.barHeight = S2, a3.globals.barWidth = L2, i.barHelpers.initializeStackedXYVars(i), 1 === i.groupCtx.prevY.length && i.groupCtx.prevY[0].every(function(t4) {
        return isNaN(t4);
      }) && (i.groupCtx.prevY[0] = i.groupCtx.prevY[0].map(function() {
        return d2;
      }), i.groupCtx.prevYF[0] = i.groupCtx.prevYF[0].map(function() {
        return 0;
      }));
      for (var P2 = 0; P2 < a3.globals.dataPoints; P2++) {
        var I2 = i.barHelpers.getStrokeWidth(s3, P2, p2), T2 = { indexes: { i: s3, j: P2, realIndex: p2, translationsIndex: w2, bc: l3 }, strokeWidth: I2, x: n2, y: o2, elSeries: k2, columnGroupIndex: b2, seriesGroup: a3.globals.seriesGroups[x2] }, z2 = null;
        i.isHorizontal ? (z2 = i.drawStackedBarPaths(u(u({}, T2), {}, { zeroW: g2, barHeight: S2, yDivision: c3 })), L2 = i.series[s3][P2] / i.invertedYRatio) : (z2 = i.drawStackedColumnPaths(u(u({}, T2), {}, { xDivision: h3, barWidth: L2, zeroH: d2 })), S2 = i.series[s3][P2] / i.yRatio[w2]);
        var X2 = i.barHelpers.drawGoalLine({ barXPosition: z2.barXPosition, barYPosition: z2.barYPosition, goalX: z2.goalX, goalY: z2.goalY, barHeight: S2, barWidth: L2 });
        X2 && C2.add(X2), o2 = z2.y, n2 = z2.x, m2.push(n2), y2.push(o2);
        var R2 = i.barHelpers.getPathFillColor(t3, s3, P2, p2), E2 = "", Y2 = a3.globals.isBarHorizontal ? "apexcharts-flip-x" : "apexcharts-flip-y";
        ("bottom" === i.barHelpers.arrBorderRadius[p2][P2] && a3.globals.series[p2][P2] > 0 || "top" === i.barHelpers.arrBorderRadius[p2][P2] && a3.globals.series[p2][P2] < 0) && (E2 = Y2), k2 = i.renderSeries(u(u({ realIndex: p2, pathFill: R2.color }, R2.useRangeColor ? { lineFill: R2.color } : {}), {}, { j: P2, i: s3, columnGroupIndex: b2, pathFrom: z2.pathFrom, pathTo: z2.pathTo, strokeWidth: I2, elSeries: k2, x: n2, y: o2, series: t3, barHeight: S2, barWidth: L2, elDataLabelsWrap: A2, elGoalsMarkers: C2, type: "bar", visibleSeries: b2, classes: E2 }));
      }
      a3.globals.seriesXvalues[p2] = m2, a3.globals.seriesYvalues[p2] = y2, i.groupCtx.prevY.push(i.groupCtx.yArrj), i.groupCtx.prevYF.push(i.groupCtx.yArrjF), i.groupCtx.prevYVal.push(i.groupCtx.yArrjVal), i.groupCtx.prevX.push(i.groupCtx.xArrj), i.groupCtx.prevXF.push(i.groupCtx.xArrjF), i.groupCtx.prevXVal.push(i.groupCtx.xArrjVal), r2.add(k2);
    }, h2 = 0, c2 = 0; h2 < t3.length; h2++, c2++)
      l2(h2, c2);
    return r2;
  } }, { key: "initialPositions", value: function(t3, e3, i, a3, s2, r2, n2) {
    var o2, l2, h2 = this.w;
    if (this.isHorizontal) {
      a3 = h2.globals.gridHeight / h2.globals.dataPoints;
      var c2 = h2.config.plotOptions.bar.barHeight;
      o2 = -1 === String(c2).indexOf("%") ? parseInt(c2, 10) : a3 * parseInt(c2, 10) / 100, r2 = h2.globals.padHorizontal + (this.isReversed ? h2.globals.gridWidth - this.baseLineInvertedY : this.baseLineInvertedY), e3 = (a3 - o2) / 2;
    } else {
      l2 = i = h2.globals.gridWidth / h2.globals.dataPoints;
      var d2 = h2.config.plotOptions.bar.columnWidth;
      h2.globals.isXNumeric && h2.globals.dataPoints > 1 ? l2 = (i = h2.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : -1 === String(d2).indexOf("%") ? l2 = parseInt(d2, 10) : l2 *= parseInt(d2, 10) / 100, s2 = this.isReversed ? this.baseLineY[n2] : h2.globals.gridHeight - this.baseLineY[n2], t3 = h2.globals.padHorizontal + (i - l2) / 2;
    }
    var u2 = h2.globals.barGroups.length || 1;
    return { x: t3, y: e3, yDivision: a3, xDivision: i, barHeight: o2 / u2, barWidth: l2 / u2, zeroH: s2, zeroW: r2 };
  } }, { key: "drawStackedBarPaths", value: function(t3) {
    for (var e3, i = t3.indexes, a3 = t3.barHeight, s2 = t3.strokeWidth, r2 = t3.zeroW, n2 = t3.x, o2 = t3.y, l2 = t3.columnGroupIndex, h2 = t3.seriesGroup, c2 = t3.yDivision, d2 = t3.elSeries, u2 = this.w, g2 = o2 + l2 * a3, p2 = i.i, f2 = i.j, x2 = i.realIndex, b2 = i.translationsIndex, m2 = 0, v2 = 0; v2 < this.groupCtx.prevXF.length; v2++)
      m2 += this.groupCtx.prevXF[v2][f2];
    var y2 = p2;
    if (u2.config.series[x2].name && (y2 = h2.indexOf(u2.config.series[x2].name)), y2 > 0) {
      var w2 = r2;
      this.groupCtx.prevXVal[y2 - 1][f2] < 0 ? w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] + m2 - 2 * (this.isReversed ? m2 : 0) : this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevXVal[y2 - 1][f2] >= 0 && (w2 = this.series[p2][f2] >= 0 ? this.groupCtx.prevX[y2 - 1][f2] : this.groupCtx.prevX[y2 - 1][f2] - m2 + 2 * (this.isReversed ? m2 : 0)), e3 = w2;
    } else
      e3 = r2;
    n2 = null === this.series[p2][f2] ? e3 : e3 + this.series[p2][f2] / this.invertedYRatio - 2 * (this.isReversed ? this.series[p2][f2] / this.invertedYRatio : 0);
    var k2 = this.barHelpers.getBarpaths({ barYPosition: g2, barHeight: a3, x1: e3, x2: n2, strokeWidth: s2, isReversed: this.isReversed, series: this.series, realIndex: i.realIndex, seriesGroup: h2, i: p2, j: f2, w: u2 });
    return this.barHelpers.barBackground({ j: f2, i: p2, y1: g2, y2: a3, elSeries: d2 }), o2 += c2, { pathTo: k2.pathTo, pathFrom: k2.pathFrom, goalX: this.barHelpers.getGoalValues("x", r2, null, p2, f2, b2), barXPosition: e3, barYPosition: g2, x: n2, y: o2 };
  } }, { key: "drawStackedColumnPaths", value: function(t3) {
    var e3 = t3.indexes, i = t3.x, a3 = t3.y, s2 = t3.xDivision, r2 = t3.barWidth, n2 = t3.zeroH, o2 = t3.columnGroupIndex, l2 = t3.seriesGroup, h2 = t3.elSeries, c2 = this.w, d2 = e3.i, u2 = e3.j, g2 = e3.bc, p2 = e3.realIndex, f2 = e3.translationsIndex;
    if (c2.globals.isXNumeric) {
      var x2 = c2.globals.seriesX[p2][u2];
      x2 || (x2 = 0), i = (x2 - c2.globals.minX) / this.xRatio - r2 / 2 * c2.globals.barGroups.length;
    }
    for (var b2, m2 = i + o2 * r2, v2 = 0, y2 = 0; y2 < this.groupCtx.prevYF.length; y2++)
      v2 += isNaN(this.groupCtx.prevYF[y2][u2]) ? 0 : this.groupCtx.prevYF[y2][u2];
    var w2 = d2;
    if (l2 && (w2 = l2.indexOf(c2.globals.seriesNames[p2])), w2 > 0 && !c2.globals.isXNumeric || w2 > 0 && c2.globals.isXNumeric && c2.globals.seriesX[p2 - 1][u2] === c2.globals.seriesX[p2][u2]) {
      var k2, A2, C2, S2 = Math.min(this.yRatio.length + 1, p2 + 1);
      if (void 0 !== this.groupCtx.prevY[w2 - 1] && this.groupCtx.prevY[w2 - 1].length)
        for (var L2 = 1; L2 < S2; L2++) {
          var M2;
          if (!isNaN(null === (M2 = this.groupCtx.prevY[w2 - L2]) || void 0 === M2 ? void 0 : M2[u2])) {
            C2 = this.groupCtx.prevY[w2 - L2][u2];
            break;
          }
        }
      for (var P2 = 1; P2 < S2; P2++) {
        var I2, T2;
        if ((null === (I2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === I2 ? void 0 : I2[u2]) < 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 - v2 + 2 * (this.isReversed ? v2 : 0) : C2;
          break;
        }
        if ((null === (T2 = this.groupCtx.prevYVal[w2 - P2]) || void 0 === T2 ? void 0 : T2[u2]) >= 0) {
          A2 = this.series[d2][u2] >= 0 ? C2 : C2 + v2 - 2 * (this.isReversed ? v2 : 0);
          break;
        }
      }
      void 0 === A2 && (A2 = c2.globals.gridHeight), b2 = null !== (k2 = this.groupCtx.prevYF[0]) && void 0 !== k2 && k2.every(function(t4) {
        return 0 === t4;
      }) && this.groupCtx.prevYF.slice(1, w2).every(function(t4) {
        return t4.every(function(t5) {
          return isNaN(t5);
        });
      }) ? n2 : A2;
    } else
      b2 = n2;
    a3 = this.series[d2][u2] ? b2 - this.series[d2][u2] / this.yRatio[f2] + 2 * (this.isReversed ? this.series[d2][u2] / this.yRatio[f2] : 0) : b2;
    var z2 = this.barHelpers.getColumnPaths({ barXPosition: m2, barWidth: r2, y1: b2, y2: a3, yRatio: this.yRatio[f2], strokeWidth: this.strokeWidth, isReversed: this.isReversed, series: this.series, seriesGroup: l2, realIndex: e3.realIndex, i: d2, j: u2, w: c2 });
    return this.barHelpers.barBackground({ bc: g2, j: u2, i: d2, x1: m2, x2: r2, elSeries: h2 }), { pathTo: z2.pathTo, pathFrom: z2.pathFrom, goalY: this.barHelpers.getGoalValues("y", null, n2, d2, u2), barXPosition: m2, x: c2.globals.isXNumeric ? i : i + s2, y: a3 };
  } }]), a2;
}(), Ta = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i$1(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3, i) {
    var a3 = this, s2 = this.w, r2 = new Mi(this.ctx), n2 = s2.globals.comboCharts ? e3 : s2.config.chart.type, o2 = new ji(this.ctx);
    this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = s2.config.plotOptions.bar.horizontal;
    var l2 = new Pi(this.ctx, s2);
    t3 = l2.getLogSeries(t3), this.series = t3, this.yRatio = l2.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t3);
    for (var h2 = r2.group({ class: "apexcharts-".concat(n2, "-series apexcharts-plot-series") }), c2 = function(e4) {
      a3.isBoxPlot = "boxPlot" === s2.config.chart.type || "boxPlot" === s2.config.series[e4].type;
      var n3, l3, c3, d3, g2 = void 0, p2 = void 0, f2 = [], x2 = [], b2 = s2.globals.comboCharts ? i[e4] : e4, m2 = a3.barHelpers.getGroupIndex(b2).columnGroupIndex, y2 = r2.group({ class: "apexcharts-series", seriesName: v.escapeString(s2.globals.seriesNames[b2]), rel: e4 + 1, "data:realIndex": b2 });
      a3.ctx.series.addCollapsedClassToSeries(y2, b2), t3[e4].length > 0 && (a3.visibleI = a3.visibleI + 1);
      var w2, k2, A2 = 0;
      a3.yRatio.length > 1 && (a3.yaxisIndex = s2.globals.seriesYAxisReverseMap[b2][0], A2 = b2);
      var C2 = a3.barHelpers.initialPositions(b2);
      p2 = C2.y, w2 = C2.barHeight, l3 = C2.yDivision, d3 = C2.zeroW, g2 = C2.x, k2 = C2.barWidth, n3 = C2.xDivision, c3 = C2.zeroH, x2.push(g2 + k2 / 2);
      for (var S2 = r2.group({ class: "apexcharts-datalabels", "data:realIndex": b2 }), L2 = r2.group({ class: "apexcharts-bar-goals-markers" }), M2 = function(i2) {
        var r3 = a3.barHelpers.getStrokeWidth(e4, i2, b2), h3 = null, v2 = { indexes: { i: e4, j: i2, realIndex: b2, translationsIndex: A2 }, x: g2, y: p2, strokeWidth: r3, elSeries: y2 };
        h3 = a3.isHorizontal ? a3.drawHorizontalBoxPaths(u(u({}, v2), {}, { yDivision: l3, barHeight: w2, zeroW: d3 })) : a3.drawVerticalBoxPaths(u(u({}, v2), {}, { xDivision: n3, barWidth: k2, zeroH: c3 })), p2 = h3.y, g2 = h3.x;
        var C3 = a3.barHelpers.drawGoalLine({ barXPosition: h3.barXPosition, barYPosition: h3.barYPosition, goalX: h3.goalX, goalY: h3.goalY, barHeight: w2, barWidth: k2 });
        C3 && L2.add(C3), i2 > 0 && x2.push(g2 + k2 / 2), f2.push(p2), h3.pathTo.forEach(function(n4, l4) {
          var c4 = !a3.isBoxPlot && a3.candlestickOptions.wick.useFillColor ? h3.color[l4] : s2.globals.stroke.colors[e4], d4 = o2.fillPath({ seriesNumber: b2, dataPointIndex: i2, color: h3.color[l4], value: t3[e4][i2] });
          a3.renderSeries({ realIndex: b2, pathFill: d4, lineFill: c4, j: i2, i: e4, pathFrom: h3.pathFrom, pathTo: n4, strokeWidth: r3, elSeries: y2, x: g2, y: p2, series: t3, columnGroupIndex: m2, barHeight: w2, barWidth: k2, elDataLabelsWrap: S2, elGoalsMarkers: L2, visibleSeries: a3.visibleI, type: s2.config.chart.type });
        });
      }, P2 = 0; P2 < s2.globals.dataPoints; P2++)
        M2(P2);
      s2.globals.seriesXvalues[b2] = x2, s2.globals.seriesYvalues[b2] = f2, h2.add(y2);
    }, d2 = 0; d2 < t3.length; d2++)
      c2(d2);
    return h2;
  } }, { key: "drawVerticalBoxPaths", value: function(t3) {
    var e3 = t3.indexes, i = t3.x;
    t3.y;
    var a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.zeroH, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = o2.config.plotOptions.candlestick.colors, u2 = this.boxOptions.colors, g2 = e3.realIndex, p2 = function(t4) {
      return Array.isArray(t4) ? t4[g2] : t4;
    }, f2 = p2(d2.upward), x2 = p2(d2.downward), b2 = this.yRatio[e3.translationsIndex], m2 = this.getOHLCValue(g2, c2), v2 = r2, y2 = r2, w2 = m2.o < m2.c ? [f2] : [x2];
    this.isBoxPlot && (w2 = [p2(u2.lower), p2(u2.upper)]);
    var k2 = Math.min(m2.o, m2.c), A2 = Math.max(m2.o, m2.c), C2 = m2.m;
    o2.globals.isXNumeric && (i = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.xRatio - s2 / 2);
    var S2 = i + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (k2 = r2, A2 = r2) : (k2 = r2 - k2 / b2, A2 = r2 - A2 / b2, v2 = r2 - m2.h / b2, y2 = r2 - m2.l / b2, C2 = r2 - m2.m / b2);
    var L2 = l2.move(S2, r2), M2 = l2.move(S2 + s2 / 2, k2);
    return o2.globals.previousPaths.length > 0 && (M2 = this.getPreviousPath(g2, c2, true)), L2 = this.isBoxPlot ? [l2.move(S2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 4, v2) + l2.line(S2 + s2 - s2 / 4, v2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2, C2) + l2.line(S2, C2) + l2.line(S2, k2 + n2 / 2), l2.move(S2, C2) + l2.line(S2 + s2, C2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 - s2 / 4, y2) + l2.line(S2 + s2 / 4, y2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2, A2) + l2.line(S2, C2) + "z"] : [l2.move(S2, A2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2 / 2, v2) + l2.line(S2 + s2 / 2, A2) + l2.line(S2 + s2, A2) + l2.line(S2 + s2, k2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2 + s2 / 2, y2) + l2.line(S2 + s2 / 2, k2) + l2.line(S2, k2) + l2.line(S2, A2 - n2 / 2)], M2 += l2.move(S2, k2), o2.globals.isXNumeric || (i += a3), { pathTo: L2, pathFrom: M2, x: i, y: A2, goalY: this.barHelpers.getGoalValues("y", null, r2, h2, c2, e3.translationsIndex), barXPosition: S2, color: w2 };
  } }, { key: "drawHorizontalBoxPaths", value: function(t3) {
    var e3 = t3.indexes;
    t3.x;
    var i = t3.y, a3 = t3.yDivision, s2 = t3.barHeight, r2 = t3.zeroW, n2 = t3.strokeWidth, o2 = this.w, l2 = new Mi(this.ctx), h2 = e3.i, c2 = e3.j, d2 = this.boxOptions.colors.lower;
    this.isBoxPlot && (d2 = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
    var u2 = this.invertedYRatio, g2 = e3.realIndex, p2 = this.getOHLCValue(g2, c2), f2 = r2, x2 = r2, b2 = Math.min(p2.o, p2.c), m2 = Math.max(p2.o, p2.c), v2 = p2.m;
    o2.globals.isXNumeric && (i = (o2.globals.seriesX[g2][c2] - o2.globals.minX) / this.invertedXRatio - s2 / 2);
    var y2 = i + s2 * this.visibleI;
    void 0 === this.series[h2][c2] || null === this.series[h2][c2] ? (b2 = r2, m2 = r2) : (b2 = r2 + b2 / u2, m2 = r2 + m2 / u2, f2 = r2 + p2.h / u2, x2 = r2 + p2.l / u2, v2 = r2 + p2.m / u2);
    var w2 = l2.move(r2, y2), k2 = l2.move(b2, y2 + s2 / 2);
    return o2.globals.previousPaths.length > 0 && (k2 = this.getPreviousPath(g2, c2, true)), w2 = [l2.move(b2, y2) + l2.line(b2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2) + l2.line(f2, y2 + s2 / 2 - s2 / 4) + l2.line(f2, y2 + s2 / 2 + s2 / 4) + l2.line(f2, y2 + s2 / 2) + l2.line(b2, y2 + s2 / 2) + l2.line(b2, y2 + s2) + l2.line(v2, y2 + s2) + l2.line(v2, y2) + l2.line(b2 + n2 / 2, y2), l2.move(v2, y2) + l2.line(v2, y2 + s2) + l2.line(m2, y2 + s2) + l2.line(m2, y2 + s2 / 2) + l2.line(x2, y2 + s2 / 2) + l2.line(x2, y2 + s2 - s2 / 4) + l2.line(x2, y2 + s2 / 4) + l2.line(x2, y2 + s2 / 2) + l2.line(m2, y2 + s2 / 2) + l2.line(m2, y2) + l2.line(v2, y2) + "z"], k2 += l2.move(b2, y2), o2.globals.isXNumeric || (i += a3), { pathTo: w2, pathFrom: k2, x: m2, y: i, goalX: this.barHelpers.getGoalValues("x", r2, null, h2, c2), barYPosition: y2, color: d2 };
  } }, { key: "getOHLCValue", value: function(t3, e3) {
    var i = this.w, a3 = new Pi(this.ctx, i), s2 = a3.getLogValAtSeriesIndex(i.globals.seriesCandleH[t3][e3], t3), r2 = a3.getLogValAtSeriesIndex(i.globals.seriesCandleO[t3][e3], t3), n2 = a3.getLogValAtSeriesIndex(i.globals.seriesCandleM[t3][e3], t3), o2 = a3.getLogValAtSeriesIndex(i.globals.seriesCandleC[t3][e3], t3), l2 = a3.getLogValAtSeriesIndex(i.globals.seriesCandleL[t3][e3], t3);
    return { o: this.isBoxPlot ? s2 : r2, h: this.isBoxPlot ? r2 : s2, m: n2, l: this.isBoxPlot ? o2 : l2, c: this.isBoxPlot ? l2 : o2 };
  } }]), a2;
}(), za = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "checkColorRange", value: function() {
    var t3 = this.w, e2 = false, i = t3.config.plotOptions[t3.config.chart.type];
    return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map(function(t4, i2) {
      t4.from <= 0 && (e2 = true);
    }), e2;
  } }, { key: "getShadeColor", value: function(t3, e2, i, a2) {
    var s2 = this.w, r2 = 1, n2 = s2.config.plotOptions[t3].shadeIntensity, o2 = this.determineColor(t3, e2, i);
    s2.globals.hasNegs || a2 ? r2 = s2.config.plotOptions[t3].reverseNegativeShade ? o2.percent < 0 ? o2.percent / 100 * (1.25 * n2) : (1 - o2.percent / 100) * (1.25 * n2) : o2.percent <= 0 ? 1 - (1 + o2.percent / 100) * n2 : (1 - o2.percent / 100) * n2 : (r2 = 1 - o2.percent / 100, "treemap" === t3 && (r2 = (1 - o2.percent / 100) * (1.25 * n2)));
    var l2 = o2.color, h2 = new v();
    if (s2.config.plotOptions[t3].enableShades)
      if ("dark" === this.w.config.theme.mode) {
        var c2 = h2.shadeColor(-1 * r2, o2.color);
        l2 = v.hexToRgba(v.isColorHex(c2) ? c2 : v.rgb2hex(c2), s2.config.fill.opacity);
      } else {
        var d2 = h2.shadeColor(r2, o2.color);
        l2 = v.hexToRgba(v.isColorHex(d2) ? d2 : v.rgb2hex(d2), s2.config.fill.opacity);
      }
    return { color: l2, colorProps: o2 };
  } }, { key: "determineColor", value: function(t3, e2, i) {
    var a2 = this.w, s2 = a2.globals.series[e2][i], r2 = a2.config.plotOptions[t3], n2 = r2.colorScale.inverse ? i : e2;
    r2.distributed && "treemap" === a2.config.chart.type && (n2 = i);
    var o2 = a2.globals.colors[n2], l2 = null, h2 = Math.min.apply(Math, f(a2.globals.series[e2])), c2 = Math.max.apply(Math, f(a2.globals.series[e2]));
    r2.distributed || "heatmap" !== t3 || (h2 = a2.globals.minY, c2 = a2.globals.maxY), void 0 !== r2.colorScale.min && (h2 = r2.colorScale.min < a2.globals.minY ? r2.colorScale.min : a2.globals.minY, c2 = r2.colorScale.max > a2.globals.maxY ? r2.colorScale.max : a2.globals.maxY);
    var d2 = Math.abs(c2) + Math.abs(h2), u2 = 100 * s2 / (0 === d2 ? d2 - 1e-6 : d2);
    r2.colorScale.ranges.length > 0 && r2.colorScale.ranges.map(function(t4, e3) {
      if (s2 >= t4.from && s2 <= t4.to) {
        o2 = t4.color, l2 = t4.foreColor ? t4.foreColor : null, h2 = t4.from, c2 = t4.to;
        var i2 = Math.abs(c2) + Math.abs(h2);
        u2 = 100 * s2 / (0 === i2 ? i2 - 1e-6 : i2);
      }
    });
    return { color: o2, foreColor: l2, percent: u2 };
  } }, { key: "calculateDataLabels", value: function(t3) {
    var e2 = t3.text, i = t3.x, a2 = t3.y, s2 = t3.i, r2 = t3.j, n2 = t3.colorProps, o2 = t3.fontSize, l2 = this.w.config.dataLabels, h2 = new Mi(this.ctx), c2 = new qi(this.ctx), d2 = null;
    if (l2.enabled) {
      d2 = h2.group({ class: "apexcharts-data-labels" });
      var u2 = l2.offsetX, g2 = l2.offsetY, p2 = i + u2, f2 = a2 + parseFloat(l2.style.fontSize) / 3 + g2;
      c2.plotDataLabelsText({ x: p2, y: f2, text: e2, i: s2, j: r2, color: n2.foreColor, parent: d2, fontSize: o2, dataLabelsConfig: l2 });
    }
    return d2;
  } }, { key: "addListeners", value: function(t3) {
    var e2 = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", e2.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", e2.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mousedown", e2.pathMouseDown.bind(this, t3));
  } }]), t2;
}(), Xa = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.xRatio = a2.xRatio, this.yRatio = a2.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new za(e2), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0;
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a2 = i.group({ class: "apexcharts-heatmap" });
    a2.attr("clip-path", "url(#gridRectMask".concat(e2.globals.cuid, ")"));
    var s2 = e2.globals.gridWidth / e2.globals.dataPoints, r2 = e2.globals.gridHeight / e2.globals.series.length, n2 = 0, o2 = false;
    this.negRange = this.helpers.checkColorRange();
    var l2 = t3.slice();
    e2.config.yaxis[0].reversed && (o2 = true, l2.reverse());
    for (var h2 = o2 ? 0 : l2.length - 1; o2 ? h2 < l2.length : h2 >= 0; o2 ? h2++ : h2--) {
      var c2 = i.group({ class: "apexcharts-series apexcharts-heatmap-series", seriesName: v.escapeString(e2.globals.seriesNames[h2]), rel: h2 + 1, "data:realIndex": h2 });
      if (this.ctx.series.addCollapsedClassToSeries(c2, h2), e2.config.chart.dropShadow.enabled) {
        var d2 = e2.config.chart.dropShadow;
        new Li(this.ctx).dropShadow(c2, d2, h2);
      }
      for (var u2 = 0, g2 = e2.config.plotOptions.heatmap.shadeIntensity, p2 = 0, f2 = 0; f2 < e2.globals.dataPoints; f2++)
        if (e2.globals.seriesX.length && !e2.globals.allSeriesHasEqualX && e2.globals.minX + e2.globals.minXDiff * f2 < e2.globals.seriesX[h2][p2])
          u2 += s2;
        else {
          if (p2 >= l2[h2].length)
            break;
          var x2 = this.helpers.getShadeColor(e2.config.chart.type, h2, p2, this.negRange), b2 = x2.color, m2 = x2.colorProps;
          if ("image" === e2.config.fill.type)
            b2 = new ji(this.ctx).fillPath({ seriesNumber: h2, dataPointIndex: p2, opacity: e2.globals.hasNegs ? m2.percent < 0 ? 1 - (1 + m2.percent / 100) : g2 + m2.percent / 100 : m2.percent / 100, patternID: v.randomId(), width: e2.config.fill.image.width ? e2.config.fill.image.width : s2, height: e2.config.fill.image.height ? e2.config.fill.image.height : r2 });
          var y2 = this.rectRadius, w2 = i.drawRect(u2, n2, s2, r2, y2);
          if (w2.attr({ cx: u2, cy: n2 }), w2.node.classList.add("apexcharts-heatmap-rect"), c2.add(w2), w2.attr({ fill: b2, i: h2, index: h2, j: p2, val: t3[h2][p2], "stroke-width": this.strokeWidth, stroke: e2.config.plotOptions.heatmap.useFillColorAsStroke ? b2 : e2.globals.stroke.colors[0], color: b2 }), this.helpers.addListeners(w2), e2.config.chart.animations.enabled && !e2.globals.dataChanged) {
            var k2 = 1;
            e2.globals.resized || (k2 = e2.config.chart.animations.speed), this.animateHeatMap(w2, u2, n2, s2, r2, k2);
          }
          if (e2.globals.dataChanged) {
            var A2 = 1;
            if (this.dynamicAnim.enabled && e2.globals.shouldAnimate) {
              A2 = this.dynamicAnim.speed;
              var C2 = e2.globals.previousPaths[h2] && e2.globals.previousPaths[h2][p2] && e2.globals.previousPaths[h2][p2].color;
              C2 || (C2 = "rgba(255, 255, 255, 0)"), this.animateHeatColor(w2, v.isColorHex(C2) ? C2 : v.rgb2hex(C2), v.isColorHex(b2) ? b2 : v.rgb2hex(b2), A2);
            }
          }
          var S2 = (0, e2.config.dataLabels.formatter)(e2.globals.series[h2][p2], { value: e2.globals.series[h2][p2], seriesIndex: h2, dataPointIndex: p2, w: e2 }), L2 = this.helpers.calculateDataLabels({ text: S2, x: u2 + s2 / 2, y: n2 + r2 / 2, i: h2, j: p2, colorProps: m2, series: l2 });
          null !== L2 && c2.add(L2), u2 += s2, p2++;
        }
      n2 += r2, a2.add(c2);
    }
    var M2 = e2.globals.yAxisScale[0].result.slice();
    return e2.config.yaxis[0].reversed ? M2.unshift("") : M2.push(""), e2.globals.yAxisScale[0].result = M2, a2;
  } }, { key: "animateHeatMap", value: function(t3, e2, i, a2, s2, r2) {
    var n2 = new y(this.ctx);
    n2.animateRect(t3, { x: e2 + a2 / 2, y: i + s2 / 2, width: 0, height: 0 }, { x: e2, y: i, width: a2, height: s2 }, r2, function() {
      n2.animationCompleted(t3);
    });
  } }, { key: "animateHeatColor", value: function(t3, e2, i, a2) {
    t3.attr({ fill: e2 }).animate(a2).attr({ fill: i });
  } }]), t2;
}(), Ra = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "drawYAxisTexts", value: function(t3, e2, i, a2) {
    var s2 = this.w, r2 = s2.config.yaxis[0], n2 = s2.globals.yLabelFormatters[0];
    return new Mi(this.ctx).drawText({ x: t3 + r2.labels.offsetX, y: e2 + r2.labels.offsetY, text: n2(a2, i), textAnchor: "middle", fontSize: r2.labels.style.fontSize, fontFamily: r2.labels.style.fontFamily, foreColor: Array.isArray(r2.labels.style.colors) ? r2.labels.style.colors[i] : r2.labels.style.colors });
  } }]), t2;
}(), Ea = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
    var a2 = this.w;
    this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = Math.min(a2.globals.gridWidth, a2.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = a2.globals.gridWidth / 2, "radialBar" === a2.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(a2.config.plotOptions.pie.endAngle - a2.config.plotOptions.pie.startAngle), this.initialAngle = a2.config.plotOptions.pie.startAngle % this.fullAngle, a2.globals.radialSize = this.defaultSize / 2.05 - a2.config.stroke.width - (a2.config.chart.sparkline.enabled ? 0 : a2.config.chart.dropShadow.blur), this.donutSize = a2.globals.radialSize * parseInt(a2.config.plotOptions.pie.donut.size, 10) / 100;
    var s2 = a2.config.plotOptions.pie.customScale, r2 = a2.globals.gridWidth / 2, n2 = a2.globals.gridHeight / 2;
    this.translateX = r2 - r2 * s2, this.translateY = n2 - n2 * s2, this.dataLabelsGroup = new Mi(this.ctx).group({ class: "apexcharts-datalabels-group", transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(s2, ")") }), this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i = this.w, a2 = new Mi(this.ctx), s2 = a2.group({ class: "apexcharts-pie" });
    if (i.globals.noData)
      return s2;
    for (var r2 = 0, n2 = 0; n2 < t3.length; n2++)
      r2 += v.negToZero(t3[n2]);
    var o2 = [], l2 = a2.group();
    0 === r2 && (r2 = 1e-5), t3.forEach(function(t4) {
      e2.maxY = Math.max(e2.maxY, t4);
    }), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s2);
    for (var h2 = 0; h2 < t3.length; h2++) {
      var c2 = this.fullAngle * v.negToZero(t3[h2]) / r2;
      o2.push(c2), "polarArea" === this.chartType ? (o2[h2] = this.fullAngle / t3.length, this.sliceSizes.push(i.globals.radialSize * t3[h2] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize);
    }
    if (i.globals.dataChanged) {
      for (var d2, u2 = 0, g2 = 0; g2 < i.globals.previousPaths.length; g2++)
        u2 += v.negToZero(i.globals.previousPaths[g2]);
      for (var p2 = 0; p2 < i.globals.previousPaths.length; p2++)
        d2 = this.fullAngle * v.negToZero(i.globals.previousPaths[p2]) / u2, this.prevSectorAngleArr.push(d2);
    }
    if (this.donutSize < 0 && (this.donutSize = 0), "donut" === this.chartType) {
      var f2 = a2.drawCircle(this.donutSize);
      f2.attr({ cx: this.centerX, cy: this.centerY, fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent" }), l2.add(f2);
    }
    var x2 = this.drawArcs(o2, t3);
    if (this.sliceLabels.forEach(function(t4) {
      x2.add(t4);
    }), l2.attr({ transform: "translate(".concat(this.translateX, ", ").concat(this.translateY, ") scale(").concat(i.config.plotOptions.pie.customScale, ")") }), l2.add(x2), s2.add(l2), this.donutDataLabels.show) {
      var b2 = this.renderInnerDataLabels(this.dataLabelsGroup, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      s2.add(b2);
    }
    return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(s2), s2;
  } }, { key: "drawArcs", value: function(t3, e2) {
    var i = this.w, a2 = new Li(this.ctx), s2 = new Mi(this.ctx), r2 = new ji(this.ctx), n2 = s2.group({ class: "apexcharts-slices" }), o2 = this.initialAngle, l2 = this.initialAngle, h2 = this.initialAngle, c2 = this.initialAngle;
    this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
    for (var d2 = 0; d2 < t3.length; d2++) {
      var u2 = s2.group({ class: "apexcharts-series apexcharts-pie-series", seriesName: v.escapeString(i.globals.seriesNames[d2]), rel: d2 + 1, "data:realIndex": d2 });
      n2.add(u2), l2 = c2, h2 = (o2 = h2) + t3[d2], c2 = l2 + this.prevSectorAngleArr[d2];
      var g2 = h2 < o2 ? this.fullAngle + h2 - o2 : h2 - o2, p2 = r2.fillPath({ seriesNumber: d2, size: this.sliceSizes[d2], value: e2[d2] }), f2 = this.getChangedPath(l2, c2), x2 = s2.drawPath({ d: f2, stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d2] : this.lineColorArr, strokeWidth: 0, fill: p2, fillOpacity: i.config.fill.opacity, classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d2) });
      if (x2.attr({ index: 0, j: d2 }), a2.setSelectionFilter(x2, 0, d2), i.config.chart.dropShadow.enabled) {
        var b2 = i.config.chart.dropShadow;
        a2.dropShadow(x2, b2, d2);
      }
      this.addListeners(x2, this.donutDataLabels), Mi.setAttrs(x2.node, { "data:angle": g2, "data:startAngle": o2, "data:strokeWidth": this.strokeWidth, "data:value": e2[d2] });
      var m2 = { x: 0, y: 0 };
      "pie" === this.chartType || "polarArea" === this.chartType ? m2 = v.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle) : "donut" === this.chartType && (m2 = v.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o2 + g2 / 2) % this.fullAngle)), u2.add(x2);
      var y2 = 0;
      if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 === (y2 = g2 / this.fullAngle * i.config.chart.animations.speed) && (y2 = 1), this.animDur = y2 + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, prevStartAngle: l2, prevEndAngle: c2, animateStartingPos: true, i: d2, animBeginArr: this.animBeginArr, shouldSetPrevPaths: true, dur: i.config.chart.animations.dynamicAnimation.speed }) : this.animatePaths(x2, { size: this.sliceSizes[d2], endAngle: h2, startAngle: o2, i: d2, totalItems: t3.length - 1, animBeginArr: this.animBeginArr, dur: y2 }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && x2.node.addEventListener("mouseup", this.pieClicked.bind(this, d2)), void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(d2) > -1 && this.pieClicked(d2), i.config.dataLabels.enabled) {
        var w2 = m2.x, k2 = m2.y, A2 = 100 * g2 / this.fullAngle + "%";
        if (0 !== g2 && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t3[d2]) {
          var C2 = i.config.dataLabels.formatter;
          void 0 !== C2 && (A2 = C2(i.globals.seriesPercent[d2][0], { seriesIndex: d2, w: i }));
          var S2 = i.globals.dataLabels.style.colors[d2], L2 = s2.group({ class: "apexcharts-datalabels" }), M2 = s2.drawText({ x: w2, y: k2, text: A2, textAnchor: "middle", fontSize: i.config.dataLabels.style.fontSize, fontFamily: i.config.dataLabels.style.fontFamily, fontWeight: i.config.dataLabels.style.fontWeight, foreColor: S2 });
          if (L2.add(M2), i.config.dataLabels.dropShadow.enabled) {
            var P2 = i.config.dataLabels.dropShadow;
            a2.dropShadow(M2, P2);
          }
          M2.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && false === i.globals.resized && (M2.node.classList.add("apexcharts-pie-label-delay"), M2.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(L2);
        }
      }
    }
    return n2;
  } }, { key: "addListeners", value: function(t3, e2) {
    var i = new Mi(this.ctx);
    t3.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t3)), t3.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t3)), t3.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t3)), this.donutDataLabels.total.showAlways || (t3.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t3.node, e2)), t3.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t3.node, e2)));
  } }, { key: "animatePaths", value: function(t3, e2) {
    var i = this.w, a2 = e2.endAngle < e2.startAngle ? this.fullAngle + e2.endAngle - e2.startAngle : e2.endAngle - e2.startAngle, s2 = a2, r2 = e2.startAngle, n2 = e2.startAngle;
    void 0 !== e2.prevStartAngle && void 0 !== e2.prevEndAngle && (r2 = e2.prevEndAngle, s2 = e2.prevEndAngle < e2.prevStartAngle ? this.fullAngle + e2.prevEndAngle - e2.prevStartAngle : e2.prevEndAngle - e2.prevStartAngle), e2.i === i.config.series.length - 1 && (a2 + n2 > this.fullAngle ? e2.endAngle = e2.endAngle - (a2 + n2) : a2 + n2 < this.fullAngle && (e2.endAngle = e2.endAngle + (this.fullAngle - (a2 + n2)))), a2 === this.fullAngle && (a2 = this.fullAngle - 0.01), this.animateArc(t3, r2, n2, a2, s2, e2);
  } }, { key: "animateArc", value: function(t3, e2, i, a2, s2, r2) {
    var n2, o2 = this, l2 = this.w, h2 = new y(this.ctx), c2 = r2.size;
    (isNaN(e2) || isNaN(s2)) && (e2 = i, s2 = a2, r2.dur = 0);
    var d2 = a2, u2 = i, g2 = e2 < i ? this.fullAngle + e2 - i : e2 - i;
    l2.globals.dataChanged && r2.shouldSetPrevPaths && r2.prevEndAngle && (n2 = o2.getPiePath({ me: o2, startAngle: r2.prevStartAngle, angle: r2.prevEndAngle < r2.prevStartAngle ? this.fullAngle + r2.prevEndAngle - r2.prevStartAngle : r2.prevEndAngle - r2.prevStartAngle, size: c2 }), t3.attr({ d: n2 })), 0 !== r2.dur ? t3.animate(r2.dur, r2.animBeginArr[r2.i]).after(function() {
      "pie" !== o2.chartType && "donut" !== o2.chartType && "polarArea" !== o2.chartType || this.animate(l2.config.chart.animations.dynamicAnimation.speed).attr({ "stroke-width": o2.strokeWidth }), r2.i === l2.config.series.length - 1 && h2.animationCompleted(t3);
    }).during(function(l3) {
      d2 = g2 + (a2 - g2) * l3, r2.animateStartingPos && (d2 = s2 + (a2 - s2) * l3, u2 = e2 - s2 + (i - (e2 - s2)) * l3), n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: d2, size: c2 }), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2 });
    }) : (n2 = o2.getPiePath({ me: o2, startAngle: u2, angle: a2, size: c2 }), r2.isTrack || (l2.globals.animationEnded = true), t3.node.setAttribute("data:pathOrig", n2), t3.attr({ d: n2, "stroke-width": o2.strokeWidth }));
  } }, { key: "pieClicked", value: function(t3) {
    var e2, i = this.w, a2 = this, s2 = a2.sliceSizes[t3] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0), r2 = i.globals.dom.Paper.findOne(".apexcharts-".concat(a2.chartType.toLowerCase(), "-slice-").concat(t3));
    if ("true" !== r2.attr("data:pieClicked")) {
      var n2 = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
      Array.prototype.forEach.call(n2, function(t4) {
        t4.setAttribute("data:pieClicked", "false");
        var e3 = t4.getAttribute("data:pathOrig");
        e3 && t4.setAttribute("d", e3);
      }), i.globals.capturedDataPointIndex = t3, r2.attr("data:pieClicked", "true");
      var o2 = parseInt(r2.attr("data:startAngle"), 10), l2 = parseInt(r2.attr("data:angle"), 10);
      e2 = a2.getPiePath({ me: a2, startAngle: o2, angle: l2, size: s2 }), 360 !== l2 && r2.plot(e2);
    } else {
      r2.attr({ "data:pieClicked": "false" }), this.revertDataLabelsInner(r2.node, this.donutDataLabels);
      var h2 = r2.attr("data:pathOrig");
      r2.attr({ d: h2 });
    }
  } }, { key: "getChangedPath", value: function(t3, e2) {
    var i = "";
    return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({ me: this, startAngle: t3, angle: e2 - t3, size: this.size })), i;
  } }, { key: "getPiePath", value: function(t3) {
    var e2, i = t3.me, a2 = t3.startAngle, s2 = t3.angle, r2 = t3.size, n2 = new Mi(this.ctx), o2 = a2, l2 = Math.PI * (o2 - 90) / 180, h2 = s2 + a2;
    Math.ceil(h2) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (h2 = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - 0.01), Math.ceil(h2) > this.fullAngle && (h2 -= this.fullAngle);
    var c2 = Math.PI * (h2 - 90) / 180, d2 = i.centerX + r2 * Math.cos(l2), u2 = i.centerY + r2 * Math.sin(l2), g2 = i.centerX + r2 * Math.cos(c2), p2 = i.centerY + r2 * Math.sin(c2), f2 = v.polarToCartesian(i.centerX, i.centerY, i.donutSize, h2), x2 = v.polarToCartesian(i.centerX, i.centerY, i.donutSize, o2), b2 = s2 > 180 ? 1 : 0, m2 = ["M", d2, u2, "A", r2, r2, 0, b2, 1, g2, p2];
    return e2 = "donut" === i.chartType ? [].concat(m2, ["L", f2.x, f2.y, "A", i.donutSize, i.donutSize, 0, b2, 0, x2.x, x2.y, "L", d2, u2, "z"]).join(" ") : "pie" === i.chartType || "polarArea" === i.chartType ? [].concat(m2, ["L", i.centerX, i.centerY, "L", d2, u2]).join(" ") : [].concat(m2).join(" "), n2.roundPathCorners(e2, 2 * this.strokeWidth);
  } }, { key: "drawPolarElements", value: function(t3) {
    var e2 = this.w, i = new ta(this.ctx), a2 = new Mi(this.ctx), s2 = new Ra(this.ctx), r2 = a2.group(), n2 = a2.group(), o2 = i.niceScale(0, Math.ceil(this.maxY), 0), l2 = o2.result.reverse(), h2 = o2.result.length;
    this.maxY = o2.niceMax;
    for (var c2 = e2.globals.radialSize, d2 = c2 / (h2 - 1), u2 = 0; u2 < h2 - 1; u2++) {
      var g2 = a2.drawCircle(c2);
      if (g2.attr({ cx: this.centerX, cy: this.centerY, fill: "none", "stroke-width": e2.config.plotOptions.polarArea.rings.strokeWidth, stroke: e2.config.plotOptions.polarArea.rings.strokeColor }), e2.config.yaxis[0].show) {
        var p2 = s2.drawYAxisTexts(this.centerX, this.centerY - c2 + parseInt(e2.config.yaxis[0].labels.style.fontSize, 10) / 2, u2, l2[u2]);
        n2.add(p2);
      }
      r2.add(g2), c2 -= d2;
    }
    this.drawSpokes(t3), t3.add(r2), t3.add(n2);
  } }, { key: "renderInnerDataLabels", value: function(t3, e2, i) {
    var a2 = this.w, s2 = new Mi(this.ctx), r2 = e2.total.show;
    t3.node.innerHTML = "", t3.node.style.opacity = i.opacity;
    var n2, o2, l2 = i.centerX, h2 = this.donutDataLabels.total.label ? i.centerY : i.centerY - i.centerY / 6;
    n2 = void 0 === e2.name.color ? a2.globals.colors[0] : e2.name.color;
    var c2 = e2.name.fontSize, d2 = e2.name.fontFamily, u2 = e2.name.fontWeight;
    o2 = void 0 === e2.value.color ? a2.config.chart.foreColor : e2.value.color;
    var g2 = e2.value.formatter, p2 = "", f2 = "";
    if (r2 ? (n2 = e2.total.color, c2 = e2.total.fontSize, d2 = e2.total.fontFamily, u2 = e2.total.fontWeight, f2 = this.donutDataLabels.total.label ? e2.total.label : "", p2 = e2.total.formatter(a2)) : 1 === a2.globals.series.length && (p2 = g2(a2.globals.series[0], a2), f2 = a2.globals.seriesNames[0]), f2 && (f2 = e2.name.formatter(f2, e2.total.show, a2)), e2.name.show) {
      var x2 = s2.drawText({ x: l2, y: h2 + parseFloat(e2.name.offsetY), text: f2, textAnchor: "middle", foreColor: n2, fontSize: c2, fontWeight: u2, fontFamily: d2 });
      x2.node.classList.add("apexcharts-datalabel-label"), t3.add(x2);
    }
    if (e2.value.show) {
      var b2 = e2.name.show ? parseFloat(e2.value.offsetY) + 16 : e2.value.offsetY, m2 = s2.drawText({ x: l2, y: h2 + b2, text: p2, textAnchor: "middle", foreColor: o2, fontWeight: e2.value.fontWeight, fontSize: e2.value.fontSize, fontFamily: e2.value.fontFamily });
      m2.node.classList.add("apexcharts-datalabel-value"), t3.add(m2);
    }
    return t3;
  } }, { key: "printInnerLabels", value: function(t3, e2, i, a2) {
    var s2, r2 = this.w;
    a2 ? s2 = void 0 === t3.name.color ? r2.globals.colors[parseInt(a2.parentNode.getAttribute("rel"), 10) - 1] : t3.name.color : r2.globals.series.length > 1 && t3.total.show && (s2 = t3.total.color);
    var n2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"), o2 = r2.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
    i = (0, t3.value.formatter)(i, r2), a2 || "function" != typeof t3.total.formatter || (i = t3.total.formatter(r2));
    var l2 = e2 === t3.total.label;
    e2 = this.donutDataLabels.total.label ? t3.name.formatter(e2, l2, r2) : "", null !== n2 && (n2.textContent = e2), null !== o2 && (o2.textContent = i), null !== n2 && (n2.style.fill = s2);
  } }, { key: "printDataLabelsInner", value: function(t3, e2) {
    var i = this.w, a2 = t3.getAttribute("data:value"), s2 = i.globals.seriesNames[parseInt(t3.parentNode.getAttribute("rel"), 10) - 1];
    i.globals.series.length > 1 && this.printInnerLabels(e2, s2, a2, t3);
    var r2 = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
    null !== r2 && (r2.style.opacity = 1);
  } }, { key: "drawSpokes", value: function(t3) {
    var e2 = this, i = this.w, a2 = new Mi(this.ctx), s2 = i.config.plotOptions.polarArea.spokes;
    if (0 !== s2.strokeWidth) {
      for (var r2 = [], n2 = 360 / i.globals.series.length, o2 = 0; o2 < i.globals.series.length; o2++)
        r2.push(v.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + n2 * o2));
      r2.forEach(function(i2, r3) {
        var n3 = a2.drawLine(i2.x, i2.y, e2.centerX, e2.centerY, Array.isArray(s2.connectorColors) ? s2.connectorColors[r3] : s2.connectorColors);
        t3.add(n3);
      });
    }
  } }, { key: "revertDataLabelsInner", value: function() {
    var t3 = this.w;
    if (this.donutDataLabels.show) {
      var e2 = t3.globals.dom.Paper.findOne(".apexcharts-datalabels-group"), i = this.renderInnerDataLabels(e2, this.donutDataLabels, { hollowSize: this.donutSize, centerX: this.centerX, centerY: this.centerY, opacity: this.donutDataLabels.show });
      t3.globals.dom.Paper.findOne(".apexcharts-radialbar, .apexcharts-pie").add(i);
    }
  } }]), t2;
}(), Ya = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
    var a2 = this.w;
    this.graphics = new Mi(this.ctx), this.lineColorArr = void 0 !== a2.globals.stroke.colors ? a2.globals.stroke.colors : a2.globals.colors, this.defaultSize = a2.globals.svgHeight < a2.globals.svgWidth ? a2.globals.gridHeight : a2.globals.gridWidth, this.isLog = a2.config.yaxis[0].logarithmic, this.logBase = a2.config.yaxis[0].logBase, this.coreUtils = new Pi(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, a2.globals.maxY, 0) : a2.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.logBase, this.w.globals.minY, 0) : a2.globals.minY, this.polygons = a2.config.plotOptions.radar.polygons, this.strokeWidth = a2.config.stroke.show ? a2.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - a2.config.chart.dropShadow.blur, a2.config.xaxis.labels.show && (this.size = this.size - a2.globals.xAxisLabelsWidth / 1.75), void 0 !== a2.config.plotOptions.radar.size && (this.size = a2.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i = this.w, a2 = new ji(this.ctx), s2 = [], r2 = new qi(this.ctx);
    t3.length && (this.dataPointsLen = t3[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
    var n2 = i.globals.gridWidth / 2, o2 = i.globals.gridHeight / 2, l2 = n2 + i.config.plotOptions.radar.offsetX, h2 = o2 + i.config.plotOptions.radar.offsetY, c2 = this.graphics.group({ class: "apexcharts-radar-series apexcharts-plot-series", transform: "translate(".concat(l2 || 0, ", ").concat(h2 || 0, ")") }), d2 = [], g2 = null, p2 = null;
    if (this.yaxisLabels = this.graphics.group({ class: "apexcharts-yaxis" }), t3.forEach(function(t4, n3) {
      var o3 = t4.length === i.globals.dataPoints, l3 = e2.graphics.group().attr({ class: "apexcharts-series", "data:longestSeries": o3, seriesName: v.escapeString(i.globals.seriesNames[n3]), rel: n3 + 1, "data:realIndex": n3 });
      e2.dataRadiusOfPercent[n3] = [], e2.dataRadius[n3] = [], e2.angleArr[n3] = [], t4.forEach(function(t5, i2) {
        var a3 = Math.abs(e2.maxValue - e2.minValue);
        t5 -= e2.minValue, e2.isLog && (t5 = e2.coreUtils.getLogVal(e2.logBase, t5, 0)), e2.dataRadiusOfPercent[n3][i2] = t5 / a3, e2.dataRadius[n3][i2] = e2.dataRadiusOfPercent[n3][i2] * e2.size, e2.angleArr[n3][i2] = i2 * e2.disAngle;
      }), d2 = e2.getDataPointsPos(e2.dataRadius[n3], e2.angleArr[n3]);
      var h3 = e2.createPaths(d2, { x: 0, y: 0 });
      g2 = e2.graphics.group({ class: "apexcharts-series-markers-wrap apexcharts-element-hidden" }), p2 = e2.graphics.group({ class: "apexcharts-datalabels", "data:realIndex": n3 }), i.globals.delayedElements.push({ el: g2.node, index: n3 });
      var c3 = { i: n3, realIndex: n3, animationDelay: n3, initialSpeed: i.config.chart.animations.speed, dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-radar", shouldClipToGrid: false, bindEventsOnPaths: false, stroke: i.globals.stroke.colors[n3], strokeLineCap: i.config.stroke.lineCap }, f3 = null;
      i.globals.previousPaths.length > 0 && (f3 = e2.getPreviousPath(n3));
      for (var x2 = 0; x2 < h3.linePathsTo.length; x2++) {
        var b2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.linePathsFrom[x2] : f3, pathTo: h3.linePathsTo[x2], strokeWidth: Array.isArray(e2.strokeWidth) ? e2.strokeWidth[n3] : e2.strokeWidth, fill: "none", drawShadow: false }));
        l3.add(b2);
        var m2 = a2.fillPath({ seriesNumber: n3 }), y2 = e2.graphics.renderPaths(u(u({}, c3), {}, { pathFrom: null === f3 ? h3.areaPathsFrom[x2] : f3, pathTo: h3.areaPathsTo[x2], strokeWidth: 0, fill: m2, drawShadow: false }));
        if (i.config.chart.dropShadow.enabled) {
          var w2 = new Li(e2.ctx), k2 = i.config.chart.dropShadow;
          w2.dropShadow(y2, Object.assign({}, k2, { noUserSpaceOnUse: true }), n3);
        }
        l3.add(y2);
      }
      t4.forEach(function(t5, a3) {
        var s3 = new Vi(e2.ctx).getMarkerConfig({ cssClass: "apexcharts-marker", seriesIndex: n3, dataPointIndex: a3 }), o4 = e2.graphics.drawMarker(d2[a3].x, d2[a3].y, s3);
        o4.attr("rel", a3), o4.attr("j", a3), o4.attr("index", n3), o4.node.setAttribute("default-marker-size", s3.pSize);
        var h4 = e2.graphics.group({ class: "apexcharts-series-markers" });
        h4 && h4.add(o4), g2.add(h4), l3.add(g2);
        var c4 = i.config.dataLabels;
        if (c4.enabled) {
          var f4 = c4.formatter(i.globals.series[n3][a3], { seriesIndex: n3, dataPointIndex: a3, w: i });
          r2.plotDataLabelsText({ x: d2[a3].x, y: d2[a3].y, text: f4, textAnchor: "middle", i: n3, j: n3, parent: p2, offsetCorrection: false, dataLabelsConfig: u({}, c4) });
        }
        l3.add(p2);
      }), s2.push(l3);
    }), this.drawPolygons({ parent: c2 }), i.config.xaxis.labels.show) {
      var f2 = this.drawXAxisTexts();
      c2.add(f2);
    }
    return s2.forEach(function(t4) {
      c2.add(t4);
    }), c2.add(this.yaxisLabels), c2;
  } }, { key: "drawPolygons", value: function(t3) {
    for (var e2 = this, i = this.w, a2 = t3.parent, s2 = new Ra(this.ctx), r2 = i.globals.yAxisScale[0].result.reverse(), n2 = r2.length, o2 = [], l2 = this.size / (n2 - 1), h2 = 0; h2 < n2; h2++)
      o2[h2] = l2 * h2;
    o2.reverse();
    var c2 = [], d2 = [];
    o2.forEach(function(t4, i2) {
      var a3 = v.getPolygonPos(t4, e2.dataPointsLen), s3 = "";
      a3.forEach(function(t5, a4) {
        if (0 === i2) {
          var r3 = e2.graphics.drawLine(t5.x, t5.y, 0, 0, Array.isArray(e2.polygons.connectorColors) ? e2.polygons.connectorColors[a4] : e2.polygons.connectorColors);
          d2.push(r3);
        }
        0 === a4 && e2.yaxisLabelsTextsPos.push({ x: t5.x, y: t5.y }), s3 += t5.x + "," + t5.y + " ";
      }), c2.push(s3);
    }), c2.forEach(function(t4, s3) {
      var r3 = e2.polygons.strokeColors, n3 = e2.polygons.strokeWidth, o3 = e2.graphics.drawPolygon(t4, Array.isArray(r3) ? r3[s3] : r3, Array.isArray(n3) ? n3[s3] : n3, i.globals.radarPolygons.fill.colors[s3]);
      a2.add(o3);
    }), d2.forEach(function(t4) {
      a2.add(t4);
    }), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach(function(t4, i2) {
      var a3 = s2.drawYAxisTexts(t4.x, t4.y, i2, r2[i2]);
      e2.yaxisLabels.add(a3);
    });
  } }, { key: "drawXAxisTexts", value: function() {
    var t3 = this, e2 = this.w, i = e2.config.xaxis.labels, a2 = this.graphics.group({ class: "apexcharts-xaxis" }), s2 = v.getPolygonPos(this.size, this.dataPointsLen);
    return e2.globals.labels.forEach(function(r2, n2) {
      var o2 = e2.config.xaxis.labels.formatter, l2 = new qi(t3.ctx);
      if (s2[n2]) {
        var h2 = t3.getTextPos(s2[n2], t3.size), c2 = o2(r2, { seriesIndex: -1, dataPointIndex: n2, w: e2 });
        l2.plotDataLabelsText({ x: h2.newX, y: h2.newY, text: c2, textAnchor: h2.textAnchor, i: n2, j: n2, parent: a2, className: "apexcharts-xaxis-label", color: Array.isArray(i.style.colors) && i.style.colors[n2] ? i.style.colors[n2] : "#a8a8a8", dataLabelsConfig: u({ textAnchor: h2.textAnchor, dropShadow: { enabled: false } }, i), offsetCorrection: false }).on("click", function(i2) {
          if ("function" == typeof e2.config.chart.events.xAxisLabelClick) {
            var a3 = Object.assign({}, e2, { labelIndex: n2 });
            e2.config.chart.events.xAxisLabelClick(i2, t3.ctx, a3);
          }
        });
      }
    }), a2;
  } }, { key: "createPaths", value: function(t3, e2) {
    var i = this, a2 = [], s2 = [], r2 = [], n2 = [];
    if (t3.length) {
      s2 = [this.graphics.move(e2.x, e2.y)], n2 = [this.graphics.move(e2.x, e2.y)];
      var o2 = this.graphics.move(t3[0].x, t3[0].y), l2 = this.graphics.move(t3[0].x, t3[0].y);
      t3.forEach(function(e3, a3) {
        o2 += i.graphics.line(e3.x, e3.y), l2 += i.graphics.line(e3.x, e3.y), a3 === t3.length - 1 && (o2 += "Z", l2 += "Z");
      }), a2.push(o2), r2.push(l2);
    }
    return { linePathsFrom: s2, linePathsTo: a2, areaPathsFrom: n2, areaPathsTo: r2 };
  } }, { key: "getTextPos", value: function(t3, e2) {
    var i = "middle", a2 = t3.x, s2 = t3.y;
    return Math.abs(t3.x) >= 10 ? t3.x > 0 ? (i = "start", a2 += 10) : t3.x < 0 && (i = "end", a2 -= 10) : i = "middle", Math.abs(t3.y) >= e2 - 10 && (t3.y < 0 ? s2 -= 10 : t3.y > 0 && (s2 += 10)), { textAnchor: i, newX: a2, newY: s2 };
  } }, { key: "getPreviousPath", value: function(t3) {
    for (var e2 = this.w, i = null, a2 = 0; a2 < e2.globals.previousPaths.length; a2++) {
      var s2 = e2.globals.previousPaths[a2];
      s2.paths.length > 0 && parseInt(s2.realIndex, 10) === parseInt(t3, 10) && void 0 !== e2.globals.previousPaths[a2].paths[0] && (i = e2.globals.previousPaths[a2].paths[0].d);
    }
    return i;
  } }, { key: "getDataPointsPos", value: function(t3, e2) {
    var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
    t3 = t3 || [], e2 = e2 || [];
    for (var a2 = [], s2 = 0; s2 < i; s2++) {
      var r2 = {};
      r2.x = t3[s2] * Math.sin(e2[s2]), r2.y = -t3[s2] * Math.cos(e2[s2]), a2.push(r2);
    }
    return a2;
  } }]), t2;
}(), Ha = function(t2) {
  h(r2, Ea);
  var a2 = n(r2);
  function r2(t3) {
    var s2;
    i$1(this, r2), (s2 = a2.call(this, t3)).ctx = t3, s2.w = t3.w, s2.animBeginArr = [0], s2.animDur = 0;
    var n2 = s2.w;
    return s2.startAngle = n2.config.plotOptions.radialBar.startAngle, s2.endAngle = n2.config.plotOptions.radialBar.endAngle, s2.totalAngle = Math.abs(n2.config.plotOptions.radialBar.endAngle - n2.config.plotOptions.radialBar.startAngle), s2.trackStartAngle = n2.config.plotOptions.radialBar.track.startAngle, s2.trackEndAngle = n2.config.plotOptions.radialBar.track.endAngle, s2.barLabels = s2.w.config.plotOptions.radialBar.barLabels, s2.donutDataLabels = s2.w.config.plotOptions.radialBar.dataLabels, s2.radialDataLabels = s2.donutDataLabels, s2.trackStartAngle || (s2.trackStartAngle = s2.startAngle), s2.trackEndAngle || (s2.trackEndAngle = s2.endAngle), 360 === s2.endAngle && (s2.endAngle = 359.99), s2.margin = parseInt(n2.config.plotOptions.radialBar.track.margin, 10), s2.onBarLabelClick = s2.onBarLabelClick.bind(e(s2)), s2;
  }
  return s(r2, [{ key: "draw", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a3 = i.group({ class: "apexcharts-radialbar" });
    if (e2.globals.noData)
      return a3;
    var s2 = i.group(), r3 = this.defaultSize / 2, n2 = e2.globals.gridWidth / 2, o2 = this.defaultSize / 2.05;
    e2.config.chart.sparkline.enabled || (o2 = o2 - e2.config.stroke.width - e2.config.chart.dropShadow.blur);
    var l2 = e2.globals.fill.colors;
    if (e2.config.plotOptions.radialBar.track.show) {
      var h2 = this.drawTracks({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 });
      s2.add(h2);
    }
    var c2 = this.drawArcs({ size: o2, centerX: n2, centerY: r3, colorArr: l2, series: t3 }), d2 = 360;
    e2.config.plotOptions.radialBar.startAngle < 0 && (d2 = this.totalAngle);
    var u2 = (360 - d2) / 360;
    if (e2.globals.radialSize = o2 - o2 * u2, this.radialDataLabels.value.show) {
      var g2 = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
      e2.globals.radialSize += g2 * u2;
    }
    return s2.add(c2.g), "front" === e2.config.plotOptions.radialBar.hollow.position && (c2.g.add(c2.elHollow), c2.dataLabels && c2.g.add(c2.dataLabels)), a3.add(s2), a3;
  } }, { key: "drawTracks", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a3 = i.group({ class: "apexcharts-tracks" }), s2 = new Li(this.ctx), r3 = new ji(this.ctx), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    for (var o2 = 0; o2 < t3.series.length; o2++) {
      var l2 = i.group({ class: "apexcharts-radialbar-track apexcharts-track" });
      a3.add(l2), l2.attr({ rel: o2 + 1 }), t3.size = t3.size - n2 - this.margin;
      var h2 = e2.config.plotOptions.radialBar.track, c2 = r3.fillPath({ seriesNumber: 0, size: t3.size, fillColors: Array.isArray(h2.background) ? h2.background[o2] : h2.background, solid: true }), d2 = this.trackStartAngle, u2 = this.trackEndAngle;
      Math.abs(u2) + Math.abs(d2) >= 360 && (u2 = 360 - Math.abs(this.startAngle) - 0.1);
      var g2 = i.drawPath({ d: "", stroke: c2, strokeWidth: n2 * parseInt(h2.strokeWidth, 10) / 100, fill: "none", strokeOpacity: h2.opacity, classes: "apexcharts-radialbar-area" });
      if (h2.dropShadow.enabled) {
        var p2 = h2.dropShadow;
        s2.dropShadow(g2, p2);
      }
      l2.add(g2), g2.attr("id", "apexcharts-radialbarTrack-" + o2), this.animatePaths(g2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: u2, startAngle: d2, size: t3.size, i: o2, totalItems: 2, animBeginArr: 0, dur: 0, isTrack: true });
    }
    return a3;
  } }, { key: "drawArcs", value: function(t3) {
    var e2 = this.w, i = new Mi(this.ctx), a3 = new ji(this.ctx), s2 = new Li(this.ctx), r3 = i.group(), n2 = this.getStrokeWidth(t3);
    t3.size = t3.size - n2 / 2;
    var o2 = e2.config.plotOptions.radialBar.hollow.background, l2 = t3.size - n2 * t3.series.length - this.margin * t3.series.length - n2 * parseInt(e2.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2, h2 = l2 - e2.config.plotOptions.radialBar.hollow.margin;
    void 0 !== e2.config.plotOptions.radialBar.hollow.image && (o2 = this.drawHollowImage(t3, r3, l2, o2));
    var c2 = this.drawHollow({ size: h2, centerX: t3.centerX, centerY: t3.centerY, fill: o2 || "transparent" });
    if (e2.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
      var d2 = e2.config.plotOptions.radialBar.hollow.dropShadow;
      s2.dropShadow(c2, d2);
    }
    var u2 = 1;
    !this.radialDataLabels.total.show && e2.globals.series.length > 1 && (u2 = 0);
    var g2 = null;
    if (this.radialDataLabels.show) {
      var p2 = e2.globals.dom.Paper.findOne(".apexcharts-datalabels-group");
      g2 = this.renderInnerDataLabels(p2, this.radialDataLabels, { hollowSize: l2, centerX: t3.centerX, centerY: t3.centerY, opacity: u2 });
    }
    "back" === e2.config.plotOptions.radialBar.hollow.position && (r3.add(c2), g2 && r3.add(g2));
    var f2 = false;
    e2.config.plotOptions.radialBar.inverseOrder && (f2 = true);
    for (var x2 = f2 ? t3.series.length - 1 : 0; f2 ? x2 >= 0 : x2 < t3.series.length; f2 ? x2-- : x2++) {
      var b2 = i.group({ class: "apexcharts-series apexcharts-radial-series", seriesName: v.escapeString(e2.globals.seriesNames[x2]) });
      r3.add(b2), b2.attr({ rel: x2 + 1, "data:realIndex": x2 }), this.ctx.series.addCollapsedClassToSeries(b2, x2), t3.size = t3.size - n2 - this.margin;
      var m2 = a3.fillPath({ seriesNumber: x2, size: t3.size, value: t3.series[x2] }), y2 = this.startAngle, w2 = void 0, k2 = v.negToZero(t3.series[x2] > 100 ? 100 : t3.series[x2]) / 100, A2 = Math.round(this.totalAngle * k2) + this.startAngle, C2 = void 0;
      e2.globals.dataChanged && (w2 = this.startAngle, C2 = Math.round(this.totalAngle * v.negToZero(e2.globals.previousPaths[x2]) / 100) + w2), Math.abs(A2) + Math.abs(y2) > 360 && (A2 -= 0.01), Math.abs(C2) + Math.abs(w2) > 360 && (C2 -= 0.01);
      var S2 = A2 - y2, L2 = Array.isArray(e2.config.stroke.dashArray) ? e2.config.stroke.dashArray[x2] : e2.config.stroke.dashArray, M2 = i.drawPath({ d: "", stroke: m2, strokeWidth: n2, fill: "none", fillOpacity: e2.config.fill.opacity, classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + x2, strokeDashArray: L2 });
      if (Mi.setAttrs(M2.node, { "data:angle": S2, "data:value": t3.series[x2] }), e2.config.chart.dropShadow.enabled) {
        var P2 = e2.config.chart.dropShadow;
        s2.dropShadow(M2, P2, x2);
      }
      if (s2.setSelectionFilter(M2, 0, x2), this.addListeners(M2, this.radialDataLabels), b2.add(M2), M2.attr({ index: 0, j: x2 }), this.barLabels.enabled) {
        var I2 = v.polarToCartesian(t3.centerX, t3.centerY, t3.size, y2), T2 = this.barLabels.formatter(e2.globals.seriesNames[x2], { seriesIndex: x2, w: e2 }), z2 = ["apexcharts-radialbar-label"];
        this.barLabels.onClick || z2.push("apexcharts-no-click");
        var X2 = this.barLabels.useSeriesColors ? e2.globals.colors[x2] : e2.config.chart.foreColor;
        X2 || (X2 = e2.config.chart.foreColor);
        var R2 = I2.x + this.barLabels.offsetX, E2 = I2.y + this.barLabels.offsetY, Y2 = i.drawText({ x: R2, y: E2, text: T2, textAnchor: "end", dominantBaseline: "middle", fontFamily: this.barLabels.fontFamily, fontWeight: this.barLabels.fontWeight, fontSize: this.barLabels.fontSize, foreColor: X2, cssClass: z2.join(" ") });
        Y2.on("click", this.onBarLabelClick), Y2.attr({ rel: x2 + 1 }), 0 !== y2 && Y2.attr({ "transform-origin": "".concat(R2, " ").concat(E2), transform: "rotate(".concat(y2, " 0 0)") }), b2.add(Y2);
      }
      var H2 = 0;
      !this.initialAnim || e2.globals.resized || e2.globals.dataChanged || (H2 = e2.config.chart.animations.speed), e2.globals.dataChanged && (H2 = e2.config.chart.animations.dynamicAnimation.speed), this.animDur = H2 / (1.2 * t3.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(M2, { centerX: t3.centerX, centerY: t3.centerY, endAngle: A2, startAngle: y2, prevEndAngle: C2, prevStartAngle: w2, size: t3.size, i: x2, totalItems: 2, animBeginArr: this.animBeginArr, dur: H2, shouldSetPrevPaths: true });
    }
    return { g: r3, elHollow: c2, dataLabels: g2 };
  } }, { key: "drawHollow", value: function(t3) {
    var e2 = new Mi(this.ctx).drawCircle(2 * t3.size);
    return e2.attr({ class: "apexcharts-radialbar-hollow", cx: t3.centerX, cy: t3.centerY, r: t3.size, fill: t3.fill }), e2;
  } }, { key: "drawHollowImage", value: function(t3, e2, i, a3) {
    var s2 = this.w, r3 = new ji(this.ctx), n2 = v.randomId(), o2 = s2.config.plotOptions.radialBar.hollow.image;
    if (s2.config.plotOptions.radialBar.hollow.imageClipped)
      r3.clippedImgArea({ width: i, height: i, image: o2, patternID: "pattern".concat(s2.globals.cuid).concat(n2) }), a3 = "url(#pattern".concat(s2.globals.cuid).concat(n2, ")");
    else {
      var l2 = s2.config.plotOptions.radialBar.hollow.imageWidth, h2 = s2.config.plotOptions.radialBar.hollow.imageHeight;
      if (void 0 === l2 && void 0 === h2) {
        var c2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - e3.width / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - e3.height / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY);
        });
        e2.add(c2);
      } else {
        var d2 = s2.globals.dom.Paper.image(o2, function(e3) {
          this.move(t3.centerX - l2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetX, t3.centerY - h2 / 2 + s2.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l2, h2);
        });
        e2.add(d2);
      }
    }
    return a3;
  } }, { key: "getStrokeWidth", value: function(t3) {
    var e2 = this.w;
    return t3.size * (100 - parseInt(e2.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t3.series.length + 1) - this.margin;
  } }, { key: "onBarLabelClick", value: function(t3) {
    var e2 = parseInt(t3.target.getAttribute("rel"), 10) - 1, i = this.barLabels.onClick, a3 = this.w;
    i && i(a3.globals.seriesNames[e2], { w: a3, seriesIndex: e2 });
  } }]), r2;
}(), Oa = function(t2) {
  h(a2, Pa);
  var e2 = n(a2);
  function a2() {
    return i$1(this, a2), e2.apply(this, arguments);
  }
  return s(a2, [{ key: "draw", value: function(t3, e3) {
    var i = this.w, a3 = new Mi(this.ctx);
    this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t3, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t3);
    for (var s2 = a3.group({ class: "apexcharts-rangebar-series apexcharts-plot-series" }), r2 = 0; r2 < t3.length; r2++) {
      var n2, o2, l2, h2, c2 = void 0, d2 = void 0, g2 = i.globals.comboCharts ? e3[r2] : r2, p2 = this.barHelpers.getGroupIndex(g2).columnGroupIndex, f2 = a3.group({ class: "apexcharts-series", seriesName: v.escapeString(i.globals.seriesNames[g2]), rel: r2 + 1, "data:realIndex": g2 });
      this.ctx.series.addCollapsedClassToSeries(f2, g2), t3[r2].length > 0 && (this.visibleI = this.visibleI + 1);
      var x2 = 0, b2 = 0, m2 = 0;
      this.yRatio.length > 1 && (this.yaxisIndex = i.globals.seriesYAxisReverseMap[g2][0], m2 = g2);
      var y2 = this.barHelpers.initialPositions(g2);
      d2 = y2.y, h2 = y2.zeroW, c2 = y2.x, b2 = y2.barWidth, x2 = y2.barHeight, n2 = y2.xDivision, o2 = y2.yDivision, l2 = y2.zeroH;
      for (var w2 = a3.group({ class: "apexcharts-datalabels", "data:realIndex": g2 }), k2 = a3.group({ class: "apexcharts-rangebar-goals-markers" }), A2 = 0; A2 < i.globals.dataPoints; A2++) {
        var C2 = this.barHelpers.getStrokeWidth(r2, A2, g2), S2 = this.seriesRangeStart[r2][A2], L2 = this.seriesRangeEnd[r2][A2], M2 = null, P2 = null, I2 = null, T2 = { x: c2, y: d2, strokeWidth: C2, elSeries: f2 }, z2 = this.seriesLen;
        if (i.config.plotOptions.bar.rangeBarGroupRows && (z2 = 1), void 0 === i.config.series[r2].data[A2])
          break;
        if (this.isHorizontal) {
          I2 = d2 + x2 * this.visibleI;
          var X2 = (o2 - x2 * z2) / 2;
          if (i.config.series[r2].data[A2].x) {
            var R2 = this.detectOverlappingBars({ i: r2, j: A2, barYPosition: I2, srty: X2, barHeight: x2, yDivision: o2, initPositions: y2 });
            x2 = R2.barHeight, I2 = R2.barYPosition;
          }
          b2 = (M2 = this.drawRangeBarPaths(u({ indexes: { i: r2, j: A2, realIndex: g2 }, barHeight: x2, barYPosition: I2, zeroW: h2, yDivision: o2, y1: S2, y2: L2 }, T2))).barWidth;
        } else {
          i.globals.isXNumeric && (c2 = (i.globals.seriesX[r2][A2] - i.globals.minX) / this.xRatio - b2 / 2), P2 = c2 + b2 * this.visibleI;
          var E2 = (n2 - b2 * z2) / 2;
          if (i.config.series[r2].data[A2].x) {
            var Y2 = this.detectOverlappingBars({ i: r2, j: A2, barXPosition: P2, srtx: E2, barWidth: b2, xDivision: n2, initPositions: y2 });
            b2 = Y2.barWidth, P2 = Y2.barXPosition;
          }
          x2 = (M2 = this.drawRangeColumnPaths(u({ indexes: { i: r2, j: A2, realIndex: g2, translationsIndex: m2 }, barWidth: b2, barXPosition: P2, zeroH: l2, xDivision: n2 }, T2))).barHeight;
        }
        var H2 = this.barHelpers.drawGoalLine({ barXPosition: M2.barXPosition, barYPosition: I2, goalX: M2.goalX, goalY: M2.goalY, barHeight: x2, barWidth: b2 });
        H2 && k2.add(H2), d2 = M2.y, c2 = M2.x;
        var O2 = this.barHelpers.getPathFillColor(t3, r2, A2, g2);
        this.renderSeries({ realIndex: g2, pathFill: O2.color, lineFill: O2.useRangeColor ? O2.color : i.globals.stroke.colors[g2], j: A2, i: r2, x: c2, y: d2, y1: S2, y2: L2, pathFrom: M2.pathFrom, pathTo: M2.pathTo, strokeWidth: C2, elSeries: f2, series: t3, barHeight: x2, barWidth: b2, barXPosition: P2, barYPosition: I2, columnGroupIndex: p2, elDataLabelsWrap: w2, elGoalsMarkers: k2, visibleSeries: this.visibleI, type: "rangebar" });
      }
      s2.add(f2);
    }
    return s2;
  } }, { key: "detectOverlappingBars", value: function(t3) {
    var e3 = t3.i, i = t3.j, a3 = t3.barYPosition, s2 = t3.barXPosition, r2 = t3.srty, n2 = t3.srtx, o2 = t3.barHeight, l2 = t3.barWidth, h2 = t3.yDivision, c2 = t3.xDivision, d2 = t3.initPositions, u2 = this.w, g2 = [], p2 = u2.config.series[e3].data[i].rangeName, f2 = u2.config.series[e3].data[i].x, x2 = Array.isArray(f2) ? f2.join(" ") : f2, b2 = u2.globals.labels.map(function(t4) {
      return Array.isArray(t4) ? t4.join(" ") : t4;
    }).indexOf(x2), m2 = u2.globals.seriesRange[e3].findIndex(function(t4) {
      return t4.x === x2 && t4.overlaps.length > 0;
    });
    return this.isHorizontal ? (a3 = u2.config.plotOptions.bar.rangeBarGroupRows ? r2 + h2 * b2 : r2 + o2 * this.visibleI + h2 * b2, m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (a3 = (o2 = d2.barHeight / g2.length) * this.visibleI + h2 * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + o2 * (this.visibleI + g2.indexOf(p2)) + h2 * b2)) : (b2 > -1 && !u2.globals.timescaleLabels.length && (s2 = u2.config.plotOptions.bar.rangeBarGroupRows ? n2 + c2 * b2 : n2 + l2 * this.visibleI + c2 * b2), m2 > -1 && !u2.config.plotOptions.bar.rangeBarOverlap && (g2 = u2.globals.seriesRange[e3][m2].overlaps).indexOf(p2) > -1 && (s2 = (l2 = d2.barWidth / g2.length) * this.visibleI + c2 * (100 - parseInt(this.barOptions.barWidth, 10)) / 100 / 2 + l2 * (this.visibleI + g2.indexOf(p2)) + c2 * b2)), { barYPosition: a3, barXPosition: s2, barHeight: o2, barWidth: l2 };
  } }, { key: "drawRangeColumnPaths", value: function(t3) {
    var e3 = t3.indexes, i = t3.x, a3 = t3.xDivision, s2 = t3.barWidth, r2 = t3.barXPosition, n2 = t3.zeroH, o2 = this.w, l2 = e3.i, h2 = e3.j, c2 = e3.realIndex, d2 = e3.translationsIndex, u2 = this.yRatio[d2], g2 = this.getRangeValue(c2, h2), p2 = Math.min(g2.start, g2.end), f2 = Math.max(g2.start, g2.end);
    void 0 === this.series[l2][h2] || null === this.series[l2][h2] ? p2 = n2 : (p2 = n2 - p2 / u2, f2 = n2 - f2 / u2);
    var x2 = Math.abs(f2 - p2), b2 = this.barHelpers.getColumnPaths({ barXPosition: r2, barWidth: s2, y1: p2, y2: f2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, realIndex: c2, i: c2, j: h2, w: o2 });
    if (o2.globals.isXNumeric) {
      var m2 = this.getBarXForNumericXAxis({ x: i, j: h2, realIndex: c2, barWidth: s2 });
      i = m2.x, r2 = m2.barXPosition;
    } else
      i += a3;
    return { pathTo: b2.pathTo, pathFrom: b2.pathFrom, barHeight: x2, x: i, y: g2.start < 0 && g2.end < 0 ? p2 : f2, goalY: this.barHelpers.getGoalValues("y", null, n2, l2, h2, d2), barXPosition: r2 };
  } }, { key: "preventBarOverflow", value: function(t3) {
    var e3 = this.w;
    return t3 < 0 && (t3 = 0), t3 > e3.globals.gridWidth && (t3 = e3.globals.gridWidth), t3;
  } }, { key: "drawRangeBarPaths", value: function(t3) {
    var e3 = t3.indexes, i = t3.y, a3 = t3.y1, s2 = t3.y2, r2 = t3.yDivision, n2 = t3.barHeight, o2 = t3.barYPosition, l2 = t3.zeroW, h2 = this.w, c2 = e3.realIndex, d2 = e3.j, u2 = this.preventBarOverflow(l2 + a3 / this.invertedYRatio), g2 = this.preventBarOverflow(l2 + s2 / this.invertedYRatio), p2 = this.getRangeValue(c2, d2), f2 = Math.abs(g2 - u2), x2 = this.barHelpers.getBarpaths({ barYPosition: o2, barHeight: n2, x1: u2, x2: g2, strokeWidth: this.strokeWidth, series: this.seriesRangeEnd, i: c2, realIndex: c2, j: d2, w: h2 });
    return h2.globals.isXNumeric || (i += r2), { pathTo: x2.pathTo, pathFrom: x2.pathFrom, barWidth: f2, x: p2.start < 0 && p2.end < 0 ? u2 : g2, goalX: this.barHelpers.getGoalValues("x", l2, null, c2, d2), y: i };
  } }, { key: "getRangeValue", value: function(t3, e3) {
    var i = this.w;
    return { start: i.globals.seriesRangeStart[t3][e3], end: i.globals.seriesRangeEnd[t3][e3] };
  } }]), a2;
}(), Fa = function() {
  function t2(e2) {
    i$1(this, t2), this.w = e2.w, this.lineCtx = e2;
  }
  return s(t2, [{ key: "sameValueSeriesFix", value: function(t3, e2) {
    var i = this.w;
    if (("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t3]) && new Pi(this.lineCtx.ctx, i).seriesHaveSameValues(t3)) {
      var a2 = e2[t3].slice();
      a2[a2.length - 1] = a2[a2.length - 1] + 1e-6, e2[t3] = a2;
    }
    return e2;
  } }, { key: "calculatePoints", value: function(t3) {
    var e2 = t3.series, i = t3.realIndex, a2 = t3.x, s2 = t3.y, r2 = t3.i, n2 = t3.j, o2 = t3.prevY, l2 = this.w, h2 = [], c2 = [], d2 = this.lineCtx.categoryAxisCorrection + l2.config.markers.offsetX;
    return l2.globals.isXNumeric && (d2 = (l2.globals.seriesX[i][0] - l2.globals.minX) / this.lineCtx.xRatio + l2.config.markers.offsetX), 0 === n2 && (h2.push(d2), c2.push(v.isNumber(e2[r2][0]) ? o2 + l2.config.markers.offsetY : null)), h2.push(a2 + l2.config.markers.offsetX), c2.push(v.isNumber(e2[r2][n2 + 1]) ? s2 + l2.config.markers.offsetY : null), { x: h2, y: c2 };
  } }, { key: "checkPreviousPaths", value: function(t3) {
    for (var e2 = t3.pathFromLine, i = t3.pathFromArea, a2 = t3.realIndex, s2 = this.w, r2 = 0; r2 < s2.globals.previousPaths.length; r2++) {
      var n2 = s2.globals.previousPaths[r2];
      ("line" === n2.type || "area" === n2.type) && n2.paths.length > 0 && parseInt(n2.realIndex, 10) === parseInt(a2, 10) && ("line" === n2.type ? (this.lineCtx.appendPathFrom = false, e2 = s2.globals.previousPaths[r2].paths[0].d) : "area" === n2.type && (this.lineCtx.appendPathFrom = false, i = s2.globals.previousPaths[r2].paths[0].d, s2.config.stroke.show && s2.globals.previousPaths[r2].paths[1] && (e2 = s2.globals.previousPaths[r2].paths[1].d)));
    }
    return { pathFromLine: e2, pathFromArea: i };
  } }, { key: "determineFirstPrevY", value: function(t3) {
    var e2, i, a2, s2 = t3.i, r2 = t3.realIndex, n2 = t3.series, o2 = t3.prevY, l2 = t3.lineYPosition, h2 = t3.translationsIndex, c2 = this.w, d2 = c2.config.chart.stacked && !c2.globals.comboCharts || c2.config.chart.stacked && c2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[r2]) || void 0 === e2 ? void 0 : e2.type) || "column" === (null === (i = this.w.config.series[r2]) || void 0 === i ? void 0 : i.type));
    if (void 0 !== (null === (a2 = n2[s2]) || void 0 === a2 ? void 0 : a2[0]))
      o2 = (l2 = d2 && s2 > 0 ? this.lineCtx.prevSeriesY[s2 - 1][0] : this.lineCtx.zeroY) - n2[s2][0] / this.lineCtx.yRatio[h2] + 2 * (this.lineCtx.isReversed ? n2[s2][0] / this.lineCtx.yRatio[h2] : 0);
    else if (d2 && s2 > 0 && void 0 === n2[s2][0]) {
      for (var u2 = s2 - 1; u2 >= 0; u2--)
        if (null !== n2[u2][0] && void 0 !== n2[u2][0]) {
          o2 = l2 = this.lineCtx.prevSeriesY[u2][0];
          break;
        }
    }
    return { prevY: o2, lineYPosition: l2 };
  } }]), t2;
}(), Da = function(t2) {
  for (var e2, i, a2, s2, r2 = function(t3) {
    for (var e3 = [], i2 = t3[0], a3 = t3[1], s3 = e3[0] = Wa(i2, a3), r3 = 1, n3 = t3.length - 1; r3 < n3; r3++)
      i2 = a3, a3 = t3[r3 + 1], e3[r3] = 0.5 * (s3 + (s3 = Wa(i2, a3)));
    return e3[r3] = s3, e3;
  }(t2), n2 = t2.length - 1, o2 = [], l2 = 0; l2 < n2; l2++)
    a2 = Wa(t2[l2], t2[l2 + 1]), Math.abs(a2) < 1e-6 ? r2[l2] = r2[l2 + 1] = 0 : (s2 = (e2 = r2[l2] / a2) * e2 + (i = r2[l2 + 1] / a2) * i) > 9 && (s2 = 3 * a2 / Math.sqrt(s2), r2[l2] = s2 * e2, r2[l2 + 1] = s2 * i);
  for (var h2 = 0; h2 <= n2; h2++)
    s2 = (t2[Math.min(n2, h2 + 1)][0] - t2[Math.max(0, h2 - 1)][0]) / (6 * (1 + r2[h2] * r2[h2])), o2.push([s2 || 0, r2[h2] * s2 || 0]);
  return o2;
}, _a = function(t2) {
  var e2 = Da(t2), i = t2[1], a2 = t2[0], s2 = [], r2 = e2[1], n2 = e2[0];
  s2.push(a2, [a2[0] + n2[0], a2[1] + n2[1], i[0] - r2[0], i[1] - r2[1], i[0], i[1]]);
  for (var o2 = 2, l2 = e2.length; o2 < l2; o2++) {
    var h2 = t2[o2], c2 = e2[o2];
    s2.push([h2[0] - c2[0], h2[1] - c2[1], h2[0], h2[1]]);
  }
  return s2;
}, Na = function(t2, e2, i) {
  var a2 = t2.slice(e2, i);
  if (e2) {
    if (i - e2 > 1 && a2[1].length < 6) {
      var s2 = a2[0].length;
      a2[1] = [2 * a2[0][s2 - 2] - a2[0][s2 - 4], 2 * a2[0][s2 - 1] - a2[0][s2 - 3]].concat(a2[1]);
    }
    a2[0] = a2[0].slice(-2);
  }
  return a2;
};
function Wa(t2, e2) {
  return (e2[1] - t2[1]) / (e2[0] - t2[0]);
}
var Ba = function() {
  function t2(e2, a2, s2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.xyRatios = a2, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || s2, this.scatter = new Ui(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new Fa(this), this.markers = new Vi(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0;
  }
  return s(t2, [{ key: "draw", value: function(t3, e2, i, a2) {
    var s2, r2 = this.w, n2 = new Mi(this.ctx), o2 = r2.globals.comboCharts ? e2 : r2.config.chart.type, l2 = n2.group({ class: "apexcharts-".concat(o2, "-series apexcharts-plot-series") }), h2 = new Pi(this.ctx, r2);
    this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t3 = h2.getLogSeries(t3), this.yRatio = h2.getLogYRatios(this.yRatio), this.prevSeriesY = [];
    for (var c2 = [], d2 = 0; d2 < t3.length; d2++) {
      t3 = this.lineHelpers.sameValueSeriesFix(d2, t3);
      var g2 = r2.globals.comboCharts ? i[d2] : d2, p2 = this.yRatio.length > 1 ? g2 : 0;
      this._initSerieVariables(t3, d2, g2);
      var f2 = [], x2 = [], b2 = [], m2 = r2.globals.padHorizontal + this.categoryAxisCorrection;
      this.ctx.series.addCollapsedClassToSeries(this.elSeries, g2), r2.globals.isXNumeric && r2.globals.seriesX.length > 0 && (m2 = (r2.globals.seriesX[g2][0] - r2.globals.minX) / this.xRatio), b2.push(m2);
      var v2, y2 = m2, w2 = void 0, k2 = y2, A2 = this.zeroY, C2 = this.zeroY;
      A2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: t3, prevY: A2, lineYPosition: 0, translationsIndex: p2 }).prevY, "monotoneCubic" === r2.config.stroke.curve && null === t3[d2][0] ? f2.push(null) : f2.push(A2), v2 = A2;
      "rangeArea" === o2 && (w2 = C2 = this.lineHelpers.determineFirstPrevY({ i: d2, realIndex: g2, series: a2, prevY: C2, lineYPosition: 0, translationsIndex: p2 }).prevY, x2.push(null !== f2[0] ? C2 : null));
      var S2 = this._calculatePathsFrom({ type: o2, series: t3, i: d2, realIndex: g2, translationsIndex: p2, prevX: k2, prevY: A2, prevY2: C2 }), L2 = [f2[0]], M2 = [x2[0]], P2 = { type: o2, series: t3, realIndex: g2, translationsIndex: p2, i: d2, x: m2, y: 1, pX: y2, pY: v2, pathsFrom: S2, linePaths: [], areaPaths: [], seriesIndex: i, lineYPosition: 0, xArrj: b2, yArrj: f2, y2Arrj: x2, seriesRangeEnd: a2 }, I2 = this._iterateOverDataPoints(u(u({}, P2), {}, { iterations: "rangeArea" === o2 ? t3[d2].length - 1 : void 0, isRangeStart: true }));
      if ("rangeArea" === o2) {
        for (var T2 = this._calculatePathsFrom({ series: a2, i: d2, realIndex: g2, prevX: k2, prevY: C2 }), z2 = this._iterateOverDataPoints(u(u({}, P2), {}, { series: a2, xArrj: [m2], yArrj: L2, y2Arrj: M2, pY: w2, areaPaths: I2.areaPaths, pathsFrom: T2, iterations: a2[d2].length - 1, isRangeStart: false })), X2 = I2.linePaths.length / 2, R2 = 0; R2 < X2; R2++)
          I2.linePaths[R2] = z2.linePaths[R2 + X2] + I2.linePaths[R2];
        I2.linePaths.splice(X2), I2.pathFromLine = z2.pathFromLine + I2.pathFromLine;
      } else
        I2.pathFromArea += "z";
      this._handlePaths({ type: o2, realIndex: g2, i: d2, paths: I2 }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), c2.push(this.elSeries);
    }
    if (void 0 !== (null === (s2 = r2.config.series[0]) || void 0 === s2 ? void 0 : s2.zIndex) && c2.sort(function(t4, e3) {
      return Number(t4.node.getAttribute("zIndex")) - Number(e3.node.getAttribute("zIndex"));
    }), r2.config.chart.stacked)
      for (var E2 = c2.length - 1; E2 >= 0; E2--)
        l2.add(c2[E2]);
    else
      for (var Y2 = 0; Y2 < c2.length; Y2++)
        l2.add(c2[Y2]);
    return l2;
  } }, { key: "_initSerieVariables", value: function(t3, e2, i) {
    var a2 = this.w, s2 = new Mi(this.ctx);
    this.xDivision = a2.globals.gridWidth / (a2.globals.dataPoints - ("on" === a2.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a2.config.stroke.width) ? a2.config.stroke.width[i] : a2.config.stroke.width;
    var r2 = 0;
    if (this.yRatio.length > 1 && (this.yaxisIndex = a2.globals.seriesYAxisReverseMap[i], r2 = i), this.isReversed = a2.config.yaxis[this.yaxisIndex] && a2.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a2.globals.gridHeight - this.baseLineY[r2] - (this.isReversed ? a2.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[r2] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a2.globals.gridHeight || "end" === a2.config.plotOptions.area.fillTo) && (this.areaBottomY = a2.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s2.group({ class: "apexcharts-series", zIndex: void 0 !== a2.config.series[i].zIndex ? a2.config.series[i].zIndex : i, seriesName: v.escapeString(a2.globals.seriesNames[i]) }), this.elPointsMain = s2.group({ class: "apexcharts-series-markers-wrap", "data:realIndex": i }), a2.globals.hasNullValues) {
      var n2 = this.markers.plotChartMarkers({ pointsPos: { x: [0], y: [a2.globals.gridHeight + a2.globals.markers.largestSize] }, seriesIndex: e2, j: 0, pSize: 0.1, alwaysDrawMarker: true, isVirtualPoint: true });
      null !== n2 && this.elPointsMain.add(n2);
    }
    this.elDataLabelsWrap = s2.group({ class: "apexcharts-datalabels", "data:realIndex": i });
    var o2 = t3[e2].length === a2.globals.dataPoints;
    this.elSeries.attr({ "data:longestSeries": o2, rel: e2 + 1, "data:realIndex": i }), this.appendPathFrom = true;
  } }, { key: "_calculatePathsFrom", value: function(t3) {
    var e2, i, a2, s2, r2 = t3.type, n2 = t3.series, o2 = t3.i, l2 = t3.realIndex, h2 = t3.translationsIndex, c2 = t3.prevX, d2 = t3.prevY, u2 = t3.prevY2, g2 = this.w, p2 = new Mi(this.ctx);
    if (null === n2[o2][0]) {
      for (var f2 = 0; f2 < n2[o2].length; f2++)
        if (null !== n2[o2][f2]) {
          c2 = this.xDivision * f2, d2 = this.zeroY - n2[o2][f2] / this.yRatio[h2], e2 = p2.move(c2, d2), i = p2.move(c2, this.areaBottomY);
          break;
        }
    } else
      e2 = p2.move(c2, d2), "rangeArea" === r2 && (e2 = p2.move(c2, u2) + p2.line(c2, d2)), i = p2.move(c2, this.areaBottomY) + p2.line(c2, d2);
    if (a2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), s2 = p2.move(0, this.areaBottomY) + p2.line(0, this.areaBottomY), g2.globals.previousPaths.length > 0) {
      var x2 = this.lineHelpers.checkPreviousPaths({ pathFromLine: a2, pathFromArea: s2, realIndex: l2 });
      a2 = x2.pathFromLine, s2 = x2.pathFromArea;
    }
    return { prevX: c2, prevY: d2, linePath: e2, areaPath: i, pathFromLine: a2, pathFromArea: s2 };
  } }, { key: "_handlePaths", value: function(t3) {
    var e2 = t3.type, i = t3.realIndex, a2 = t3.i, s2 = t3.paths, r2 = this.w, n2 = new Mi(this.ctx), o2 = new ji(this.ctx);
    this.prevSeriesY.push(s2.yArrj), r2.globals.seriesXvalues[i] = s2.xArrj, r2.globals.seriesYvalues[i] = s2.yArrj;
    var l2 = r2.config.forecastDataPoints;
    if (l2.count > 0 && "rangeArea" !== e2) {
      var h2 = r2.globals.seriesXvalues[i][r2.globals.seriesXvalues[i].length - l2.count - 1], c2 = n2.drawRect(h2, 0, r2.globals.gridWidth, r2.globals.gridHeight, 0);
      r2.globals.dom.elForecastMask.appendChild(c2.node);
      var d2 = n2.drawRect(0, 0, h2, r2.globals.gridHeight, 0);
      r2.globals.dom.elNonForecastMask.appendChild(d2.node);
    }
    this.pointsChart || r2.globals.delayedElements.push({ el: this.elPointsMain.node, index: i });
    var g2 = { i: a2, realIndex: i, animationDelay: a2, initialSpeed: r2.config.chart.animations.speed, dataChangeSpeed: r2.config.chart.animations.dynamicAnimation.speed, className: "apexcharts-".concat(e2) };
    if ("area" === e2)
      for (var p2 = o2.fillPath({ seriesNumber: i }), f2 = 0; f2 < s2.areaPaths.length; f2++) {
        var x2 = n2.renderPaths(u(u({}, g2), {}, { pathFrom: s2.pathFromArea, pathTo: s2.areaPaths[f2], stroke: "none", strokeWidth: 0, strokeLineCap: null, fill: p2 }));
        this.elSeries.add(x2);
      }
    if (r2.config.stroke.show && !this.pointsChart) {
      var b2 = null;
      if ("line" === e2)
        b2 = o2.fillPath({ seriesNumber: i, i: a2 });
      else if ("solid" === r2.config.stroke.fill.type)
        b2 = r2.globals.stroke.colors[i];
      else {
        var m2 = r2.config.fill;
        r2.config.fill = r2.config.stroke.fill, b2 = o2.fillPath({ seriesNumber: i, i: a2 }), r2.config.fill = m2;
      }
      for (var v2 = 0; v2 < s2.linePaths.length; v2++) {
        var y2 = b2;
        "rangeArea" === e2 && (y2 = o2.fillPath({ seriesNumber: i }));
        var w2 = u(u({}, g2), {}, { pathFrom: s2.pathFromLine, pathTo: s2.linePaths[v2], stroke: b2, strokeWidth: this.strokeWidth, strokeLineCap: r2.config.stroke.lineCap, fill: "rangeArea" === e2 ? y2 : "none" }), k2 = n2.renderPaths(w2);
        if (this.elSeries.add(k2), k2.attr("fill-rule", "evenodd"), l2.count > 0 && "rangeArea" !== e2) {
          var A2 = n2.renderPaths(w2);
          A2.node.setAttribute("stroke-dasharray", l2.dashArray), l2.strokeWidth && A2.node.setAttribute("stroke-width", l2.strokeWidth), this.elSeries.add(A2), A2.attr("clip-path", "url(#forecastMask".concat(r2.globals.cuid, ")")), k2.attr("clip-path", "url(#nonForecastMask".concat(r2.globals.cuid, ")"));
        }
      }
    }
  } }, { key: "_iterateOverDataPoints", value: function(t3) {
    var e2, i, a2 = this, s2 = t3.type, r2 = t3.series, n2 = t3.iterations, o2 = t3.realIndex, l2 = t3.translationsIndex, h2 = t3.i, c2 = t3.x, d2 = t3.y, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathsFrom, f2 = t3.linePaths, x2 = t3.areaPaths, b2 = t3.seriesIndex, m2 = t3.lineYPosition, y2 = t3.xArrj, w2 = t3.yArrj, k2 = t3.y2Arrj, A2 = t3.isRangeStart, C2 = t3.seriesRangeEnd, S2 = this.w, L2 = new Mi(this.ctx), M2 = this.yRatio, P2 = p2.prevY, I2 = p2.linePath, T2 = p2.areaPath, z2 = p2.pathFromLine, X2 = p2.pathFromArea, R2 = v.isNumber(S2.globals.minYArr[o2]) ? S2.globals.minYArr[o2] : S2.globals.minY;
    n2 || (n2 = S2.globals.dataPoints > 1 ? S2.globals.dataPoints - 1 : S2.globals.dataPoints);
    var E2 = function(t4, e3) {
      return e3 - t4 / M2[l2] + 2 * (a2.isReversed ? t4 / M2[l2] : 0);
    }, Y2 = d2, H2 = S2.config.chart.stacked && !S2.globals.comboCharts || S2.config.chart.stacked && S2.globals.comboCharts && (!this.w.config.chart.stackOnlyBar || "bar" === (null === (e2 = this.w.config.series[o2]) || void 0 === e2 ? void 0 : e2.type) || "column" === (null === (i = this.w.config.series[o2]) || void 0 === i ? void 0 : i.type)), O2 = S2.config.stroke.curve;
    Array.isArray(O2) && (O2 = Array.isArray(b2) ? O2[b2[h2]] : O2[h2]);
    for (var F2, D2 = 0, _2 = 0; _2 < n2 && 0 !== r2[h2].length; _2++) {
      var N2 = void 0 === r2[h2][_2 + 1] || null === r2[h2][_2 + 1];
      if (S2.globals.isXNumeric) {
        var W2 = S2.globals.seriesX[o2][_2 + 1];
        void 0 === S2.globals.seriesX[o2][_2 + 1] && (W2 = S2.globals.seriesX[o2][n2 - 1]), c2 = (W2 - S2.globals.minX) / this.xRatio;
      } else
        c2 += this.xDivision;
      if (H2)
        if (h2 > 0 && S2.globals.collapsedSeries.length < S2.config.series.length - 1) {
          m2 = this.prevSeriesY[function(t4) {
            for (var e3 = t4; e3 > 0; e3--) {
              if (!(S2.globals.collapsedSeriesIndices.indexOf((null == b2 ? void 0 : b2[e3]) || e3) > -1))
                return e3;
              e3--;
            }
            return 0;
          }(h2 - 1)][_2 + 1];
        } else
          m2 = this.zeroY;
      else
        m2 = this.zeroY;
      N2 ? d2 = E2(R2, m2) : (d2 = E2(r2[h2][_2 + 1], m2), "rangeArea" === s2 && (Y2 = E2(C2[h2][_2 + 1], m2))), y2.push(null === r2[h2][_2 + 1] ? null : c2), !N2 || "smooth" !== S2.config.stroke.curve && "monotoneCubic" !== S2.config.stroke.curve ? (w2.push(d2), k2.push(Y2)) : (w2.push(null), k2.push(null));
      var B2 = this.lineHelpers.calculatePoints({ series: r2, x: c2, y: d2, realIndex: o2, i: h2, j: _2, prevY: P2 }), G2 = this._createPaths({ type: s2, series: r2, i: h2, realIndex: o2, j: _2, x: c2, y: d2, y2: Y2, xArrj: y2, yArrj: w2, y2Arrj: k2, pX: u2, pY: g2, pathState: D2, segmentStartX: F2, linePath: I2, areaPath: T2, linePaths: f2, areaPaths: x2, curve: O2, isRangeStart: A2 });
      x2 = G2.areaPaths, f2 = G2.linePaths, u2 = G2.pX, g2 = G2.pY, D2 = G2.pathState, F2 = G2.segmentStartX, T2 = G2.areaPath, I2 = G2.linePath, !this.appendPathFrom || S2.globals.hasNullValues || "monotoneCubic" === O2 && "rangeArea" === s2 || (z2 += L2.line(c2, this.areaBottomY), X2 += L2.line(c2, this.areaBottomY)), this.handleNullDataPoints(r2, B2, h2, _2, o2), this._handleMarkersAndLabels({ type: s2, pointsPos: B2, i: h2, j: _2, realIndex: o2, isRangeStart: A2 });
    }
    return { yArrj: w2, xArrj: y2, pathFromArea: X2, areaPaths: x2, pathFromLine: z2, linePaths: f2, linePath: I2, areaPath: T2 };
  } }, { key: "_handleMarkersAndLabels", value: function(t3) {
    var e2 = t3.type, i = t3.pointsPos, a2 = t3.isRangeStart, s2 = t3.i, r2 = t3.j, n2 = t3.realIndex, o2 = this.w, l2 = new qi(this.ctx);
    if (this.pointsChart)
      this.scatter.draw(this.elSeries, r2, { realIndex: n2, pointsPos: i, zRatio: this.zRatio, elParent: this.elPointsMain });
    else {
      o2.globals.series[s2].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
      var h2 = this.markers.plotChartMarkers({ pointsPos: i, seriesIndex: n2, j: r2 + 1 });
      null !== h2 && this.elPointsMain.add(h2);
    }
    var c2 = l2.drawDataLabel({ type: e2, isRangeStart: a2, pos: i, i: n2, j: r2 + 1 });
    null !== c2 && this.elDataLabelsWrap.add(c2);
  } }, { key: "_createPaths", value: function(t3) {
    var e2 = t3.type, i = t3.series, a2 = t3.i;
    t3.realIndex;
    var s2, r2 = t3.j, n2 = t3.x, o2 = t3.y, l2 = t3.xArrj, h2 = t3.yArrj, c2 = t3.y2, d2 = t3.y2Arrj, u2 = t3.pX, g2 = t3.pY, p2 = t3.pathState, f2 = t3.segmentStartX, x2 = t3.linePath, b2 = t3.areaPath, m2 = t3.linePaths, v2 = t3.areaPaths, y2 = t3.curve, w2 = t3.isRangeStart, k2 = new Mi(this.ctx), A2 = this.areaBottomY, C2 = "rangeArea" === e2, S2 = "rangeArea" === e2 && w2;
    switch (y2) {
      case "monotoneCubic":
        var L2 = w2 ? h2 : d2;
        switch (p2) {
          case 0:
            if (null === L2[r2 + 1])
              break;
            p2 = 1;
          case 1:
            if (!(C2 ? l2.length === i[a2].length : r2 === i[a2].length - 2))
              break;
          case 2:
            var M2 = w2 ? l2 : l2.slice().reverse(), P2 = w2 ? L2 : L2.slice().reverse(), I2 = (s2 = P2, M2.map(function(t4, e3) {
              return [t4, s2[e3]];
            }).filter(function(t4) {
              return null !== t4[1];
            })), T2 = I2.length > 1 ? _a(I2) : I2, z2 = [];
            C2 && (S2 ? v2 = I2 : z2 = v2.reverse());
            var X2 = 0, R2 = 0;
            if (function(t4, e3) {
              for (var i2 = function(t5) {
                var e4 = [], i3 = 0;
                return t5.forEach(function(t6) {
                  null !== t6 ? i3++ : i3 > 0 && (e4.push(i3), i3 = 0);
                }), i3 > 0 && e4.push(i3), e4;
              }(t4), a3 = [], s3 = 0, r3 = 0; s3 < i2.length; r3 += i2[s3++])
                a3[s3] = Na(e3, r3, r3 + i2[s3]);
              return a3;
            }(P2, T2).forEach(function(t4) {
              X2++;
              var e3 = function(t5) {
                for (var e4 = "", i3 = 0; i3 < t5.length; i3++) {
                  var a4 = t5[i3], s3 = a4.length;
                  s3 > 4 ? (e4 += "C".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]), e4 += ", ".concat(a4[4], ", ").concat(a4[5])) : s3 > 2 && (e4 += "S".concat(a4[0], ", ").concat(a4[1]), e4 += ", ".concat(a4[2], ", ").concat(a4[3]));
                }
                return e4;
              }(t4), i2 = R2, a3 = (R2 += t4.length) - 1;
              S2 ? x2 = k2.move(I2[i2][0], I2[i2][1]) + e3 : C2 ? x2 = k2.move(z2[i2][0], z2[i2][1]) + k2.line(I2[i2][0], I2[i2][1]) + e3 + k2.line(z2[a3][0], z2[a3][1]) : (x2 = k2.move(I2[i2][0], I2[i2][1]) + e3, b2 = x2 + k2.line(I2[a3][0], A2) + k2.line(I2[i2][0], A2) + "z", v2.push(b2)), m2.push(x2);
            }), C2 && X2 > 1 && !S2) {
              var E2 = m2.slice(X2).reverse();
              m2.splice(X2), E2.forEach(function(t4) {
                return m2.push(t4);
              });
            }
            p2 = 0;
        }
        break;
      case "smooth":
        var Y2 = 0.35 * (n2 - u2);
        if (null === i[a2][r2])
          p2 = 0;
        else
          switch (p2) {
            case 0:
              if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i[a2][r2 + 1] || void 0 === i[a2][r2 + 1]) {
                m2.push(x2), v2.push(b2);
                break;
              }
              if (p2 = 1, r2 < i[a2].length - 2) {
                var H2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
                x2 += H2, b2 += H2;
                break;
              }
            case 1:
              if (null === i[a2][r2 + 1])
                x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
              else {
                var O2 = k2.curve(u2 + Y2, g2, n2 - Y2, o2, n2, o2);
                x2 += O2, b2 += O2, r2 >= i[a2].length - 2 && (S2 && (x2 += k2.curve(n2, o2, n2, o2, n2, c2) + k2.move(n2, c2)), b2 += k2.curve(n2, o2, n2, o2, n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
              }
          }
        u2 = n2, g2 = o2;
        break;
      default:
        var F2 = function(t4, e3, i2) {
          var a3 = [];
          switch (t4) {
            case "stepline":
              a3 = k2.line(e3, null, "H") + k2.line(null, i2, "V");
              break;
            case "linestep":
              a3 = k2.line(null, i2, "V") + k2.line(e3, null, "H");
              break;
            case "straight":
              a3 = k2.line(e3, i2);
          }
          return a3;
        };
        if (null === i[a2][r2])
          p2 = 0;
        else
          switch (p2) {
            case 0:
              if (f2 = u2, x2 = S2 ? k2.move(u2, d2[r2]) + k2.line(u2, g2) : k2.move(u2, g2), b2 = k2.move(u2, g2), null === i[a2][r2 + 1] || void 0 === i[a2][r2 + 1]) {
                m2.push(x2), v2.push(b2);
                break;
              }
              if (p2 = 1, r2 < i[a2].length - 2) {
                var D2 = F2(y2, n2, o2);
                x2 += D2, b2 += D2;
                break;
              }
            case 1:
              if (null === i[a2][r2 + 1])
                x2 += S2 ? k2.line(u2, c2) : k2.move(u2, g2), b2 += k2.line(u2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1;
              else {
                var _2 = F2(y2, n2, o2);
                x2 += _2, b2 += _2, r2 >= i[a2].length - 2 && (S2 && (x2 += k2.line(n2, c2)), b2 += k2.line(n2, A2) + k2.line(f2, A2) + "z", m2.push(x2), v2.push(b2), p2 = -1);
              }
          }
        u2 = n2, g2 = o2;
    }
    return { linePaths: m2, areaPaths: v2, pX: u2, pY: g2, pathState: p2, segmentStartX: f2, linePath: x2, areaPath: b2 };
  } }, { key: "handleNullDataPoints", value: function(t3, e2, i, a2, s2) {
    var r2 = this.w;
    if (null === t3[i][a2] && r2.config.markers.showNullDataPoints || 1 === t3[i].length) {
      var n2 = this.strokeWidth - r2.config.markers.strokeWidth / 2;
      n2 > 0 || (n2 = 0);
      var o2 = this.markers.plotChartMarkers({ pointsPos: e2, seriesIndex: s2, j: a2 + 1, pSize: n2, alwaysDrawMarker: true });
      null !== o2 && this.elPointsMain.add(o2);
    }
  } }]), t2;
}();
window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
  function t2(e3, i2, a3, s3) {
    this.xoffset = e3, this.yoffset = i2, this.height = s3, this.width = a3, this.shortestEdge = function() {
      return Math.min(this.height, this.width);
    }, this.getCoordinates = function(t3) {
      var e4, i3 = [], a4 = this.xoffset, s4 = this.yoffset, n3 = r2(t3) / this.height, o2 = r2(t3) / this.width;
      if (this.width >= this.height)
        for (e4 = 0; e4 < t3.length; e4++)
          i3.push([a4, s4, a4 + n3, s4 + t3[e4] / n3]), s4 += t3[e4] / n3;
      else
        for (e4 = 0; e4 < t3.length; e4++)
          i3.push([a4, s4, a4 + t3[e4] / o2, s4 + o2]), a4 += t3[e4] / o2;
      return i3;
    }, this.cutArea = function(e4) {
      var i3;
      if (this.width >= this.height) {
        var a4 = e4 / this.height, s4 = this.width - a4;
        i3 = new t2(this.xoffset + a4, this.yoffset, s4, this.height);
      } else {
        var r3 = e4 / this.width, n3 = this.height - r3;
        i3 = new t2(this.xoffset, this.yoffset + r3, this.width, n3);
      }
      return i3;
    };
  }
  function e2(e3, a3, s3, n3, o2) {
    n3 = void 0 === n3 ? 0 : n3, o2 = void 0 === o2 ? 0 : o2;
    var l2 = i(function(t3, e4) {
      var i2, a4 = [], s4 = e4 / r2(t3);
      for (i2 = 0; i2 < t3.length; i2++)
        a4[i2] = t3[i2] * s4;
      return a4;
    }(e3, a3 * s3), [], new t2(n3, o2, a3, s3), []);
    return function(t3) {
      var e4, i2, a4 = [];
      for (e4 = 0; e4 < t3.length; e4++)
        for (i2 = 0; i2 < t3[e4].length; i2++)
          a4.push(t3[e4][i2]);
      return a4;
    }(l2);
  }
  function i(t3, e3, s3, n3) {
    var o2, l2, h2;
    if (0 !== t3.length)
      return o2 = s3.shortestEdge(), function(t4, e4, i2) {
        var s4;
        if (0 === t4.length)
          return true;
        (s4 = t4.slice()).push(e4);
        var r3 = a2(t4, i2), n4 = a2(s4, i2);
        return r3 >= n4;
      }(e3, l2 = t3[0], o2) ? (e3.push(l2), i(t3.slice(1), e3, s3, n3)) : (h2 = s3.cutArea(r2(e3), n3), n3.push(s3.getCoordinates(e3)), i(t3, [], h2, n3)), n3;
    n3.push(s3.getCoordinates(e3));
  }
  function a2(t3, e3) {
    var i2 = Math.min.apply(Math, t3), a3 = Math.max.apply(Math, t3), s3 = r2(t3);
    return Math.max(Math.pow(e3, 2) * a3 / Math.pow(s3, 2), Math.pow(s3, 2) / (Math.pow(e3, 2) * i2));
  }
  function s2(t3) {
    return t3 && t3.constructor === Array;
  }
  function r2(t3) {
    var e3, i2 = 0;
    for (e3 = 0; e3 < t3.length; e3++)
      i2 += t3[e3];
    return i2;
  }
  function n2(t3) {
    var e3, i2 = 0;
    if (s2(t3[0]))
      for (e3 = 0; e3 < t3.length; e3++)
        i2 += n2(t3[e3]);
    else
      i2 = r2(t3);
    return i2;
  }
  return function t3(i2, a3, r3, o2, l2) {
    o2 = void 0 === o2 ? 0 : o2, l2 = void 0 === l2 ? 0 : l2;
    var h2, c2, d2 = [], u2 = [];
    if (s2(i2[0])) {
      for (c2 = 0; c2 < i2.length; c2++)
        d2[c2] = n2(i2[c2]);
      for (h2 = e2(d2, a3, r3, o2, l2), c2 = 0; c2 < i2.length; c2++)
        u2.push(t3(i2[c2], h2[c2][2] - h2[c2][0], h2[c2][3] - h2[c2][1], h2[c2][0], h2[c2][1]));
    } else
      u2 = e2(i2, a3, r3, o2, l2);
    return u2;
  };
}();
var Ga = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new za(e2), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = [];
  }
  return s(t2, [{ key: "draw", value: function(t3) {
    var e2 = this, i = this.w, a2 = new Mi(this.ctx), s2 = new ji(this.ctx), r2 = a2.group({ class: "apexcharts-treemap" });
    if (i.globals.noData)
      return r2;
    var n2 = [];
    return t3.forEach(function(t4) {
      var e3 = t4.map(function(t5) {
        return Math.abs(t5);
      });
      n2.push(e3);
    }), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach(function(t4, i2) {
      t4.data.forEach(function(t5) {
        Array.isArray(e2.labels[i2]) || (e2.labels[i2] = []), e2.labels[i2].push(t5.x);
      });
    }), window.TreemapSquared.generate(n2, i.globals.gridWidth, i.globals.gridHeight).forEach(function(n3, o2) {
      var l2 = a2.group({ class: "apexcharts-series apexcharts-treemap-series", seriesName: v.escapeString(i.globals.seriesNames[o2]), rel: o2 + 1, "data:realIndex": o2 });
      if (i.config.chart.dropShadow.enabled) {
        var h2 = i.config.chart.dropShadow;
        new Li(e2.ctx).dropShadow(r2, h2, o2);
      }
      var c2 = a2.group({ class: "apexcharts-data-labels" }), d2 = { xMin: 1 / 0, yMin: 1 / 0, xMax: -1 / 0, yMax: -1 / 0 };
      n3.forEach(function(r3, n4) {
        var h3 = r3[0], c3 = r3[1], u3 = r3[2], g3 = r3[3];
        d2.xMin = Math.min(d2.xMin, h3), d2.yMin = Math.min(d2.yMin, c3), d2.xMax = Math.max(d2.xMax, u3), d2.yMax = Math.max(d2.yMax, g3);
        var p3 = e2.helpers.getShadeColor(i.config.chart.type, o2, n4, e2.negRange), f3 = p3.color, x3 = s2.fillPath({ color: f3, seriesNumber: o2, dataPointIndex: n4 }), b3 = a2.drawRect(h3, c3, u3 - h3, g3 - c3, i.config.plotOptions.treemap.borderRadius, "#fff", 1, e2.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? f3 : i.globals.stroke.colors[o2]);
        b3.attr({ cx: h3, cy: c3, index: o2, i: o2, j: n4, width: u3 - h3, height: g3 - c3, fill: x3 }), b3.node.classList.add("apexcharts-treemap-rect"), e2.helpers.addListeners(b3);
        var m3 = { x: h3 + (u3 - h3) / 2, y: c3 + (g3 - c3) / 2, width: 0, height: 0 }, v2 = { x: h3, y: c3, width: u3 - h3, height: g3 - c3 };
        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
          var y3 = 1;
          i.globals.resized || (y3 = i.config.chart.animations.speed), e2.animateTreemap(b3, m3, v2, y3);
        }
        if (i.globals.dataChanged) {
          var w3 = 1;
          e2.dynamicAnim.enabled && i.globals.shouldAnimate && (w3 = e2.dynamicAnim.speed, i.globals.previousPaths[o2] && i.globals.previousPaths[o2][n4] && i.globals.previousPaths[o2][n4].rect && (m3 = i.globals.previousPaths[o2][n4].rect), e2.animateTreemap(b3, m3, v2, w3));
        }
        var k3 = e2.getFontSize(r3), A3 = i.config.dataLabels.formatter(e2.labels[o2][n4], { value: i.globals.series[o2][n4], seriesIndex: o2, dataPointIndex: n4, w: i });
        "truncate" === i.config.plotOptions.treemap.dataLabels.format && (k3 = parseInt(i.config.dataLabels.style.fontSize, 10), A3 = e2.truncateLabels(A3, k3, h3, c3, u3, g3));
        var C3 = null;
        i.globals.series[o2][n4] && (C3 = e2.helpers.calculateDataLabels({ text: A3, x: (h3 + u3) / 2, y: (c3 + g3) / 2 + e2.strokeWidth / 2 + k3 / 3, i: o2, j: n4, colorProps: p3, fontSize: k3, series: t3 })), i.config.dataLabels.enabled && C3 && e2.rotateToFitLabel(C3, k3, A3, h3, c3, u3, g3), l2.add(b3), null !== C3 && l2.add(C3);
      });
      var u2 = i.config.plotOptions.treemap.seriesTitle;
      if (i.config.series.length > 1 && u2 && u2.show) {
        var g2 = i.config.series[o2].name || "";
        if (g2 && d2.xMin < 1 / 0 && d2.yMin < 1 / 0) {
          var p2 = u2.offsetX, f2 = u2.offsetY, x2 = u2.borderColor, b2 = u2.borderWidth, m2 = u2.borderRadius, y2 = u2.style, w2 = y2.color || i.config.chart.foreColor, k2 = { left: y2.padding.left, right: y2.padding.right, top: y2.padding.top, bottom: y2.padding.bottom }, A2 = a2.getTextRects(g2, y2.fontSize, y2.fontFamily), C2 = A2.width + k2.left + k2.right, S2 = A2.height + k2.top + k2.bottom, L2 = d2.xMin + (p2 || 0), M2 = d2.yMin + (f2 || 0), P2 = a2.drawRect(L2, M2, C2, S2, m2, y2.background, 1, b2, x2), I2 = a2.drawText({ x: L2 + k2.left, y: M2 + k2.top + 0.75 * A2.height, text: g2, fontSize: y2.fontSize, fontFamily: y2.fontFamily, fontWeight: y2.fontWeight, foreColor: w2, cssClass: y2.cssClass || "" });
          l2.add(P2), l2.add(I2);
        }
      }
      l2.add(c2), r2.add(l2);
    }), r2;
  } }, { key: "getFontSize", value: function(t3) {
    var e2 = this.w;
    var i = function t4(e3) {
      var i2, a2 = 0;
      if (Array.isArray(e3[0]))
        for (i2 = 0; i2 < e3.length; i2++)
          a2 += t4(e3[i2]);
      else
        for (i2 = 0; i2 < e3.length; i2++)
          a2 += e3[i2].length;
      return a2;
    }(this.labels) / function t4(e3) {
      var i2, a2 = 0;
      if (Array.isArray(e3[0]))
        for (i2 = 0; i2 < e3.length; i2++)
          a2 += t4(e3[i2]);
      else
        for (i2 = 0; i2 < e3.length; i2++)
          a2 += 1;
      return a2;
    }(this.labels);
    return function(t4, a2) {
      var s2 = t4 * a2, r2 = Math.pow(s2, 0.5);
      return Math.min(r2 / i, parseInt(e2.config.dataLabels.style.fontSize, 10));
    }(t3[2] - t3[0], t3[3] - t3[1]);
  } }, { key: "rotateToFitLabel", value: function(t3, e2, i, a2, s2, r2, n2) {
    var o2 = new Mi(this.ctx), l2 = o2.getTextRects(i, e2);
    if (l2.width + this.w.config.stroke.width + 5 > r2 - a2 && l2.width <= n2 - s2) {
      var h2 = o2.rotateAroundCenter(t3.node);
      t3.node.setAttribute("transform", "rotate(-90 ".concat(h2.x, " ").concat(h2.y, ") translate(").concat(l2.height / 3, ")"));
    }
  } }, { key: "truncateLabels", value: function(t3, e2, i, a2, s2, r2) {
    var n2 = new Mi(this.ctx), o2 = n2.getTextRects(t3, e2).width + this.w.config.stroke.width + 5 > s2 - i && r2 - a2 > s2 - i ? r2 - a2 : s2 - i, l2 = n2.getTextBasedOnMaxWidth({ text: t3, maxWidth: o2, fontSize: e2 });
    return t3.length !== l2.length && o2 / e2 < 5 ? "" : l2;
  } }, { key: "animateTreemap", value: function(t3, e2, i, a2) {
    var s2 = new y(this.ctx);
    s2.animateRect(t3, e2, i, a2, function() {
      s2.animationCompleted(t3);
    });
  } }]), t2;
}(), ja = 86400, Va = 10 / ja, Ua = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC;
  }
  return s(t2, [{ key: "calculateTimeScaleTicks", value: function(t3, e2) {
    var i = this, a2 = this.w;
    if (a2.globals.allSeriesCollapsed)
      return a2.globals.labels = [], a2.globals.timescaleLabels = [], [];
    var s2 = new zi(this.ctx), r2 = (e2 - t3) / 864e5;
    this.determineInterval(r2), a2.globals.disableZoomIn = false, a2.globals.disableZoomOut = false, r2 < Va ? a2.globals.disableZoomIn = true : r2 > 5e4 && (a2.globals.disableZoomOut = true);
    var n2 = s2.getTimeUnitsfromTimestamp(t3, e2, this.utc), o2 = a2.globals.gridWidth / r2, l2 = o2 / 24, h2 = l2 / 60, c2 = h2 / 60, d2 = Math.floor(24 * r2), g2 = Math.floor(1440 * r2), p2 = Math.floor(r2 * ja), f2 = Math.floor(r2), x2 = Math.floor(r2 / 30), b2 = Math.floor(r2 / 365), m2 = { minMillisecond: n2.minMillisecond, minSecond: n2.minSecond, minMinute: n2.minMinute, minHour: n2.minHour, minDate: n2.minDate, minMonth: n2.minMonth, minYear: n2.minYear }, v2 = { firstVal: m2, currentMillisecond: m2.minMillisecond, currentSecond: m2.minSecond, currentMinute: m2.minMinute, currentHour: m2.minHour, currentMonthDate: m2.minDate, currentDate: m2.minDate, currentMonth: m2.minMonth, currentYear: m2.minYear, daysWidthOnXAxis: o2, hoursWidthOnXAxis: l2, minutesWidthOnXAxis: h2, secondsWidthOnXAxis: c2, numberOfSeconds: p2, numberOfMinutes: g2, numberOfHours: d2, numberOfDays: f2, numberOfMonths: x2, numberOfYears: b2 };
    switch (this.tickInterval) {
      case "years":
        this.generateYearScale(v2);
        break;
      case "months":
      case "half_year":
        this.generateMonthScale(v2);
        break;
      case "months_days":
      case "months_fortnight":
      case "days":
      case "week_days":
        this.generateDayScale(v2);
        break;
      case "hours":
        this.generateHourScale(v2);
        break;
      case "minutes_fives":
      case "minutes":
        this.generateMinuteScale(v2);
        break;
      case "seconds_tens":
      case "seconds_fives":
      case "seconds":
        this.generateSecondScale(v2);
    }
    var y2 = this.timeScaleArray.map(function(t4) {
      var e3 = { position: t4.position, unit: t4.unit, year: t4.year, day: t4.day ? t4.day : 1, hour: t4.hour ? t4.hour : 0, month: t4.month + 1 };
      return "month" === t4.unit ? u(u({}, e3), {}, { day: 1, value: t4.value + 1 }) : "day" === t4.unit || "hour" === t4.unit ? u(u({}, e3), {}, { value: t4.value }) : "minute" === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.value }) : "second" === t4.unit ? u(u({}, e3), {}, { value: t4.value, minute: t4.minute, second: t4.second }) : t4;
    });
    return y2.filter(function(t4) {
      var e3 = 1, s3 = Math.ceil(a2.globals.gridWidth / 120), r3 = t4.value;
      void 0 !== a2.config.xaxis.tickAmount && (s3 = a2.config.xaxis.tickAmount), y2.length > s3 && (e3 = Math.floor(y2.length / s3));
      var n3 = false, o3 = false;
      switch (i.tickInterval) {
        case "years":
          "year" === t4.unit && (n3 = true);
          break;
        case "half_year":
          e3 = 7, "year" === t4.unit && (n3 = true);
          break;
        case "months":
          e3 = 1, "year" === t4.unit && (n3 = true);
          break;
        case "months_fortnight":
          e3 = 15, "year" !== t4.unit && "month" !== t4.unit || (n3 = true), 30 === r3 && (o3 = true);
          break;
        case "months_days":
          e3 = 10, "month" === t4.unit && (n3 = true), 30 === r3 && (o3 = true);
          break;
        case "week_days":
          e3 = 8, "month" === t4.unit && (n3 = true);
          break;
        case "days":
          e3 = 1, "month" === t4.unit && (n3 = true);
          break;
        case "hours":
          "day" === t4.unit && (n3 = true);
          break;
        case "minutes_fives":
        case "seconds_fives":
          r3 % 5 != 0 && (o3 = true);
          break;
        case "seconds_tens":
          r3 % 10 != 0 && (o3 = true);
      }
      if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
        if (!o3)
          return true;
      } else if ((r3 % e3 == 0 || n3) && !o3)
        return true;
    });
  } }, { key: "recalcDimensionsBasedOnFormat", value: function(t3, e2) {
    var i = this.w, a2 = this.formatDates(t3), s2 = this.removeOverlappingTS(a2);
    i.globals.timescaleLabels = s2.slice(), new pa(this.ctx).plotCoords();
  } }, { key: "determineInterval", value: function(t3) {
    var e2 = 24 * t3, i = 60 * e2;
    switch (true) {
      case t3 / 365 > 5:
        this.tickInterval = "years";
        break;
      case t3 > 800:
        this.tickInterval = "half_year";
        break;
      case t3 > 180:
        this.tickInterval = "months";
        break;
      case t3 > 90:
        this.tickInterval = "months_fortnight";
        break;
      case t3 > 60:
        this.tickInterval = "months_days";
        break;
      case t3 > 30:
        this.tickInterval = "week_days";
        break;
      case t3 > 2:
        this.tickInterval = "days";
        break;
      case e2 > 2.4:
        this.tickInterval = "hours";
        break;
      case i > 15:
        this.tickInterval = "minutes_fives";
        break;
      case i > 5:
        this.tickInterval = "minutes";
        break;
      case i > 1:
        this.tickInterval = "seconds_tens";
        break;
      case 60 * i > 20:
        this.tickInterval = "seconds_fives";
        break;
      default:
        this.tickInterval = "seconds";
    }
  } }, { key: "generateYearScale", value: function(t3) {
    var e2 = t3.firstVal, i = t3.currentMonth, a2 = t3.currentYear, s2 = t3.daysWidthOnXAxis, r2 = t3.numberOfYears, n2 = e2.minYear, o2 = 0, l2 = new zi(this.ctx), h2 = "year";
    if (e2.minDate > 1 || e2.minMonth > 0) {
      var c2 = l2.determineRemainingDaysOfYear(e2.minYear, e2.minMonth, e2.minDate);
      o2 = (l2.determineDaysOfYear(e2.minYear) - c2 + 1) * s2, n2 = e2.minYear + 1, this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: n2, month: v.monthMod(i + 1) });
    } else
      1 === e2.minDate && 0 === e2.minMonth && this.timeScaleArray.push({ position: o2, value: n2, unit: h2, year: a2, month: v.monthMod(i + 1) });
    for (var d2 = n2, u2 = o2, g2 = 0; g2 < r2; g2++)
      d2++, u2 = l2.determineDaysOfYear(d2 - 1) * s2 + u2, this.timeScaleArray.push({ position: u2, value: d2, unit: h2, year: d2, month: 1 });
  } }, { key: "generateMonthScale", value: function(t3) {
    var e2 = t3.firstVal, i = t3.currentMonthDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.daysWidthOnXAxis, n2 = t3.numberOfMonths, o2 = a2, l2 = 0, h2 = new zi(this.ctx), c2 = "month", d2 = 0;
    if (e2.minDate > 1) {
      l2 = (h2.determineDaysOfMonths(a2 + 1, e2.minYear) - i + 1) * r2, o2 = v.monthMod(a2 + 1);
      var u2 = s2 + d2, g2 = v.monthMod(o2), p2 = o2;
      0 === o2 && (c2 = "year", p2 = u2, g2 = 1, u2 += d2 += 1), this.timeScaleArray.push({ position: l2, value: p2, unit: c2, year: u2, month: g2 });
    } else
      this.timeScaleArray.push({ position: l2, value: o2, unit: c2, year: s2, month: v.monthMod(a2) });
    for (var f2 = o2 + 1, x2 = l2, b2 = 0, m2 = 1; b2 < n2; b2++, m2++) {
      0 === (f2 = v.monthMod(f2)) ? (c2 = "year", d2 += 1) : c2 = "month";
      var y2 = this._getYear(s2, f2, d2);
      x2 = h2.determineDaysOfMonths(f2, y2) * r2 + x2;
      var w2 = 0 === f2 ? y2 : f2;
      this.timeScaleArray.push({ position: x2, value: w2, unit: c2, year: y2, month: 0 === f2 ? 1 : f2 }), f2++;
    }
  } }, { key: "generateDayScale", value: function(t3) {
    var e2 = t3.firstVal, i = t3.currentMonth, a2 = t3.currentYear, s2 = t3.hoursWidthOnXAxis, r2 = t3.numberOfDays, n2 = new zi(this.ctx), o2 = "day", l2 = e2.minDate + 1, h2 = l2, c2 = function(t4, e3, i2) {
      return t4 > n2.determineDaysOfMonths(e3 + 1, i2) ? (h2 = 1, o2 = "month", u2 = e3 += 1, e3) : e3;
    }, d2 = (24 - e2.minHour) * s2, u2 = l2, g2 = c2(h2, i, a2);
    0 === e2.minHour && 1 === e2.minDate ? (d2 = 0, u2 = v.monthMod(e2.minMonth), o2 = "month", h2 = e2.minDate) : 1 !== e2.minDate && 0 === e2.minHour && 0 === e2.minMinute && (d2 = 0, l2 = e2.minDate, u2 = l2, g2 = c2(h2 = l2, i, a2), 1 !== u2 && (o2 = "day")), this.timeScaleArray.push({ position: d2, value: u2, unit: o2, year: this._getYear(a2, g2, 0), month: v.monthMod(g2), day: h2 });
    for (var p2 = d2, f2 = 0; f2 < r2; f2++) {
      o2 = "day", g2 = c2(h2 += 1, g2, this._getYear(a2, g2, 0));
      var x2 = this._getYear(a2, g2, 0);
      p2 = 24 * s2 + p2;
      var b2 = 1 === h2 ? v.monthMod(g2) : h2;
      this.timeScaleArray.push({ position: p2, value: b2, unit: o2, year: x2, month: v.monthMod(g2), day: b2 });
    }
  } }, { key: "generateHourScale", value: function(t3) {
    var e2 = t3.firstVal, i = t3.currentDate, a2 = t3.currentMonth, s2 = t3.currentYear, r2 = t3.minutesWidthOnXAxis, n2 = t3.numberOfHours, o2 = new zi(this.ctx), l2 = "hour", h2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) && (f2 = 1, e3 += 1), { month: e3, date: f2 };
    }, c2 = function(t4, e3) {
      return t4 > o2.determineDaysOfMonths(e3 + 1, s2) ? e3 += 1 : e3;
    }, d2 = 60 - (e2.minMinute + e2.minSecond / 60), u2 = d2 * r2, g2 = e2.minHour + 1, p2 = g2;
    60 === d2 && (u2 = 0, p2 = g2 = e2.minHour);
    var f2 = i;
    p2 >= 24 && (p2 = 0, l2 = "day", g2 = f2 += 1);
    var x2 = h2(f2, a2).month;
    x2 = c2(f2, x2), g2 > 31 && (g2 = f2 = 1), this.timeScaleArray.push({ position: u2, value: g2, unit: l2, day: f2, hour: p2, year: s2, month: v.monthMod(x2) }), p2++;
    for (var b2 = u2, m2 = 0; m2 < n2; m2++) {
      if (l2 = "hour", p2 >= 24)
        p2 = 0, l2 = "day", x2 = h2(f2 += 1, x2).month, x2 = c2(f2, x2);
      var y2 = this._getYear(s2, x2, 0);
      b2 = 60 * r2 + b2;
      var w2 = 0 === p2 ? f2 : p2;
      this.timeScaleArray.push({ position: b2, value: w2, unit: l2, hour: p2, day: f2, year: y2, month: v.monthMod(x2) }), p2++;
    }
  } }, { key: "generateMinuteScale", value: function(t3) {
    for (var e2 = t3.currentMillisecond, i = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.minutesWidthOnXAxis, h2 = t3.secondsWidthOnXAxis, c2 = t3.numberOfMinutes, d2 = a2 + 1, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (60 - i - e2 / 1e3) * h2, b2 = 0; b2 < c2; b2++)
      d2 >= 60 && (d2 = 0, 24 === (f2 += 1) && (f2 = 0)), this.timeScaleArray.push({ position: x2, value: d2, unit: "minute", hour: f2, minute: d2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, d2++;
  } }, { key: "generateSecondScale", value: function(t3) {
    for (var e2 = t3.currentMillisecond, i = t3.currentSecond, a2 = t3.currentMinute, s2 = t3.currentHour, r2 = t3.currentDate, n2 = t3.currentMonth, o2 = t3.currentYear, l2 = t3.secondsWidthOnXAxis, h2 = t3.numberOfSeconds, c2 = i + 1, d2 = a2, u2 = r2, g2 = n2, p2 = o2, f2 = s2, x2 = (1e3 - e2) / 1e3 * l2, b2 = 0; b2 < h2; b2++)
      c2 >= 60 && (c2 = 0, ++d2 >= 60 && (d2 = 0, 24 === ++f2 && (f2 = 0))), this.timeScaleArray.push({ position: x2, value: c2, unit: "second", hour: f2, minute: d2, second: c2, day: u2, year: this._getYear(p2, g2, 0), month: v.monthMod(g2) }), x2 += l2, c2++;
  } }, { key: "createRawDateString", value: function(t3, e2) {
    var i = t3.year;
    return 0 === t3.month && (t3.month = 1), i += "-" + ("0" + t3.month.toString()).slice(-2), "day" === t3.unit ? i += "day" === t3.unit ? "-" + ("0" + e2).slice(-2) : "-01" : i += "-" + ("0" + (t3.day ? t3.day : "1")).slice(-2), "hour" === t3.unit ? i += "hour" === t3.unit ? "T" + ("0" + e2).slice(-2) : "T00" : i += "T" + ("0" + (t3.hour ? t3.hour : "0")).slice(-2), "minute" === t3.unit ? i += ":" + ("0" + e2).slice(-2) : i += ":" + (t3.minute ? ("0" + t3.minute).slice(-2) : "00"), "second" === t3.unit ? i += ":" + ("0" + e2).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i;
  } }, { key: "formatDates", value: function(t3) {
    var e2 = this, i = this.w;
    return t3.map(function(t4) {
      var a2 = t4.value.toString(), s2 = new zi(e2.ctx), r2 = e2.createRawDateString(t4, a2), n2 = s2.getDate(s2.parseDate(r2));
      if (e2.utc || (n2 = s2.getDate(s2.parseDateWithTimezone(r2))), void 0 === i.config.xaxis.labels.format) {
        var o2 = "dd MMM", l2 = i.config.xaxis.labels.datetimeFormatter;
        "year" === t4.unit && (o2 = l2.year), "month" === t4.unit && (o2 = l2.month), "day" === t4.unit && (o2 = l2.day), "hour" === t4.unit && (o2 = l2.hour), "minute" === t4.unit && (o2 = l2.minute), "second" === t4.unit && (o2 = l2.second), a2 = s2.formatDate(n2, o2);
      } else
        a2 = s2.formatDate(n2, i.config.xaxis.labels.format);
      return { dateString: r2, position: t4.position, value: a2, unit: t4.unit, year: t4.year, month: t4.month };
    });
  } }, { key: "removeOverlappingTS", value: function(t3) {
    var e2, i = this, a2 = new Mi(this.ctx), s2 = false;
    t3.length > 0 && t3[0].value && t3.every(function(e3) {
      return e3.value.length === t3[0].value.length;
    }) && (s2 = true, e2 = a2.getTextRects(t3[0].value).width);
    var r2 = 0, n2 = t3.map(function(n3, o2) {
      if (o2 > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
        var l2 = s2 ? e2 : a2.getTextRects(t3[r2].value).width, h2 = t3[r2].position;
        return n3.position > h2 + l2 + 10 ? (r2 = o2, n3) : null;
      }
      return n3;
    });
    return n2 = n2.filter(function(t4) {
      return null !== t4;
    });
  } }, { key: "_getYear", value: function(t3, e2, i) {
    return t3 + Math.floor(e2 / 12) + i;
  } }]), t2;
}(), qa = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.ctx = a2, this.w = a2.w, this.el = e2;
  }
  return s(t2, [{ key: "setupElements", value: function() {
    var t3 = this.w, e2 = t3.globals, i = t3.config, a2 = i.chart.type;
    e2.axisCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].includes(a2), e2.xyCharts = ["line", "area", "bar", "rangeBar", "rangeArea", "candlestick", "boxPlot", "scatter", "bubble"].includes(a2), e2.isBarHorizontal = ["bar", "rangeBar", "boxPlot"].includes(a2) && i.plotOptions.bar.horizontal, e2.chartClass = ".apexcharts".concat(e2.chartID), e2.dom.baseEl = this.el, e2.dom.elWrap = document.createElement("div"), Mi.setAttrs(e2.dom.elWrap, { id: e2.chartClass.substring(1), class: "apexcharts-canvas ".concat(e2.chartClass.substring(1)) }), this.el.appendChild(e2.dom.elWrap), e2.dom.Paper = window.SVG().addTo(e2.dom.elWrap), e2.dom.Paper.attr({ class: "apexcharts-svg", "xmlns:data": "ApexChartsNS", transform: "translate(".concat(i.chart.offsetX, ", ").concat(i.chart.offsetY, ")") }), e2.dom.Paper.node.style.background = "dark" !== i.theme.mode || i.chart.background ? "light" !== i.theme.mode || i.chart.background ? i.chart.background : "#fff" : "#424242", this.setSVGDimensions(), e2.dom.elLegendForeign = document.createElementNS(e2.SVGNS, "foreignObject"), Mi.setAttrs(e2.dom.elLegendForeign, { x: 0, y: 0, width: e2.svgWidth, height: e2.svgHeight }), e2.dom.elLegendWrap = document.createElement("div"), e2.dom.elLegendWrap.classList.add("apexcharts-legend"), e2.dom.elWrap.appendChild(e2.dom.elLegendWrap), e2.dom.Paper.node.appendChild(e2.dom.elLegendForeign), e2.dom.elGraphical = e2.dom.Paper.group().attr({ class: "apexcharts-inner apexcharts-graphical" }), e2.dom.elDefs = e2.dom.Paper.defs(), e2.dom.Paper.add(e2.dom.elGraphical), e2.dom.elGraphical.add(e2.dom.elDefs);
  } }, { key: "plotChartType", value: function(t3, e2) {
    var i = this.w, a2 = this.ctx, s2 = i.config, r2 = i.globals, n2 = { line: { series: [], i: [] }, area: { series: [], i: [] }, scatter: { series: [], i: [] }, bubble: { series: [], i: [] }, bar: { series: [], i: [] }, candlestick: { series: [], i: [] }, boxPlot: { series: [], i: [] }, rangeBar: { series: [], i: [] }, rangeArea: { series: [], seriesRangeEnd: [], i: [] } }, o2 = s2.chart.type || "line", l2 = null, h2 = 0;
    r2.series.forEach(function(e3, a3) {
      var s3 = "column" === t3[a3].type ? "bar" : t3[a3].type || ("column" === o2 ? "bar" : o2);
      n2[s3] ? ("rangeArea" === s3 ? (n2[s3].series.push(r2.seriesRangeStart[a3]), n2[s3].seriesRangeEnd.push(r2.seriesRangeEnd[a3])) : n2[s3].series.push(e3), n2[s3].i.push(a3), "bar" === s3 && (i.globals.columnSeries = n2.bar)) : ["heatmap", "treemap", "pie", "donut", "polarArea", "radialBar", "radar"].includes(s3) ? l2 = s3 : console.warn("You have specified an unrecognized series type (".concat(s3, ").")), o2 !== s3 && "scatter" !== s3 && h2++;
    }), h2 > 0 && (l2 && console.warn("Chart or series type ".concat(l2, " cannot appear with other chart or series types.")), n2.bar.series.length > 0 && s2.plotOptions.bar.horizontal && (h2 -= n2.bar.series.length, n2.bar = { series: [], i: [] }, i.globals.columnSeries = { series: [], i: [] }, console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"))), r2.comboCharts || (r2.comboCharts = h2 > 0);
    var c2 = new Ba(a2, e2), d2 = new Ta(a2, e2);
    a2.pie = new Ea(a2);
    var u2 = new Ha(a2);
    a2.rangeBar = new Oa(a2, e2);
    var g2 = new Ya(a2), p2 = [];
    if (r2.comboCharts) {
      var x2, b2, m2 = new Pi(a2);
      if (n2.area.series.length > 0)
        (x2 = p2).push.apply(x2, f(m2.drawSeriesByGroup(n2.area, r2.areaGroups, "area", c2)));
      if (n2.bar.series.length > 0)
        if (s2.chart.stacked) {
          var v2 = new Ia(a2, e2);
          p2.push(v2.draw(n2.bar.series, n2.bar.i));
        } else
          a2.bar = new Pa(a2, e2), p2.push(a2.bar.draw(n2.bar.series, n2.bar.i));
      if (n2.rangeArea.series.length > 0 && p2.push(c2.draw(n2.rangeArea.series, "rangeArea", n2.rangeArea.i, n2.rangeArea.seriesRangeEnd)), n2.line.series.length > 0)
        (b2 = p2).push.apply(b2, f(m2.drawSeriesByGroup(n2.line, r2.lineGroups, "line", c2)));
      if (n2.candlestick.series.length > 0 && p2.push(d2.draw(n2.candlestick.series, "candlestick", n2.candlestick.i)), n2.boxPlot.series.length > 0 && p2.push(d2.draw(n2.boxPlot.series, "boxPlot", n2.boxPlot.i)), n2.rangeBar.series.length > 0 && p2.push(a2.rangeBar.draw(n2.rangeBar.series, n2.rangeBar.i)), n2.scatter.series.length > 0) {
        var y2 = new Ba(a2, e2, true);
        p2.push(y2.draw(n2.scatter.series, "scatter", n2.scatter.i));
      }
      if (n2.bubble.series.length > 0) {
        var w2 = new Ba(a2, e2, true);
        p2.push(w2.draw(n2.bubble.series, "bubble", n2.bubble.i));
      }
    } else
      switch (s2.chart.type) {
        case "line":
          p2 = c2.draw(r2.series, "line");
          break;
        case "area":
          p2 = c2.draw(r2.series, "area");
          break;
        case "bar":
          if (s2.chart.stacked)
            p2 = new Ia(a2, e2).draw(r2.series);
          else
            a2.bar = new Pa(a2, e2), p2 = a2.bar.draw(r2.series);
          break;
        case "candlestick":
          p2 = new Ta(a2, e2).draw(r2.series, "candlestick");
          break;
        case "boxPlot":
          p2 = new Ta(a2, e2).draw(r2.series, s2.chart.type);
          break;
        case "rangeBar":
          p2 = a2.rangeBar.draw(r2.series);
          break;
        case "rangeArea":
          p2 = c2.draw(r2.seriesRangeStart, "rangeArea", void 0, r2.seriesRangeEnd);
          break;
        case "heatmap":
          p2 = new Xa(a2, e2).draw(r2.series);
          break;
        case "treemap":
          p2 = new Ga(a2, e2).draw(r2.series);
          break;
        case "pie":
        case "donut":
        case "polarArea":
          p2 = a2.pie.draw(r2.series);
          break;
        case "radialBar":
          p2 = u2.draw(r2.series);
          break;
        case "radar":
          p2 = g2.draw(r2.series);
          break;
        default:
          p2 = c2.draw(r2.series);
      }
    return p2;
  } }, { key: "setSVGDimensions", value: function() {
    var t3 = this.w, e2 = t3.globals, i = t3.config;
    i.chart.width = i.chart.width || "100%", i.chart.height = i.chart.height || "auto", e2.svgWidth = i.chart.width, e2.svgHeight = i.chart.height;
    var a2 = v.getDimensions(this.el), s2 = i.chart.width.toString().split(/[0-9]+/g).pop();
    "%" === s2 ? v.isNumber(a2[0]) && (0 === a2[0].width && (a2 = v.getDimensions(this.el.parentNode)), e2.svgWidth = a2[0] * parseInt(i.chart.width, 10) / 100) : "px" !== s2 && "" !== s2 || (e2.svgWidth = parseInt(i.chart.width, 10));
    var r2 = String(i.chart.height).toString().split(/[0-9]+/g).pop();
    if ("auto" !== e2.svgHeight && "" !== e2.svgHeight)
      if ("%" === r2) {
        var n2 = v.getDimensions(this.el.parentNode);
        e2.svgHeight = n2[1] * parseInt(i.chart.height, 10) / 100;
      } else
        e2.svgHeight = parseInt(i.chart.height, 10);
    else
      e2.svgHeight = e2.axisCharts ? e2.svgWidth / 1.61 : e2.svgWidth / 1.2;
    if (e2.svgWidth = Math.max(e2.svgWidth, 0), e2.svgHeight = Math.max(e2.svgHeight, 0), Mi.setAttrs(e2.dom.Paper.node, { width: e2.svgWidth, height: e2.svgHeight }), "%" !== r2) {
      var o2 = i.chart.sparkline.enabled ? 0 : e2.axisCharts ? i.chart.parentHeightOffset : 0;
      e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(e2.svgHeight + o2, "px");
    }
    e2.dom.elWrap.style.width = "".concat(e2.svgWidth, "px"), e2.dom.elWrap.style.height = "".concat(e2.svgHeight, "px");
  } }, { key: "shiftGraphPosition", value: function() {
    var t3 = this.w.globals, e2 = t3.translateY, i = t3.translateX;
    Mi.setAttrs(t3.dom.elGraphical.node, { transform: "translate(".concat(i, ", ").concat(e2, ")") });
  } }, { key: "resizeNonAxisCharts", value: function() {
    var t3 = this.w, e2 = t3.globals, i = 0, a2 = t3.config.chart.sparkline.enabled ? 1 : 15;
    a2 += t3.config.grid.padding.bottom, ["top", "bottom"].includes(t3.config.legend.position) && t3.config.legend.show && !t3.config.legend.floating && (i = new xa(this.ctx).legendHelpers.getLegendDimensions().clwh + 7);
    var s2 = t3.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"), r2 = 2.05 * t3.globals.radialSize;
    if (s2 && !t3.config.chart.sparkline.enabled && 0 !== t3.config.plotOptions.radialBar.startAngle) {
      var n2 = v.getBoundingClientRect(s2);
      r2 = n2.bottom;
      var o2 = n2.bottom - n2.top;
      r2 = Math.max(2.05 * t3.globals.radialSize, o2);
    }
    var l2 = Math.ceil(r2 + e2.translateY + i + a2);
    e2.dom.elLegendForeign && e2.dom.elLegendForeign.setAttribute("height", l2), t3.config.chart.height && String(t3.config.chart.height).includes("%") || (e2.dom.elWrap.style.height = "".concat(l2, "px"), Mi.setAttrs(e2.dom.Paper.node, { height: l2 }), e2.dom.Paper.node.parentNode.parentNode.style.minHeight = "".concat(l2, "px"));
  } }, { key: "coreCalculations", value: function() {
    new ea(this.ctx).init();
  } }, { key: "resetGlobals", value: function() {
    var t3 = this, e2 = function() {
      return t3.w.config.series.map(function() {
        return [];
      });
    }, i = new Bi(), a2 = this.w.globals;
    i.initGlobalVars(a2), a2.seriesXvalues = e2(), a2.seriesYvalues = e2();
  } }, { key: "isMultipleY", value: function() {
    return !!(Array.isArray(this.w.config.yaxis) && this.w.config.yaxis.length > 1) && (this.w.globals.isMultipleYAxis = true, true);
  } }, { key: "xySettings", value: function() {
    var t3 = this.w, e2 = null;
    if (t3.globals.axisCharts) {
      if ("back" === t3.config.xaxis.crosshairs.position && new na(this.ctx).drawXCrosshairs(), "back" === t3.config.yaxis[0].crosshairs.position && new na(this.ctx).drawYCrosshairs(), "datetime" === t3.config.xaxis.type && void 0 === t3.config.xaxis.labels.formatter) {
        this.ctx.timeScale = new Ua(this.ctx);
        var i = [];
        isFinite(t3.globals.minX) && isFinite(t3.globals.maxX) && !t3.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minX, t3.globals.maxX) : t3.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(t3.globals.minY, t3.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i);
      }
      e2 = new Pi(this.ctx).getCalculatedRatios();
    }
    return e2;
  } }, { key: "updateSourceChart", value: function(t3) {
    this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({ chart: { selection: { xaxis: { min: t3.w.globals.minX, max: t3.w.globals.maxX } } } }, false, false);
  } }, { key: "setupBrushHandler", value: function() {
    var t3 = this, e2 = this.ctx, i = this.w;
    if (i.config.chart.brush.enabled && "function" != typeof i.config.chart.events.selection) {
      var a2 = Array.isArray(i.config.chart.brush.targets) ? i.config.chart.brush.targets : [i.config.chart.brush.target];
      a2.forEach(function(i2) {
        var a3 = e2.constructor.getChartByID(i2);
        a3.w.globals.brushSource = t3.ctx, "function" != typeof a3.w.config.chart.events.zoomed && (a3.w.config.chart.events.zoomed = function() {
          return t3.updateSourceChart(a3);
        }), "function" != typeof a3.w.config.chart.events.scrolled && (a3.w.config.chart.events.scrolled = function() {
          return t3.updateSourceChart(a3);
        });
      }), i.config.chart.events.selection = function(t4, i2) {
        a2.forEach(function(t5) {
          e2.constructor.getChartByID(t5).ctx.updateHelpers._updateOptions({ xaxis: { min: i2.xaxis.min, max: i2.xaxis.max } }, false, false, false, false);
        });
      };
    }
  } }]), t2;
}(), Za = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "_updateOptions", value: function(t3) {
    var e2 = this, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
    return new Promise(function(n2) {
      var o2 = [e2.ctx];
      s2 && (o2 = e2.ctx.getSyncedCharts()), e2.ctx.w.globals.isExecCalled && (o2 = [e2.ctx], e2.ctx.w.globals.isExecCalled = false), o2.forEach(function(s3, l2) {
        var h2 = s3.w;
        if (h2.globals.shouldAnimate = a2, i || (h2.globals.resized = true, h2.globals.dataChanged = true, a2 && s3.series.getPreviousPaths()), t3 && "object" === b(t3) && (s3.config = new Wi(t3), t3 = Pi.extendArrayProps(s3.config, t3, h2), s3.w.globals.chartID !== e2.ctx.w.globals.chartID && delete t3.series, h2.config = v.extend(h2.config, t3), r2 && (h2.globals.lastXAxis = t3.xaxis ? v.clone(t3.xaxis) : [], h2.globals.lastYAxis = t3.yaxis ? v.clone(t3.yaxis) : [], h2.globals.initialConfig = v.extend({}, h2.config), h2.globals.initialSeries = v.clone(h2.config.series), t3.series))) {
          for (var c2 = 0; c2 < h2.globals.collapsedSeriesIndices.length; c2++) {
            var d2 = h2.config.series[h2.globals.collapsedSeriesIndices[c2]];
            h2.globals.collapsedSeries[c2].data = h2.globals.axisCharts ? d2.data.slice() : d2;
          }
          for (var u2 = 0; u2 < h2.globals.ancillaryCollapsedSeriesIndices.length; u2++) {
            var g2 = h2.config.series[h2.globals.ancillaryCollapsedSeriesIndices[u2]];
            h2.globals.ancillaryCollapsedSeries[u2].data = h2.globals.axisCharts ? g2.data.slice() : g2;
          }
          s3.series.emptyCollapsedSeries(h2.config.series);
        }
        return s3.update(t3).then(function() {
          l2 === o2.length - 1 && n2(s3);
        });
      });
    });
  } }, { key: "_updateSeries", value: function(t3, e2) {
    var i = this, a2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return new Promise(function(s2) {
      var r2, n2 = i.w;
      return n2.globals.shouldAnimate = e2, n2.globals.dataChanged = true, e2 && i.ctx.series.getPreviousPaths(), n2.globals.axisCharts ? (0 === (r2 = t3.map(function(t4, e3) {
        return i._extendSeries(t4, e3);
      })).length && (r2 = [{ data: [] }]), n2.config.series = r2) : n2.config.series = t3.slice(), a2 && (n2.globals.initialConfig.series = v.clone(n2.config.series), n2.globals.initialSeries = v.clone(n2.config.series)), i.ctx.update().then(function() {
        s2(i.ctx);
      });
    });
  } }, { key: "_extendSeries", value: function(t3, e2) {
    var i = this.w, a2 = i.config.series[e2];
    return u(u({}, i.config.series[e2]), {}, { name: t3.name ? t3.name : null == a2 ? void 0 : a2.name, color: t3.color ? t3.color : null == a2 ? void 0 : a2.color, type: t3.type ? t3.type : null == a2 ? void 0 : a2.type, group: t3.group ? t3.group : null == a2 ? void 0 : a2.group, hidden: void 0 !== t3.hidden ? t3.hidden : null == a2 ? void 0 : a2.hidden, data: t3.data ? t3.data : null == a2 ? void 0 : a2.data, zIndex: void 0 !== t3.zIndex ? t3.zIndex : e2 });
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    var i = this.w, a2 = null, s2 = ".apexcharts-series[data\\:realIndex='".concat(t3, "']");
    return i.globals.axisCharts ? a2 = i.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(e2, "'], ").concat(s2, " circle[j='").concat(e2, "'], ").concat(s2, " rect[j='").concat(e2, "']")) : void 0 === e2 && (a2 = i.globals.dom.Paper.findOne("".concat(s2, " path[j='").concat(t3, "']")), "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t3)), a2 ? (new Mi(this.ctx).pathMouseDown(a2, null), a2.node ? a2.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null);
  } }, { key: "forceXAxisUpdate", value: function(t3) {
    var e2 = this.w;
    if (["min", "max"].forEach(function(i2) {
      void 0 !== t3.xaxis[i2] && (e2.config.xaxis[i2] = t3.xaxis[i2], e2.globals.lastXAxis[i2] = t3.xaxis[i2]);
    }), t3.xaxis.categories && t3.xaxis.categories.length && (e2.config.xaxis.categories = t3.xaxis.categories), e2.config.xaxis.convertedCatToNumeric) {
      var i = new Ni(t3);
      t3 = i.convertCatToNumericXaxis(t3, this.ctx);
    }
    return t3;
  } }, { key: "forceYAxisUpdate", value: function(t3) {
    return t3.chart && t3.chart.stacked && "100%" === t3.chart.stackType && (Array.isArray(t3.yaxis) ? t3.yaxis.forEach(function(e2, i) {
      t3.yaxis[i].min = 0, t3.yaxis[i].max = 100;
    }) : (t3.yaxis.min = 0, t3.yaxis.max = 100)), t3;
  } }, { key: "revertDefaultAxisMinMax", value: function(t3) {
    var e2 = this, i = this.w, a2 = i.globals.lastXAxis, s2 = i.globals.lastYAxis;
    t3 && t3.xaxis && (a2 = t3.xaxis), t3 && t3.yaxis && (s2 = t3.yaxis), i.config.xaxis.min = a2.min, i.config.xaxis.max = a2.max;
    var r2 = function(t4) {
      void 0 !== s2[t4] && (i.config.yaxis[t4].min = s2[t4].min, i.config.yaxis[t4].max = s2[t4].max);
    };
    i.config.yaxis.map(function(t4, a3) {
      i.globals.zoomed || void 0 !== s2[a3] ? r2(a3) : void 0 !== e2.ctx.opts.yaxis[a3] && (t4.min = e2.ctx.opts.yaxis[a3].min, t4.max = e2.ctx.opts.yaxis[a3].max);
    });
  } }]), t2;
}();
!function() {
  function t2() {
    for (var t3 = arguments.length > 0 && arguments[0] !== h2 ? arguments[0] : [], s3 = arguments.length > 1 ? arguments[1] : h2, r2 = arguments.length > 2 ? arguments[2] : h2, n2 = arguments.length > 3 ? arguments[3] : h2, o2 = arguments.length > 4 ? arguments[4] : h2, l2 = arguments.length > 5 ? arguments[5] : h2, h2 = arguments.length > 6 ? arguments[6] : h2, c2 = t3.slice(s3, r2 || h2), d2 = n2.slice(o2, l2 || h2), u2 = 0, g2 = { pos: [0, 0], start: [0, 0] }, p2 = { pos: [0, 0], start: [0, 0] }; ; ) {
      if (c2[u2] = e2.call(g2, c2[u2]), d2[u2] = e2.call(p2, d2[u2]), c2[u2][0] != d2[u2][0] || "M" == c2[u2][0] || "A" == c2[u2][0] && (c2[u2][4] != d2[u2][4] || c2[u2][5] != d2[u2][5]) ? (Array.prototype.splice.apply(c2, [u2, 1].concat(a2.call(g2, c2[u2]))), Array.prototype.splice.apply(d2, [u2, 1].concat(a2.call(p2, d2[u2])))) : (c2[u2] = i.call(g2, c2[u2]), d2[u2] = i.call(p2, d2[u2])), ++u2 == c2.length && u2 == d2.length)
        break;
      u2 == c2.length && c2.push(["C", g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1], g2.pos[0], g2.pos[1]]), u2 == d2.length && d2.push(["C", p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1], p2.pos[0], p2.pos[1]]);
    }
    return { start: c2, dest: d2 };
  }
  function e2(t3) {
    switch (t3[0]) {
      case "z":
      case "Z":
        t3[0] = "L", t3[1] = this.start[0], t3[2] = this.start[1];
        break;
      case "H":
        t3[0] = "L", t3[2] = this.pos[1];
        break;
      case "V":
        t3[0] = "L", t3[2] = t3[1], t3[1] = this.pos[0];
        break;
      case "T":
        t3[0] = "Q", t3[3] = t3[1], t3[4] = t3[2], t3[1] = this.reflection[1], t3[2] = this.reflection[0];
        break;
      case "S":
        t3[0] = "C", t3[6] = t3[4], t3[5] = t3[3], t3[4] = t3[2], t3[3] = t3[1], t3[2] = this.reflection[1], t3[1] = this.reflection[0];
    }
    return t3;
  }
  function i(t3) {
    var e3 = t3.length;
    return this.pos = [t3[e3 - 2], t3[e3 - 1]], -1 != "SCQT".indexOf(t3[0]) && (this.reflection = [2 * this.pos[0] - t3[e3 - 4], 2 * this.pos[1] - t3[e3 - 3]]), t3;
  }
  function a2(t3) {
    var e3 = [t3];
    switch (t3[0]) {
      case "M":
        return this.pos = this.start = [t3[1], t3[2]], e3;
      case "L":
        t3[5] = t3[3] = t3[1], t3[6] = t3[4] = t3[2], t3[1] = this.pos[0], t3[2] = this.pos[1];
        break;
      case "Q":
        t3[6] = t3[4], t3[5] = t3[3], t3[4] = 1 * t3[4] / 3 + 2 * t3[2] / 3, t3[3] = 1 * t3[3] / 3 + 2 * t3[1] / 3, t3[2] = 1 * this.pos[1] / 3 + 2 * t3[2] / 3, t3[1] = 1 * this.pos[0] / 3 + 2 * t3[1] / 3;
        break;
      case "A":
        e3 = function(t4, e4) {
          var i2, a3, s3, r2, n2, o2, l2, h2, c2, d2, u2, g2, p2, f2, x2, b2, m2, v2, y2, w2, k2, A2, C2, S2, L2, M2, P2 = Math.abs(e4[1]), I2 = Math.abs(e4[2]), T2 = e4[3] % 360, z2 = e4[4], X2 = e4[5], R2 = e4[6], E2 = e4[7], Y2 = new bt(t4), H2 = new bt(R2, E2), O2 = [];
          if (0 === P2 || 0 === I2 || Y2.x === H2.x && Y2.y === H2.y)
            return [["C", Y2.x, Y2.y, H2.x, H2.y, H2.x, H2.y]];
          i2 = new bt((Y2.x - H2.x) / 2, (Y2.y - H2.y) / 2).transform(new vt().rotate(T2)), a3 = i2.x * i2.x / (P2 * P2) + i2.y * i2.y / (I2 * I2), a3 > 1 && (P2 *= a3 = Math.sqrt(a3), I2 *= a3);
          s3 = new vt().rotate(T2).scale(1 / P2, 1 / I2).rotate(-T2), Y2 = Y2.transform(s3), H2 = H2.transform(s3), r2 = [H2.x - Y2.x, H2.y - Y2.y], o2 = r2[0] * r2[0] + r2[1] * r2[1], n2 = Math.sqrt(o2), r2[0] /= n2, r2[1] /= n2, l2 = o2 < 4 ? Math.sqrt(1 - o2 / 4) : 0, z2 === X2 && (l2 *= -1);
          h2 = new bt((H2.x + Y2.x) / 2 + l2 * -r2[1], (H2.y + Y2.y) / 2 + l2 * r2[0]), c2 = new bt(Y2.x - h2.x, Y2.y - h2.y), d2 = new bt(H2.x - h2.x, H2.y - h2.y), u2 = Math.acos(c2.x / Math.sqrt(c2.x * c2.x + c2.y * c2.y)), c2.y < 0 && (u2 *= -1);
          g2 = Math.acos(d2.x / Math.sqrt(d2.x * d2.x + d2.y * d2.y)), d2.y < 0 && (g2 *= -1);
          X2 && u2 > g2 && (g2 += 2 * Math.PI);
          !X2 && u2 < g2 && (g2 -= 2 * Math.PI);
          for (f2 = Math.ceil(2 * Math.abs(u2 - g2) / Math.PI), b2 = [], m2 = u2, p2 = (g2 - u2) / f2, x2 = 4 * Math.tan(p2 / 4) / 3, k2 = 0; k2 <= f2; k2++)
            y2 = Math.cos(m2), v2 = Math.sin(m2), w2 = new bt(h2.x + y2, h2.y + v2), b2[k2] = [new bt(w2.x + x2 * v2, w2.y - x2 * y2), w2, new bt(w2.x - x2 * v2, w2.y + x2 * y2)], m2 += p2;
          for (b2[0][0] = b2[0][1].clone(), b2[b2.length - 1][2] = b2[b2.length - 1][1].clone(), s3 = new vt().rotate(T2).scale(P2, I2).rotate(-T2), k2 = 0, A2 = b2.length; k2 < A2; k2++)
            b2[k2][0] = b2[k2][0].transform(s3), b2[k2][1] = b2[k2][1].transform(s3), b2[k2][2] = b2[k2][2].transform(s3);
          for (k2 = 1, A2 = b2.length; k2 < A2; k2++)
            C2 = (w2 = b2[k2 - 1][2]).x, S2 = w2.y, L2 = (w2 = b2[k2][0]).x, M2 = w2.y, R2 = (w2 = b2[k2][1]).x, E2 = w2.y, O2.push(["C", C2, S2, L2, M2, R2, E2]);
          return O2;
        }(this.pos, t3), t3 = e3[0];
    }
    return t3[0] = "C", this.pos = [t3[5], t3[6]], this.reflection = [2 * t3[5] - t3[3], 2 * t3[6] - t3[4]], e3;
  }
  function s2() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e3 = arguments.length > 1 ? arguments[1] : void 0;
    if (false === e3)
      return false;
    for (var i2 = e3, a3 = t3.length; i2 < a3; ++i2)
      if ("M" == t3[i2][0])
        return i2;
    return false;
  }
  Q(Ee, { morph: function(e3, i2, a3, r2, n2) {
    for (var o2 = this.parse(e3), l2 = this.parse(i2), h2 = 0, c2 = 0, d2 = false, u2 = false; false !== h2 || false !== c2; ) {
      var g2;
      d2 = s2(o2, false !== h2 && h2 + 1), u2 = s2(l2, false !== c2 && c2 + 1), false === h2 && (h2 = 0 == (g2 = new Ee(p2.start).bbox()).height || 0 == g2.width ? o2.push(o2[0]) - 1 : o2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1), false === c2 && (c2 = 0 == (g2 = new Ee(p2.dest).bbox()).height || 0 == g2.width ? l2.push(l2[0]) - 1 : l2.push(["M", g2.x + g2.width / 2, g2.y + g2.height / 2]) - 1);
      var p2 = t2(o2, h2, d2, l2, c2, u2);
      o2 = o2.slice(0, h2).concat(p2.start, false === d2 ? [] : o2.slice(d2)), l2 = l2.slice(0, c2).concat(p2.dest, false === u2 ? [] : l2.slice(u2)), h2 = false !== d2 && h2 + p2.start.length, c2 = false !== u2 && c2 + p2.dest.length;
    }
    this._array = o2, this.destination = new Ee(), this.destination._array = l2;
    var f2 = this.fromArray(o2.map(function(t3, e4) {
      var i3 = l2[e4].map(function(i4, s3) {
        return 0 === s3 ? i4 : r2.step(t3[s3], l2[e4][s3], a3, n2[e4], n2);
      });
      return i3;
    }));
    return f2;
  } });
}();
const $a = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY });
class Ja {
  constructor(t2) {
    t2.remember("_draggable", this), this.el = t2, this.drag = this.drag.bind(this), this.startDrag = this.startDrag.bind(this), this.endDrag = this.endDrag.bind(this);
  }
  init(t2) {
    t2 ? (this.el.on("mousedown.drag", this.startDrag), this.el.on("touchstart.drag", this.startDrag, { passive: false })) : (this.el.off("mousedown.drag"), this.el.off("touchstart.drag"));
  }
  startDrag(t2) {
    const e2 = !t2.type.indexOf("mouse");
    if (e2 && 1 !== t2.which && 0 !== t2.buttons)
      return;
    if (this.el.dispatch("beforedrag", { event: t2, handler: this }).defaultPrevented)
      return;
    t2.preventDefault(), t2.stopPropagation(), this.init(false), this.box = this.el.bbox(), this.lastClick = this.el.point($a(t2));
    const i = (e2 ? "mouseup" : "touchend") + ".drag";
    zt(window, (e2 ? "mousemove" : "touchmove") + ".drag", this.drag, this, { passive: false }), zt(window, i, this.endDrag, this, { passive: false }), this.el.fire("dragstart", { event: t2, handler: this, box: this.box });
  }
  drag(t2) {
    const { box: e2, lastClick: i } = this, a2 = this.el.point($a(t2)), s2 = a2.x - i.x, r2 = a2.y - i.y;
    if (!s2 && !r2)
      return e2;
    const n2 = e2.x + s2, o2 = e2.y + r2;
    this.box = new kt(n2, o2, e2.w, e2.h), this.lastClick = a2, this.el.dispatch("dragmove", { event: t2, handler: this, box: this.box }).defaultPrevented || this.move(n2, o2);
  }
  move(t2, e2) {
    "svg" === this.el.type ? gi.prototype.move.call(this.el, t2, e2) : this.el.move(t2, e2);
  }
  endDrag(t2) {
    this.drag(t2), this.el.fire("dragend", { event: t2, handler: this, box: this.box }), Xt(window, "mousemove.drag"), Xt(window, "touchmove.drag"), Xt(window, "mouseup.drag"), Xt(window, "touchend.drag"), this.init(true);
  }
}
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function Qa(t2, e2, i, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i });
  };
}
function Ka([t2, e2], { a: i, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { draggable(t2 = true) {
  return (this.remember("_draggable") || new Ja(this)).init(t2), this;
} });
let ts = class {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", Qa(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i, a2) {
    const s2 = a2.at(i - 1), r2 = a2[(i + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i = this.getPoint("t");
    t2.get(0).plot(i[0], i[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", Qa("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) => Ka(t3, e2)), this.rotationPoint = Ka(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i], [s2, i], [e2, i], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
};
const es = (t2) => function(e2 = true, i = {}) {
  "object" == typeof e2 && (i = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ts ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i), this;
};
/*!
* @svgdotjs/svg.resize.js - An extension for svg.js which allows to resize elements which are selected
* @version 2.0.4
* https://github.com/svgdotjs/svg.resize.js
*
* @copyright [object Object]
* @license MIT
*
* BUILT: Fri Sep 13 2024 12:43:14 GMT+0200 (Central European Summer Time)
*/
/*!
* @svgdotjs/svg.select.js - An extension of svg.js which allows to select elements with mouse
* @version 4.0.1
* https://github.com/svgdotjs/svg.select.js
*
* @copyright Ulrich-Matthias Schäfer
* @license MIT
*
* BUILT: Mon Jul 01 2024 15:04:42 GMT+0200 (Central European Summer Time)
*/
function is(t2, e2, i, a2 = null) {
  return function(s2) {
    s2.preventDefault(), s2.stopPropagation();
    var r2 = s2.pageX || s2.touches[0].pageX, n2 = s2.pageY || s2.touches[0].pageY;
    e2.fire(t2, { x: r2, y: n2, event: s2, index: a2, points: i });
  };
}
function as([t2, e2], { a: i, b: a2, c: s2, d: r2, e: n2, f: o2 }) {
  return [t2 * i + e2 * s2 + n2, t2 * a2 + e2 * r2 + o2];
}
Q(Gt, { select: es(ts) }), Q([Ge, je, xe], { pointSelect: es(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i) => {
      this.createHandle.call(this, this.selection, t2, e2, i), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", Qa("point", this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) => Ka(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
class ss {
  constructor(t2) {
    this.el = t2, t2.remember("_selectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.createRot = t2.createRot || this.createRotFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.updateRot = t2.updateRot || this.updateRotFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createResizeHandles(), this.updateResizeHandles(), this.createRotationHandle(), this.updateRotationHandle(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.handlePoints).addClass("svg_select_shape");
  }
  updateSelection() {
    this.selection.get(0).plot(this.handlePoints);
  }
  createResizeHandles() {
    this.handlePoints.forEach((t2, e2, i) => {
      const a2 = this.order[e2];
      this.createHandle.call(this, this.selection, t2, e2, i, a2), this.selection.get(e2 + 1).addClass("svg_select_handle svg_select_handle_" + a2).on("mousedown.selection touchstart.selection", is(a2, this.el, this.handlePoints, e2));
    });
  }
  createHandleFn(t2) {
    t2.polyline();
  }
  updateHandleFn(t2, e2, i, a2) {
    const s2 = a2.at(i - 1), r2 = a2[(i + 1) % a2.length], n2 = e2, o2 = [n2[0] - s2[0], n2[1] - s2[1]], l2 = [n2[0] - r2[0], n2[1] - r2[1]], h2 = Math.sqrt(o2[0] * o2[0] + o2[1] * o2[1]), c2 = Math.sqrt(l2[0] * l2[0] + l2[1] * l2[1]), d2 = [o2[0] / h2, o2[1] / h2], u2 = [l2[0] / c2, l2[1] / c2], g2 = [n2[0] - 10 * d2[0], n2[1] - 10 * d2[1]], p2 = [n2[0] - 10 * u2[0], n2[1] - 10 * u2[1]];
    t2.plot([g2, n2, p2]);
  }
  updateResizeHandles() {
    this.handlePoints.forEach((t2, e2, i) => {
      const a2 = this.order[e2];
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i, a2);
    });
  }
  createRotFn(t2) {
    t2.line(), t2.circle(5);
  }
  getPoint(t2) {
    return this.handlePoints[this.order.indexOf(t2)];
  }
  getPointHandle(t2) {
    return this.selection.get(this.order.indexOf(t2) + 1);
  }
  updateRotFn(t2, e2) {
    const i = this.getPoint("t");
    t2.get(0).plot(i[0], i[1], e2[0], e2[1]), t2.get(1).center(e2[0], e2[1]);
  }
  createRotationHandle() {
    const t2 = this.selection.group().addClass("svg_select_handle_rot").on("mousedown.selection touchstart.selection", is("rot", this.el, this.handlePoints));
    this.createRot.call(this, t2);
  }
  updateRotationHandle() {
    const t2 = this.selection.findOne("g.svg_select_handle_rot");
    this.updateRot(t2, this.rotationPoint, this.handlePoints);
  }
  updatePoints() {
    const t2 = this.el.bbox(), e2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.handlePoints = this.getHandlePoints(t2).map((t3) => as(t3, e2)), this.rotationPoint = as(this.getRotationPoint(t2), e2);
  }
  getHandlePoints({ x: t2, x2: e2, y: i, y2: a2, cx: s2, cy: r2 } = this.el.bbox()) {
    return [[t2, i], [s2, i], [e2, i], [e2, r2], [e2, a2], [s2, a2], [t2, a2], [t2, r2]];
  }
  getRotationPoint({ y: t2, cx: e2 } = this.el.bbox()) {
    return [e2, t2 - 20];
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updateResizeHandles(), this.updateRotationHandle();
  }
}
const rs = (t2) => function(e2 = true, i = {}) {
  "object" == typeof e2 && (i = e2, e2 = true);
  let a2 = this.remember("_" + t2.name);
  return a2 || (e2.prototype instanceof ss ? (a2 = new e2(this), e2 = true) : a2 = new t2(this), this.remember("_" + t2.name, a2)), a2.active(e2, i), this;
};
Q(Gt, { select: rs(ss) }), Q([Ge, je, xe], { pointSelect: rs(class {
  constructor(t2) {
    this.el = t2, t2.remember("_pointSelectHandler", this), this.selection = new gi(), this.order = ["lt", "t", "rt", "r", "rb", "b", "lb", "l", "rot"], this.mutationHandler = this.mutationHandler.bind(this);
    const e2 = F();
    this.observer = new e2.MutationObserver(this.mutationHandler);
  }
  init(t2) {
    this.createHandle = t2.createHandle || this.createHandleFn, this.updateHandle = t2.updateHandle || this.updateHandleFn, this.el.root().put(this.selection), this.updatePoints(), this.createSelection(), this.createPointHandles(), this.updatePointHandles(), this.observer.observe(this.el.node, { attributes: true });
  }
  active(t2, e2) {
    if (!t2)
      return this.selection.clear().remove(), void this.observer.disconnect();
    this.init(e2);
  }
  createSelection() {
    this.selection.polygon(this.points).addClass("svg_select_shape_pointSelect");
  }
  updateSelection() {
    this.selection.get(0).plot(this.points);
  }
  createPointHandles() {
    this.points.forEach((t2, e2, i) => {
      this.createHandle.call(this, this.selection, t2, e2, i), this.selection.get(e2 + 1).addClass("svg_select_handle_point").on("mousedown.selection touchstart.selection", is("point", this.el, this.points, e2));
    });
  }
  createHandleFn(t2) {
    t2.circle(5);
  }
  updateHandleFn(t2, e2) {
    t2.center(e2[0], e2[1]);
  }
  updatePointHandles() {
    this.points.forEach((t2, e2, i) => {
      this.updateHandle.call(this, this.selection.get(e2 + 1), t2, e2, i);
    });
  }
  updatePoints() {
    const t2 = this.el.parent().screenCTM().inverseO().multiplyO(this.el.screenCTM());
    this.points = this.el.array().map((e2) => as(e2, t2));
  }
  mutationHandler() {
    this.updatePoints(), this.updateSelection(), this.updatePointHandles();
  }
}) });
const ns$1 = (t2) => (t2.changedTouches && (t2 = t2.changedTouches[0]), { x: t2.clientX, y: t2.clientY }), os = (t2) => {
  let e2 = 1 / 0, i = 1 / 0, a2 = -1 / 0, s2 = -1 / 0;
  for (let r2 = 0; r2 < t2.length; r2++) {
    const n2 = t2[r2];
    e2 = Math.min(e2, n2[0]), i = Math.min(i, n2[1]), a2 = Math.max(a2, n2[0]), s2 = Math.max(s2, n2[1]);
  }
  return new kt(e2, i, a2 - e2, s2 - i);
};
class ls {
  constructor(t2) {
    this.el = t2, t2.remember("_ResizeHandler", this), this.lastCoordinates = null, this.eventType = "", this.lastEvent = null, this.handleResize = this.handleResize.bind(this), this.resize = this.resize.bind(this), this.endResize = this.endResize.bind(this), this.rotate = this.rotate.bind(this), this.movePoint = this.movePoint.bind(this);
  }
  active(t2, e2) {
    this.preserveAspectRatio = e2.preserveAspectRatio ?? false, this.aroundCenter = e2.aroundCenter ?? false, this.grid = e2.grid ?? 0, this.degree = e2.degree ?? 0, this.el.off(".resize"), t2 && (this.el.on(["lt.resize", "rt.resize", "rb.resize", "lb.resize", "t.resize", "r.resize", "b.resize", "l.resize", "rot.resize", "point.resize"], this.handleResize), this.lastEvent && ("rot" === this.eventType ? this.rotate(this.lastEvent) : "point" === this.eventType ? this.movePoint(this.lastEvent) : this.resize(this.lastEvent)));
  }
  handleResize(t2) {
    this.eventType = t2.type;
    const { event: e2, index: i, points: a2 } = t2.detail, s2 = !e2.type.indexOf("mouse");
    if (s2 && 1 !== (e2.which || e2.buttons))
      return;
    if (this.el.dispatch("beforeresize", { event: t2, handler: this }).defaultPrevented)
      return;
    this.box = this.el.bbox(), this.startPoint = this.el.point(ns$1(e2)), this.index = i, this.points = a2.slice();
    const r2 = (s2 ? "mousemove" : "touchmove") + ".resize", n2 = (s2 ? "mouseup" : "touchcancel.resize touchend") + ".resize";
    "point" === t2.type ? zt(window, r2, this.movePoint) : "rot" === t2.type ? zt(window, r2, this.rotate) : zt(window, r2, this.resize), zt(window, n2, this.endResize);
  }
  resize(t2) {
    this.lastEvent = t2;
    const e2 = this.snapToGrid(this.el.point(ns$1(t2)));
    let i = e2.x - this.startPoint.x, a2 = e2.y - this.startPoint.y;
    this.preserveAspectRatio && this.aroundCenter && (i *= 2, a2 *= 2);
    const s2 = this.box.x + i, r2 = this.box.y + a2, n2 = this.box.x2 + i, o2 = this.box.y2 + a2;
    let l2 = new kt(this.box);
    if (this.eventType.includes("l") && (l2.x = Math.min(s2, this.box.x2), l2.x2 = Math.max(s2, this.box.x2)), this.eventType.includes("r") && (l2.x = Math.min(n2, this.box.x), l2.x2 = Math.max(n2, this.box.x)), this.eventType.includes("t") && (l2.y = Math.min(r2, this.box.y2), l2.y2 = Math.max(r2, this.box.y2)), this.eventType.includes("b") && (l2.y = Math.min(o2, this.box.y), l2.y2 = Math.max(o2, this.box.y)), l2.width = l2.x2 - l2.x, l2.height = l2.y2 - l2.y, this.preserveAspectRatio) {
      const t3 = l2.width / this.box.width, e3 = l2.height / this.box.height, i2 = ["lt", "t", "rt", "r", "rb", "b", "lb", "l"], a3 = (i2.indexOf(this.eventType) + 4) % i2.length, s3 = this.aroundCenter ? [this.box.cx, this.box.cy] : this.points[a3];
      let r3 = this.eventType.includes("t") || this.eventType.includes("b") ? e3 : t3;
      r3 = 2 === this.eventType.length ? Math.max(t3, e3) : r3, l2 = function(t4, e4, i3) {
        const a4 = [[t4.x, t4.y], [t4.x + t4.width, t4.y], [t4.x + t4.width, t4.y + t4.height], [t4.x, t4.y + t4.height]].map(([t5, a5]) => {
          const s4 = t5 - e4[0], r4 = (a5 - e4[1]) * i3;
          return [s4 * i3 + e4[0], r4 + e4[1]];
        });
        return os(a4);
      }(this.box, s3, r3);
    }
    this.el.dispatch("resize", { box: new kt(l2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.size(l2.width, l2.height).move(l2.x, l2.y);
  }
  movePoint(t2) {
    this.lastEvent = t2;
    const { x: e2, y: i } = this.snapToGrid(this.el.point(ns$1(t2))), a2 = this.el.array().slice();
    a2[this.index] = [e2, i], this.el.dispatch("resize", { box: os(a2), angle: 0, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.plot(a2);
  }
  rotate(t2) {
    this.lastEvent = t2;
    const e2 = this.startPoint, i = this.el.point(ns$1(t2)), { cx: a2, cy: s2 } = this.box, r2 = e2.x - a2, n2 = e2.y - s2, o2 = i.x - a2, l2 = i.y - s2, h2 = Math.sqrt(r2 * r2 + n2 * n2) * Math.sqrt(o2 * o2 + l2 * l2);
    if (0 === h2)
      return;
    let c2 = Math.acos((r2 * o2 + n2 * l2) / h2) / Math.PI * 180;
    if (!c2)
      return;
    i.x < e2.x && (c2 = -c2);
    const d2 = new vt(this.el), { x: u2, y: g2 } = new bt(a2, s2).transformO(d2), { rotate: p2 } = d2.decompose(), f2 = this.snapToAngle(p2 + c2) - p2;
    this.el.dispatch("resize", { box: this.box, angle: f2, eventType: this.eventType, event: t2, handler: this }).defaultPrevented || this.el.transform(d2.rotateO(f2, u2, g2));
  }
  endResize(t2) {
    "rot" !== this.eventType && "point" !== this.eventType && this.resize(t2), this.lastEvent = null, this.eventType = "", Xt(window, "mousemove.resize touchmove.resize"), Xt(window, "mouseup.resize touchend.resize");
  }
  snapToGrid(t2) {
    return this.grid && (t2.x = Math.round(t2.x / this.grid) * this.grid, t2.y = Math.round(t2.y / this.grid) * this.grid), t2;
  }
  snapToAngle(t2) {
    return this.degree && (t2 = Math.round(t2 / this.degree) * this.degree), t2;
  }
}
Q(Gt, { resize: function(t2 = true, e2 = {}) {
  "object" == typeof t2 && (e2 = t2, t2 = true);
  let i = this.remember("_ResizeHandler");
  return i || (t2.prototype instanceof ls ? (i = new t2(this), t2 = true) : i = new ls(this), this.remember("_resizeHandler", i)), i.active(t2, e2), this;
} }), void 0 === window.SVG && (window.SVG = yi), void 0 === window.Apex && (window.Apex = {});
var hs = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "initModules", value: function() {
    this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "isSeriesHidden", "highlightSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new y(this.ctx), this.ctx.axes = new ra(this.ctx), this.ctx.core = new qa(this.ctx.el, this.ctx), this.ctx.config = new Wi({}), this.ctx.data = new $i(this.ctx), this.ctx.grid = new Ki(this.ctx), this.ctx.graphics = new Mi(this.ctx), this.ctx.coreUtils = new Pi(this.ctx), this.ctx.crosshairs = new na(this.ctx), this.ctx.events = new aa(this.ctx), this.ctx.exports = new Ji(this.ctx), this.ctx.fill = new ji(this.ctx), this.ctx.localization = new sa(this.ctx), this.ctx.options = new Oi(), this.ctx.responsive = new oa(this.ctx), this.ctx.series = new Zi(this.ctx), this.ctx.theme = new la(this.ctx), this.ctx.formatters = new Xi(this.ctx), this.ctx.titleSubtitle = new ha(this.ctx), this.ctx.legend = new xa(this.ctx), this.ctx.toolbar = new ba(this.ctx), this.ctx.tooltip = new Sa(this.ctx), this.ctx.dimensions = new pa(this.ctx), this.ctx.updateHelpers = new Za(this.ctx), this.ctx.zoomPanSelection = new ma(this.ctx), this.ctx.w.globals.tooltip = new Sa(this.ctx);
  } }]), t2;
}(), cs = function() {
  function t2(e2) {
    i$1(this, t2), this.ctx = e2, this.w = e2.w;
  }
  return s(t2, [{ key: "clear", value: function(t3) {
    var e2 = t3.isUpdating;
    this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({ isUpdating: e2 });
  } }, { key: "killSVG", value: function(t3) {
    t3.each(function() {
      this.removeClass("*"), this.off();
    }, true), t3.clear();
  } }, { key: "clearDomElements", value: function(t3) {
    var e2 = this, i = t3.isUpdating, a2 = this.w.globals.dom.Paper.node;
    a2.parentNode && a2.parentNode.parentNode && !i && (a2.parentNode.parentNode.style.minHeight = "unset");
    var s2 = this.w.globals.dom.baseEl;
    s2 && this.ctx.eventList.forEach(function(t4) {
      s2.removeEventListener(t4, e2.ctx.events.documentEvent);
    });
    var r2 = this.w.globals.dom;
    if (null !== this.ctx.el)
      for (; this.ctx.el.firstChild; )
        this.ctx.el.removeChild(this.ctx.el.firstChild);
    this.killSVG(r2.Paper), r2.Paper.remove(), r2.elWrap = null, r2.elGraphical = null, r2.elLegendWrap = null, r2.elLegendForeign = null, r2.baseEl = null, r2.elGridRect = null, r2.elGridRectMask = null, r2.elGridRectBarMask = null, r2.elGridRectMarkerMask = null, r2.elForecastMask = null, r2.elNonForecastMask = null, r2.elDefs = null;
  } }]), t2;
}(), ds = /* @__PURE__ */ new WeakMap();
var us = function() {
  function t2(e2, a2) {
    i$1(this, t2), this.opts = a2, this.ctx = this, this.w = new Gi(a2).init(), this.el = e2, this.w.globals.cuid = v.randomId(), this.w.globals.chartID = this.w.config.chart.id ? v.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new hs(this).initModules(), this.create = v.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this);
  }
  return s(t2, [{ key: "render", value: function() {
    var t3 = this;
    return new Promise(function(e2, i) {
      if (v.elementExists(t3.el)) {
        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t3.w.config.chart.id && Apex._chartInstances.push({ id: t3.w.globals.chartID, group: t3.w.config.chart.group, chart: t3 }), t3.setLocale(t3.w.config.chart.defaultLocale);
        var a2 = t3.w.config.chart.events.beforeMount;
        "function" == typeof a2 && a2(t3, t3.w), t3.events.fireEvent("beforeMount", [t3, t3.w]), window.addEventListener("resize", t3.windowResizeHandler), function(t4, e3) {
          var i2 = false;
          if (t4.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
            var a3 = t4.getBoundingClientRect();
            "none" !== t4.style.display && 0 !== a3.width || (i2 = true);
          }
          var s3 = new ResizeObserver(function(a4) {
            i2 && e3.call(t4, a4), i2 = true;
          });
          t4.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t4.children).forEach(function(t5) {
            return s3.observe(t5);
          }) : s3.observe(t4), ds.set(e3, s3);
        }(t3.el.parentNode, t3.parentResizeHandler);
        var s2 = t3.el.getRootNode && t3.el.getRootNode(), r2 = v.is("ShadowRoot", s2), n2 = t3.el.ownerDocument, o2 = r2 ? s2.getElementById("apexcharts-css") : n2.getElementById("apexcharts-css");
        if (!o2) {
          var l2;
          (o2 = document.createElement("style")).id = "apexcharts-css", o2.textContent = '@keyframes opaque {\n  0% {\n    opacity: 0\n  }\n\n  to {\n    opacity: 1\n  }\n}\n\n@keyframes resizeanim {\n\n  0%,\n  to {\n    opacity: 0\n  }\n}\n\n.apexcharts-canvas {\n  position: relative;\n  direction: ltr !important;\n  user-select: none\n}\n\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5)\n}\n\n.apexcharts-inner {\n  position: relative\n}\n\n.apexcharts-text tspan {\n  font-family: inherit\n}\n\nrect.legend-mouseover-inactive,\n.legend-mouseover-inactive rect,\n.legend-mouseover-inactive path,\n.legend-mouseover-inactive circle,\n.legend-mouseover-inactive line,\n.legend-mouseover-inactive text.apexcharts-yaxis-title-text,\n.legend-mouseover-inactive text.apexcharts-yaxis-label {\n  transition: .15s ease all;\n  opacity: .2\n}\n\n.apexcharts-legend-text {\n  padding-left: 15px;\n  margin-left: -15px;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, .96)\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, .8)\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit\n}\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #eceff1;\n  border-bottom: 1px solid #ddd\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, .7);\n  border-bottom: 1px solid #333\n}\n\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  margin-left: 5px;\n  font-weight: 600\n}\n\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-z-value:empty,\n.apexcharts-tooltip-title:empty {\n  display: none\n}\n\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px\n}\n\n.apexcharts-tooltip-goals-group,\n.apexcharts-tooltip-text-goals-label,\n.apexcharts-tooltip-text-goals-value {\n  display: flex\n}\n\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px\n}\n\n.apexcharts-tooltip-marker {\n  display: inline-block;\n  position: relative;\n  width: 16px;\n  height: 16px;\n  font-size: 16px;\n  line-height: 16px;\n  margin-right: 4px;\n  text-align: center;\n  vertical-align: middle;\n  color: inherit;\n}\n\n.apexcharts-tooltip-marker::before {\n  content: "";\n  display: inline-block;\n  width: 100%;\n  text-align: center;\n  color: currentcolor;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  font-size: 26px;\n  font-family: Arial, Helvetica, sans-serif;\n  line-height: 14px;\n  font-weight: 900;\n}\n\n.apexcharts-tooltip-marker[shape="circle"]::before {\n  content: "\\25CF";\n}\n\n.apexcharts-tooltip-marker[shape="square"]::before,\n.apexcharts-tooltip-marker[shape="rect"]::before {\n  content: "\\25A0";\n  transform: translate(-1px, -2px);\n}\n\n.apexcharts-tooltip-marker[shape="line"]::before {\n  content: "\\2500";\n}\n\n.apexcharts-tooltip-marker[shape="diamond"]::before {\n  content: "\\25C6";\n  font-size: 28px;\n}\n\n.apexcharts-tooltip-marker[shape="triangle"]::before {\n  content: "\\25B2";\n  font-size: 22px;\n}\n\n.apexcharts-tooltip-marker[shape="cross"]::before {\n  content: "\\2715";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="plus"]::before {\n  content: "\\2715";\n  transform: rotate(45deg) translate(-1px, -1px);\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="star"]::before {\n  content: "\\2605";\n  font-size: 18px;\n}\n\n.apexcharts-tooltip-marker[shape="sparkle"]::before {\n  content: "\\2726";\n  font-size: 20px;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px\n}\n\n.apexcharts-custom-tooltip,\n.apexcharts-tooltip-box {\n  padding: 4px 8px\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: 700\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: 700;\n  display: block;\n  margin-bottom: 5px\n}\n\n.apexcharts-xaxistooltip,\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #eceff1;\n  border: 1px solid #90a4ae\n}\n\n.apexcharts-xaxistooltip {\n  padding: 9px 10px;\n  transition: .15s ease all\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-left: -6px\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-left: -7px\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #eceff1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90a4ae\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after,\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-yaxistooltip {\n  padding: 4px 10px\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, .7);\n  border: 1px solid rgba(0, 0, 0, .5);\n  color: #fff\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: transparent;\n  border-width: 6px;\n  margin-top: -6px\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: transparent;\n  border-width: 7px;\n  margin-top: -7px\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #eceff1\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90a4ae\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after,\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, .5)\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: .15s ease all\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: .15s ease all\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0\n}\n\n.apexcharts-selection-rect {\n  cursor: move\n}\n\n.svg_select_shape {\n  stroke-width: 1;\n  stroke-dasharray: 10 10;\n  stroke: black;\n  stroke-opacity: 0.1;\n  pointer-events: none;\n  fill: none;\n}\n\n.svg_select_handle {\n  stroke-width: 3;\n  stroke: black;\n  fill: none;\n}\n\n.svg_select_handle_r {\n  cursor: e-resize;\n}\n\n.svg_select_handle_l {\n  cursor: w-resize;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-menu-icon,\n.apexcharts-pan-icon,\n.apexcharts-reset-icon,\n.apexcharts-selection-icon,\n.apexcharts-toolbar-custom-icon,\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6e8192;\n  text-align: center\n}\n\n.apexcharts-menu-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg {\n  fill: #6e8192\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(.76)\n}\n\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg {\n  fill: #f3f4f5\n}\n\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg {\n  fill: #008ffb\n}\n\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg {\n  fill: #333\n}\n\n.apexcharts-menu-icon,\n.apexcharts-selection-icon {\n  position: relative\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px\n}\n\n.apexcharts-menu-icon,\n.apexcharts-reset-icon,\n.apexcharts-zoom-icon {\n  transform: scale(.85)\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px\n}\n\n.apexcharts-pan-icon {\n  transform: scale(.62);\n  position: relative;\n  left: 1px;\n  top: 0\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6e8192;\n  stroke-width: 2\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008ffb\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0 6px 2px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: .15s ease all;\n  pointer-events: none\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: .15s ease all\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, .7);\n  color: #fff\n}\n\n@media screen and (min-width:768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1\n  }\n}\n\n.apexcharts-canvas .apexcharts-element-hidden,\n.apexcharts-datalabel.apexcharts-element-hidden,\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-hidden-element-shown {\n  opacity: 1;\n  transition: 0.25s ease all;\n}\n\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value,\n.apexcharts-datalabels,\n.apexcharts-pie-label {\n  cursor: default;\n  pointer-events: none\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: .3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease\n}\n\n.apexcharts-radialbar-label {\n  cursor: pointer;\n}\n\n.apexcharts-annotation-rect,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-gridline,\n.apexcharts-line,\n.apexcharts-point-annotation-label,\n.apexcharts-radar-series path:not(.apexcharts-marker),\n.apexcharts-radar-series polygon,\n.apexcharts-toolbar svg,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-zoom-rect,\n.no-pointer-events {\n  pointer-events: none\n}\n\n.apexcharts-tooltip-active .apexcharts-marker {\n  transition: .15s ease all\n}\n\n.apexcharts-radar-series .apexcharts-yaxis {\n  pointer-events: none;\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden\n}\n\n.contract-trigger:before,\n.resize-triggers,\n.resize-triggers>div {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0\n}\n\n.resize-triggers>div {\n  height: 100%;\n  width: 100%;\n  background: #eee;\n  overflow: auto\n}\n\n.contract-trigger:before {\n  overflow: hidden;\n  width: 200%;\n  height: 200%\n}\n\n.apexcharts-bar-goals-markers {\n  pointer-events: none\n}\n\n.apexcharts-bar-shadows {\n  pointer-events: none\n}\n\n.apexcharts-rangebar-goals-markers {\n  pointer-events: none\n}';
          var h2 = (null === (l2 = t3.opts.chart) || void 0 === l2 ? void 0 : l2.nonce) || t3.w.config.chart.nonce;
          h2 && o2.setAttribute("nonce", h2), r2 ? s2.prepend(o2) : n2.head.appendChild(o2);
        }
        var c2 = t3.create(t3.w.config.series, {});
        if (!c2)
          return e2(t3);
        t3.mount(c2).then(function() {
          "function" == typeof t3.w.config.chart.events.mounted && t3.w.config.chart.events.mounted(t3, t3.w), t3.events.fireEvent("mounted", [t3, t3.w]), e2(c2);
        }).catch(function(t4) {
          i(t4);
        });
      } else
        i(new Error("Element not found"));
    });
  } }, { key: "create", value: function(t3, e2) {
    var i = this, a2 = this.w;
    new hs(this).initModules();
    var s2 = this.w.globals;
    if (s2.noData = false, s2.animationEnded = false, !v.elementExists(this.el))
      return s2.animationEnded = true, this.destroy(), null;
    (this.responsive.checkResponsiveConfig(e2), a2.config.xaxis.convertedCatToNumeric) && new Ni(a2.config).convertCatToNumericXaxis(a2.config, this.ctx);
    if (this.core.setupElements(), "treemap" === a2.config.chart.type && (a2.config.grid.show = false, a2.config.yaxis[0].show = false), 0 === s2.svgWidth)
      return s2.animationEnded = true, null;
    var r2 = t3;
    t3.forEach(function(t4, e3) {
      t4.hidden && (r2 = i.legend.legendHelpers.getSeriesAfterCollapsing({ realIndex: e3 }));
    });
    var n2 = Pi.checkComboSeries(r2, a2.config.chart.type);
    s2.comboCharts = n2.comboCharts, s2.comboBarCount = n2.comboBarCount;
    var o2 = r2.every(function(t4) {
      return t4.data && 0 === t4.data.length;
    });
    (0 === r2.length || o2 && s2.collapsedSeries.length < 1) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(r2), this.theme.init(), new Vi(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), s2.noData && s2.collapsedSeries.length !== s2.series.length && !a2.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), s2.axisCharts && (this.core.coreCalculations(), "category" !== a2.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = a2.globals.minX, this.ctx.toolbar.maxX = a2.globals.maxX), this.formatters.heatmapLabelFormatters(), new Pi(this).getLargestMarkerSize(), this.dimensions.plotCoords();
    var l2 = this.core.xySettings();
    this.grid.createGridMask();
    var h2 = this.core.plotChartType(r2, l2), c2 = new qi(this);
    return c2.bringForward(), a2.config.dataLabels.background.enabled && c2.dataLabelsBackground(), this.core.shiftGraphPosition(), { elGraph: h2, xyRatios: l2, dimensions: { plot: { left: a2.globals.translateX, top: a2.globals.translateY, width: a2.globals.gridWidth, height: a2.globals.gridHeight } } };
  } }, { key: "mount", value: function() {
    var t3 = this, e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, i = this, a2 = i.w;
    return new Promise(function(s2, r2) {
      if (null === i.el)
        return r2(new Error("Not enough data to display or target element not found"));
      (null === e2 || a2.globals.allSeriesCollapsed) && i.series.handleNoData(), i.grid = new Ki(i);
      var n2, o2, l2 = i.grid.drawGrid();
      (i.annotations = new Fi(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === a2.config.grid.position) && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (n2 = l2.elGridBorders) && void 0 !== n2 && n2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      if (Array.isArray(e2.elGraph))
        for (var h2 = 0; h2 < e2.elGraph.length; h2++)
          a2.globals.dom.elGraphical.add(e2.elGraph[h2]);
      else
        a2.globals.dom.elGraphical.add(e2.elGraph);
      "front" === a2.config.grid.position && (l2 && a2.globals.dom.elGraphical.add(l2.el), null != l2 && null !== (o2 = l2.elGridBorders) && void 0 !== o2 && o2.node && a2.globals.dom.elGraphical.add(l2.elGridBorders));
      "front" === a2.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === a2.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "treemap" !== a2.config.chart.type && i.axes.drawAxis(a2.config.chart.type, l2);
      var c2 = new Qi(t3.ctx, l2), d2 = new ia(t3.ctx, l2);
      if (null !== l2 && (c2.xAxisLabelCorrections(l2.xAxisTickWidth), d2.setYAxisTextAlignments(), a2.config.yaxis.map(function(t4, e3) {
        -1 === a2.globals.ignoreYAxisIndexes.indexOf(e3) && d2.yAxisTitleRotate(e3, t4.opposite);
      })), i.annotations.drawAxesAnnotations(), !a2.globals.noData) {
        if (a2.config.tooltip.enabled && !a2.globals.noData && i.w.globals.tooltip.drawTooltip(e2.xyRatios), a2.globals.axisCharts && (a2.globals.isXNumeric || a2.config.xaxis.convertedCatToNumeric || a2.globals.isRangeBar))
          (a2.config.chart.zoom.enabled || a2.config.chart.selection && a2.config.chart.selection.enabled || a2.config.chart.pan && a2.config.chart.pan.enabled) && i.zoomPanSelection.init({ xyRatios: e2.xyRatios });
        else {
          var u2 = a2.config.chart.toolbar.tools;
          ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach(function(t4) {
            u2[t4] = false;
          });
        }
        a2.config.chart.toolbar.show && !a2.globals.allSeriesCollapsed && i.toolbar.createToolbar();
      }
      a2.globals.memory.methodsToExec.length > 0 && a2.globals.memory.methodsToExec.forEach(function(t4) {
        t4.method(t4.params, false, t4.context);
      }), a2.globals.axisCharts || a2.globals.noData || i.core.resizeNonAxisCharts(), s2(i);
    });
  } }, { key: "destroy", value: function() {
    window.removeEventListener("resize", this.windowResizeHandler), function(t4, e2) {
      var i = ds.get(e2);
      i && (i.disconnect(), ds.delete(e2));
    }(this.el.parentNode, this.parentResizeHandler);
    var t3 = this.w.config.chart.id;
    t3 && Apex._chartInstances.forEach(function(e2, i) {
      e2.id === v.escapeString(t3) && Apex._chartInstances.splice(i, 1);
    }), new cs(this.ctx).clear({ isUpdating: false });
  } }, { key: "updateOptions", value: function(t3) {
    var e2 = this, i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], a2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], s2 = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3], r2 = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4], n2 = this.w;
    return n2.globals.selection = void 0, t3.series && (this.series.resetSeries(false, true, false), t3.series.length && t3.series[0].data && (t3.series = t3.series.map(function(t4, i2) {
      return e2.updateHelpers._extendSeries(t4, i2);
    })), this.updateHelpers.revertDefaultAxisMinMax()), t3.xaxis && (t3 = this.updateHelpers.forceXAxisUpdate(t3)), t3.yaxis && (t3 = this.updateHelpers.forceYAxisUpdate(t3)), n2.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t3.theme && (t3 = this.theme.updateThemeOptions(t3)), this.updateHelpers._updateOptions(t3, i, a2, s2, r2);
  } }, { key: "updateSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
    return this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t3, e2, i);
  } }, { key: "appendSeries", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2], a2 = this.w.config.series.slice();
    return a2.push(t3), this.series.resetSeries(false), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a2, e2, i);
  } }, { key: "appendData", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = this;
    i.w.globals.dataChanged = true, i.series.getPreviousPaths();
    for (var a2 = i.w.config.series.slice(), s2 = 0; s2 < a2.length; s2++)
      if (null !== t3[s2] && void 0 !== t3[s2])
        for (var r2 = 0; r2 < t3[s2].data.length; r2++)
          a2[s2].data.push(t3[s2].data[r2]);
    return i.w.config.series = a2, e2 && (i.w.globals.initialSeries = v.clone(i.w.config.series)), this.update();
  } }, { key: "update", value: function(t3) {
    var e2 = this;
    return new Promise(function(i, a2) {
      new cs(e2.ctx).clear({ isUpdating: true });
      var s2 = e2.create(e2.w.config.series, t3);
      if (!s2)
        return i(e2);
      e2.mount(s2).then(function() {
        "function" == typeof e2.w.config.chart.events.updated && e2.w.config.chart.events.updated(e2, e2.w), e2.events.fireEvent("updated", [e2, e2.w]), e2.w.globals.isDirty = true, i(e2);
      }).catch(function(t4) {
        a2(t4);
      });
    });
  } }, { key: "getSyncedCharts", value: function() {
    var t3 = this.getGroupedCharts(), e2 = [this];
    return t3.length && (e2 = [], t3.forEach(function(t4) {
      e2.push(t4);
    })), e2;
  } }, { key: "getGroupedCharts", value: function() {
    var t3 = this;
    return Apex._chartInstances.filter(function(t4) {
      if (t4.group)
        return true;
    }).map(function(e2) {
      return t3.w.config.chart.group === e2.group ? e2.chart : t3;
    });
  } }, { key: "toggleSeries", value: function(t3) {
    return this.series.toggleSeries(t3);
  } }, { key: "highlightSeriesOnLegendHover", value: function(t3, e2) {
    return this.series.toggleSeriesOnHover(t3, e2);
  } }, { key: "showSeries", value: function(t3) {
    this.series.showSeries(t3);
  } }, { key: "hideSeries", value: function(t3) {
    this.series.hideSeries(t3);
  } }, { key: "highlightSeries", value: function(t3) {
    this.series.highlightSeries(t3);
  } }, { key: "isSeriesHidden", value: function(t3) {
    this.series.isSeriesHidden(t3);
  } }, { key: "resetSeries", value: function() {
    var t3 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0], e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    this.series.resetSeries(t3, e2);
  } }, { key: "addEventListener", value: function(t3, e2) {
    this.events.addEventListener(t3, e2);
  } }, { key: "removeEventListener", value: function(t3, e2) {
    this.events.removeEventListener(t3, e2);
  } }, { key: "addXaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i && (a2 = i), a2.annotations.addXaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addYaxisAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i && (a2 = i), a2.annotations.addYaxisAnnotationExternal(t3, e2, a2);
  } }, { key: "addPointAnnotation", value: function(t3) {
    var e2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1], i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, a2 = this;
    i && (a2 = i), a2.annotations.addPointAnnotationExternal(t3, e2, a2);
  } }, { key: "clearAnnotations", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0, e2 = this;
    t3 && (e2 = t3), e2.annotations.clearAnnotations(e2);
  } }, { key: "removeAnnotation", value: function(t3) {
    var e2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0, i = this;
    e2 && (i = e2), i.annotations.removeAnnotation(i, t3);
  } }, { key: "getChartArea", value: function() {
    return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner");
  } }, { key: "getSeriesTotalXRange", value: function(t3, e2) {
    return this.coreUtils.getSeriesTotalsXRange(t3, e2);
  } }, { key: "getHighestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).highestY;
  } }, { key: "getLowestValueInSeries", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
    return new ea(this.ctx).getMinYMaxY(t3).lowestY;
  } }, { key: "getSeriesTotal", value: function() {
    return this.w.globals.seriesTotals;
  } }, { key: "toggleDataPointSelection", value: function(t3, e2) {
    return this.updateHelpers.toggleDataPointSelection(t3, e2);
  } }, { key: "zoomX", value: function(t3, e2) {
    this.ctx.toolbar.zoomUpdateOptions(t3, e2);
  } }, { key: "setLocale", value: function(t3) {
    this.localization.setCurrentLocaleValues(t3);
  } }, { key: "dataURI", value: function(t3) {
    return new Ji(this.ctx).dataURI(t3);
  } }, { key: "getSvgString", value: function(t3) {
    return new Ji(this.ctx).getSvgString(t3);
  } }, { key: "exportToCSV", value: function() {
    var t3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    return new Ji(this.ctx).exportToCSV(t3);
  } }, { key: "paper", value: function() {
    return this.w.globals.dom.Paper;
  } }, { key: "_parentResizeCallback", value: function() {
    this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize();
  } }, { key: "_windowResize", value: function() {
    var t3 = this;
    clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout(function() {
      t3.w.globals.resized = true, t3.w.globals.dataChanged = false, t3.ctx.update();
    }, 150);
  } }, { key: "_windowResizeHandler", value: function() {
    var t3 = this.w.config.chart.redrawOnWindowResize;
    "function" == typeof t3 && (t3 = t3()), t3 && this._windowResize();
  } }], [{ key: "getChartByID", value: function(t3) {
    var e2 = v.escapeString(t3);
    if (Apex._chartInstances) {
      var i = Apex._chartInstances.filter(function(t4) {
        return t4.id === e2;
      })[0];
      return i && i.chart;
    }
  } }, { key: "initOnLoad", value: function() {
    for (var e2 = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e2.length; i++) {
      new t2(e2[i], JSON.parse(e2[i].getAttribute("data-options"))).render();
    }
  } }, { key: "exec", value: function(t3, e2) {
    var i = this.getChartByID(t3);
    if (i) {
      i.w.globals.isExecCalled = true;
      var a2 = null;
      if (-1 !== i.publicMethods.indexOf(e2)) {
        for (var s2 = arguments.length, r2 = new Array(s2 > 2 ? s2 - 2 : 0), n2 = 2; n2 < s2; n2++)
          r2[n2 - 2] = arguments[n2];
        a2 = i[e2].apply(i, r2);
      }
      return a2;
    }
  } }, { key: "merge", value: function(t3, e2) {
    return v.extend(t3, e2);
  } }]), t2;
}();
const theme = "";
(function() {
  if ($("#nav-toggle").length) {
    $("#nav-toggle").on("click", function(e2) {
      e2.preventDefault();
      $("#db-wrapper").toggleClass("toggled");
    });
  }
  if ($(".nav-scroller").length) {
    $(".nav-scroller").slimScroll({
      height: "97%"
    });
  }
  if ($(".notification-list-scroll").length) {
    $(".notification-list-scroll").slimScroll({
      height: 300
    });
  }
  if ($('[data-bs-toggle="tooltip"]').length) {
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.map(function(tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl);
    });
  }
  if ($('[data-bs-toggle="popover"]').length) {
    var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="popover"]'));
    popoverTriggerList.map(function(popoverTriggerEl) {
      return new bootstrap.Popover(popoverTriggerEl);
    });
  }
  if ($('[data-bs-spy="scroll"]').length) {
    var dataSpyList = [].slice.call(document.querySelectorAll('[data-bs-spy="scroll"]'));
    dataSpyList.forEach(function(dataSpyEl) {
      bootstrap.ScrollSpy.getInstance(dataSpyEl).refresh();
    });
  }
  if ($(".toast").length) {
    var toastElList = [].slice.call(document.querySelectorAll(".toast"));
    toastElList.map(function(toastEl) {
      return new bootstrap.Toast(toastEl);
    });
  }
  if ($("#perfomanceChart").length) {
    var options = {
      series: [100, 78, 89],
      chart: {
        height: 320,
        type: "radialBar"
      },
      colors: ["#28a745", "#ffc107", "#dc3545"],
      stroke: {
        lineCap: "round"
      },
      plotOptions: {
        radialBar: {
          startAngle: -168,
          endAngle: -450,
          hollow: {
            size: "55%"
          },
          track: {
            background: "transaprent"
          },
          dataLabels: {
            show: false
          }
        }
      }
    };
    var chart = new ApexCharts(document.querySelector("#perfomanceChart"), options);
    chart.render();
  }
})();
var feather$1 = { exports: {} };
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module.exports = factory();
  })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name2, getter) {
          if (!__webpack_require__.o(exports2, name2)) {
            Object.defineProperty(exports2, name2, {
              /******/
              configurable: false,
              /******/
              enumerable: true,
              /******/
              get: getter
              /******/
            });
          }
        };
        __webpack_require__.r = function(exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? (
            /******/
            function getDefault() {
              return module2["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module2;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 0);
      }({
        /***/
        "./dist/icons.json": (
          /*!*************************!*\
            !*** ./dist/icons.json ***!
            \*************************/
          /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, aperture, archive, arrow-down-circle, arrow-down-left, arrow-down-right, arrow-down, arrow-left-circle, arrow-left, arrow-right-circle, arrow-right, arrow-up-circle, arrow-up-left, arrow-up-right, arrow-up, at-sign, award, bar-chart-2, bar-chart, battery-charging, battery, bell-off, bell, bluetooth, bold, book-open, book, bookmark, box, briefcase, calendar, camera-off, camera, cast, check-circle, check-square, check, chevron-down, chevron-left, chevron-right, chevron-up, chevrons-down, chevrons-left, chevrons-right, chevrons-up, chrome, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-off, cloud-rain, cloud-snow, cloud, code, codepen, codesandbox, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, divide-circle, divide-square, divide, dollar-sign, download-cloud, download, dribbble, droplet, edit-2, edit-3, edit, external-link, eye-off, eye, facebook, fast-forward, feather, figma, file-minus, file-plus, file-text, file, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, grid, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, info, instagram, italic, key, layers, layout, life-buoy, link-2, link, linkedin, list, loader, lock, log-in, log-out, mail, map-pin, map, maximize-2, maximize, meh, menu, message-circle, message-square, mic-off, mic, minimize-2, minimize, minus-circle, minus-square, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation-2, navigation, octagon, package, paperclip, pause-circle, pause, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, pie-chart, play-circle, play, plus-circle, plus-square, plus, pocket, power, printer, radio, refresh-ccw, refresh-cw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, server, settings, share-2, share, shield-off, shield, shopping-bag, shopping-cart, shuffle, sidebar, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, square, star, stop-circle, sun, sunrise, sunset, table, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash-2, trash, trello, trending-down, trending-up, triangle, truck, tv, twitch, twitter, type, umbrella, underline, unlock, upload-cloud, upload, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume-1, volume-2, volume-x, volume, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
          /***/
          function(module2) {
            module2.exports = { "activity": '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', "airplay": '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', "anchor": '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', "aperture": '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', "archive": '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', "award": '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', "battery": '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "bell": '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', "bluetooth": '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', "bold": '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', "book": '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', "bookmark": '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', "box": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "briefcase": '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', "calendar": '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', "camera": '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', "cast": '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', "check": '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', "chrome": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', "circle": '<circle cx="12" cy="12" r="10"></circle>', "clipboard": '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', "clock": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', "cloud": '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', "code": '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', "codepen": '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', "codesandbox": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "coffee": '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', "columns": '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', "command": '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', "compass": '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', "copy": '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', "cpu": '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', "crop": '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', "crosshair": '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', "database": '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', "delete": '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', "disc": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', "divide": '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', "download": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', "dribbble": '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', "droplet": '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', "edit": '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "eye": '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', "facebook": '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', "feather": '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', "figma": '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', "file": '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', "film": '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', "filter": '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', "flag": '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', "folder": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', "framer": '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', "frown": '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "gift": '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', "github": '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', "gitlab": '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', "globe": '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', "grid": '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', "hash": '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', "headphones": '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', "heart": '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', "hexagon": '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', "home": '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', "image": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', "inbox": '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', "info": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', "instagram": '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', "italic": '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', "key": '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', "layers": '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', "layout": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', "link": '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', "linkedin": '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', "list": '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', "loader": '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', "lock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', "mail": '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', "map": '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "maximize": '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', "meh": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "menu": '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "mic": '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', "minimize": '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', "minus": '<line x1="5" y1="12" x2="19" y2="12"></line>', "monitor": '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', "moon": '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', "move": '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', "music": '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', "navigation": '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', "octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', "package": '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', "paperclip": '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', "pause": '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', "percent": '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone": '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', "play": '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus": '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', "pocket": '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', "power": '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', "printer": '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', "radio": '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', "repeat": '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', "rewind": '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', "rss": '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', "save": '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', "scissors": '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', "search": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', "send": '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', "server": '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', "settings": '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', "share": '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "shield": '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', "shuffle": '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', "sidebar": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', "slack": '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', "slash": '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', "sliders": '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', "smartphone": '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "smile": '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', "speaker": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', "square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', "star": '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', "sun": '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', "sunrise": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', "sunset": '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', "table": '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>', "tablet": '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', "tag": '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', "target": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', "terminal": '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', "thermometer": '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', "tool": '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', "trash": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', "trello": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', "triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', "truck": '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', "tv": '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', "twitch": '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', "twitter": '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', "type": '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', "umbrella": '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', "underline": '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', "unlock": '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', "upload": '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', "user": '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', "users": '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "video": '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', "voicemail": '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', "volume": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', "watch": '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wifi": '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', "wind": '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', "x": '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', "youtube": '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', "zap": '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' };
          }
        ),
        /***/
        "./node_modules/classnames/dedupe.js": (
          /*!*******************************************!*\
            !*** ./node_modules/classnames/dedupe.js ***!
            \*******************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
            /*!
              Copyright (c) 2016 Jed Watson.
              Licensed under the MIT License (MIT), see
              http://jedwatson.github.io/classnames
            */
            (function() {
              var classNames2 = function() {
                function StorageObject() {
                }
                StorageObject.prototype = /* @__PURE__ */ Object.create(null);
                function _parseArray(resultSet, array) {
                  var length = array.length;
                  for (var i = 0; i < length; ++i) {
                    _parse(resultSet, array[i]);
                  }
                }
                var hasOwn = {}.hasOwnProperty;
                function _parseNumber(resultSet, num) {
                  resultSet[num] = true;
                }
                function _parseObject(resultSet, object) {
                  for (var k2 in object) {
                    if (hasOwn.call(object, k2)) {
                      resultSet[k2] = !!object[k2];
                    }
                  }
                }
                var SPACE = /\s+/;
                function _parseString(resultSet, str2) {
                  var array = str2.split(SPACE);
                  var length = array.length;
                  for (var i = 0; i < length; ++i) {
                    resultSet[array[i]] = true;
                  }
                }
                function _parse(resultSet, arg) {
                  if (!arg)
                    return;
                  var argType = typeof arg;
                  if (argType === "string") {
                    _parseString(resultSet, arg);
                  } else if (Array.isArray(arg)) {
                    _parseArray(resultSet, arg);
                  } else if (argType === "object") {
                    _parseObject(resultSet, arg);
                  } else if (argType === "number") {
                    _parseNumber(resultSet, arg);
                  }
                }
                function _classNames() {
                  var len = arguments.length;
                  var args = Array(len);
                  for (var i = 0; i < len; i++) {
                    args[i] = arguments[i];
                  }
                  var classSet = new StorageObject();
                  _parseArray(classSet, args);
                  var list2 = [];
                  for (var k2 in classSet) {
                    if (classSet[k2]) {
                      list2.push(k2);
                    }
                  }
                  return list2.join(" ");
                }
                return _classNames;
              }();
              if (typeof module2 !== "undefined" && module2.exports) {
                module2.exports = classNames2;
              } else {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                  return classNames2;
                }).apply(exports2, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
              }
            })();
          }
        ),
        /***/
        "./node_modules/core-js/es/array/from.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/es/array/from.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(
              /*! ../../modules/es.string.iterator */
              "./node_modules/core-js/modules/es.string.iterator.js"
            );
            __webpack_require__(
              /*! ../../modules/es.array.from */
              "./node_modules/core-js/modules/es.array.from.js"
            );
            var path = __webpack_require__(
              /*! ../../internals/path */
              "./node_modules/core-js/internals/path.js"
            );
            module2.exports = path.Array.from;
          }
        ),
        /***/
        "./node_modules/core-js/internals/a-function.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/a-function.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              if (typeof it2 != "function") {
                throw TypeError(String(it2) + " is not a function");
              }
              return it2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/an-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/an-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            module2.exports = function(it2) {
              if (!isObject2(it2)) {
                throw TypeError(String(it2) + " is not an object");
              }
              return it2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/array-from.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/array-from.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var bind2 = __webpack_require__(
              /*! ../internals/bind-context */
              "./node_modules/core-js/internals/bind-context.js"
            );
            var toObject = __webpack_require__(
              /*! ../internals/to-object */
              "./node_modules/core-js/internals/to-object.js"
            );
            var callWithSafeIterationClosing = __webpack_require__(
              /*! ../internals/call-with-safe-iteration-closing */
              "./node_modules/core-js/internals/call-with-safe-iteration-closing.js"
            );
            var isArrayIteratorMethod = __webpack_require__(
              /*! ../internals/is-array-iterator-method */
              "./node_modules/core-js/internals/is-array-iterator-method.js"
            );
            var toLength = __webpack_require__(
              /*! ../internals/to-length */
              "./node_modules/core-js/internals/to-length.js"
            );
            var createProperty = __webpack_require__(
              /*! ../internals/create-property */
              "./node_modules/core-js/internals/create-property.js"
            );
            var getIteratorMethod = __webpack_require__(
              /*! ../internals/get-iterator-method */
              "./node_modules/core-js/internals/get-iterator-method.js"
            );
            module2.exports = function from(arrayLike) {
              var O2 = toObject(arrayLike);
              var C2 = typeof this == "function" ? this : Array;
              var argumentsLength = arguments.length;
              var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
              var mapping = mapfn !== void 0;
              var index = 0;
              var iteratorMethod = getIteratorMethod(O2);
              var length, result, step, iterator;
              if (mapping)
                mapfn = bind2(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
              if (iteratorMethod != void 0 && !(C2 == Array && isArrayIteratorMethod(iteratorMethod))) {
                iterator = iteratorMethod.call(O2);
                result = new C2();
                for (; !(step = iterator.next()).done; index++) {
                  createProperty(
                    result,
                    index,
                    mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value
                  );
                }
              } else {
                length = toLength(O2.length);
                result = new C2(length);
                for (; length > index; index++) {
                  createProperty(result, index, mapping ? mapfn(O2[index], index) : O2[index]);
                }
              }
              result.length = index;
              return result;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/array-includes.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/array-includes.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toIndexedObject = __webpack_require__(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            );
            var toLength = __webpack_require__(
              /*! ../internals/to-length */
              "./node_modules/core-js/internals/to-length.js"
            );
            var toAbsoluteIndex = __webpack_require__(
              /*! ../internals/to-absolute-index */
              "./node_modules/core-js/internals/to-absolute-index.js"
            );
            module2.exports = function(IS_INCLUDES) {
              return function($this, el, fromIndex) {
                var O2 = toIndexedObject($this);
                var length = toLength(O2.length);
                var index = toAbsoluteIndex(fromIndex, length);
                var value;
                if (IS_INCLUDES && el != el)
                  while (length > index) {
                    value = O2[index++];
                    if (value != value)
                      return true;
                  }
                else
                  for (; length > index; index++)
                    if (IS_INCLUDES || index in O2) {
                      if (O2[index] === el)
                        return IS_INCLUDES || index || 0;
                    }
                return !IS_INCLUDES && -1;
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/bind-context.js": (
          /*!********************************************************!*\
            !*** ./node_modules/core-js/internals/bind-context.js ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var aFunction = __webpack_require__(
              /*! ../internals/a-function */
              "./node_modules/core-js/internals/a-function.js"
            );
            module2.exports = function(fn3, that, length) {
              aFunction(fn3);
              if (that === void 0)
                return fn3;
              switch (length) {
                case 0:
                  return function() {
                    return fn3.call(that);
                  };
                case 1:
                  return function(a2) {
                    return fn3.call(that, a2);
                  };
                case 2:
                  return function(a2, b2) {
                    return fn3.call(that, a2, b2);
                  };
                case 3:
                  return function(a2, b2, c2) {
                    return fn3.call(that, a2, b2, c2);
                  };
              }
              return function() {
                return fn3.apply(that, arguments);
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": (
          /*!****************************************************************************!*\
            !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
            \****************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            module2.exports = function(iterator, fn3, value, ENTRIES) {
              try {
                return ENTRIES ? fn3(anObject(value)[0], value[1]) : fn3(value);
              } catch (error2) {
                var returnMethod = iterator["return"];
                if (returnMethod !== void 0)
                  anObject(returnMethod.call(iterator));
                throw error2;
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/check-correctness-of-iteration.js": (
          /*!**************************************************************************!*\
            !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
            \**************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var ITERATOR = wellKnownSymbol("iterator");
            var SAFE_CLOSING = false;
            try {
              var called = 0;
              var iteratorWithReturn = {
                next: function() {
                  return { done: !!called++ };
                },
                "return": function() {
                  SAFE_CLOSING = true;
                }
              };
              iteratorWithReturn[ITERATOR] = function() {
                return this;
              };
              Array.from(iteratorWithReturn, function() {
                throw 2;
              });
            } catch (error2) {
            }
            module2.exports = function(exec, SKIP_CLOSING) {
              if (!SKIP_CLOSING && !SAFE_CLOSING)
                return false;
              var ITERATION_SUPPORT = false;
              try {
                var object = {};
                object[ITERATOR] = function() {
                  return {
                    next: function() {
                      return { done: ITERATION_SUPPORT = true };
                    }
                  };
                };
                exec(object);
              } catch (error2) {
              }
              return ITERATION_SUPPORT;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/classof-raw.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/classof-raw.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            var toString3 = {}.toString;
            module2.exports = function(it2) {
              return toString3.call(it2).slice(8, -1);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/classof.js": (
          /*!***************************************************!*\
            !*** ./node_modules/core-js/internals/classof.js ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var classofRaw = __webpack_require__(
              /*! ../internals/classof-raw */
              "./node_modules/core-js/internals/classof-raw.js"
            );
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            var CORRECT_ARGUMENTS = classofRaw(function() {
              return arguments;
            }()) == "Arguments";
            var tryGet = function(it2, key) {
              try {
                return it2[key];
              } catch (error2) {
              }
            };
            module2.exports = function(it2) {
              var O2, tag, result;
              return it2 === void 0 ? "Undefined" : it2 === null ? "Null" : typeof (tag = tryGet(O2 = Object(it2), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && typeof O2.callee == "function" ? "Arguments" : result;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/copy-constructor-properties.js": (
          /*!***********************************************************************!*\
            !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
            \***********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var ownKeys = __webpack_require__(
              /*! ../internals/own-keys */
              "./node_modules/core-js/internals/own-keys.js"
            );
            var getOwnPropertyDescriptorModule = __webpack_require__(
              /*! ../internals/object-get-own-property-descriptor */
              "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
            );
            var definePropertyModule = __webpack_require__(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            );
            module2.exports = function(target, source) {
              var keys = ownKeys(source);
              var defineProperty2 = definePropertyModule.f;
              var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
              for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                if (!has(target, key))
                  defineProperty2(target, key, getOwnPropertyDescriptor(source, key));
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/correct-prototype-getter.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            module2.exports = !fails(function() {
              function F2() {
              }
              F2.prototype.constructor = null;
              return Object.getPrototypeOf(new F2()) !== F2.prototype;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-iterator-constructor.js": (
          /*!***********************************************************************!*\
            !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
            \***********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var IteratorPrototype = __webpack_require__(
              /*! ../internals/iterators-core */
              "./node_modules/core-js/internals/iterators-core.js"
            ).IteratorPrototype;
            var create2 = __webpack_require__(
              /*! ../internals/object-create */
              "./node_modules/core-js/internals/object-create.js"
            );
            var createPropertyDescriptor = __webpack_require__(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            var setToStringTag = __webpack_require__(
              /*! ../internals/set-to-string-tag */
              "./node_modules/core-js/internals/set-to-string-tag.js"
            );
            var Iterators = __webpack_require__(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            );
            var returnThis = function() {
              return this;
            };
            module2.exports = function(IteratorConstructor, NAME2, next) {
              var TO_STRING_TAG = NAME2 + " Iterator";
              IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
              setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
              Iterators[TO_STRING_TAG] = returnThis;
              return IteratorConstructor;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-property-descriptor.js": (
          /*!**********************************************************************!*\
            !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
            \**********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/create-property.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/create-property.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toPrimitive = __webpack_require__(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            );
            var definePropertyModule = __webpack_require__(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            );
            var createPropertyDescriptor = __webpack_require__(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            module2.exports = function(object, key, value) {
              var propertyKey = toPrimitive(key);
              if (propertyKey in object)
                definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
              else
                object[propertyKey] = value;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/define-iterator.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/define-iterator.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__(
              /*! ../internals/export */
              "./node_modules/core-js/internals/export.js"
            );
            var createIteratorConstructor = __webpack_require__(
              /*! ../internals/create-iterator-constructor */
              "./node_modules/core-js/internals/create-iterator-constructor.js"
            );
            var getPrototypeOf2 = __webpack_require__(
              /*! ../internals/object-get-prototype-of */
              "./node_modules/core-js/internals/object-get-prototype-of.js"
            );
            var setPrototypeOf = __webpack_require__(
              /*! ../internals/object-set-prototype-of */
              "./node_modules/core-js/internals/object-set-prototype-of.js"
            );
            var setToStringTag = __webpack_require__(
              /*! ../internals/set-to-string-tag */
              "./node_modules/core-js/internals/set-to-string-tag.js"
            );
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            var redefine = __webpack_require__(
              /*! ../internals/redefine */
              "./node_modules/core-js/internals/redefine.js"
            );
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var IS_PURE = __webpack_require__(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            );
            var Iterators = __webpack_require__(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            );
            var IteratorsCore = __webpack_require__(
              /*! ../internals/iterators-core */
              "./node_modules/core-js/internals/iterators-core.js"
            );
            var IteratorPrototype = IteratorsCore.IteratorPrototype;
            var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
            var ITERATOR = wellKnownSymbol("iterator");
            var KEYS = "keys";
            var VALUES = "values";
            var ENTRIES = "entries";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
              createIteratorConstructor(IteratorConstructor, NAME2, next);
              var getIterationMethod = function(KIND) {
                if (KIND === DEFAULT && defaultIterator)
                  return defaultIterator;
                if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                  return IterablePrototype[KIND];
                switch (KIND) {
                  case KEYS:
                    return function keys() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case VALUES:
                    return function values() {
                      return new IteratorConstructor(this, KIND);
                    };
                  case ENTRIES:
                    return function entries() {
                      return new IteratorConstructor(this, KIND);
                    };
                }
                return function() {
                  return new IteratorConstructor(this);
                };
              };
              var TO_STRING_TAG = NAME2 + " Iterator";
              var INCORRECT_VALUES_NAME = false;
              var IterablePrototype = Iterable.prototype;
              var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT && IterablePrototype[DEFAULT];
              var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
              var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
              var CurrentIteratorPrototype, methods2, KEY;
              if (anyNativeIterator) {
                CurrentIteratorPrototype = getPrototypeOf2(anyNativeIterator.call(new Iterable()));
                if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                  if (!IS_PURE && getPrototypeOf2(CurrentIteratorPrototype) !== IteratorPrototype) {
                    if (setPrototypeOf) {
                      setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                    } else if (typeof CurrentIteratorPrototype[ITERATOR] != "function") {
                      hide2(CurrentIteratorPrototype, ITERATOR, returnThis);
                    }
                  }
                  setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                  if (IS_PURE)
                    Iterators[TO_STRING_TAG] = returnThis;
                }
              }
              if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() {
                  return nativeIterator.call(this);
                };
              }
              if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
                hide2(IterablePrototype, ITERATOR, defaultIterator);
              }
              Iterators[NAME2] = defaultIterator;
              if (DEFAULT) {
                methods2 = {
                  values: getIterationMethod(VALUES),
                  keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                  entries: getIterationMethod(ENTRIES)
                };
                if (FORCED)
                  for (KEY in methods2) {
                    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                      redefine(IterablePrototype, KEY, methods2[KEY]);
                    }
                  }
                else
                  $2({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods2);
              }
              return methods2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/descriptors.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/descriptors.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            module2.exports = !fails(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/document-create-element.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/document-create-element.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var isObject2 = __webpack_require__(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            var document2 = global2.document;
            var exist = isObject2(document2) && isObject2(document2.createElement);
            module2.exports = function(it2) {
              return exist ? document2.createElement(it2) : {};
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/enum-bug-keys.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = [
              "constructor",
              "hasOwnProperty",
              "isPrototypeOf",
              "propertyIsEnumerable",
              "toLocaleString",
              "toString",
              "valueOf"
            ];
          }
        ),
        /***/
        "./node_modules/core-js/internals/export.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/export.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var getOwnPropertyDescriptor = __webpack_require__(
              /*! ../internals/object-get-own-property-descriptor */
              "./node_modules/core-js/internals/object-get-own-property-descriptor.js"
            ).f;
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            var redefine = __webpack_require__(
              /*! ../internals/redefine */
              "./node_modules/core-js/internals/redefine.js"
            );
            var setGlobal = __webpack_require__(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            );
            var copyConstructorProperties = __webpack_require__(
              /*! ../internals/copy-constructor-properties */
              "./node_modules/core-js/internals/copy-constructor-properties.js"
            );
            var isForced = __webpack_require__(
              /*! ../internals/is-forced */
              "./node_modules/core-js/internals/is-forced.js"
            );
            module2.exports = function(options, source) {
              var TARGET = options.target;
              var GLOBAL = options.global;
              var STATIC = options.stat;
              var FORCED, target, key, targetProperty, sourceProperty, descriptor;
              if (GLOBAL) {
                target = global2;
              } else if (STATIC) {
                target = global2[TARGET] || setGlobal(TARGET, {});
              } else {
                target = (global2[TARGET] || {}).prototype;
              }
              if (target)
                for (key in source) {
                  sourceProperty = source[key];
                  if (options.noTargetGet) {
                    descriptor = getOwnPropertyDescriptor(target, key);
                    targetProperty = descriptor && descriptor.value;
                  } else
                    targetProperty = target[key];
                  FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
                  if (!FORCED && targetProperty !== void 0) {
                    if (typeof sourceProperty === typeof targetProperty)
                      continue;
                    copyConstructorProperties(sourceProperty, targetProperty);
                  }
                  if (options.sham || targetProperty && targetProperty.sham) {
                    hide2(sourceProperty, "sham", true);
                  }
                  redefine(target, key, sourceProperty, options);
                }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/fails.js": (
          /*!*************************************************!*\
            !*** ./node_modules/core-js/internals/fails.js ***!
            \*************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (error2) {
                return true;
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/function-to-string.js": (
          /*!**************************************************************!*\
            !*** ./node_modules/core-js/internals/function-to-string.js ***!
            \**************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var shared = __webpack_require__(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            );
            module2.exports = shared("native-function-to-string", Function.toString);
          }
        ),
        /***/
        "./node_modules/core-js/internals/get-iterator-method.js": (
          /*!***************************************************************!*\
            !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
            \***************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var classof = __webpack_require__(
              /*! ../internals/classof */
              "./node_modules/core-js/internals/classof.js"
            );
            var Iterators = __webpack_require__(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            );
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var ITERATOR = wellKnownSymbol("iterator");
            module2.exports = function(it2) {
              if (it2 != void 0)
                return it2[ITERATOR] || it2["@@iterator"] || Iterators[classof(it2)];
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/global.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/global.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            (function(global2) {
              var O2 = "object";
              var check = function(it2) {
                return it2 && it2.Math == Math && it2;
              };
              module2.exports = // eslint-disable-next-line no-undef
              check(typeof globalThis == O2 && globalThis) || check(typeof window == O2 && window) || check(typeof self == O2 && self) || check(typeof global2 == O2 && global2) || // eslint-disable-next-line no-new-func
              Function("return this")();
            }).call(this, __webpack_require__(
              /*! ./../../webpack/buildin/global.js */
              "./node_modules/webpack/buildin/global.js"
            ));
          }
        ),
        /***/
        "./node_modules/core-js/internals/has.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/internals/has.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            var hasOwnProperty2 = {}.hasOwnProperty;
            module2.exports = function(it2, key) {
              return hasOwnProperty2.call(it2, key);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/hidden-keys.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/hidden-keys.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = {};
          }
        ),
        /***/
        "./node_modules/core-js/internals/hide.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/hide.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            );
            var definePropertyModule = __webpack_require__(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            );
            var createPropertyDescriptor = __webpack_require__(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            module2.exports = DESCRIPTORS ? function(object, key, value) {
              return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/html.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/html.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var document2 = global2.document;
            module2.exports = document2 && document2.documentElement;
          }
        ),
        /***/
        "./node_modules/core-js/internals/ie8-dom-define.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            );
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            var createElement2 = __webpack_require__(
              /*! ../internals/document-create-element */
              "./node_modules/core-js/internals/document-create-element.js"
            );
            module2.exports = !DESCRIPTORS && !fails(function() {
              return Object.defineProperty(createElement2("div"), "a", {
                get: function() {
                  return 7;
                }
              }).a != 7;
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/indexed-object.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/indexed-object.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            var classof = __webpack_require__(
              /*! ../internals/classof-raw */
              "./node_modules/core-js/internals/classof-raw.js"
            );
            var split = "".split;
            module2.exports = fails(function() {
              return !Object("z").propertyIsEnumerable(0);
            }) ? function(it2) {
              return classof(it2) == "String" ? split.call(it2, "") : Object(it2);
            } : Object;
          }
        ),
        /***/
        "./node_modules/core-js/internals/internal-state.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/internal-state.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var NATIVE_WEAK_MAP = __webpack_require__(
              /*! ../internals/native-weak-map */
              "./node_modules/core-js/internals/native-weak-map.js"
            );
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var isObject2 = __webpack_require__(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            var objectHas = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var sharedKey = __webpack_require__(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            );
            var hiddenKeys = __webpack_require__(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            );
            var WeakMap2 = global2.WeakMap;
            var set, get, has;
            var enforce = function(it2) {
              return has(it2) ? get(it2) : set(it2, {});
            };
            var getterFor = function(TYPE) {
              return function(it2) {
                var state2;
                if (!isObject2(it2) || (state2 = get(it2)).type !== TYPE) {
                  throw TypeError("Incompatible receiver, " + TYPE + " required");
                }
                return state2;
              };
            };
            if (NATIVE_WEAK_MAP) {
              var store = new WeakMap2();
              var wmget = store.get;
              var wmhas = store.has;
              var wmset = store.set;
              set = function(it2, metadata) {
                wmset.call(store, it2, metadata);
                return metadata;
              };
              get = function(it2) {
                return wmget.call(store, it2) || {};
              };
              has = function(it2) {
                return wmhas.call(store, it2);
              };
            } else {
              var STATE = sharedKey("state");
              hiddenKeys[STATE] = true;
              set = function(it2, metadata) {
                hide2(it2, STATE, metadata);
                return metadata;
              };
              get = function(it2) {
                return objectHas(it2, STATE) ? it2[STATE] : {};
              };
              has = function(it2) {
                return objectHas(it2, STATE);
              };
            }
            module2.exports = {
              set,
              get,
              has,
              enforce,
              getterFor
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-array-iterator-method.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var Iterators = __webpack_require__(
              /*! ../internals/iterators */
              "./node_modules/core-js/internals/iterators.js"
            );
            var ITERATOR = wellKnownSymbol("iterator");
            var ArrayPrototype = Array.prototype;
            module2.exports = function(it2) {
              return it2 !== void 0 && (Iterators.Array === it2 || ArrayPrototype[ITERATOR] === it2);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-forced.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/is-forced.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            var replacement = /#|\.prototype\./;
            var isForced = function(feature, detection) {
              var value = data2[normalize2(feature)];
              return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == "function" ? fails(detection) : !!detection;
            };
            var normalize2 = isForced.normalize = function(string) {
              return String(string).replace(replacement, ".").toLowerCase();
            };
            var data2 = isForced.data = {};
            var NATIVE = isForced.NATIVE = "N";
            var POLYFILL = isForced.POLYFILL = "P";
            module2.exports = isForced;
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/is-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              return typeof it2 === "object" ? it2 !== null : typeof it2 === "function";
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/is-pure.js": (
          /*!***************************************************!*\
            !*** ./node_modules/core-js/internals/is-pure.js ***!
            \***************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = false;
          }
        ),
        /***/
        "./node_modules/core-js/internals/iterators-core.js": (
          /*!**********************************************************!*\
            !*** ./node_modules/core-js/internals/iterators-core.js ***!
            \**********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var getPrototypeOf2 = __webpack_require__(
              /*! ../internals/object-get-prototype-of */
              "./node_modules/core-js/internals/object-get-prototype-of.js"
            );
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var IS_PURE = __webpack_require__(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            );
            var ITERATOR = wellKnownSymbol("iterator");
            var BUGGY_SAFARI_ITERATORS = false;
            var returnThis = function() {
              return this;
            };
            var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
            if ([].keys) {
              arrayIterator = [].keys();
              if (!("next" in arrayIterator))
                BUGGY_SAFARI_ITERATORS = true;
              else {
                PrototypeOfArrayIteratorPrototype = getPrototypeOf2(getPrototypeOf2(arrayIterator));
                if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                  IteratorPrototype = PrototypeOfArrayIteratorPrototype;
              }
            }
            if (IteratorPrototype == void 0)
              IteratorPrototype = {};
            if (!IS_PURE && !has(IteratorPrototype, ITERATOR))
              hide2(IteratorPrototype, ITERATOR, returnThis);
            module2.exports = {
              IteratorPrototype,
              BUGGY_SAFARI_ITERATORS
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/iterators.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/iterators.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = {};
          }
        ),
        /***/
        "./node_modules/core-js/internals/native-symbol.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/native-symbol.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var fails = __webpack_require__(
              /*! ../internals/fails */
              "./node_modules/core-js/internals/fails.js"
            );
            module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
              return !String(Symbol());
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/native-weak-map.js": (
          /*!***********************************************************!*\
            !*** ./node_modules/core-js/internals/native-weak-map.js ***!
            \***********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var nativeFunctionToString = __webpack_require__(
              /*! ../internals/function-to-string */
              "./node_modules/core-js/internals/function-to-string.js"
            );
            var WeakMap2 = global2.WeakMap;
            module2.exports = typeof WeakMap2 === "function" && /native code/.test(nativeFunctionToString.call(WeakMap2));
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-create.js": (
          /*!*********************************************************!*\
            !*** ./node_modules/core-js/internals/object-create.js ***!
            \*********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            var defineProperties = __webpack_require__(
              /*! ../internals/object-define-properties */
              "./node_modules/core-js/internals/object-define-properties.js"
            );
            var enumBugKeys = __webpack_require__(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            );
            var hiddenKeys = __webpack_require__(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            );
            var html = __webpack_require__(
              /*! ../internals/html */
              "./node_modules/core-js/internals/html.js"
            );
            var documentCreateElement = __webpack_require__(
              /*! ../internals/document-create-element */
              "./node_modules/core-js/internals/document-create-element.js"
            );
            var sharedKey = __webpack_require__(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            );
            var IE_PROTO = sharedKey("IE_PROTO");
            var PROTOTYPE = "prototype";
            var Empty = function() {
            };
            var createDict = function() {
              var iframe = documentCreateElement("iframe");
              var length = enumBugKeys.length;
              var lt2 = "<";
              var script = "script";
              var gt2 = ">";
              var js = "java" + script + ":";
              var iframeDocument;
              iframe.style.display = "none";
              html.appendChild(iframe);
              iframe.src = String(js);
              iframeDocument = iframe.contentWindow.document;
              iframeDocument.open();
              iframeDocument.write(lt2 + script + gt2 + "document.F=Object" + lt2 + "/" + script + gt2);
              iframeDocument.close();
              createDict = iframeDocument.F;
              while (length--)
                delete createDict[PROTOTYPE][enumBugKeys[length]];
              return createDict();
            };
            module2.exports = Object.create || function create2(O2, Properties) {
              var result;
              if (O2 !== null) {
                Empty[PROTOTYPE] = anObject(O2);
                result = new Empty();
                Empty[PROTOTYPE] = null;
                result[IE_PROTO] = O2;
              } else
                result = createDict();
              return Properties === void 0 ? result : defineProperties(result, Properties);
            };
            hiddenKeys[IE_PROTO] = true;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-define-properties.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/object-define-properties.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            );
            var definePropertyModule = __webpack_require__(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            );
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            var objectKeys = __webpack_require__(
              /*! ../internals/object-keys */
              "./node_modules/core-js/internals/object-keys.js"
            );
            module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O2, Properties) {
              anObject(O2);
              var keys = objectKeys(Properties);
              var length = keys.length;
              var i = 0;
              var key;
              while (length > i)
                definePropertyModule.f(O2, key = keys[i++], Properties[key]);
              return O2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-define-property.js": (
          /*!******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-define-property.js ***!
            \******************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            );
            var IE8_DOM_DEFINE = __webpack_require__(
              /*! ../internals/ie8-dom-define */
              "./node_modules/core-js/internals/ie8-dom-define.js"
            );
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            var toPrimitive = __webpack_require__(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            );
            var nativeDefineProperty = Object.defineProperty;
            exports2.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty2(O2, P2, Attributes) {
              anObject(O2);
              P2 = toPrimitive(P2, true);
              anObject(Attributes);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeDefineProperty(O2, P2, Attributes);
                } catch (error2) {
                }
              if ("get" in Attributes || "set" in Attributes)
                throw TypeError("Accessors not supported");
              if ("value" in Attributes)
                O2[P2] = Attributes.value;
              return O2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-descriptor.js": (
          /*!******************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
            \******************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var DESCRIPTORS = __webpack_require__(
              /*! ../internals/descriptors */
              "./node_modules/core-js/internals/descriptors.js"
            );
            var propertyIsEnumerableModule = __webpack_require__(
              /*! ../internals/object-property-is-enumerable */
              "./node_modules/core-js/internals/object-property-is-enumerable.js"
            );
            var createPropertyDescriptor = __webpack_require__(
              /*! ../internals/create-property-descriptor */
              "./node_modules/core-js/internals/create-property-descriptor.js"
            );
            var toIndexedObject = __webpack_require__(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            );
            var toPrimitive = __webpack_require__(
              /*! ../internals/to-primitive */
              "./node_modules/core-js/internals/to-primitive.js"
            );
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var IE8_DOM_DEFINE = __webpack_require__(
              /*! ../internals/ie8-dom-define */
              "./node_modules/core-js/internals/ie8-dom-define.js"
            );
            var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            exports2.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
              O2 = toIndexedObject(O2);
              P2 = toPrimitive(P2, true);
              if (IE8_DOM_DEFINE)
                try {
                  return nativeGetOwnPropertyDescriptor(O2, P2);
                } catch (error2) {
                }
              if (has(O2, P2))
                return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O2, P2), O2[P2]);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-names.js": (
          /*!*************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
            \*************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var internalObjectKeys = __webpack_require__(
              /*! ../internals/object-keys-internal */
              "./node_modules/core-js/internals/object-keys-internal.js"
            );
            var enumBugKeys = __webpack_require__(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            );
            var hiddenKeys = enumBugKeys.concat("length", "prototype");
            exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
              return internalObjectKeys(O2, hiddenKeys);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-own-property-symbols.js": (
          /*!***************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
            \***************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            exports2.f = Object.getOwnPropertySymbols;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-get-prototype-of.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var toObject = __webpack_require__(
              /*! ../internals/to-object */
              "./node_modules/core-js/internals/to-object.js"
            );
            var sharedKey = __webpack_require__(
              /*! ../internals/shared-key */
              "./node_modules/core-js/internals/shared-key.js"
            );
            var CORRECT_PROTOTYPE_GETTER = __webpack_require__(
              /*! ../internals/correct-prototype-getter */
              "./node_modules/core-js/internals/correct-prototype-getter.js"
            );
            var IE_PROTO = sharedKey("IE_PROTO");
            var ObjectPrototype = Object.prototype;
            module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O2) {
              O2 = toObject(O2);
              if (has(O2, IE_PROTO))
                return O2[IE_PROTO];
              if (typeof O2.constructor == "function" && O2 instanceof O2.constructor) {
                return O2.constructor.prototype;
              }
              return O2 instanceof Object ? ObjectPrototype : null;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-keys-internal.js": (
          /*!****************************************************************!*\
            !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
            \****************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var toIndexedObject = __webpack_require__(
              /*! ../internals/to-indexed-object */
              "./node_modules/core-js/internals/to-indexed-object.js"
            );
            var arrayIncludes = __webpack_require__(
              /*! ../internals/array-includes */
              "./node_modules/core-js/internals/array-includes.js"
            );
            var hiddenKeys = __webpack_require__(
              /*! ../internals/hidden-keys */
              "./node_modules/core-js/internals/hidden-keys.js"
            );
            var arrayIndexOf = arrayIncludes(false);
            module2.exports = function(object, names) {
              var O2 = toIndexedObject(object);
              var i = 0;
              var result = [];
              var key;
              for (key in O2)
                !has(hiddenKeys, key) && has(O2, key) && result.push(key);
              while (names.length > i)
                if (has(O2, key = names[i++])) {
                  ~arrayIndexOf(result, key) || result.push(key);
                }
              return result;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-keys.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/internals/object-keys.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var internalObjectKeys = __webpack_require__(
              /*! ../internals/object-keys-internal */
              "./node_modules/core-js/internals/object-keys-internal.js"
            );
            var enumBugKeys = __webpack_require__(
              /*! ../internals/enum-bug-keys */
              "./node_modules/core-js/internals/enum-bug-keys.js"
            );
            module2.exports = Object.keys || function keys(O2) {
              return internalObjectKeys(O2, enumBugKeys);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-property-is-enumerable.js": (
          /*!*************************************************************************!*\
            !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
            \*************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
            var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
            var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);
            exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
              var descriptor = getOwnPropertyDescriptor(this, V2);
              return !!descriptor && descriptor.enumerable;
            } : nativePropertyIsEnumerable;
          }
        ),
        /***/
        "./node_modules/core-js/internals/object-set-prototype-of.js": (
          /*!*******************************************************************!*\
            !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
            \*******************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var validateSetPrototypeOfArguments = __webpack_require__(
              /*! ../internals/validate-set-prototype-of-arguments */
              "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"
            );
            module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
              var correctSetter = false;
              var test2 = {};
              var setter;
              try {
                setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
                setter.call(test2, []);
                correctSetter = test2 instanceof Array;
              } catch (error2) {
              }
              return function setPrototypeOf(O2, proto) {
                validateSetPrototypeOfArguments(O2, proto);
                if (correctSetter)
                  setter.call(O2, proto);
                else
                  O2.__proto__ = proto;
                return O2;
              };
            }() : void 0);
          }
        ),
        /***/
        "./node_modules/core-js/internals/own-keys.js": (
          /*!****************************************************!*\
            !*** ./node_modules/core-js/internals/own-keys.js ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var getOwnPropertyNamesModule = __webpack_require__(
              /*! ../internals/object-get-own-property-names */
              "./node_modules/core-js/internals/object-get-own-property-names.js"
            );
            var getOwnPropertySymbolsModule = __webpack_require__(
              /*! ../internals/object-get-own-property-symbols */
              "./node_modules/core-js/internals/object-get-own-property-symbols.js"
            );
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            var Reflect2 = global2.Reflect;
            module2.exports = Reflect2 && Reflect2.ownKeys || function ownKeys(it2) {
              var keys = getOwnPropertyNamesModule.f(anObject(it2));
              var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
              return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it2)) : keys;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/path.js": (
          /*!************************************************!*\
            !*** ./node_modules/core-js/internals/path.js ***!
            \************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            module2.exports = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
          }
        ),
        /***/
        "./node_modules/core-js/internals/redefine.js": (
          /*!****************************************************!*\
            !*** ./node_modules/core-js/internals/redefine.js ***!
            \****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var shared = __webpack_require__(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            );
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var setGlobal = __webpack_require__(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            );
            var nativeFunctionToString = __webpack_require__(
              /*! ../internals/function-to-string */
              "./node_modules/core-js/internals/function-to-string.js"
            );
            var InternalStateModule = __webpack_require__(
              /*! ../internals/internal-state */
              "./node_modules/core-js/internals/internal-state.js"
            );
            var getInternalState = InternalStateModule.get;
            var enforceInternalState = InternalStateModule.enforce;
            var TEMPLATE = String(nativeFunctionToString).split("toString");
            shared("inspectSource", function(it2) {
              return nativeFunctionToString.call(it2);
            });
            (module2.exports = function(O2, key, value, options) {
              var unsafe = options ? !!options.unsafe : false;
              var simple = options ? !!options.enumerable : false;
              var noTargetGet = options ? !!options.noTargetGet : false;
              if (typeof value == "function") {
                if (typeof key == "string" && !has(value, "name"))
                  hide2(value, "name", key);
                enforceInternalState(value).source = TEMPLATE.join(typeof key == "string" ? key : "");
              }
              if (O2 === global2) {
                if (simple)
                  O2[key] = value;
                else
                  setGlobal(key, value);
                return;
              } else if (!unsafe) {
                delete O2[key];
              } else if (!noTargetGet && O2[key]) {
                simple = true;
              }
              if (simple)
                O2[key] = value;
              else
                hide2(O2, key, value);
            })(Function.prototype, "toString", function toString3() {
              return typeof this == "function" && getInternalState(this).source || nativeFunctionToString.call(this);
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/require-object-coercible.js": (
          /*!********************************************************************!*\
            !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
            \********************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            module2.exports = function(it2) {
              if (it2 == void 0)
                throw TypeError("Can't call method on " + it2);
              return it2;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/set-global.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/set-global.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var hide2 = __webpack_require__(
              /*! ../internals/hide */
              "./node_modules/core-js/internals/hide.js"
            );
            module2.exports = function(key, value) {
              try {
                hide2(global2, key, value);
              } catch (error2) {
                global2[key] = value;
              }
              return value;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/set-to-string-tag.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var defineProperty2 = __webpack_require__(
              /*! ../internals/object-define-property */
              "./node_modules/core-js/internals/object-define-property.js"
            ).f;
            var has = __webpack_require__(
              /*! ../internals/has */
              "./node_modules/core-js/internals/has.js"
            );
            var wellKnownSymbol = __webpack_require__(
              /*! ../internals/well-known-symbol */
              "./node_modules/core-js/internals/well-known-symbol.js"
            );
            var TO_STRING_TAG = wellKnownSymbol("toStringTag");
            module2.exports = function(it2, TAG, STATIC) {
              if (it2 && !has(it2 = STATIC ? it2 : it2.prototype, TO_STRING_TAG)) {
                defineProperty2(it2, TO_STRING_TAG, { configurable: true, value: TAG });
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/shared-key.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/shared-key.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var shared = __webpack_require__(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            );
            var uid = __webpack_require__(
              /*! ../internals/uid */
              "./node_modules/core-js/internals/uid.js"
            );
            var keys = shared("keys");
            module2.exports = function(key) {
              return keys[key] || (keys[key] = uid(key));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/shared.js": (
          /*!**************************************************!*\
            !*** ./node_modules/core-js/internals/shared.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var setGlobal = __webpack_require__(
              /*! ../internals/set-global */
              "./node_modules/core-js/internals/set-global.js"
            );
            var IS_PURE = __webpack_require__(
              /*! ../internals/is-pure */
              "./node_modules/core-js/internals/is-pure.js"
            );
            var SHARED = "__core-js_shared__";
            var store = global2[SHARED] || setGlobal(SHARED, {});
            (module2.exports = function(key, value) {
              return store[key] || (store[key] = value !== void 0 ? value : {});
            })("versions", []).push({
              version: "3.1.3",
              mode: IS_PURE ? "pure" : "global",
              copyright: "© 2019 Denis Pushkarev (zloirock.ru)"
            });
          }
        ),
        /***/
        "./node_modules/core-js/internals/string-at.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/string-at.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            );
            var requireObjectCoercible = __webpack_require__(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            module2.exports = function(that, pos, CONVERT_TO_STRING) {
              var S2 = String(requireObjectCoercible(that));
              var position = toInteger(pos);
              var size = S2.length;
              var first, second;
              if (position < 0 || position >= size)
                return CONVERT_TO_STRING ? "" : void 0;
              first = S2.charCodeAt(position);
              return first < 55296 || first > 56319 || position + 1 === size || (second = S2.charCodeAt(position + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S2.charAt(position) : first : CONVERT_TO_STRING ? S2.slice(position, position + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-absolute-index.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            );
            var max2 = Math.max;
            var min2 = Math.min;
            module2.exports = function(index, length) {
              var integer = toInteger(index);
              return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-indexed-object.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var IndexedObject = __webpack_require__(
              /*! ../internals/indexed-object */
              "./node_modules/core-js/internals/indexed-object.js"
            );
            var requireObjectCoercible = __webpack_require__(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            module2.exports = function(it2) {
              return IndexedObject(requireObjectCoercible(it2));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-integer.js": (
          /*!******************************************************!*\
            !*** ./node_modules/core-js/internals/to-integer.js ***!
            \******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            var ceil = Math.ceil;
            var floor = Math.floor;
            module2.exports = function(argument) {
              return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-length.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/to-length.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var toInteger = __webpack_require__(
              /*! ../internals/to-integer */
              "./node_modules/core-js/internals/to-integer.js"
            );
            var min2 = Math.min;
            module2.exports = function(argument) {
              return argument > 0 ? min2(toInteger(argument), 9007199254740991) : 0;
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-object.js": (
          /*!*****************************************************!*\
            !*** ./node_modules/core-js/internals/to-object.js ***!
            \*****************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var requireObjectCoercible = __webpack_require__(
              /*! ../internals/require-object-coercible */
              "./node_modules/core-js/internals/require-object-coercible.js"
            );
            module2.exports = function(argument) {
              return Object(requireObjectCoercible(argument));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/to-primitive.js": (
          /*!********************************************************!*\
            !*** ./node_modules/core-js/internals/to-primitive.js ***!
            \********************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            module2.exports = function(it2, S2) {
              if (!isObject2(it2))
                return it2;
              var fn3, val;
              if (S2 && typeof (fn3 = it2.toString) == "function" && !isObject2(val = fn3.call(it2)))
                return val;
              if (typeof (fn3 = it2.valueOf) == "function" && !isObject2(val = fn3.call(it2)))
                return val;
              if (!S2 && typeof (fn3 = it2.toString) == "function" && !isObject2(val = fn3.call(it2)))
                return val;
              throw TypeError("Can't convert object to primitive value");
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/uid.js": (
          /*!***********************************************!*\
            !*** ./node_modules/core-js/internals/uid.js ***!
            \***********************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            var id = 0;
            var postfix = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + postfix).toString(36));
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": (
          /*!*******************************************************************************!*\
            !*** ./node_modules/core-js/internals/validate-set-prototype-of-arguments.js ***!
            \*******************************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var isObject2 = __webpack_require__(
              /*! ../internals/is-object */
              "./node_modules/core-js/internals/is-object.js"
            );
            var anObject = __webpack_require__(
              /*! ../internals/an-object */
              "./node_modules/core-js/internals/an-object.js"
            );
            module2.exports = function(O2, proto) {
              anObject(O2);
              if (!isObject2(proto) && proto !== null) {
                throw TypeError("Can't set " + String(proto) + " as a prototype");
              }
            };
          }
        ),
        /***/
        "./node_modules/core-js/internals/well-known-symbol.js": (
          /*!*************************************************************!*\
            !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
            \*************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var global2 = __webpack_require__(
              /*! ../internals/global */
              "./node_modules/core-js/internals/global.js"
            );
            var shared = __webpack_require__(
              /*! ../internals/shared */
              "./node_modules/core-js/internals/shared.js"
            );
            var uid = __webpack_require__(
              /*! ../internals/uid */
              "./node_modules/core-js/internals/uid.js"
            );
            var NATIVE_SYMBOL = __webpack_require__(
              /*! ../internals/native-symbol */
              "./node_modules/core-js/internals/native-symbol.js"
            );
            var Symbol2 = global2.Symbol;
            var store = shared("wks");
            module2.exports = function(name2) {
              return store[name2] || (store[name2] = NATIVE_SYMBOL && Symbol2[name2] || (NATIVE_SYMBOL ? Symbol2 : uid)("Symbol." + name2));
            };
          }
        ),
        /***/
        "./node_modules/core-js/modules/es.array.from.js": (
          /*!*******************************************************!*\
            !*** ./node_modules/core-js/modules/es.array.from.js ***!
            \*******************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var $2 = __webpack_require__(
              /*! ../internals/export */
              "./node_modules/core-js/internals/export.js"
            );
            var from = __webpack_require__(
              /*! ../internals/array-from */
              "./node_modules/core-js/internals/array-from.js"
            );
            var checkCorrectnessOfIteration = __webpack_require__(
              /*! ../internals/check-correctness-of-iteration */
              "./node_modules/core-js/internals/check-correctness-of-iteration.js"
            );
            var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
              Array.from(iterable);
            });
            $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
              from
            });
          }
        ),
        /***/
        "./node_modules/core-js/modules/es.string.iterator.js": (
          /*!************************************************************!*\
            !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
            \************************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var codePointAt = __webpack_require__(
              /*! ../internals/string-at */
              "./node_modules/core-js/internals/string-at.js"
            );
            var InternalStateModule = __webpack_require__(
              /*! ../internals/internal-state */
              "./node_modules/core-js/internals/internal-state.js"
            );
            var defineIterator = __webpack_require__(
              /*! ../internals/define-iterator */
              "./node_modules/core-js/internals/define-iterator.js"
            );
            var STRING_ITERATOR = "String Iterator";
            var setInternalState = InternalStateModule.set;
            var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
            defineIterator(String, "String", function(iterated) {
              setInternalState(this, {
                type: STRING_ITERATOR,
                string: String(iterated),
                index: 0
              });
            }, function next() {
              var state2 = getInternalState(this);
              var string = state2.string;
              var index = state2.index;
              var point;
              if (index >= string.length)
                return { value: void 0, done: true };
              point = codePointAt(string, index, true);
              state2.index += point.length;
              return { value: point, done: false };
            });
          }
        ),
        /***/
        "./node_modules/webpack/buildin/global.js": (
          /*!***********************************!*\
            !*** (webpack)/buildin/global.js ***!
            \***********************************/
          /*! no static exports found */
          /***/
          function(module2, exports2) {
            var g2;
            g2 = function() {
              return this;
            }();
            try {
              g2 = g2 || Function("return this")() || (1, eval)("this");
            } catch (e2) {
              if (typeof window === "object")
                g2 = window;
            }
            module2.exports = g2;
          }
        ),
        /***/
        "./src/default-attrs.json": (
          /*!********************************!*\
            !*** ./src/default-attrs.json ***!
            \********************************/
          /*! exports provided: xmlns, width, height, viewBox, fill, stroke, stroke-width, stroke-linecap, stroke-linejoin, default */
          /***/
          function(module2) {
            module2.exports = { "xmlns": "http://www.w3.org/2000/svg", "width": 24, "height": 24, "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" };
          }
        ),
        /***/
        "./src/icon.js": (
          /*!*********************!*\
            !*** ./src/icon.js ***!
            \*********************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _createClass = function() {
              function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                  var descriptor = props[i];
                  descriptor.enumerable = descriptor.enumerable || false;
                  descriptor.configurable = true;
                  if ("value" in descriptor)
                    descriptor.writable = true;
                  Object.defineProperty(target, descriptor.key, descriptor);
                }
              }
              return function(Constructor, protoProps, staticProps) {
                if (protoProps)
                  defineProperties(Constructor.prototype, protoProps);
                if (staticProps)
                  defineProperties(Constructor, staticProps);
                return Constructor;
              };
            }();
            var _dedupe = __webpack_require__(
              /*! classnames/dedupe */
              "./node_modules/classnames/dedupe.js"
            );
            var _dedupe2 = _interopRequireDefault(_dedupe);
            var _defaultAttrs = __webpack_require__(
              /*! ./default-attrs.json */
              "./src/default-attrs.json"
            );
            var _defaultAttrs2 = _interopRequireDefault(_defaultAttrs);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }
            var Icon = function() {
              function Icon2(name2, contents) {
                var tags = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
                _classCallCheck(this, Icon2);
                this.name = name2;
                this.contents = contents;
                this.tags = tags;
                this.attrs = _extends({}, _defaultAttrs2.default, { class: "feather feather-" + name2 });
              }
              _createClass(Icon2, [{
                key: "toSvg",
                value: function toSvg() {
                  var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                  var combinedAttrs = _extends({}, this.attrs, attrs, { class: (0, _dedupe2.default)(this.attrs.class, attrs.class) });
                  return "<svg " + attrsToString(combinedAttrs) + ">" + this.contents + "</svg>";
                }
                /**
                 * Return string representation of an `Icon`.
                 *
                 * Added for backward compatibility. If old code expects `feather.icons.<name>`
                 * to be a string, `toString()` will get implicitly called.
                 *
                 * @returns {string}
                 */
              }, {
                key: "toString",
                value: function toString3() {
                  return this.contents;
                }
              }]);
              return Icon2;
            }();
            function attrsToString(attrs) {
              return Object.keys(attrs).map(function(key) {
                return key + '="' + attrs[key] + '"';
              }).join(" ");
            }
            exports2.default = Icon;
          }
        ),
        /***/
        "./src/icons.js": (
          /*!**********************!*\
            !*** ./src/icons.js ***!
            \**********************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _icon = __webpack_require__(
              /*! ./icon */
              "./src/icon.js"
            );
            var _icon2 = _interopRequireDefault(_icon);
            var _icons = __webpack_require__(
              /*! ../dist/icons.json */
              "./dist/icons.json"
            );
            var _icons2 = _interopRequireDefault(_icons);
            var _tags = __webpack_require__(
              /*! ./tags.json */
              "./src/tags.json"
            );
            var _tags2 = _interopRequireDefault(_tags);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            exports2.default = Object.keys(_icons2.default).map(function(key) {
              return new _icon2.default(key, _icons2.default[key], _tags2.default[key]);
            }).reduce(function(object, icon) {
              object[icon.name] = icon;
              return object;
            }, {});
          }
        ),
        /***/
        "./src/index.js": (
          /*!**********************!*\
            !*** ./src/index.js ***!
            \**********************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            var _icons = __webpack_require__(
              /*! ./icons */
              "./src/icons.js"
            );
            var _icons2 = _interopRequireDefault(_icons);
            var _toSvg = __webpack_require__(
              /*! ./to-svg */
              "./src/to-svg.js"
            );
            var _toSvg2 = _interopRequireDefault(_toSvg);
            var _replace = __webpack_require__(
              /*! ./replace */
              "./src/replace.js"
            );
            var _replace2 = _interopRequireDefault(_replace);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            module2.exports = { icons: _icons2.default, toSvg: _toSvg2.default, replace: _replace2.default };
          }
        ),
        /***/
        "./src/replace.js": (
          /*!************************!*\
            !*** ./src/replace.js ***!
            \************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _extends = Object.assign || function(target) {
              for (var i = 1; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            };
            var _dedupe = __webpack_require__(
              /*! classnames/dedupe */
              "./node_modules/classnames/dedupe.js"
            );
            var _dedupe2 = _interopRequireDefault(_dedupe);
            var _icons = __webpack_require__(
              /*! ./icons */
              "./src/icons.js"
            );
            var _icons2 = _interopRequireDefault(_icons);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function replace() {
              var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              if (typeof document === "undefined") {
                throw new Error("`feather.replace()` only works in a browser environment.");
              }
              var elementsToReplace = document.querySelectorAll("[data-feather]");
              Array.from(elementsToReplace).forEach(function(element) {
                return replaceElement(element, attrs);
              });
            }
            function replaceElement(element) {
              var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              var elementAttrs = getAttrs(element);
              var name2 = elementAttrs["data-feather"];
              delete elementAttrs["data-feather"];
              if (_icons2.default[name2] === void 0) {
                console.warn("feather: '" + name2 + "' is not a valid icon");
                return;
              }
              var svgString = _icons2.default[name2].toSvg(_extends({}, attrs, elementAttrs, { class: (0, _dedupe2.default)(attrs.class, elementAttrs.class) }));
              var svgDocument = new DOMParser().parseFromString(svgString, "image/svg+xml");
              var svgElement = svgDocument.querySelector("svg");
              element.parentNode.replaceChild(svgElement, element);
            }
            function getAttrs(element) {
              return Array.from(element.attributes).reduce(function(attrs, attr2) {
                attrs[attr2.name] = attr2.value;
                return attrs;
              }, {});
            }
            exports2.default = replace;
          }
        ),
        /***/
        "./src/tags.json": (
          /*!***********************!*\
            !*** ./src/tags.json ***!
            \***********************/
          /*! exports provided: activity, airplay, alert-circle, alert-octagon, alert-triangle, align-center, align-justify, align-left, align-right, anchor, archive, at-sign, award, aperture, bar-chart, bar-chart-2, battery, battery-charging, bell, bell-off, bluetooth, book-open, book, bookmark, box, briefcase, calendar, camera, cast, chevron-down, chevron-up, circle, clipboard, clock, cloud-drizzle, cloud-lightning, cloud-rain, cloud-snow, cloud, codepen, codesandbox, code, coffee, columns, command, compass, copy, corner-down-left, corner-down-right, corner-left-down, corner-left-up, corner-right-down, corner-right-up, corner-up-left, corner-up-right, cpu, credit-card, crop, crosshair, database, delete, disc, dollar-sign, droplet, edit, edit-2, edit-3, eye, eye-off, external-link, facebook, fast-forward, figma, file-minus, file-plus, file-text, film, filter, flag, folder-minus, folder-plus, folder, framer, frown, gift, git-branch, git-commit, git-merge, git-pull-request, github, gitlab, globe, hard-drive, hash, headphones, heart, help-circle, hexagon, home, image, inbox, instagram, key, layers, layout, life-buoy, link, link-2, linkedin, list, lock, log-in, log-out, mail, map-pin, map, maximize, maximize-2, meh, menu, message-circle, message-square, mic-off, mic, minimize, minimize-2, minus, monitor, moon, more-horizontal, more-vertical, mouse-pointer, move, music, navigation, navigation-2, octagon, package, paperclip, pause, pause-circle, pen-tool, percent, phone-call, phone-forwarded, phone-incoming, phone-missed, phone-off, phone-outgoing, phone, play, pie-chart, play-circle, plus, plus-circle, plus-square, pocket, power, printer, radio, refresh-cw, refresh-ccw, repeat, rewind, rotate-ccw, rotate-cw, rss, save, scissors, search, send, settings, share-2, shield, shield-off, shopping-bag, shopping-cart, shuffle, skip-back, skip-forward, slack, slash, sliders, smartphone, smile, speaker, star, stop-circle, sun, sunrise, sunset, tablet, tag, target, terminal, thermometer, thumbs-down, thumbs-up, toggle-left, toggle-right, tool, trash, trash-2, triangle, truck, tv, twitch, twitter, type, umbrella, unlock, user-check, user-minus, user-plus, user-x, user, users, video-off, video, voicemail, volume, volume-1, volume-2, volume-x, watch, wifi-off, wifi, wind, x-circle, x-octagon, x-square, x, youtube, zap-off, zap, zoom-in, zoom-out, default */
          /***/
          function(module2) {
            module2.exports = { "activity": ["pulse", "health", "action", "motion"], "airplay": ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], "anchor": [], "archive": ["index", "box"], "at-sign": ["mention", "at", "email", "message"], "award": ["achievement", "badge"], "aperture": ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], "battery": ["power", "electricity"], "battery-charging": ["power", "electricity"], "bell": ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], "bluetooth": ["wireless"], "book-open": ["read", "library"], "book": ["read", "dictionary", "booklet", "magazine", "library"], "bookmark": ["read", "clip", "marker", "tag"], "box": ["cube"], "briefcase": ["work", "bag", "baggage", "folder"], "calendar": ["date"], "camera": ["photo"], "cast": ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], "circle": ["off", "zero", "record"], "clipboard": ["copy"], "clock": ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], "cloud": ["weather"], "codepen": ["logo"], "codesandbox": ["logo"], "code": ["source", "programming"], "coffee": ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], "columns": ["layout"], "command": ["keyboard", "cmd", "terminal", "prompt"], "compass": ["navigation", "safari", "travel", "direction"], "copy": ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], "cpu": ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], "crop": ["photo", "image"], "crosshair": ["aim", "target"], "database": ["storage", "memory"], "delete": ["remove"], "disc": ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], "droplet": ["water"], "edit": ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], "eye": ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], "facebook": ["logo", "social"], "fast-forward": ["music"], "figma": ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], "film": ["movie", "video"], "filter": ["funnel", "hopper"], "flag": ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], "folder": ["directory"], "framer": ["logo", "design", "tool"], "frown": ["emoji", "face", "bad", "sad", "emotion"], "gift": ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], "github": ["logo", "version control"], "gitlab": ["logo", "version control"], "globe": ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], "hash": ["hashtag", "number", "pound"], "headphones": ["music", "audio", "sound"], "heart": ["like", "love", "emotion"], "help-circle": ["question mark"], "hexagon": ["shape", "node.js", "logo"], "home": ["house", "living"], "image": ["picture"], "inbox": ["email"], "instagram": ["logo", "camera"], "key": ["password", "login", "authentication", "secure"], "layers": ["stack"], "layout": ["window", "webpage"], "life-buoy": ["help", "life ring", "support"], "link": ["chain", "url"], "link-2": ["chain", "url"], "linkedin": ["logo", "social media"], "list": ["options"], "lock": ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], "mail": ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], "map": ["location", "navigation", "travel"], "maximize": ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], "meh": ["emoji", "face", "neutral", "emotion"], "menu": ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], "mic": ["record", "sound", "listen"], "minimize": ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], "minus": ["subtract"], "monitor": ["tv", "screen", "display"], "moon": ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], "move": ["arrows"], "music": ["note"], "navigation": ["location", "travel"], "navigation-2": ["location", "travel"], "octagon": ["stop"], "package": ["box", "container"], "paperclip": ["attachment"], "pause": ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], "percent": ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], "phone": ["call"], "play": ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], "plus": ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], "pocket": ["logo", "save"], "power": ["on", "off"], "printer": ["fax", "office", "device"], "radio": ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], "repeat": ["loop", "arrows"], "rewind": ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], "rss": ["feed", "subscribe"], "save": ["floppy disk"], "scissors": ["cut"], "search": ["find", "magnifier", "magnifying glass"], "send": ["message", "mail", "email", "paper airplane", "paper aeroplane"], "settings": ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], "shield": ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], "shuffle": ["music"], "skip-back": ["music"], "skip-forward": ["music"], "slack": ["logo"], "slash": ["ban", "no"], "sliders": ["settings", "controls"], "smartphone": ["cellphone", "device"], "smile": ["emoji", "face", "happy", "good", "emotion"], "speaker": ["audio", "music"], "star": ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], "sun": ["brightness", "weather", "light"], "sunrise": ["weather", "time", "morning", "day"], "sunset": ["weather", "time", "evening", "night"], "tablet": ["device"], "tag": ["label"], "target": ["logo", "bullseye"], "terminal": ["code", "command line", "prompt"], "thermometer": ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], "tool": ["settings", "spanner"], "trash": ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], "triangle": ["delta"], "truck": ["delivery", "van", "shipping", "transport", "lorry"], "tv": ["television", "stream"], "twitch": ["logo"], "twitter": ["logo", "social"], "type": ["text"], "umbrella": ["rain", "weather"], "unlock": ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], "user": ["person", "account"], "users": ["group"], "video-off": ["camera", "movie", "film"], "video": ["camera", "movie", "film"], "voicemail": ["phone"], "volume": ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], "watch": ["clock", "time"], "wifi-off": ["disabled"], "wifi": ["connection", "signal", "wireless"], "wind": ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], "x": ["cancel", "close", "delete", "remove", "times", "clear"], "youtube": ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], "zap": ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] };
          }
        ),
        /***/
        "./src/to-svg.js": (
          /*!***********************!*\
            !*** ./src/to-svg.js ***!
            \***********************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            Object.defineProperty(exports2, "__esModule", {
              value: true
            });
            var _icons = __webpack_require__(
              /*! ./icons */
              "./src/icons.js"
            );
            var _icons2 = _interopRequireDefault(_icons);
            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : { default: obj };
            }
            function toSvg(name2) {
              var attrs = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.");
              if (!name2) {
                throw new Error("The required `key` (icon name) parameter is missing.");
              }
              if (!_icons2.default[name2]) {
                throw new Error("No icon matching '" + name2 + "'. See the complete list of icons at https://feathericons.com");
              }
              return _icons2.default[name2].toSvg(attrs);
            }
            exports2.default = toSvg;
          }
        ),
        /***/
        0: (
          /*!**************************************************!*\
            !*** multi core-js/es/array/from ./src/index.js ***!
            \**************************************************/
          /*! no static exports found */
          /***/
          function(module2, exports2, __webpack_require__) {
            __webpack_require__(
              /*! core-js/es/array/from */
              "./node_modules/core-js/es/array/from.js"
            );
            module2.exports = __webpack_require__(
              /*! /home/runner/work/feather/feather/src/index.js */
              "./src/index.js"
            );
          }
        )
        /******/
      })
    );
  });
})(feather$1);
var featherExports = feather$1.exports;
const feather = /* @__PURE__ */ getDefaultExportFromCjs(featherExports);
(function() {
  feather.replace();
})();
(function() {
  var url = window.location + "";
  var path = url.replace(window.location.protocol + "//" + window.location.host + "/", "");
  var element = $("ul#sidebarnav a").filter(function() {
    return this.href === url || this.href === path;
  });
  element.parentsUntil(".sidebar-nav").each(function(index) {
    if ($(this).is("li") && $(this).children("a").length !== 0) {
      $(this).children("a").addClass("active");
      $(this).parent("ul#sidebarnav").length === 0 ? $(this).addClass("active") : $(this).addClass("active");
    } else if (!$(this).is("ul") && $(this).children("a").length === 0) {
      $(this).addClass("active");
    } else if ($(this).is("ul")) {
      $(this).addClass("in");
    }
  });
})();
window.Swal = Swal$1;
window.swal = Swal$1;
window.toastr = toastr$1;
jQuery$1.fn.inputmask = function(maskOrAlias, opts) {
  return this.each(function() {
    const im = new Inputmask(maskOrAlias, opts);
    im.mask(this);
  });
};
/*! DataTables 2.2.2
 * © SpryMedia Ltd - datatables.net/license
 */
var $$6 = jQuery$1;
var DataTable = function(selector, options) {
  if (DataTable.factory(selector, options)) {
    return DataTable;
  }
  if (this instanceof DataTable) {
    return $$6(selector).DataTable(options);
  } else {
    options = selector;
  }
  var _that = this;
  var emptyInit = options === void 0;
  var len = this.length;
  if (emptyInit) {
    options = {};
  }
  this.api = function() {
    return new _Api(this);
  };
  this.each(function() {
    var o2 = {};
    var oInit = len > 1 ? (
      // optimisation for single table case
      _fnExtend(o2, options, true)
    ) : options;
    var i = 0, iLen;
    var sId = this.getAttribute("id");
    var defaults2 = DataTable.defaults;
    var $this = $$6(this);
    if (this.nodeName.toLowerCase() != "table") {
      _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2);
      return;
    }
    $$6(this).trigger("options.dt", oInit);
    _fnCompatOpts(defaults2);
    _fnCompatCols(defaults2.column);
    _fnCamelToHungarian(defaults2, defaults2, true);
    _fnCamelToHungarian(defaults2.column, defaults2.column, true);
    _fnCamelToHungarian(defaults2, $$6.extend(oInit, $this.data()), true);
    var allSettings = DataTable.settings;
    for (i = 0, iLen = allSettings.length; i < iLen; i++) {
      var s2 = allSettings[i];
      if (s2.nTable == this || s2.nTHead && s2.nTHead.parentNode == this || s2.nTFoot && s2.nTFoot.parentNode == this) {
        var bRetrieve = oInit.bRetrieve !== void 0 ? oInit.bRetrieve : defaults2.bRetrieve;
        var bDestroy = oInit.bDestroy !== void 0 ? oInit.bDestroy : defaults2.bDestroy;
        if (emptyInit || bRetrieve) {
          return s2.oInstance;
        } else if (bDestroy) {
          new DataTable.Api(s2).destroy();
          break;
        } else {
          _fnLog(s2, 0, "Cannot reinitialise DataTable", 3);
          return;
        }
      }
      if (s2.sTableId == this.id) {
        allSettings.splice(i, 1);
        break;
      }
    }
    if (sId === null || sId === "") {
      sId = "DataTables_Table_" + DataTable.ext._unique++;
      this.id = sId;
    }
    var oSettings = $$6.extend(true, {}, DataTable.models.oSettings, {
      "sDestroyWidth": $this[0].style.width,
      "sInstance": sId,
      "sTableId": sId,
      colgroup: $$6("<colgroup>").prependTo(this),
      fastData: function(row, column, type) {
        return _fnGetCellData(oSettings, row, column, type);
      }
    });
    oSettings.nTable = this;
    oSettings.oInit = oInit;
    allSettings.push(oSettings);
    oSettings.api = new _Api(oSettings);
    oSettings.oInstance = _that.length === 1 ? _that : $this.dataTable();
    _fnCompatOpts(oInit);
    if (oInit.aLengthMenu && !oInit.iDisplayLength) {
      oInit.iDisplayLength = Array.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : $$6.isPlainObject(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0].value : oInit.aLengthMenu[0];
    }
    oInit = _fnExtend($$6.extend(true, {}, defaults2), oInit);
    _fnMap(oSettings.oFeatures, oInit, [
      "bPaginate",
      "bLengthChange",
      "bFilter",
      "bSort",
      "bSortMulti",
      "bInfo",
      "bProcessing",
      "bAutoWidth",
      "bSortClasses",
      "bServerSide",
      "bDeferRender"
    ]);
    _fnMap(oSettings, oInit, [
      "ajax",
      "fnFormatNumber",
      "sServerMethod",
      "aaSorting",
      "aaSortingFixed",
      "aLengthMenu",
      "sPaginationType",
      "iStateDuration",
      "bSortCellsTop",
      "iTabIndex",
      "sDom",
      "fnStateLoadCallback",
      "fnStateSaveCallback",
      "renderer",
      "searchDelay",
      "rowId",
      "caption",
      "layout",
      "orderDescReverse",
      "typeDetect",
      ["iCookieDuration", "iStateDuration"],
      // backwards compat
      ["oSearch", "oPreviousSearch"],
      ["aoSearchCols", "aoPreSearchCols"],
      ["iDisplayLength", "_iDisplayLength"]
    ]);
    _fnMap(oSettings.oScroll, oInit, [
      ["sScrollX", "sX"],
      ["sScrollXInner", "sXInner"],
      ["sScrollY", "sY"],
      ["bScrollCollapse", "bCollapse"]
    ]);
    _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback");
    _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback);
    _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams);
    _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams);
    _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded);
    _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback);
    _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow);
    _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback);
    _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback);
    _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete);
    _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback);
    oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId);
    _fnBrowserDetect(oSettings);
    var oClasses = oSettings.oClasses;
    $$6.extend(oClasses, DataTable.ext.classes, oInit.oClasses);
    $this.addClass(oClasses.table);
    if (!oSettings.oFeatures.bPaginate) {
      oInit.iDisplayStart = 0;
    }
    if (oSettings.iInitDisplayStart === void 0) {
      oSettings.iInitDisplayStart = oInit.iDisplayStart;
      oSettings._iDisplayStart = oInit.iDisplayStart;
    }
    var defer = oInit.iDeferLoading;
    if (defer !== null) {
      oSettings.deferLoading = true;
      var tmp = Array.isArray(defer);
      oSettings._iRecordsDisplay = tmp ? defer[0] : defer;
      oSettings._iRecordsTotal = tmp ? defer[1] : defer;
    }
    var columnsInit = [];
    var thead = this.getElementsByTagName("thead");
    var initHeaderLayout = _fnDetectHeader(oSettings, thead[0]);
    if (oInit.aoColumns) {
      columnsInit = oInit.aoColumns;
    } else if (initHeaderLayout.length) {
      for (i = 0, iLen = initHeaderLayout[0].length; i < iLen; i++) {
        columnsInit.push(null);
      }
    }
    for (i = 0, iLen = columnsInit.length; i < iLen; i++) {
      _fnAddColumn(oSettings);
    }
    _fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, columnsInit, initHeaderLayout, function(iCol, oDef) {
      _fnColumnOptions(oSettings, iCol, oDef);
    });
    var rowOne = $this.children("tbody").find("tr").eq(0);
    if (rowOne.length) {
      var a2 = function(cell, name2) {
        return cell.getAttribute("data-" + name2) !== null ? name2 : null;
      };
      $$6(rowOne[0]).children("th, td").each(function(i2, cell) {
        var col = oSettings.aoColumns[i2];
        if (!col) {
          _fnLog(oSettings, 0, "Incorrect column count", 18);
        }
        if (col.mData === i2) {
          var sort = a2(cell, "sort") || a2(cell, "order");
          var filter2 = a2(cell, "filter") || a2(cell, "search");
          if (sort !== null || filter2 !== null) {
            col.mData = {
              _: i2 + ".display",
              sort: sort !== null ? i2 + ".@data-" + sort : void 0,
              type: sort !== null ? i2 + ".@data-" + sort : void 0,
              filter: filter2 !== null ? i2 + ".@data-" + filter2 : void 0
            };
            col._isArrayHost = true;
            _fnColumnOptions(oSettings, i2);
          }
        }
      });
    }
    _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState);
    var features = oSettings.oFeatures;
    if (oInit.bStateSave) {
      features.bStateSave = true;
    }
    if (oInit.aaSorting === void 0) {
      var sorting = oSettings.aaSorting;
      for (i = 0, iLen = sorting.length; i < iLen; i++) {
        sorting[i][1] = oSettings.aoColumns[i].asSorting[0];
      }
    }
    _fnSortingClasses(oSettings);
    _fnCallbackReg(oSettings, "aoDrawCallback", function() {
      if (oSettings.bSorted || _fnDataSource(oSettings) === "ssp" || features.bDeferRender) {
        _fnSortingClasses(oSettings);
      }
    });
    var caption = $this.children("caption");
    if (oSettings.caption) {
      if (caption.length === 0) {
        caption = $$6("<caption/>").appendTo($this);
      }
      caption.html(oSettings.caption);
    }
    if (caption.length) {
      caption[0]._captionSide = caption.css("caption-side");
      oSettings.captionNode = caption[0];
    }
    if (thead.length === 0) {
      thead = $$6("<thead/>").appendTo($this);
    }
    oSettings.nTHead = thead[0];
    var tbody = $this.children("tbody");
    if (tbody.length === 0) {
      tbody = $$6("<tbody/>").insertAfter(thead);
    }
    oSettings.nTBody = tbody[0];
    var tfoot = $this.children("tfoot");
    if (tfoot.length === 0) {
      tfoot = $$6("<tfoot/>").appendTo($this);
    }
    oSettings.nTFoot = tfoot[0];
    oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
    oSettings.bInitialised = true;
    var oLanguage = oSettings.oLanguage;
    $$6.extend(true, oLanguage, oInit.oLanguage);
    if (oLanguage.sUrl) {
      $$6.ajax({
        dataType: "json",
        url: oLanguage.sUrl,
        success: function(json) {
          _fnCamelToHungarian(defaults2.oLanguage, json);
          $$6.extend(true, oLanguage, json, oSettings.oInit.oLanguage);
          _fnCallbackFire(oSettings, null, "i18n", [oSettings], true);
          _fnInitialise(oSettings);
        },
        error: function() {
          _fnLog(oSettings, 0, "i18n file loading error", 21);
          _fnInitialise(oSettings);
        }
      });
    } else {
      _fnCallbackFire(oSettings, null, "i18n", [oSettings], true);
      _fnInitialise(oSettings);
    }
  });
  _that = null;
  return this;
};
DataTable.ext = _ext = {
  /**
   * Buttons. For use with the Buttons extension for DataTables. This is
   * defined here so other extensions can define buttons regardless of load
   * order. It is _not_ used by DataTables core.
   *
   *  @type object
   *  @default {}
   */
  buttons: {},
  /**
   * Element class names
   *
   *  @type object
   *  @default {}
   */
  classes: {},
  /**
   * DataTables build type (expanded by the download builder)
   *
   *  @type string
   */
  builder: "-source-",
  /**
   * Error reporting.
   * 
   * How should DataTables report an error. Can take the value 'alert',
   * 'throw', 'none' or a function.
   *
   *  @type string|function
   *  @default alert
   */
  errMode: "alert",
  /**
   * Legacy so v1 plug-ins don't throw js errors on load
   */
  feature: [],
  /**
   * Feature plug-ins.
   * 
   * This is an object of callbacks which provide the features for DataTables
   * to be initialised via the `layout` option.
   */
  features: {},
  /**
   * Row searching.
   * 
   * This method of searching is complimentary to the default type based
   * searching, and a lot more comprehensive as it allows you complete control
   * over the searching logic. Each element in this array is a function
   * (parameters described below) that is called for every row in the table,
   * and your logic decides if it should be included in the searching data set
   * or not.
   *
   * Searching functions have the following input parameters:
   *
   * 1. `{object}` DataTables settings object: see
   *    {@link DataTable.models.oSettings}
   * 2. `{array|object}` Data for the row to be processed (same as the
   *    original format that was passed in as the data source, or an array
   *    from a DOM data source
   * 3. `{int}` Row index ({@link DataTable.models.oSettings.aoData}), which
   *    can be useful to retrieve the `TR` element if you need DOM interaction.
   *
   * And the following return is expected:
   *
   * * {boolean} Include the row in the searched result set (true) or not
   *   (false)
   *
   * Note that as with the main search ability in DataTables, technically this
   * is "filtering", since it is subtractive. However, for consistency in
   * naming we call it searching here.
   *
   *  @type array
   *  @default []
   *
   *  @example
   *    // The following example shows custom search being applied to the
   *    // fourth column (i.e. the data[3] index) based on two input values
   *    // from the end-user, matching the data in a certain range.
   *    $.fn.dataTable.ext.search.push(
   *      function( settings, data, dataIndex ) {
   *        var min = document.getElementById('min').value * 1;
   *        var max = document.getElementById('max').value * 1;
   *        var version = data[3] == "-" ? 0 : data[3]*1;
   *
   *        if ( min == "" && max == "" ) {
   *          return true;
   *        }
   *        else if ( min == "" && version < max ) {
   *          return true;
   *        }
   *        else if ( min < version && "" == max ) {
   *          return true;
   *        }
   *        else if ( min < version && version < max ) {
   *          return true;
   *        }
   *        return false;
   *      }
   *    );
   */
  search: [],
  /**
   * Selector extensions
   *
   * The `selector` option can be used to extend the options available for the
   * selector modifier options (`selector-modifier` object data type) that
   * each of the three built in selector types offer (row, column and cell +
   * their plural counterparts). For example the Select extension uses this
   * mechanism to provide an option to select only rows, columns and cells
   * that have been marked as selected by the end user (`{selected: true}`),
   * which can be used in conjunction with the existing built in selector
   * options.
   *
   * Each property is an array to which functions can be pushed. The functions
   * take three attributes:
   *
   * * Settings object for the host table
   * * Options object (`selector-modifier` object type)
   * * Array of selected item indexes
   *
   * The return is an array of the resulting item indexes after the custom
   * selector has been applied.
   *
   *  @type object
   */
  selector: {
    cell: [],
    column: [],
    row: []
  },
  /**
   * Legacy configuration options. Enable and disable legacy options that
   * are available in DataTables.
   *
   *  @type object
   */
  legacy: {
    /**
     * Enable / disable DataTables 1.9 compatible server-side processing
     * requests
     *
     *  @type boolean
     *  @default null
     */
    ajax: null
  },
  /**
   * Pagination plug-in methods.
   * 
   * Each entry in this object is a function and defines which buttons should
   * be shown by the pagination rendering method that is used for the table:
   * {@link DataTable.ext.renderer.pageButton}. The renderer addresses how the
   * buttons are displayed in the document, while the functions here tell it
   * what buttons to display. This is done by returning an array of button
   * descriptions (what each button will do).
   *
   * Pagination types (the four built in options and any additional plug-in
   * options defined here) can be used through the `paginationType`
   * initialisation parameter.
   *
   * The functions defined take two parameters:
   *
   * 1. `{int} page` The current page index
   * 2. `{int} pages` The number of pages in the table
   *
   * Each function is expected to return an array where each element of the
   * array can be one of:
   *
   * * `first` - Jump to first page when activated
   * * `last` - Jump to last page when activated
   * * `previous` - Show previous page when activated
   * * `next` - Show next page when activated
   * * `{int}` - Show page of the index given
   * * `{array}` - A nested array containing the above elements to add a
   *   containing 'DIV' element (might be useful for styling).
   *
   * Note that DataTables v1.9- used this object slightly differently whereby
   * an object with two functions would be defined for each plug-in. That
   * ability is still supported by DataTables 1.10+ to provide backwards
   * compatibility, but this option of use is now decremented and no longer
   * documented in DataTables 1.10+.
   *
   *  @type object
   *  @default {}
   *
   *  @example
   *    // Show previous, next and current page buttons only
   *    $.fn.dataTableExt.oPagination.current = function ( page, pages ) {
   *      return [ 'previous', page, 'next' ];
   *    };
   */
  pager: {},
  renderer: {
    pageButton: {},
    header: {}
  },
  /**
   * Ordering plug-ins - custom data source
   * 
   * The extension options for ordering of data available here is complimentary
   * to the default type based ordering that DataTables typically uses. It
   * allows much greater control over the the data that is being used to
   * order a column, but is necessarily therefore more complex.
   * 
   * This type of ordering is useful if you want to do ordering based on data
   * live from the DOM (for example the contents of an 'input' element) rather
   * than just the static string that DataTables knows of.
   * 
   * The way these plug-ins work is that you create an array of the values you
   * wish to be ordering for the column in question and then return that
   * array. The data in the array much be in the index order of the rows in
   * the table (not the currently ordering order!). Which order data gathering
   * function is run here depends on the `dt-init columns.orderDataType`
   * parameter that is used for the column (if any).
   *
   * The functions defined take two parameters:
   *
   * 1. `{object}` DataTables settings object: see
   *    {@link DataTable.models.oSettings}
   * 2. `{int}` Target column index
   *
   * Each function is expected to return an array:
   *
   * * `{array}` Data for the column to be ordering upon
   *
   *  @type array
   *
   *  @example
   *    // Ordering using `input` node values
   *    $.fn.dataTable.ext.order['dom-text'] = function  ( settings, col )
   *    {
   *      return this.api().column( col, {order:'index'} ).nodes().map( function ( td, i ) {
   *        return $('input', td).val();
   *      } );
   *    }
   */
  order: {},
  /**
   * Type based plug-ins.
   *
   * Each column in DataTables has a type assigned to it, either by automatic
   * detection or by direct assignment using the `type` option for the column.
   * The type of a column will effect how it is ordering and search (plug-ins
   * can also make use of the column type if required).
   *
   * @namespace
   */
  type: {
    /**
     * Automatic column class assignment
     */
    className: {},
    /**
     * Type detection functions.
     *
     * The functions defined in this object are used to automatically detect
     * a column's type, making initialisation of DataTables super easy, even
     * when complex data is in the table.
     *
     * The functions defined take two parameters:
     *
        *  1. `{*}` Data from the column cell to be analysed
        *  2. `{settings}` DataTables settings object. This can be used to
        *     perform context specific type detection - for example detection
        *     based on language settings such as using a comma for a decimal
        *     place. Generally speaking the options from the settings will not
        *     be required
     *
     * Each function is expected to return:
     *
     * * `{string|null}` Data type detected, or null if unknown (and thus
     *   pass it on to the other type detection functions.
     *
     *  @type array
     *
     *  @example
     *    // Currency type detection plug-in:
     *    $.fn.dataTable.ext.type.detect.push(
     *      function ( data, settings ) {
     *        // Check the numeric part
     *        if ( ! data.substring(1).match(/[0-9]/) ) {
     *          return null;
     *        }
     *
     *        // Check prefixed by currency
     *        if ( data.charAt(0) == '$' || data.charAt(0) == '&pound;' ) {
     *          return 'currency';
     *        }
     *        return null;
     *      }
     *    );
     */
    detect: [],
    /**
     * Automatic renderer assignment
     */
    render: {},
    /**
     * Type based search formatting.
     *
     * The type based searching functions can be used to pre-format the
     * data to be search on. For example, it can be used to strip HTML
     * tags or to de-format telephone numbers for numeric only searching.
     *
     * Note that is a search is not defined for a column of a given type,
     * no search formatting will be performed.
     * 
     * Pre-processing of searching data plug-ins - When you assign the sType
     * for a column (or have it automatically detected for you by DataTables
     * or a type detection plug-in), you will typically be using this for
     * custom sorting, but it can also be used to provide custom searching
     * by allowing you to pre-processing the data and returning the data in
     * the format that should be searched upon. This is done by adding
     * functions this object with a parameter name which matches the sType
     * for that target column. This is the corollary of <i>afnSortData</i>
     * for searching data.
     *
     * The functions defined take a single parameter:
     *
        *  1. `{*}` Data from the column cell to be prepared for searching
     *
     * Each function is expected to return:
     *
     * * `{string|null}` Formatted string that will be used for the searching.
     *
     *  @type object
     *  @default {}
     *
     *  @example
     *    $.fn.dataTable.ext.type.search['title-numeric'] = function ( d ) {
     *      return d.replace(/\n/g," ").replace( /<.*?>/g, "" );
     *    }
     */
    search: {},
    /**
     * Type based ordering.
     *
     * The column type tells DataTables what ordering to apply to the table
     * when a column is sorted upon. The order for each type that is defined,
     * is defined by the functions available in this object.
     *
     * Each ordering option can be described by three properties added to
     * this object:
     *
     * * `{type}-pre` - Pre-formatting function
     * * `{type}-asc` - Ascending order function
     * * `{type}-desc` - Descending order function
     *
     * All three can be used together, only `{type}-pre` or only
     * `{type}-asc` and `{type}-desc` together. It is generally recommended
     * that only `{type}-pre` is used, as this provides the optimal
     * implementation in terms of speed, although the others are provided
     * for compatibility with existing Javascript sort functions.
     *
     * `{type}-pre`: Functions defined take a single parameter:
     *
        *  1. `{*}` Data from the column cell to be prepared for ordering
     *
     * And return:
     *
     * * `{*}` Data to be sorted upon
     *
     * `{type}-asc` and `{type}-desc`: Functions are typical Javascript sort
     * functions, taking two parameters:
     *
        *  1. `{*}` Data to compare to the second parameter
        *  2. `{*}` Data to compare to the first parameter
     *
     * And returning:
     *
     * * `{*}` Ordering match: <0 if first parameter should be sorted lower
     *   than the second parameter, ===0 if the two parameters are equal and
     *   >0 if the first parameter should be sorted height than the second
     *   parameter.
     * 
     *  @type object
     *  @default {}
     *
     *  @example
     *    // Numeric ordering of formatted numbers with a pre-formatter
     *    $.extend( $.fn.dataTable.ext.type.order, {
     *      "string-pre": function(x) {
     *        a = (a === "-" || a === "") ? 0 : a.replace( /[^\d\-\.]/g, "" );
     *        return parseFloat( a );
     *      }
     *    } );
     *
     *  @example
     *    // Case-sensitive string ordering, with no pre-formatting method
     *    $.extend( $.fn.dataTable.ext.order, {
     *      "string-case-asc": function(x,y) {
     *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
     *      },
     *      "string-case-desc": function(x,y) {
     *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
     *      }
     *    } );
     */
    order: {}
  },
  /**
   * Unique DataTables instance counter
   *
   * @type int
   * @private
   */
  _unique: 0,
  //
  // Depreciated
  // The following properties are retained for backwards compatibility only.
  // The should not be used in new projects and will be removed in a future
  // version
  //
  /**
   * Version check function.
   *  @type function
   *  @depreciated Since 1.10
   */
  fnVersionCheck: DataTable.fnVersionCheck,
  /**
   * Index for what 'this' index API functions should use
   *  @type int
   *  @deprecated Since v1.10
   */
  iApiIndex: 0,
  /**
   * Software version
   *  @type string
   *  @deprecated Since v1.10
   */
  sVersion: DataTable.version
};
$$6.extend(_ext, {
  afnFiltering: _ext.search,
  aTypes: _ext.type.detect,
  ofnSearch: _ext.type.search,
  oSort: _ext.type.order,
  afnSortData: _ext.order,
  aoFeatures: _ext.feature,
  oStdClasses: _ext.classes,
  oPagination: _ext.pager
});
$$6.extend(DataTable.ext.classes, {
  container: "dt-container",
  empty: {
    row: "dt-empty"
  },
  info: {
    container: "dt-info"
  },
  layout: {
    row: "dt-layout-row",
    cell: "dt-layout-cell",
    tableRow: "dt-layout-table",
    tableCell: "",
    start: "dt-layout-start",
    end: "dt-layout-end",
    full: "dt-layout-full"
  },
  length: {
    container: "dt-length",
    select: "dt-input"
  },
  order: {
    canAsc: "dt-orderable-asc",
    canDesc: "dt-orderable-desc",
    isAsc: "dt-ordering-asc",
    isDesc: "dt-ordering-desc",
    none: "dt-orderable-none",
    position: "sorting_"
  },
  processing: {
    container: "dt-processing"
  },
  scrolling: {
    body: "dt-scroll-body",
    container: "dt-scroll",
    footer: {
      self: "dt-scroll-foot",
      inner: "dt-scroll-footInner"
    },
    header: {
      self: "dt-scroll-head",
      inner: "dt-scroll-headInner"
    }
  },
  search: {
    container: "dt-search",
    input: "dt-input"
  },
  table: "dataTable",
  tbody: {
    cell: "",
    row: ""
  },
  thead: {
    cell: "",
    row: ""
  },
  tfoot: {
    cell: "",
    row: ""
  },
  paging: {
    active: "current",
    button: "dt-paging-button",
    container: "dt-paging",
    disabled: "disabled",
    nav: ""
  }
});
var _ext;
var _Api;
var _api_register;
var _api_registerPlural;
var _re_dic = {};
var _re_new_lines = /[\r\n\u2028]/g;
var _re_html = /<([^>]*>)/g;
var _max_str_len = Math.pow(2, 28);
var _re_date = /^\d{2,4}[./-]\d{1,2}[./-]\d{1,2}([T ]{1}\d{1,2}[:.]\d{2}([.:]\d{2})?)?$/;
var _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g");
var _re_formatted_numeric = /['\u00A0,$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi;
var _empty = function(d2) {
  return !d2 || d2 === true || d2 === "-" ? true : false;
};
var _intVal = function(s2) {
  var integer = parseInt(s2, 10);
  return !isNaN(integer) && isFinite(s2) ? integer : null;
};
var _numToDecimal = function(num, decimalPoint) {
  if (!_re_dic[decimalPoint]) {
    _re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g");
  }
  return typeof num === "string" && decimalPoint !== "." ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num;
};
var _isNumber = function(d2, decimalPoint, formatted, allowEmpty) {
  var type = typeof d2;
  var strType = type === "string";
  if (type === "number" || type === "bigint") {
    return true;
  }
  if (allowEmpty && _empty(d2)) {
    return true;
  }
  if (decimalPoint && strType) {
    d2 = _numToDecimal(d2, decimalPoint);
  }
  if (formatted && strType) {
    d2 = d2.replace(_re_formatted_numeric, "");
  }
  return !isNaN(parseFloat(d2)) && isFinite(d2);
};
var _isHtml = function(d2) {
  return _empty(d2) || typeof d2 === "string";
};
var _htmlNumeric = function(d2, decimalPoint, formatted, allowEmpty) {
  if (allowEmpty && _empty(d2)) {
    return true;
  }
  if (typeof d2 === "string" && d2.match(/<(input|select)/i)) {
    return null;
  }
  var html = _isHtml(d2);
  return !html ? null : _isNumber(_stripHtml(d2), decimalPoint, formatted, allowEmpty) ? true : null;
};
var _pluck = function(a2, prop, prop2) {
  var out = [];
  var i = 0, ien = a2.length;
  if (prop2 !== void 0) {
    for (; i < ien; i++) {
      if (a2[i] && a2[i][prop]) {
        out.push(a2[i][prop][prop2]);
      }
    }
  } else {
    for (; i < ien; i++) {
      if (a2[i]) {
        out.push(a2[i][prop]);
      }
    }
  }
  return out;
};
var _pluck_order = function(a2, order2, prop, prop2) {
  var out = [];
  var i = 0, ien = order2.length;
  if (prop2 !== void 0) {
    for (; i < ien; i++) {
      if (a2[order2[i]] && a2[order2[i]][prop]) {
        out.push(a2[order2[i]][prop][prop2]);
      }
    }
  } else {
    for (; i < ien; i++) {
      if (a2[order2[i]]) {
        out.push(a2[order2[i]][prop]);
      }
    }
  }
  return out;
};
var _range = function(len, start2) {
  var out = [];
  var end2;
  if (start2 === void 0) {
    start2 = 0;
    end2 = len;
  } else {
    end2 = start2;
    start2 = len;
  }
  for (var i = start2; i < end2; i++) {
    out.push(i);
  }
  return out;
};
var _removeEmpty = function(a2) {
  var out = [];
  for (var i = 0, ien = a2.length; i < ien; i++) {
    if (a2[i]) {
      out.push(a2[i]);
    }
  }
  return out;
};
var _stripHtml = function(input) {
  if (!input || typeof input !== "string") {
    return input;
  }
  if (input.length > _max_str_len) {
    throw new Error("Exceeded max str len");
  }
  var previous;
  input = input.replace(_re_html, "");
  do {
    previous = input;
    input = input.replace(/<script/i, "");
  } while (input !== previous);
  return previous;
};
var _escapeHtml = function(d2) {
  if (Array.isArray(d2)) {
    d2 = d2.join(",");
  }
  return typeof d2 === "string" ? d2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d2;
};
var _normalize = function(str2, both) {
  if (typeof str2 !== "string") {
    return str2;
  }
  var res2 = str2.normalize ? str2.normalize("NFD") : str2;
  return res2.length !== str2.length ? (both === true ? str2 + " " : "") + res2.replace(/[\u0300-\u036f]/g, "") : res2;
};
var _areAllUnique = function(src) {
  if (src.length < 2) {
    return true;
  }
  var sorted = src.slice().sort();
  var last = sorted[0];
  for (var i = 1, ien = sorted.length; i < ien; i++) {
    if (sorted[i] === last) {
      return false;
    }
    last = sorted[i];
  }
  return true;
};
var _unique = function(src) {
  if (Array.from && Set) {
    return Array.from(new Set(src));
  }
  if (_areAllUnique(src)) {
    return src.slice();
  }
  var out = [], val, i, ien = src.length, j2, k2 = 0;
  again:
    for (i = 0; i < ien; i++) {
      val = src[i];
      for (j2 = 0; j2 < k2; j2++) {
        if (out[j2] === val) {
          continue again;
        }
      }
      out.push(val);
      k2++;
    }
  return out;
};
var _flatten = function(out, val) {
  if (Array.isArray(val)) {
    for (var i = 0; i < val.length; i++) {
      _flatten(out, val[i]);
    }
  } else {
    out.push(val);
  }
  return out;
};
function _addClass(el, name2) {
  if (name2) {
    name2.split(" ").forEach(function(n2) {
      if (n2) {
        el.classList.add(n2);
      }
    });
  }
}
DataTable.util = {
  /**
   * Return a string with diacritic characters decomposed
   * @param {*} mixed Function or string to normalize
   * @param {*} both Return original string and the normalized string
   * @returns String or undefined
   */
  diacritics: function(mixed, both) {
    var type = typeof mixed;
    if (type !== "function") {
      return _normalize(mixed, both);
    }
    _normalize = mixed;
  },
  /**
   * Debounce a function
   *
   * @param {function} fn Function to be called
   * @param {integer} freq Call frequency in mS
   * @return {function} Wrapped function
   */
  debounce: function(fn3, timeout2) {
    var timer;
    return function() {
      var that = this;
      var args = arguments;
      clearTimeout(timer);
      timer = setTimeout(function() {
        fn3.apply(that, args);
      }, timeout2 || 250);
    };
  },
  /**
   * Throttle the calls to a function. Arguments and context are maintained
   * for the throttled function.
   *
   * @param {function} fn Function to be called
   * @param {integer} freq Call frequency in mS
   * @return {function} Wrapped function
   */
  throttle: function(fn3, freq) {
    var frequency = freq !== void 0 ? freq : 200, last, timer;
    return function() {
      var that = this, now = +/* @__PURE__ */ new Date(), args = arguments;
      if (last && now < last + frequency) {
        clearTimeout(timer);
        timer = setTimeout(function() {
          last = void 0;
          fn3.apply(that, args);
        }, frequency);
      } else {
        last = now;
        fn3.apply(that, args);
      }
    };
  },
  /**
   * Escape a string such that it can be used in a regular expression
   *
   *  @param {string} val string to escape
   *  @returns {string} escaped string
   */
  escapeRegex: function(val) {
    return val.replace(_re_escape_regex, "\\$1");
  },
  /**
   * Create a function that will write to a nested object or array
   * @param {*} source JSON notation string
   * @returns Write function
   */
  set: function(source) {
    if ($$6.isPlainObject(source)) {
      return DataTable.util.set(source._);
    } else if (source === null) {
      return function() {
      };
    } else if (typeof source === "function") {
      return function(data2, val, meta) {
        source(data2, "set", val, meta);
      };
    } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
      var setData = function(data2, val, src) {
        var a2 = _fnSplitObjNotation(src), b2;
        var aLast = a2[a2.length - 1];
        var arrayNotation, funcNotation, o2, innerSrc;
        for (var i = 0, iLen = a2.length - 1; i < iLen; i++) {
          if (a2[i] === "__proto__" || a2[i] === "constructor") {
            throw new Error("Cannot set prototype values");
          }
          arrayNotation = a2[i].match(__reArray);
          funcNotation = a2[i].match(__reFn);
          if (arrayNotation) {
            a2[i] = a2[i].replace(__reArray, "");
            data2[a2[i]] = [];
            b2 = a2.slice();
            b2.splice(0, i + 1);
            innerSrc = b2.join(".");
            if (Array.isArray(val)) {
              for (var j2 = 0, jLen = val.length; j2 < jLen; j2++) {
                o2 = {};
                setData(o2, val[j2], innerSrc);
                data2[a2[i]].push(o2);
              }
            } else {
              data2[a2[i]] = val;
            }
            return;
          } else if (funcNotation) {
            a2[i] = a2[i].replace(__reFn, "");
            data2 = data2[a2[i]](val);
          }
          if (data2[a2[i]] === null || data2[a2[i]] === void 0) {
            data2[a2[i]] = {};
          }
          data2 = data2[a2[i]];
        }
        if (aLast.match(__reFn)) {
          data2 = data2[aLast.replace(__reFn, "")](val);
        } else {
          data2[aLast.replace(__reArray, "")] = val;
        }
      };
      return function(data2, val) {
        return setData(data2, val, source);
      };
    } else {
      return function(data2, val) {
        data2[source] = val;
      };
    }
  },
  /**
   * Create a function that will read nested objects from arrays, based on JSON notation
   * @param {*} source JSON notation string
   * @returns Value read
   */
  get: function(source) {
    if ($$6.isPlainObject(source)) {
      var o2 = {};
      $$6.each(source, function(key, val) {
        if (val) {
          o2[key] = DataTable.util.get(val);
        }
      });
      return function(data2, type, row, meta) {
        var t2 = o2[type] || o2._;
        return t2 !== void 0 ? t2(data2, type, row, meta) : data2;
      };
    } else if (source === null) {
      return function(data2) {
        return data2;
      };
    } else if (typeof source === "function") {
      return function(data2, type, row, meta) {
        return source(data2, type, row, meta);
      };
    } else if (typeof source === "string" && (source.indexOf(".") !== -1 || source.indexOf("[") !== -1 || source.indexOf("(") !== -1)) {
      var fetchData = function(data2, type, src) {
        var arrayNotation, funcNotation, out, innerSrc;
        if (src !== "") {
          var a2 = _fnSplitObjNotation(src);
          for (var i = 0, iLen = a2.length; i < iLen; i++) {
            arrayNotation = a2[i].match(__reArray);
            funcNotation = a2[i].match(__reFn);
            if (arrayNotation) {
              a2[i] = a2[i].replace(__reArray, "");
              if (a2[i] !== "") {
                data2 = data2[a2[i]];
              }
              out = [];
              a2.splice(0, i + 1);
              innerSrc = a2.join(".");
              if (Array.isArray(data2)) {
                for (var j2 = 0, jLen = data2.length; j2 < jLen; j2++) {
                  out.push(fetchData(data2[j2], type, innerSrc));
                }
              }
              var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
              data2 = join === "" ? out : out.join(join);
              break;
            } else if (funcNotation) {
              a2[i] = a2[i].replace(__reFn, "");
              data2 = data2[a2[i]]();
              continue;
            }
            if (data2 === null || data2[a2[i]] === null) {
              return null;
            } else if (data2 === void 0 || data2[a2[i]] === void 0) {
              return void 0;
            }
            data2 = data2[a2[i]];
          }
        }
        return data2;
      };
      return function(data2, type) {
        return fetchData(data2, type, source);
      };
    } else {
      return function(data2) {
        return data2[source];
      };
    }
  },
  stripHtml: function(mixed) {
    var type = typeof mixed;
    if (type === "function") {
      _stripHtml = mixed;
      return;
    } else if (type === "string") {
      return _stripHtml(mixed);
    }
    return mixed;
  },
  escapeHtml: function(mixed) {
    var type = typeof mixed;
    if (type === "function") {
      _escapeHtml = mixed;
      return;
    } else if (type === "string" || Array.isArray(mixed)) {
      return _escapeHtml(mixed);
    }
    return mixed;
  },
  unique: _unique
};
function _fnHungarianMap(o2) {
  var hungarian = "a aa ai ao as b fn i m o s ", match, newKey, map2 = {};
  $$6.each(o2, function(key) {
    match = key.match(/^([^A-Z]+?)([A-Z])/);
    if (match && hungarian.indexOf(match[1] + " ") !== -1) {
      newKey = key.replace(match[0], match[2].toLowerCase());
      map2[newKey] = key;
      if (match[1] === "o") {
        _fnHungarianMap(o2[key]);
      }
    }
  });
  o2._hungarianMap = map2;
}
function _fnCamelToHungarian(src, user, force) {
  if (!src._hungarianMap) {
    _fnHungarianMap(src);
  }
  var hungarianKey;
  $$6.each(user, function(key) {
    hungarianKey = src._hungarianMap[key];
    if (hungarianKey !== void 0 && (force || user[hungarianKey] === void 0)) {
      if (hungarianKey.charAt(0) === "o") {
        if (!user[hungarianKey]) {
          user[hungarianKey] = {};
        }
        $$6.extend(true, user[hungarianKey], user[key]);
        _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force);
      } else {
        user[hungarianKey] = user[key];
      }
    }
  });
}
var _fnCompatMap = function(o2, knew, old2) {
  if (o2[knew] !== void 0) {
    o2[old2] = o2[knew];
  }
};
function _fnCompatOpts(init2) {
  _fnCompatMap(init2, "ordering", "bSort");
  _fnCompatMap(init2, "orderMulti", "bSortMulti");
  _fnCompatMap(init2, "orderClasses", "bSortClasses");
  _fnCompatMap(init2, "orderCellsTop", "bSortCellsTop");
  _fnCompatMap(init2, "order", "aaSorting");
  _fnCompatMap(init2, "orderFixed", "aaSortingFixed");
  _fnCompatMap(init2, "paging", "bPaginate");
  _fnCompatMap(init2, "pagingType", "sPaginationType");
  _fnCompatMap(init2, "pageLength", "iDisplayLength");
  _fnCompatMap(init2, "searching", "bFilter");
  if (typeof init2.sScrollX === "boolean") {
    init2.sScrollX = init2.sScrollX ? "100%" : "";
  }
  if (typeof init2.scrollX === "boolean") {
    init2.scrollX = init2.scrollX ? "100%" : "";
  }
  var searchCols = init2.aoSearchCols;
  if (searchCols) {
    for (var i = 0, ien = searchCols.length; i < ien; i++) {
      if (searchCols[i]) {
        _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i]);
      }
    }
  }
  if (init2.serverSide && !init2.searchDelay) {
    init2.searchDelay = 400;
  }
}
function _fnCompatCols(init2) {
  _fnCompatMap(init2, "orderable", "bSortable");
  _fnCompatMap(init2, "orderData", "aDataSort");
  _fnCompatMap(init2, "orderSequence", "asSorting");
  _fnCompatMap(init2, "orderDataType", "sortDataType");
  var dataSort = init2.aDataSort;
  if (typeof dataSort === "number" && !Array.isArray(dataSort)) {
    init2.aDataSort = [dataSort];
  }
}
function _fnBrowserDetect(settings) {
  if (!DataTable.__browser) {
    var browser2 = {};
    DataTable.__browser = browser2;
    var n2 = $$6("<div/>").css({
      position: "fixed",
      top: 0,
      left: -1 * window.pageXOffset,
      // allow for scrolling
      height: 1,
      width: 1,
      overflow: "hidden"
    }).append(
      $$6("<div/>").css({
        position: "absolute",
        top: 1,
        left: 1,
        width: 100,
        overflow: "scroll"
      }).append(
        $$6("<div/>").css({
          width: "100%",
          height: 10
        })
      )
    ).appendTo("body");
    var outer = n2.children();
    var inner = outer.children();
    browser2.barWidth = outer[0].offsetWidth - outer[0].clientWidth;
    browser2.bScrollbarLeft = Math.round(inner.offset().left) !== 1;
    n2.remove();
  }
  $$6.extend(settings.oBrowser, DataTable.__browser);
  settings.oScroll.iBarWidth = DataTable.__browser.barWidth;
}
function _fnAddColumn(oSettings) {
  var oDefaults = DataTable.defaults.column;
  var iCol = oSettings.aoColumns.length;
  var oCol = $$6.extend({}, DataTable.models.oColumn, oDefaults, {
    "aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
    "mData": oDefaults.mData ? oDefaults.mData : iCol,
    idx: iCol,
    searchFixed: {},
    colEl: $$6("<col>").attr("data-dt-column", iCol)
  });
  oSettings.aoColumns.push(oCol);
  var searchCols = oSettings.aoPreSearchCols;
  searchCols[iCol] = $$6.extend({}, DataTable.models.oSearch, searchCols[iCol]);
}
function _fnColumnOptions(oSettings, iCol, oOptions) {
  var oCol = oSettings.aoColumns[iCol];
  if (oOptions !== void 0 && oOptions !== null) {
    _fnCompatCols(oOptions);
    _fnCamelToHungarian(DataTable.defaults.column, oOptions, true);
    if (oOptions.mDataProp !== void 0 && !oOptions.mData) {
      oOptions.mData = oOptions.mDataProp;
    }
    if (oOptions.sType) {
      oCol._sManualType = oOptions.sType;
    }
    if (oOptions.className && !oOptions.sClass) {
      oOptions.sClass = oOptions.className;
    }
    var origClass = oCol.sClass;
    $$6.extend(oCol, oOptions);
    _fnMap(oCol, oOptions, "sWidth", "sWidthOrig");
    if (origClass !== oCol.sClass) {
      oCol.sClass = origClass + " " + oCol.sClass;
    }
    if (oOptions.iDataSort !== void 0) {
      oCol.aDataSort = [oOptions.iDataSort];
    }
    _fnMap(oCol, oOptions, "aDataSort");
  }
  var mDataSrc = oCol.mData;
  var mData = _fnGetObjectDataFn(mDataSrc);
  if (oCol.mRender && Array.isArray(oCol.mRender)) {
    var copy = oCol.mRender.slice();
    var name2 = copy.shift();
    oCol.mRender = DataTable.render[name2].apply(window, copy);
  }
  oCol._render = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null;
  var attrTest = function(src) {
    return typeof src === "string" && src.indexOf("@") !== -1;
  };
  oCol._bAttrSrc = $$6.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter));
  oCol._setter = null;
  oCol.fnGetData = function(rowData, type, meta) {
    var innerData = mData(rowData, type, void 0, meta);
    return oCol._render && type ? oCol._render(innerData, type, rowData, meta) : innerData;
  };
  oCol.fnSetData = function(rowData, val, meta) {
    return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta);
  };
  if (typeof mDataSrc !== "number" && !oCol._isArrayHost) {
    oSettings._rowReadObject = true;
  }
  if (!oSettings.oFeatures.bSort) {
    oCol.bSortable = false;
  }
}
function _fnAdjustColumnSizing(settings) {
  _fnCalculateColumnWidths(settings);
  _fnColumnSizes(settings);
  var scroll = settings.oScroll;
  if (scroll.sY !== "" || scroll.sX !== "") {
    _fnScrollDraw(settings);
  }
  _fnCallbackFire(settings, null, "column-sizing", [settings]);
}
function _fnColumnSizes(settings) {
  var cols = settings.aoColumns;
  for (var i = 0; i < cols.length; i++) {
    var width = _fnColumnsSumWidth(settings, [i], false, false);
    cols[i].colEl.css("width", width);
    if (settings.oScroll.sX) {
      cols[i].colEl.css("min-width", width);
    }
  }
}
function _fnVisibleToColumnIndex(oSettings, iMatch) {
  var aiVis = _fnGetColumns(oSettings, "bVisible");
  return typeof aiVis[iMatch] === "number" ? aiVis[iMatch] : null;
}
function _fnColumnIndexToVisible(oSettings, iMatch) {
  var aiVis = _fnGetColumns(oSettings, "bVisible");
  var iPos = aiVis.indexOf(iMatch);
  return iPos !== -1 ? iPos : null;
}
function _fnVisbleColumns(settings) {
  var layout = settings.aoHeader;
  var columns = settings.aoColumns;
  var vis = 0;
  if (layout.length) {
    for (var i = 0, ien = layout[0].length; i < ien; i++) {
      if (columns[i].bVisible && $$6(layout[0][i].cell).css("display") !== "none") {
        vis++;
      }
    }
  }
  return vis;
}
function _fnGetColumns(oSettings, sParam) {
  var a2 = [];
  oSettings.aoColumns.map(function(val, i) {
    if (val[sParam]) {
      a2.push(i);
    }
  });
  return a2;
}
function _typeResult(typeDetect, res2) {
  return res2 === true ? typeDetect._name : res2;
}
function _fnColumnTypes(settings) {
  var columns = settings.aoColumns;
  var data2 = settings.aoData;
  var types = DataTable.ext.type.detect;
  var i, ien, j2, jen, k2, ken;
  var col, detectedType, cache;
  for (i = 0, ien = columns.length; i < ien; i++) {
    col = columns[i];
    cache = [];
    if (!col.sType && col._sManualType) {
      col.sType = col._sManualType;
    } else if (!col.sType) {
      if (!settings.typeDetect) {
        return;
      }
      for (j2 = 0, jen = types.length; j2 < jen; j2++) {
        var typeDetect = types[j2];
        var oneOf = typeDetect.oneOf;
        var allOf = typeDetect.allOf || typeDetect;
        var init2 = typeDetect.init;
        var one = false;
        detectedType = null;
        if (init2) {
          detectedType = _typeResult(typeDetect, init2(settings, col, i));
          if (detectedType) {
            col.sType = detectedType;
            break;
          }
        }
        for (k2 = 0, ken = data2.length; k2 < ken; k2++) {
          if (!data2[k2]) {
            continue;
          }
          if (cache[k2] === void 0) {
            cache[k2] = _fnGetCellData(settings, k2, i, "type");
          }
          if (oneOf && !one) {
            one = _typeResult(typeDetect, oneOf(cache[k2], settings));
          }
          detectedType = _typeResult(typeDetect, allOf(cache[k2], settings));
          if (!detectedType && j2 !== types.length - 3) {
            break;
          }
          if (detectedType === "html" && !_empty(cache[k2])) {
            break;
          }
        }
        if (oneOf && one && detectedType || !oneOf && detectedType) {
          col.sType = detectedType;
          break;
        }
      }
      if (!col.sType) {
        col.sType = "string";
      }
    }
    var autoClass = _ext.type.className[col.sType];
    if (autoClass) {
      _columnAutoClass(settings.aoHeader, i, autoClass);
      _columnAutoClass(settings.aoFooter, i, autoClass);
    }
    var renderer = _ext.type.render[col.sType];
    if (renderer && !col._render) {
      col._render = DataTable.util.get(renderer);
      _columnAutoRender(settings, i);
    }
  }
}
function _columnAutoRender(settings, colIdx) {
  var data2 = settings.aoData;
  for (var i = 0; i < data2.length; i++) {
    if (data2[i].nTr) {
      var display = _fnGetCellData(settings, i, colIdx, "display");
      data2[i].displayData[colIdx] = display;
      _fnWriteCell(data2[i].anCells[colIdx], display);
    }
  }
}
function _columnAutoClass(container, colIdx, className) {
  container.forEach(function(row) {
    if (row[colIdx] && row[colIdx].unique) {
      _addClass(row[colIdx].cell, className);
    }
  });
}
function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, headerLayout, fn3) {
  var i, iLen, j2, jLen, k2, kLen, def;
  var columns = oSettings.aoColumns;
  if (aoCols) {
    for (i = 0, iLen = aoCols.length; i < iLen; i++) {
      if (aoCols[i] && aoCols[i].name) {
        columns[i].sName = aoCols[i].name;
      }
    }
  }
  if (aoColDefs) {
    for (i = aoColDefs.length - 1; i >= 0; i--) {
      def = aoColDefs[i];
      var aTargets = def.target !== void 0 ? def.target : def.targets !== void 0 ? def.targets : def.aTargets;
      if (!Array.isArray(aTargets)) {
        aTargets = [aTargets];
      }
      for (j2 = 0, jLen = aTargets.length; j2 < jLen; j2++) {
        var target = aTargets[j2];
        if (typeof target === "number" && target >= 0) {
          while (columns.length <= target) {
            _fnAddColumn(oSettings);
          }
          fn3(target, def);
        } else if (typeof target === "number" && target < 0) {
          fn3(columns.length + target, def);
        } else if (typeof target === "string") {
          for (k2 = 0, kLen = columns.length; k2 < kLen; k2++) {
            if (target === "_all") {
              fn3(k2, def);
            } else if (target.indexOf(":name") !== -1) {
              if (columns[k2].sName === target.replace(":name", "")) {
                fn3(k2, def);
              }
            } else {
              headerLayout.forEach(function(row) {
                if (row[k2]) {
                  var cell = $$6(row[k2].cell);
                  if (target.match(/^[a-z][\w-]*$/i)) {
                    target = "." + target;
                  }
                  if (cell.is(target)) {
                    fn3(k2, def);
                  }
                }
              });
            }
          }
        }
      }
    }
  }
  if (aoCols) {
    for (i = 0, iLen = aoCols.length; i < iLen; i++) {
      fn3(i, aoCols[i]);
    }
  }
}
function _fnColumnsSumWidth(settings, targets, original, incVisible) {
  if (!Array.isArray(targets)) {
    targets = _fnColumnsFromHeader(targets);
  }
  var sum = 0;
  var unit;
  var columns = settings.aoColumns;
  for (var i = 0, ien = targets.length; i < ien; i++) {
    var column = columns[targets[i]];
    var definedWidth = original ? column.sWidthOrig : column.sWidth;
    if (!incVisible && column.bVisible === false) {
      continue;
    }
    if (definedWidth === null || definedWidth === void 0) {
      return null;
    } else if (typeof definedWidth === "number") {
      unit = "px";
      sum += definedWidth;
    } else {
      var matched = definedWidth.match(/([\d\.]+)([^\d]*)/);
      if (matched) {
        sum += matched[1] * 1;
        unit = matched.length === 3 ? matched[2] : "px";
      }
    }
  }
  return sum + unit;
}
function _fnColumnsFromHeader(cell) {
  var attr2 = $$6(cell).closest("[data-dt-column]").attr("data-dt-column");
  if (!attr2) {
    return [];
  }
  return attr2.split(",").map(function(val) {
    return val * 1;
  });
}
function _fnAddData(settings, dataIn, tr, tds) {
  var rowIdx = settings.aoData.length;
  var rowModel = $$6.extend(true, {}, DataTable.models.oRow, {
    src: tr ? "dom" : "data",
    idx: rowIdx
  });
  rowModel._aData = dataIn;
  settings.aoData.push(rowModel);
  var columns = settings.aoColumns;
  for (var i = 0, iLen = columns.length; i < iLen; i++) {
    columns[i].sType = null;
  }
  settings.aiDisplayMaster.push(rowIdx);
  var id = settings.rowIdFn(dataIn);
  if (id !== void 0) {
    settings.aIds[id] = rowModel;
  }
  if (tr || !settings.oFeatures.bDeferRender) {
    _fnCreateTr(settings, rowIdx, tr, tds);
  }
  return rowIdx;
}
function _fnAddTr(settings, trs) {
  var row;
  if (!(trs instanceof $$6)) {
    trs = $$6(trs);
  }
  return trs.map(function(i, el) {
    row = _fnGetRowElements(settings, el);
    return _fnAddData(settings, row.data, el, row.cells);
  });
}
function _fnGetCellData(settings, rowIdx, colIdx, type) {
  if (type === "search") {
    type = "filter";
  } else if (type === "order") {
    type = "sort";
  }
  var row = settings.aoData[rowIdx];
  if (!row) {
    return void 0;
  }
  var draw = settings.iDraw;
  var col = settings.aoColumns[colIdx];
  var rowData = row._aData;
  var defaultContent = col.sDefaultContent;
  var cellData = col.fnGetData(rowData, type, {
    settings,
    row: rowIdx,
    col: colIdx
  });
  if (type !== "display" && cellData && typeof cellData === "object" && cellData.nodeName) {
    cellData = cellData.innerHTML;
  }
  if (cellData === void 0) {
    if (settings.iDrawError != draw && defaultContent === null) {
      _fnLog(settings, 0, "Requested unknown parameter " + (typeof col.mData == "function" ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4);
      settings.iDrawError = draw;
    }
    return defaultContent;
  }
  if ((cellData === rowData || cellData === null) && defaultContent !== null && type !== void 0) {
    cellData = defaultContent;
  } else if (typeof cellData === "function") {
    return cellData.call(rowData);
  }
  if (cellData === null && type === "display") {
    return "";
  }
  if (type === "filter") {
    var fomatters = DataTable.ext.type.search;
    if (fomatters[col.sType]) {
      cellData = fomatters[col.sType](cellData);
    }
  }
  return cellData;
}
function _fnSetCellData(settings, rowIdx, colIdx, val) {
  var col = settings.aoColumns[colIdx];
  var rowData = settings.aoData[rowIdx]._aData;
  col.fnSetData(rowData, val, {
    settings,
    row: rowIdx,
    col: colIdx
  });
}
function _fnWriteCell(td, val) {
  if (val && typeof val === "object" && val.nodeName) {
    $$6(td).empty().append(val);
  } else {
    td.innerHTML = val;
  }
}
var __reArray = /\[.*?\]$/;
var __reFn = /\(\)$/;
function _fnSplitObjNotation(str2) {
  var parts = str2.match(/(\\.|[^.])+/g) || [""];
  return parts.map(function(s2) {
    return s2.replace(/\\\./g, ".");
  });
}
var _fnGetObjectDataFn = DataTable.util.get;
var _fnSetObjectDataFn = DataTable.util.set;
function _fnGetDataMaster(settings) {
  return _pluck(settings.aoData, "_aData");
}
function _fnClearTable(settings) {
  settings.aoData.length = 0;
  settings.aiDisplayMaster.length = 0;
  settings.aiDisplay.length = 0;
  settings.aIds = {};
}
function _fnInvalidate(settings, rowIdx, src, colIdx) {
  var row = settings.aoData[rowIdx];
  var i, ien;
  row._aSortData = null;
  row._aFilterData = null;
  row.displayData = null;
  if (src === "dom" || (!src || src === "auto") && row.src === "dom") {
    row._aData = _fnGetRowElements(
      settings,
      row,
      colIdx,
      colIdx === void 0 ? void 0 : row._aData
    ).data;
  } else {
    var cells = row.anCells;
    var display = _fnGetRowDisplay(settings, rowIdx);
    if (cells) {
      if (colIdx !== void 0) {
        _fnWriteCell(cells[colIdx], display[colIdx]);
      } else {
        for (i = 0, ien = cells.length; i < ien; i++) {
          _fnWriteCell(cells[i], display[i]);
        }
      }
    }
  }
  var cols = settings.aoColumns;
  if (colIdx !== void 0) {
    cols[colIdx].sType = null;
    cols[colIdx].maxLenString = null;
  } else {
    for (i = 0, ien = cols.length; i < ien; i++) {
      cols[i].sType = null;
      cols[i].maxLenString = null;
    }
    _fnRowAttributes(settings, row);
  }
}
function _fnGetRowElements(settings, row, colIdx, d2) {
  var tds = [], td = row.firstChild, name2, col, i = 0, contents, columns = settings.aoColumns, objectRead = settings._rowReadObject;
  d2 = d2 !== void 0 ? d2 : objectRead ? {} : [];
  var attr2 = function(str2, td2) {
    if (typeof str2 === "string") {
      var idx = str2.indexOf("@");
      if (idx !== -1) {
        var attr3 = str2.substring(idx + 1);
        var setter = _fnSetObjectDataFn(str2);
        setter(d2, td2.getAttribute(attr3));
      }
    }
  };
  var cellProcess = function(cell) {
    if (colIdx === void 0 || colIdx === i) {
      col = columns[i];
      contents = cell.innerHTML.trim();
      if (col && col._bAttrSrc) {
        var setter = _fnSetObjectDataFn(col.mData._);
        setter(d2, contents);
        attr2(col.mData.sort, cell);
        attr2(col.mData.type, cell);
        attr2(col.mData.filter, cell);
      } else {
        if (objectRead) {
          if (!col._setter) {
            col._setter = _fnSetObjectDataFn(col.mData);
          }
          col._setter(d2, contents);
        } else {
          d2[i] = contents;
        }
      }
    }
    i++;
  };
  if (td) {
    while (td) {
      name2 = td.nodeName.toUpperCase();
      if (name2 == "TD" || name2 == "TH") {
        cellProcess(td);
        tds.push(td);
      }
      td = td.nextSibling;
    }
  } else {
    tds = row.anCells;
    for (var j2 = 0, jen = tds.length; j2 < jen; j2++) {
      cellProcess(tds[j2]);
    }
  }
  var rowNode = row.firstChild ? row : row.nTr;
  if (rowNode) {
    var id = rowNode.getAttribute("id");
    if (id) {
      _fnSetObjectDataFn(settings.rowId)(d2, id);
    }
  }
  return {
    data: d2,
    cells: tds
  };
}
function _fnGetRowDisplay(settings, rowIdx) {
  var rowModal = settings.aoData[rowIdx];
  var columns = settings.aoColumns;
  if (!rowModal.displayData) {
    rowModal.displayData = [];
    for (var colIdx = 0, len = columns.length; colIdx < len; colIdx++) {
      rowModal.displayData.push(
        _fnGetCellData(settings, rowIdx, colIdx, "display")
      );
    }
  }
  return rowModal.displayData;
}
function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
  var row = oSettings.aoData[iRow], rowData = row._aData, cells = [], nTr, nTd, oCol, i, iLen, create2, trClass = oSettings.oClasses.tbody.row;
  if (row.nTr === null) {
    nTr = nTrIn || document.createElement("tr");
    row.nTr = nTr;
    row.anCells = cells;
    _addClass(nTr, trClass);
    nTr._DT_RowIndex = iRow;
    _fnRowAttributes(oSettings, row);
    for (i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) {
      oCol = oSettings.aoColumns[i];
      create2 = nTrIn && anTds[i] ? false : true;
      nTd = create2 ? document.createElement(oCol.sCellType) : anTds[i];
      if (!nTd) {
        _fnLog(oSettings, 0, "Incorrect column count", 18);
      }
      nTd._DT_CellIndex = {
        row: iRow,
        column: i
      };
      cells.push(nTd);
      var display = _fnGetRowDisplay(oSettings, iRow);
      if (create2 || (oCol.mRender || oCol.mData !== i) && (!$$6.isPlainObject(oCol.mData) || oCol.mData._ !== i + ".display")) {
        _fnWriteCell(nTd, display[i]);
      }
      _addClass(nTd, oCol.sClass);
      if (oCol.bVisible && create2) {
        nTr.appendChild(nTd);
      } else if (!oCol.bVisible && !create2) {
        nTd.parentNode.removeChild(nTd);
      }
      if (oCol.fnCreatedCell) {
        oCol.fnCreatedCell.call(
          oSettings.oInstance,
          nTd,
          _fnGetCellData(oSettings, iRow, i),
          rowData,
          iRow,
          i
        );
      }
    }
    _fnCallbackFire(oSettings, "aoRowCreatedCallback", "row-created", [nTr, rowData, iRow, cells]);
  } else {
    _addClass(row.nTr, trClass);
  }
}
function _fnRowAttributes(settings, row) {
  var tr = row.nTr;
  var data2 = row._aData;
  if (tr) {
    var id = settings.rowIdFn(data2);
    if (id) {
      tr.id = id;
    }
    if (data2.DT_RowClass) {
      var a2 = data2.DT_RowClass.split(" ");
      row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a2)) : a2;
      $$6(tr).removeClass(row.__rowc.join(" ")).addClass(data2.DT_RowClass);
    }
    if (data2.DT_RowAttr) {
      $$6(tr).attr(data2.DT_RowAttr);
    }
    if (data2.DT_RowData) {
      $$6(tr).data(data2.DT_RowData);
    }
  }
}
function _fnBuildHead(settings, side) {
  var classes = settings.oClasses;
  var columns = settings.aoColumns;
  var i, ien, row;
  var target = side === "header" ? settings.nTHead : settings.nTFoot;
  var titleProp = side === "header" ? "sTitle" : side;
  if (!target) {
    return;
  }
  if (side === "header" || _pluck(settings.aoColumns, titleProp).join("")) {
    row = $$6("tr", target);
    if (!row.length) {
      row = $$6("<tr/>").appendTo(target);
    }
    if (row.length === 1) {
      var cellCount = 0;
      $$6("td, th", row).each(function() {
        cellCount += this.colSpan;
      });
      for (i = cellCount, ien = columns.length; i < ien; i++) {
        $$6("<th/>").html(columns[i][titleProp] || "").appendTo(row);
      }
    }
  }
  var detected = _fnDetectHeader(settings, target, true);
  if (side === "header") {
    settings.aoHeader = detected;
    $$6("tr", target).addClass(classes.thead.row);
  } else {
    settings.aoFooter = detected;
    $$6("tr", target).addClass(classes.tfoot.row);
  }
  $$6(target).children("tr").children("th, td").each(function() {
    _fnRenderer(settings, side)(
      settings,
      $$6(this),
      classes
    );
  });
}
function _fnHeaderLayout(settings, source, incColumns) {
  var row, column, cell;
  var local = [];
  var structure = [];
  var columns = settings.aoColumns;
  var columnCount = columns.length;
  var rowspan, colspan;
  if (!source) {
    return;
  }
  if (!incColumns) {
    incColumns = _range(columnCount).filter(function(idx) {
      return columns[idx].bVisible;
    });
  }
  for (row = 0; row < source.length; row++) {
    local[row] = source[row].slice().filter(function(cell2, i) {
      return incColumns.includes(i);
    });
    structure.push([]);
  }
  for (row = 0; row < local.length; row++) {
    for (column = 0; column < local[row].length; column++) {
      rowspan = 1;
      colspan = 1;
      if (structure[row][column] === void 0) {
        cell = local[row][column].cell;
        while (local[row + rowspan] !== void 0 && local[row][column].cell == local[row + rowspan][column].cell) {
          structure[row + rowspan][column] = null;
          rowspan++;
        }
        while (local[row][column + colspan] !== void 0 && local[row][column].cell == local[row][column + colspan].cell) {
          for (var k2 = 0; k2 < rowspan; k2++) {
            structure[row + k2][column + colspan] = null;
          }
          colspan++;
        }
        var titleSpan = $$6("span.dt-column-title", cell);
        structure[row][column] = {
          cell,
          colspan,
          rowspan,
          title: titleSpan.length ? titleSpan.html() : $$6(cell).html()
        };
      }
    }
  }
  return structure;
}
function _fnDrawHead(settings, source) {
  var layout = _fnHeaderLayout(settings, source);
  var tr, n2;
  for (var row = 0; row < source.length; row++) {
    tr = source[row].row;
    if (tr) {
      while (n2 = tr.firstChild) {
        tr.removeChild(n2);
      }
    }
    for (var column = 0; column < layout[row].length; column++) {
      var point = layout[row][column];
      if (point) {
        $$6(point.cell).appendTo(tr).attr("rowspan", point.rowspan).attr("colspan", point.colspan);
      }
    }
  }
}
function _fnDraw(oSettings, ajaxComplete) {
  _fnStart(oSettings);
  var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
  if (aPreDraw.indexOf(false) !== -1) {
    _fnProcessingDisplay(oSettings, false);
    return;
  }
  var anRows = [];
  var iRowCount = 0;
  var bServerSide = _fnDataSource(oSettings) == "ssp";
  var aiDisplay = oSettings.aiDisplay;
  var iDisplayStart = oSettings._iDisplayStart;
  var iDisplayEnd = oSettings.fnDisplayEnd();
  var columns = oSettings.aoColumns;
  var body = $$6(oSettings.nTBody);
  oSettings.bDrawing = true;
  if (oSettings.deferLoading) {
    oSettings.deferLoading = false;
    oSettings.iDraw++;
    _fnProcessingDisplay(oSettings, false);
  } else if (!bServerSide) {
    oSettings.iDraw++;
  } else if (!oSettings.bDestroying && !ajaxComplete) {
    if (oSettings.iDraw === 0) {
      body.empty().append(_emptyRow(oSettings));
    }
    _fnAjaxUpdate(oSettings);
    return;
  }
  if (aiDisplay.length !== 0) {
    var iStart = bServerSide ? 0 : iDisplayStart;
    var iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd;
    for (var j2 = iStart; j2 < iEnd; j2++) {
      var iDataIndex = aiDisplay[j2];
      var aoData = oSettings.aoData[iDataIndex];
      if (aoData.nTr === null) {
        _fnCreateTr(oSettings, iDataIndex);
      }
      var nRow = aoData.nTr;
      for (var i = 0; i < columns.length; i++) {
        var col = columns[i];
        var td = aoData.anCells[i];
        _addClass(td, _ext.type.className[col.sType]);
        _addClass(td, oSettings.oClasses.tbody.cell);
      }
      _fnCallbackFire(
        oSettings,
        "aoRowCallback",
        null,
        [nRow, aoData._aData, iRowCount, j2, iDataIndex]
      );
      anRows.push(nRow);
      iRowCount++;
    }
  } else {
    anRows[0] = _emptyRow(oSettings);
  }
  _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [
    $$6(oSettings.nTHead).children("tr")[0],
    _fnGetDataMaster(oSettings),
    iDisplayStart,
    iDisplayEnd,
    aiDisplay
  ]);
  _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [
    $$6(oSettings.nTFoot).children("tr")[0],
    _fnGetDataMaster(oSettings),
    iDisplayStart,
    iDisplayEnd,
    aiDisplay
  ]);
  if (body[0].replaceChildren) {
    body[0].replaceChildren.apply(body[0], anRows);
  } else {
    body.children().detach();
    body.append($$6(anRows));
  }
  $$6(oSettings.nTableWrapper).toggleClass("dt-empty-footer", $$6("tr", oSettings.nTFoot).length === 0);
  _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings], true);
  oSettings.bSorted = false;
  oSettings.bFiltered = false;
  oSettings.bDrawing = false;
}
function _fnReDraw(settings, holdPosition, recompute) {
  var features = settings.oFeatures, sort = features.bSort, filter2 = features.bFilter;
  if (recompute === void 0 || recompute === true) {
    _fnColumnTypes(settings);
    if (sort) {
      _fnSort(settings);
    }
    if (filter2) {
      _fnFilterComplete(settings, settings.oPreviousSearch);
    } else {
      settings.aiDisplay = settings.aiDisplayMaster.slice();
    }
  }
  if (holdPosition !== true) {
    settings._iDisplayStart = 0;
  }
  settings._drawHold = holdPosition;
  _fnDraw(settings);
  settings._drawHold = false;
}
function _emptyRow(settings) {
  var oLang = settings.oLanguage;
  var zero = oLang.sZeroRecords;
  var dataSrc = _fnDataSource(settings);
  if (settings.iDraw < 1 && dataSrc === "ssp" || settings.iDraw <= 1 && dataSrc === "ajax") {
    zero = oLang.sLoadingRecords;
  } else if (oLang.sEmptyTable && settings.fnRecordsTotal() === 0) {
    zero = oLang.sEmptyTable;
  }
  return $$6("<tr/>").append($$6("<td />", {
    "colSpan": _fnVisbleColumns(settings),
    "class": settings.oClasses.empty.row
  }).html(zero))[0];
}
function _layoutItems(row, align, items) {
  if (Array.isArray(items)) {
    for (var i = 0; i < items.length; i++) {
      _layoutItems(row, align, items[i]);
    }
    return;
  }
  var rowCell = row[align];
  if ($$6.isPlainObject(items)) {
    if (items.features) {
      if (items.rowId) {
        row.id = items.rowId;
      }
      if (items.rowClass) {
        row.className = items.rowClass;
      }
      rowCell.id = items.id;
      rowCell.className = items.className;
      _layoutItems(row, align, items.features);
    } else {
      Object.keys(items).map(function(key) {
        rowCell.contents.push({
          feature: key,
          opts: items[key]
        });
      });
    }
  } else {
    rowCell.contents.push(items);
  }
}
function _layoutGetRow(rows, rowNum, align) {
  var row;
  for (var i = 0; i < rows.length; i++) {
    row = rows[i];
    if (row.rowNum === rowNum) {
      if (align === "full" && row.full || (align === "start" || align === "end") && (row.start || row.end)) {
        if (!row[align]) {
          row[align] = {
            contents: []
          };
        }
        return row;
      }
    }
  }
  row = {
    rowNum
  };
  row[align] = {
    contents: []
  };
  rows.push(row);
  return row;
}
function _layoutArray(settings, layout, side) {
  var rows = [];
  $$6.each(layout, function(pos, items) {
    if (items === null) {
      return;
    }
    var parts = pos.match(/^([a-z]+)([0-9]*)([A-Za-z]*)$/);
    var rowNum = parts[2] ? parts[2] * 1 : 0;
    var align = parts[3] ? parts[3].toLowerCase() : "full";
    if (parts[1] !== side) {
      return;
    }
    var row2 = _layoutGetRow(rows, rowNum, align);
    _layoutItems(row2, align, items);
  });
  rows.sort(function(a2, b2) {
    var order1 = a2.rowNum;
    var order2 = b2.rowNum;
    if (order1 === order2) {
      var ret = a2.full && !b2.full ? -1 : 1;
      return side === "bottom" ? ret * -1 : ret;
    }
    return order2 - order1;
  });
  if (side === "bottom") {
    rows.reverse();
  }
  for (var row = 0; row < rows.length; row++) {
    delete rows[row].rowNum;
    _layoutResolve(settings, rows[row]);
  }
  return rows;
}
function _layoutResolve(settings, row) {
  var getFeature = function(feature, opts) {
    if (!_ext.features[feature]) {
      _fnLog(settings, 0, "Unknown feature: " + feature);
    }
    return _ext.features[feature].apply(this, [settings, opts]);
  };
  var resolve = function(item2) {
    if (!row[item2]) {
      return;
    }
    var line = row[item2].contents;
    for (var i = 0, ien = line.length; i < ien; i++) {
      if (!line[i]) {
        continue;
      } else if (typeof line[i] === "string") {
        line[i] = getFeature(line[i], null);
      } else if ($$6.isPlainObject(line[i])) {
        line[i] = getFeature(line[i].feature, line[i].opts);
      } else if (typeof line[i].node === "function") {
        line[i] = line[i].node(settings);
      } else if (typeof line[i] === "function") {
        var inst = line[i](settings);
        line[i] = typeof inst.node === "function" ? inst.node() : inst;
      }
    }
  };
  resolve("start");
  resolve("end");
  resolve("full");
}
function _fnAddOptionsHtml(settings) {
  var classes = settings.oClasses;
  var table = $$6(settings.nTable);
  var insert = $$6("<div/>").attr({
    id: settings.sTableId + "_wrapper",
    "class": classes.container
  }).insertBefore(table);
  settings.nTableWrapper = insert[0];
  if (settings.sDom) {
    _fnLayoutDom(settings, settings.sDom, insert);
  } else {
    var top2 = _layoutArray(settings, settings.layout, "top");
    var bottom2 = _layoutArray(settings, settings.layout, "bottom");
    var renderer = _fnRenderer(settings, "layout");
    top2.forEach(function(item2) {
      renderer(settings, insert, item2);
    });
    renderer(settings, insert, {
      full: {
        table: true,
        contents: [_fnFeatureHtmlTable(settings)]
      }
    });
    bottom2.forEach(function(item2) {
      renderer(settings, insert, item2);
    });
  }
  _processingHtml(settings);
}
function _fnLayoutDom(settings, dom, insert) {
  var parts = dom.match(/(".*?")|('.*?')|./g);
  var featureNode, option2, newNode, next, attr2;
  for (var i = 0; i < parts.length; i++) {
    featureNode = null;
    option2 = parts[i];
    if (option2 == "<") {
      newNode = $$6("<div/>");
      next = parts[i + 1];
      if (next[0] == "'" || next[0] == '"') {
        attr2 = next.replace(/['"]/g, "");
        var id = "", className;
        if (attr2.indexOf(".") != -1) {
          var split = attr2.split(".");
          id = split[0];
          className = split[1];
        } else if (attr2[0] == "#") {
          id = attr2;
        } else {
          className = attr2;
        }
        newNode.attr("id", id.substring(1)).addClass(className);
        i++;
      }
      insert.append(newNode);
      insert = newNode;
    } else if (option2 == ">") {
      insert = insert.parent();
    } else if (option2 == "t") {
      featureNode = _fnFeatureHtmlTable(settings);
    } else {
      DataTable.ext.feature.forEach(function(feature) {
        if (option2 == feature.cFeature) {
          featureNode = feature.fnInit(settings);
        }
      });
    }
    if (featureNode) {
      insert.append(featureNode);
    }
  }
}
function _fnDetectHeader(settings, thead, write2) {
  var columns = settings.aoColumns;
  var rows = $$6(thead).children("tr");
  var row, cell;
  var i, k2, l2, iLen, shifted, column, colspan, rowspan;
  var isHeader = thead && thead.nodeName.toLowerCase() === "thead";
  var layout = [];
  var unique;
  var shift = function(a2, i2, j2) {
    var k3 = a2[i2];
    while (k3[j2]) {
      j2++;
    }
    return j2;
  };
  for (i = 0, iLen = rows.length; i < iLen; i++) {
    layout.push([]);
  }
  for (i = 0, iLen = rows.length; i < iLen; i++) {
    row = rows[i];
    column = 0;
    cell = row.firstChild;
    while (cell) {
      if (cell.nodeName.toUpperCase() == "TD" || cell.nodeName.toUpperCase() == "TH") {
        var cols = [];
        colspan = cell.getAttribute("colspan") * 1;
        rowspan = cell.getAttribute("rowspan") * 1;
        colspan = !colspan || colspan === 0 || colspan === 1 ? 1 : colspan;
        rowspan = !rowspan || rowspan === 0 || rowspan === 1 ? 1 : rowspan;
        shifted = shift(layout, i, column);
        unique = colspan === 1 ? true : false;
        if (write2) {
          if (unique) {
            _fnColumnOptions(settings, shifted, $$6(cell).data());
            var columnDef = columns[shifted];
            var width = cell.getAttribute("width") || null;
            var t2 = cell.style.width.match(/width:\s*(\d+[pxem%]+)/);
            if (t2) {
              width = t2[1];
            }
            columnDef.sWidthOrig = columnDef.sWidth || width;
            if (isHeader) {
              if (columnDef.sTitle !== null && !columnDef.autoTitle) {
                cell.innerHTML = columnDef.sTitle;
              }
              if (!columnDef.sTitle && unique) {
                columnDef.sTitle = _stripHtml(cell.innerHTML);
                columnDef.autoTitle = true;
              }
            } else {
              if (columnDef.footer) {
                cell.innerHTML = columnDef.footer;
              }
            }
            if (!columnDef.ariaTitle) {
              columnDef.ariaTitle = $$6(cell).attr("aria-label") || columnDef.sTitle;
            }
            if (columnDef.className) {
              $$6(cell).addClass(columnDef.className);
            }
          }
          if ($$6("span.dt-column-title", cell).length === 0) {
            $$6("<span>").addClass("dt-column-title").append(cell.childNodes).appendTo(cell);
          }
          if (isHeader && $$6("span.dt-column-order", cell).length === 0) {
            $$6("<span>").addClass("dt-column-order").appendTo(cell);
          }
        }
        for (l2 = 0; l2 < colspan; l2++) {
          for (k2 = 0; k2 < rowspan; k2++) {
            layout[i + k2][shifted + l2] = {
              cell,
              unique
            };
            layout[i + k2].row = row;
          }
          cols.push(shifted + l2);
        }
        cell.setAttribute("data-dt-column", _unique(cols).join(","));
      }
      cell = cell.nextSibling;
    }
  }
  return layout;
}
function _fnStart(oSettings) {
  var bServerSide = _fnDataSource(oSettings) == "ssp";
  var iInitDisplayStart = oSettings.iInitDisplayStart;
  if (iInitDisplayStart !== void 0 && iInitDisplayStart !== -1) {
    oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart;
    oSettings.iInitDisplayStart = -1;
  }
}
function _fnBuildAjax(oSettings, data2, fn3) {
  var ajaxData;
  var ajax = oSettings.ajax;
  var instance = oSettings.oInstance;
  var callback = function(json) {
    var status = oSettings.jqXHR ? oSettings.jqXHR.status : null;
    if (json === null || typeof status === "number" && status == 204) {
      json = {};
      _fnAjaxDataSrc(oSettings, json, []);
    }
    var error2 = json.error || json.sError;
    if (error2) {
      _fnLog(oSettings, 0, error2);
    }
    if (json.d && typeof json.d === "string") {
      try {
        json = JSON.parse(json.d);
      } catch (e2) {
      }
    }
    oSettings.json = json;
    _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR], true);
    fn3(json);
  };
  if ($$6.isPlainObject(ajax) && ajax.data) {
    ajaxData = ajax.data;
    var newData = typeof ajaxData === "function" ? ajaxData(data2, oSettings) : (
      // fn can manipulate data or return
      ajaxData
    );
    data2 = typeof ajaxData === "function" && newData ? newData : $$6.extend(true, data2, newData);
    delete ajax.data;
  }
  var baseAjax = {
    "url": typeof ajax === "string" ? ajax : "",
    "data": data2,
    "success": callback,
    "dataType": "json",
    "cache": false,
    "type": oSettings.sServerMethod,
    "error": function(xhr, error2) {
      var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR], true);
      if (ret.indexOf(true) === -1) {
        if (error2 == "parsererror") {
          _fnLog(oSettings, 0, "Invalid JSON response", 1);
        } else if (xhr.readyState === 4) {
          _fnLog(oSettings, 0, "Ajax error", 7);
        }
      }
      _fnProcessingDisplay(oSettings, false);
    }
  };
  if ($$6.isPlainObject(ajax)) {
    $$6.extend(baseAjax, ajax);
  }
  oSettings.oAjaxData = data2;
  _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data2, baseAjax], true);
  if (typeof ajax === "function") {
    oSettings.jqXHR = ajax.call(instance, data2, callback, oSettings);
  } else if (ajax.url === "") {
    var empty = {};
    DataTable.util.set(ajax.dataSrc)(empty, []);
    callback(empty);
  } else {
    oSettings.jqXHR = $$6.ajax(baseAjax);
  }
  if (ajaxData) {
    ajax.data = ajaxData;
  }
}
function _fnAjaxUpdate(settings) {
  settings.iDraw++;
  _fnProcessingDisplay(settings, true);
  _fnBuildAjax(
    settings,
    _fnAjaxParameters(settings),
    function(json) {
      _fnAjaxUpdateDraw(settings, json);
    }
  );
}
function _fnAjaxParameters(settings) {
  var columns = settings.aoColumns, features = settings.oFeatures, preSearch = settings.oPreviousSearch, preColSearch = settings.aoPreSearchCols, colData = function(idx, prop) {
    return typeof columns[idx][prop] === "function" ? "function" : columns[idx][prop];
  };
  return {
    draw: settings.iDraw,
    columns: columns.map(function(column, i) {
      return {
        data: colData(i, "mData"),
        name: column.sName,
        searchable: column.bSearchable,
        orderable: column.bSortable,
        search: {
          value: preColSearch[i].search,
          regex: preColSearch[i].regex,
          fixed: Object.keys(column.searchFixed).map(function(name2) {
            return {
              name: name2,
              term: column.searchFixed[name2].toString()
            };
          })
        }
      };
    }),
    order: _fnSortFlatten(settings).map(function(val) {
      return {
        column: val.col,
        dir: val.dir,
        name: colData(val.col, "sName")
      };
    }),
    start: settings._iDisplayStart,
    length: features.bPaginate ? settings._iDisplayLength : -1,
    search: {
      value: preSearch.search,
      regex: preSearch.regex,
      fixed: Object.keys(settings.searchFixed).map(function(name2) {
        return {
          name: name2,
          term: settings.searchFixed[name2].toString()
        };
      })
    }
  };
}
function _fnAjaxUpdateDraw(settings, json) {
  var data2 = _fnAjaxDataSrc(settings, json);
  var draw = _fnAjaxDataSrcParam(settings, "draw", json);
  var recordsTotal = _fnAjaxDataSrcParam(settings, "recordsTotal", json);
  var recordsFiltered = _fnAjaxDataSrcParam(settings, "recordsFiltered", json);
  if (draw !== void 0) {
    if (draw * 1 < settings.iDraw) {
      return;
    }
    settings.iDraw = draw * 1;
  }
  if (!data2) {
    data2 = [];
  }
  _fnClearTable(settings);
  settings._iRecordsTotal = parseInt(recordsTotal, 10);
  settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
  for (var i = 0, ien = data2.length; i < ien; i++) {
    _fnAddData(settings, data2[i]);
  }
  settings.aiDisplay = settings.aiDisplayMaster.slice();
  _fnColumnTypes(settings);
  _fnDraw(settings, true);
  _fnInitComplete(settings);
  _fnProcessingDisplay(settings, false);
}
function _fnAjaxDataSrc(settings, json, write2) {
  var dataProp = "data";
  if ($$6.isPlainObject(settings.ajax) && settings.ajax.dataSrc !== void 0) {
    var dataSrc = settings.ajax.dataSrc;
    if (typeof dataSrc === "string" || typeof dataSrc === "function") {
      dataProp = dataSrc;
    } else if (dataSrc.data !== void 0) {
      dataProp = dataSrc.data;
    }
  }
  if (!write2) {
    if (dataProp === "data") {
      return json.aaData || json[dataProp];
    }
    return dataProp !== "" ? _fnGetObjectDataFn(dataProp)(json) : json;
  }
  _fnSetObjectDataFn(dataProp)(json, write2);
}
function _fnAjaxDataSrcParam(settings, param, json) {
  var dataSrc = $$6.isPlainObject(settings.ajax) ? settings.ajax.dataSrc : null;
  if (dataSrc && dataSrc[param]) {
    return _fnGetObjectDataFn(dataSrc[param])(json);
  }
  var old2 = "";
  if (param === "draw") {
    old2 = "sEcho";
  } else if (param === "recordsTotal") {
    old2 = "iTotalRecords";
  } else if (param === "recordsFiltered") {
    old2 = "iTotalDisplayRecords";
  }
  return json[old2] !== void 0 ? json[old2] : json[param];
}
function _fnFilterComplete(settings, input) {
  var columnsSearch = settings.aoPreSearchCols;
  if (_fnDataSource(settings) != "ssp") {
    _fnFilterData(settings);
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnFilter(settings.aiDisplay, settings, input.search, input);
    $$6.each(settings.searchFixed, function(name2, term) {
      _fnFilter(settings.aiDisplay, settings, term, {});
    });
    for (var i = 0; i < columnsSearch.length; i++) {
      var col = columnsSearch[i];
      _fnFilter(
        settings.aiDisplay,
        settings,
        col.search,
        col,
        i
      );
      $$6.each(settings.aoColumns[i].searchFixed, function(name2, term) {
        _fnFilter(settings.aiDisplay, settings, term, {}, i);
      });
    }
    _fnFilterCustom(settings);
  }
  settings.bFiltered = true;
  _fnCallbackFire(settings, null, "search", [settings]);
}
function _fnFilterCustom(settings) {
  var filters2 = DataTable.ext.search;
  var displayRows = settings.aiDisplay;
  var row, rowIdx;
  for (var i = 0, ien = filters2.length; i < ien; i++) {
    var rows = [];
    for (var j2 = 0, jen = displayRows.length; j2 < jen; j2++) {
      rowIdx = displayRows[j2];
      row = settings.aoData[rowIdx];
      if (filters2[i](settings, row._aFilterData, rowIdx, row._aData, j2)) {
        rows.push(rowIdx);
      }
    }
    displayRows.length = 0;
    _fnArrayApply(displayRows, rows);
  }
}
function _fnFilter(searchRows, settings, input, options, column) {
  if (input === "") {
    return;
  }
  var i = 0;
  var matched = [];
  var searchFunc = typeof input === "function" ? input : null;
  var rpSearch = input instanceof RegExp ? input : searchFunc ? null : _fnFilterCreateSearch(input, options);
  for (i = 0; i < searchRows.length; i++) {
    var row = settings.aoData[searchRows[i]];
    var data2 = column === void 0 ? row._sFilterRow : row._aFilterData[column];
    if (searchFunc && searchFunc(data2, row._aData, searchRows[i], column) || rpSearch && rpSearch.test(data2)) {
      matched.push(searchRows[i]);
    }
  }
  searchRows.length = matched.length;
  for (i = 0; i < matched.length; i++) {
    searchRows[i] = matched[i];
  }
}
function _fnFilterCreateSearch(search, inOpts) {
  var not = [];
  var options = $$6.extend({}, {
    boundary: false,
    caseInsensitive: true,
    exact: false,
    regex: false,
    smart: true
  }, inOpts);
  if (typeof search !== "string") {
    search = search.toString();
  }
  search = _normalize(search);
  if (options.exact) {
    return new RegExp(
      "^" + _fnEscapeRegex(search) + "$",
      options.caseInsensitive ? "i" : ""
    );
  }
  search = options.regex ? search : _fnEscapeRegex(search);
  if (options.smart) {
    var parts = search.match(/!?["\u201C][^"\u201D]+["\u201D]|[^ ]+/g) || [""];
    var a2 = parts.map(function(word) {
      var negative = false;
      var m2;
      if (word.charAt(0) === "!") {
        negative = true;
        word = word.substring(1);
      }
      if (word.charAt(0) === '"') {
        m2 = word.match(/^"(.*)"$/);
        word = m2 ? m2[1] : word;
      } else if (word.charAt(0) === "“") {
        m2 = word.match(/^\u201C(.*)\u201D$/);
        word = m2 ? m2[1] : word;
      }
      if (negative) {
        if (word.length > 1) {
          not.push("(?!" + word + ")");
        }
        word = "";
      }
      return word.replace(/"/g, "");
    });
    var match = not.length ? not.join("") : "";
    var boundary = options.boundary ? "\\b" : "";
    search = "^(?=.*?" + boundary + a2.join(")(?=.*?" + boundary) + ")(" + match + ".)*$";
  }
  return new RegExp(search, options.caseInsensitive ? "i" : "");
}
var _fnEscapeRegex = DataTable.util.escapeRegex;
var __filter_div = $$6("<div>")[0];
var __filter_div_textContent = __filter_div.textContent !== void 0;
function _fnFilterData(settings) {
  var columns = settings.aoColumns;
  var data2 = settings.aoData;
  var column;
  var j2, jen, filterData, cellData, row;
  var wasInvalidated = false;
  for (var rowIdx = 0; rowIdx < data2.length; rowIdx++) {
    if (!data2[rowIdx]) {
      continue;
    }
    row = data2[rowIdx];
    if (!row._aFilterData) {
      filterData = [];
      for (j2 = 0, jen = columns.length; j2 < jen; j2++) {
        column = columns[j2];
        if (column.bSearchable) {
          cellData = _fnGetCellData(settings, rowIdx, j2, "filter");
          if (cellData === null) {
            cellData = "";
          }
          if (typeof cellData !== "string" && cellData.toString) {
            cellData = cellData.toString();
          }
        } else {
          cellData = "";
        }
        if (cellData.indexOf && cellData.indexOf("&") !== -1) {
          __filter_div.innerHTML = cellData;
          cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText;
        }
        if (cellData.replace) {
          cellData = cellData.replace(/[\r\n\u2028]/g, "");
        }
        filterData.push(cellData);
      }
      row._aFilterData = filterData;
      row._sFilterRow = filterData.join("  ");
      wasInvalidated = true;
    }
  }
  return wasInvalidated;
}
function _fnInitialise(settings) {
  var i;
  var init2 = settings.oInit;
  var deferLoading = settings.deferLoading;
  var dataSrc = _fnDataSource(settings);
  if (!settings.bInitialised) {
    setTimeout(function() {
      _fnInitialise(settings);
    }, 200);
    return;
  }
  _fnBuildHead(settings, "header");
  _fnBuildHead(settings, "footer");
  _fnLoadState(settings, init2, function() {
    _fnDrawHead(settings, settings.aoHeader);
    _fnDrawHead(settings, settings.aoFooter);
    var iAjaxStart = settings.iInitDisplayStart;
    if (init2.aaData) {
      for (i = 0; i < init2.aaData.length; i++) {
        _fnAddData(settings, init2.aaData[i]);
      }
    } else if (deferLoading || dataSrc == "dom") {
      _fnAddTr(settings, $$6(settings.nTBody).children("tr"));
    }
    settings.aiDisplay = settings.aiDisplayMaster.slice();
    _fnAddOptionsHtml(settings);
    _fnSortInit(settings);
    _colGroup(settings);
    _fnProcessingDisplay(settings, true);
    _fnCallbackFire(settings, null, "preInit", [settings], true);
    _fnReDraw(settings);
    if (dataSrc != "ssp" || deferLoading) {
      if (dataSrc == "ajax") {
        _fnBuildAjax(settings, {}, function(json) {
          var aData = _fnAjaxDataSrc(settings, json);
          for (i = 0; i < aData.length; i++) {
            _fnAddData(settings, aData[i]);
          }
          settings.iInitDisplayStart = iAjaxStart;
          _fnReDraw(settings);
          _fnProcessingDisplay(settings, false);
          _fnInitComplete(settings);
        });
      } else {
        _fnInitComplete(settings);
        _fnProcessingDisplay(settings, false);
      }
    }
  });
}
function _fnInitComplete(settings) {
  if (settings._bInitComplete) {
    return;
  }
  var args = [settings, settings.json];
  settings._bInitComplete = true;
  _fnAdjustColumnSizing(settings);
  _fnCallbackFire(settings, null, "plugin-init", args, true);
  _fnCallbackFire(settings, "aoInitComplete", "init", args, true);
}
function _fnLengthChange(settings, val) {
  var len = parseInt(val, 10);
  settings._iDisplayLength = len;
  _fnLengthOverflow(settings);
  _fnCallbackFire(settings, null, "length", [settings, len]);
}
function _fnPageChange(settings, action, redraw) {
  var start2 = settings._iDisplayStart, len = settings._iDisplayLength, records = settings.fnRecordsDisplay();
  if (records === 0 || len === -1) {
    start2 = 0;
  } else if (typeof action === "number") {
    start2 = action * len;
    if (start2 > records) {
      start2 = 0;
    }
  } else if (action == "first") {
    start2 = 0;
  } else if (action == "previous") {
    start2 = len >= 0 ? start2 - len : 0;
    if (start2 < 0) {
      start2 = 0;
    }
  } else if (action == "next") {
    if (start2 + len < records) {
      start2 += len;
    }
  } else if (action == "last") {
    start2 = Math.floor((records - 1) / len) * len;
  } else if (action === "ellipsis") {
    return;
  } else {
    _fnLog(settings, 0, "Unknown paging action: " + action, 5);
  }
  var changed = settings._iDisplayStart !== start2;
  settings._iDisplayStart = start2;
  _fnCallbackFire(settings, null, changed ? "page" : "page-nc", [settings]);
  if (changed && redraw) {
    _fnDraw(settings);
  }
  return changed;
}
function _processingHtml(settings) {
  var table = settings.nTable;
  var scrolling = settings.oScroll.sX !== "" || settings.oScroll.sY !== "";
  if (settings.oFeatures.bProcessing) {
    var n2 = $$6("<div/>", {
      "id": settings.sTableId + "_processing",
      "class": settings.oClasses.processing.container,
      "role": "status"
    }).html(settings.oLanguage.sProcessing).append("<div><div></div><div></div><div></div><div></div></div>");
    if (scrolling) {
      n2.prependTo($$6("div.dt-scroll", settings.nTableWrapper));
    } else {
      n2.insertBefore(table);
    }
    $$6(table).on("processing.dt.DT", function(e2, s2, show2) {
      n2.css("display", show2 ? "block" : "none");
    });
  }
}
function _fnProcessingDisplay(settings, show2) {
  if (settings.bDrawing && show2 === false) {
    return;
  }
  _fnCallbackFire(settings, null, "processing", [settings, show2]);
}
function _fnProcessingRun(settings, enable, run2) {
  if (!enable) {
    run2();
  } else {
    _fnProcessingDisplay(settings, true);
    setTimeout(function() {
      run2();
      _fnProcessingDisplay(settings, false);
    }, 0);
  }
}
function _fnFeatureHtmlTable(settings) {
  var table = $$6(settings.nTable);
  var scroll = settings.oScroll;
  if (scroll.sX === "" && scroll.sY === "") {
    return settings.nTable;
  }
  var scrollX = scroll.sX;
  var scrollY = scroll.sY;
  var classes = settings.oClasses.scrolling;
  var caption = settings.captionNode;
  var captionSide = caption ? caption._captionSide : null;
  var headerClone = $$6(table[0].cloneNode(false));
  var footerClone = $$6(table[0].cloneNode(false));
  var footer = table.children("tfoot");
  var _div = "<div/>";
  var size = function(s2) {
    return !s2 ? null : _fnStringToCss(s2);
  };
  if (!footer.length) {
    footer = null;
  }
  var scroller = $$6(_div, { "class": classes.container }).append(
    $$6(_div, { "class": classes.header.self }).css({
      overflow: "hidden",
      position: "relative",
      border: 0,
      width: scrollX ? size(scrollX) : "100%"
    }).append(
      $$6(_div, { "class": classes.header.inner }).css({
        "box-sizing": "content-box",
        width: scroll.sXInner || "100%"
      }).append(
        headerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "top" ? caption : null).append(
          table.children("thead")
        )
      )
    )
  ).append(
    $$6(_div, { "class": classes.body }).css({
      position: "relative",
      overflow: "auto",
      width: size(scrollX)
    }).append(table)
  );
  if (footer) {
    scroller.append(
      $$6(_div, { "class": classes.footer.self }).css({
        overflow: "hidden",
        border: 0,
        width: scrollX ? size(scrollX) : "100%"
      }).append(
        $$6(_div, { "class": classes.footer.inner }).append(
          footerClone.removeAttr("id").css("margin-left", 0).append(captionSide === "bottom" ? caption : null).append(
            table.children("tfoot")
          )
        )
      )
    );
  }
  var children = scroller.children();
  var scrollHead = children[0];
  var scrollBody = children[1];
  var scrollFoot = footer ? children[2] : null;
  $$6(scrollBody).on("scroll.DT", function() {
    var scrollLeft = this.scrollLeft;
    scrollHead.scrollLeft = scrollLeft;
    if (footer) {
      scrollFoot.scrollLeft = scrollLeft;
    }
  });
  $$6("th, td", scrollHead).on("focus", function() {
    var scrollLeft = scrollHead.scrollLeft;
    scrollBody.scrollLeft = scrollLeft;
    if (footer) {
      scrollBody.scrollLeft = scrollLeft;
    }
  });
  $$6(scrollBody).css("max-height", scrollY);
  if (!scroll.bCollapse) {
    $$6(scrollBody).css("height", scrollY);
  }
  settings.nScrollHead = scrollHead;
  settings.nScrollBody = scrollBody;
  settings.nScrollFoot = scrollFoot;
  settings.aoDrawCallback.push(_fnScrollDraw);
  return scroller[0];
}
function _fnScrollDraw(settings) {
  var scroll = settings.oScroll, barWidth = scroll.iBarWidth, divHeader = $$6(settings.nScrollHead), divHeaderInner = divHeader.children("div"), divHeaderTable = divHeaderInner.children("table"), divBodyEl = settings.nScrollBody, divBody = $$6(divBodyEl), divFooter = $$6(settings.nScrollFoot), divFooterInner = divFooter.children("div"), divFooterTable = divFooterInner.children("table"), header = $$6(settings.nTHead), table = $$6(settings.nTable), footer = settings.nTFoot && $$6("th, td", settings.nTFoot).length ? $$6(settings.nTFoot) : null, browser2 = settings.oBrowser, headerCopy, footerCopy;
  var scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
  if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== void 0) {
    settings.scrollBarVis = scrollBarVis;
    _fnAdjustColumnSizing(settings);
    return;
  } else {
    settings.scrollBarVis = scrollBarVis;
  }
  table.children("thead, tfoot").remove();
  headerCopy = header.clone().prependTo(table);
  headerCopy.find("th, td").removeAttr("tabindex");
  headerCopy.find("[id]").removeAttr("id");
  if (footer) {
    footerCopy = footer.clone().prependTo(table);
    footerCopy.find("[id]").removeAttr("id");
  }
  if (settings.aiDisplay.length) {
    var firstTr = null;
    var start2 = _fnDataSource(settings) !== "ssp" ? settings._iDisplayStart : 0;
    for (i = start2; i < start2 + settings.aiDisplay.length; i++) {
      var idx = settings.aiDisplay[i];
      var tr = settings.aoData[idx].nTr;
      if (tr) {
        firstTr = tr;
        break;
      }
    }
    if (firstTr) {
      var colSizes = $$6(firstTr).children("th, td").map(function(vis) {
        return {
          idx: _fnVisibleToColumnIndex(settings, vis),
          width: $$6(this).outerWidth()
        };
      });
      for (var i = 0; i < colSizes.length; i++) {
        var colEl = settings.aoColumns[colSizes[i].idx].colEl[0];
        var colWidth = colEl.style.width.replace("px", "");
        if (colWidth !== colSizes[i].width) {
          colEl.style.width = colSizes[i].width + "px";
          if (scroll.sX) {
            colEl.style.minWidth = colSizes[i].width + "px";
          }
        }
      }
    }
  }
  divHeaderTable.find("colgroup").remove();
  divHeaderTable.append(settings.colgroup.clone());
  if (footer) {
    divFooterTable.find("colgroup").remove();
    divFooterTable.append(settings.colgroup.clone());
  }
  $$6("th, td", headerCopy).each(function() {
    $$6(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
  });
  if (footer) {
    $$6("th, td", footerCopy).each(function() {
      $$6(this.childNodes).wrapAll('<div class="dt-scroll-sizing">');
    });
  }
  var isScrolling = Math.floor(table.height()) > divBodyEl.clientHeight || divBody.css("overflow-y") == "scroll";
  var paddingSide = "padding" + (browser2.bScrollbarLeft ? "Left" : "Right");
  var outerWidth = table.outerWidth();
  divHeaderTable.css("width", _fnStringToCss(outerWidth));
  divHeaderInner.css("width", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
  if (footer) {
    divFooterTable.css("width", _fnStringToCss(outerWidth));
    divFooterInner.css("width", _fnStringToCss(outerWidth)).css(paddingSide, isScrolling ? barWidth + "px" : "0px");
  }
  table.children("colgroup").prependTo(table);
  divBody.trigger("scroll");
  if ((settings.bSorted || settings.bFiltered) && !settings._drawHold) {
    divBodyEl.scrollTop = 0;
  }
}
function _fnCalculateColumnWidths(settings) {
  if (!settings.oFeatures.bAutoWidth) {
    return;
  }
  var table = settings.nTable, columns = settings.aoColumns, scroll = settings.oScroll, scrollY = scroll.sY, scrollX = scroll.sX, scrollXInner = scroll.sXInner, visibleColumns = _fnGetColumns(settings, "bVisible"), tableWidthAttr = table.getAttribute("width"), tableContainer = table.parentNode, i, column, columnIdx;
  var styleWidth = table.style.width;
  var containerWidth = _fnWrapperWidth(settings);
  if (containerWidth === settings.containerWidth) {
    return false;
  }
  settings.containerWidth = containerWidth;
  if (!styleWidth && !tableWidthAttr) {
    table.style.width = "100%";
    styleWidth = "100%";
  }
  if (styleWidth && styleWidth.indexOf("%") !== -1) {
    tableWidthAttr = styleWidth;
  }
  _fnCallbackFire(
    settings,
    null,
    "column-calc",
    { visible: visibleColumns },
    false
  );
  var tmpTable = $$6(table.cloneNode()).css("visibility", "hidden").removeAttr("id");
  tmpTable.append("<tbody>");
  var tr = $$6("<tr/>").appendTo(tmpTable.find("tbody"));
  tmpTable.append($$6(settings.nTHead).clone()).append($$6(settings.nTFoot).clone());
  tmpTable.find("tfoot th, tfoot td").css("width", "");
  tmpTable.find("thead th, thead td").each(function() {
    var width = _fnColumnsSumWidth(settings, this, true, false);
    if (width) {
      this.style.width = width;
      if (scrollX) {
        this.style.minWidth = width;
        $$6(this).append($$6("<div/>").css({
          width,
          margin: 0,
          padding: 0,
          border: 0,
          height: 1
        }));
      }
    } else {
      this.style.width = "";
    }
  });
  for (i = 0; i < visibleColumns.length; i++) {
    columnIdx = visibleColumns[i];
    column = columns[columnIdx];
    var longest = _fnGetMaxLenString(settings, columnIdx);
    var autoClass = _ext.type.className[column.sType];
    var text2 = longest + column.sContentPadding;
    var insert = longest.indexOf("<") === -1 ? document.createTextNode(text2) : text2;
    $$6("<td/>").addClass(autoClass).addClass(column.sClass).append(insert).appendTo(tr);
  }
  $$6("[name]", tmpTable).removeAttr("name");
  var holder = $$6("<div/>").css(
    scrollX || scrollY ? {
      position: "absolute",
      top: 0,
      left: 0,
      height: 1,
      right: 0,
      overflow: "hidden"
    } : {}
  ).append(tmpTable).appendTo(tableContainer);
  if (scrollX && scrollXInner) {
    tmpTable.width(scrollXInner);
  } else if (scrollX) {
    tmpTable.css("width", "auto");
    tmpTable.removeAttr("width");
    if (tmpTable.outerWidth() < tableContainer.clientWidth && tableWidthAttr) {
      tmpTable.outerWidth(tableContainer.clientWidth);
    }
  } else if (scrollY) {
    tmpTable.outerWidth(tableContainer.clientWidth);
  } else if (tableWidthAttr) {
    tmpTable.outerWidth(tableWidthAttr);
  }
  var total = 0;
  var bodyCells = tmpTable.find("tbody tr").eq(0).children();
  for (i = 0; i < visibleColumns.length; i++) {
    var bounding = bodyCells[i].getBoundingClientRect().width;
    total += bounding;
    columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding);
  }
  table.style.width = _fnStringToCss(total);
  holder.remove();
  if (tableWidthAttr) {
    table.style.width = _fnStringToCss(tableWidthAttr);
  }
  if ((tableWidthAttr || scrollX) && !settings._reszEvt) {
    var resize = DataTable.util.throttle(function() {
      var newWidth = _fnWrapperWidth(settings);
      if (!settings.bDestroying && newWidth !== 0) {
        _fnAdjustColumnSizing(settings);
      }
    });
    if (window.ResizeObserver) {
      var first = $$6(settings.nTableWrapper).is(":visible");
      var resizer = $$6("<div>").css({
        width: "100%",
        height: 0
      }).addClass("dt-autosize").appendTo(settings.nTableWrapper);
      settings.resizeObserver = new ResizeObserver(function(e2) {
        if (first) {
          first = false;
        } else {
          resize();
        }
      });
      settings.resizeObserver.observe(resizer[0]);
    } else {
      $$6(window).on("resize.DT-" + settings.sInstance, resize);
    }
    settings._reszEvt = true;
  }
}
function _fnWrapperWidth(settings) {
  return $$6(settings.nTableWrapper).is(":visible") ? $$6(settings.nTableWrapper).width() : 0;
}
function _fnGetMaxLenString(settings, colIdx) {
  var column = settings.aoColumns[colIdx];
  if (!column.maxLenString) {
    var s2, max2 = "", maxLen = -1;
    for (var i = 0, ien = settings.aiDisplayMaster.length; i < ien; i++) {
      var rowIdx = settings.aiDisplayMaster[i];
      var data2 = _fnGetRowDisplay(settings, rowIdx)[colIdx];
      var cellString = data2 && typeof data2 === "object" && data2.nodeType ? data2.innerHTML : data2 + "";
      cellString = cellString.replace(/id=".*?"/g, "").replace(/name=".*?"/g, "");
      s2 = _stripHtml(cellString).replace(/&nbsp;/g, " ");
      if (s2.length > maxLen) {
        max2 = cellString;
        maxLen = s2.length;
      }
    }
    column.maxLenString = max2;
  }
  return column.maxLenString;
}
function _fnStringToCss(s2) {
  if (s2 === null) {
    return "0px";
  }
  if (typeof s2 == "number") {
    return s2 < 0 ? "0px" : s2 + "px";
  }
  return s2.match(/\d$/) ? s2 + "px" : s2;
}
function _colGroup(settings) {
  var cols = settings.aoColumns;
  settings.colgroup.empty();
  for (i = 0; i < cols.length; i++) {
    if (cols[i].bVisible) {
      settings.colgroup.append(cols[i].colEl);
    }
  }
}
function _fnSortInit(settings) {
  var target = settings.nTHead;
  var headerRows = target.querySelectorAll("tr");
  var legacyTop = settings.bSortCellsTop;
  var notSelector = ':not([data-dt-order="disable"]):not([data-dt-order="icon-only"])';
  if (legacyTop === true) {
    target = headerRows[0];
  } else if (legacyTop === false) {
    target = headerRows[headerRows.length - 1];
  }
  _fnSortAttachListener(
    settings,
    target,
    target === settings.nTHead ? "tr" + notSelector + " th" + notSelector + ", tr" + notSelector + " td" + notSelector : "th" + notSelector + ", td" + notSelector
  );
  var order2 = [];
  _fnSortResolve(settings, order2, settings.aaSorting);
  settings.aaSorting = order2;
}
function _fnSortAttachListener(settings, node, selector, column, callback) {
  _fnBindAction(node, selector, function(e2) {
    var run2 = false;
    var columns = column === void 0 ? _fnColumnsFromHeader(e2.target) : [column];
    if (columns.length) {
      for (var i = 0, ien = columns.length; i < ien; i++) {
        var ret = _fnSortAdd(settings, columns[i], i, e2.shiftKey);
        if (ret !== false) {
          run2 = true;
        }
        if (settings.aaSorting.length === 1 && settings.aaSorting[0][1] === "") {
          break;
        }
      }
      if (run2) {
        _fnProcessingRun(settings, true, function() {
          _fnSort(settings);
          _fnSortDisplay(settings, settings.aiDisplay);
          _fnReDraw(settings, false, false);
          if (callback) {
            callback();
          }
        });
      }
    }
  });
}
function _fnSortDisplay(settings, display) {
  if (display.length < 2) {
    return;
  }
  var master = settings.aiDisplayMaster;
  var masterMap = {};
  var map2 = {};
  var i;
  for (i = 0; i < master.length; i++) {
    masterMap[master[i]] = i;
  }
  for (i = 0; i < display.length; i++) {
    map2[display[i]] = masterMap[display[i]];
  }
  display.sort(function(a2, b2) {
    return map2[a2] - map2[b2];
  });
}
function _fnSortResolve(settings, nestedSort, sort) {
  var push = function(a2) {
    if ($$6.isPlainObject(a2)) {
      if (a2.idx !== void 0) {
        nestedSort.push([a2.idx, a2.dir]);
      } else if (a2.name) {
        var cols = _pluck(settings.aoColumns, "sName");
        var idx = cols.indexOf(a2.name);
        if (idx !== -1) {
          nestedSort.push([idx, a2.dir]);
        }
      }
    } else {
      nestedSort.push(a2);
    }
  };
  if ($$6.isPlainObject(sort)) {
    push(sort);
  } else if (sort.length && typeof sort[0] === "number") {
    push(sort);
  } else if (sort.length) {
    for (var z2 = 0; z2 < sort.length; z2++) {
      push(sort[z2]);
    }
  }
}
function _fnSortFlatten(settings) {
  var i, k2, kLen, aSort = [], extSort = DataTable.ext.type.order, aoColumns = settings.aoColumns, aDataSort, iCol, sType, srcCol, fixed = settings.aaSortingFixed, fixedObj = $$6.isPlainObject(fixed), nestedSort = [];
  if (!settings.oFeatures.bSort) {
    return aSort;
  }
  if (Array.isArray(fixed)) {
    _fnSortResolve(settings, nestedSort, fixed);
  }
  if (fixedObj && fixed.pre) {
    _fnSortResolve(settings, nestedSort, fixed.pre);
  }
  _fnSortResolve(settings, nestedSort, settings.aaSorting);
  if (fixedObj && fixed.post) {
    _fnSortResolve(settings, nestedSort, fixed.post);
  }
  for (i = 0; i < nestedSort.length; i++) {
    srcCol = nestedSort[i][0];
    if (aoColumns[srcCol]) {
      aDataSort = aoColumns[srcCol].aDataSort;
      for (k2 = 0, kLen = aDataSort.length; k2 < kLen; k2++) {
        iCol = aDataSort[k2];
        sType = aoColumns[iCol].sType || "string";
        if (nestedSort[i]._idx === void 0) {
          nestedSort[i]._idx = aoColumns[iCol].asSorting.indexOf(nestedSort[i][1]);
        }
        if (nestedSort[i][1]) {
          aSort.push({
            src: srcCol,
            col: iCol,
            dir: nestedSort[i][1],
            index: nestedSort[i]._idx,
            type: sType,
            formatter: extSort[sType + "-pre"],
            sorter: extSort[sType + "-" + nestedSort[i][1]]
          });
        }
      }
    }
  }
  return aSort;
}
function _fnSort(oSettings, col, dir) {
  var i, ien, iLen, aiOrig = [], extSort = DataTable.ext.type.order, aoData = oSettings.aoData, sortCol, displayMaster = oSettings.aiDisplayMaster, aSort;
  _fnColumnTypes(oSettings);
  if (col !== void 0) {
    var srcCol = oSettings.aoColumns[col];
    aSort = [{
      src: col,
      col,
      dir,
      index: 0,
      type: srcCol.sType,
      formatter: extSort[srcCol.sType + "-pre"],
      sorter: extSort[srcCol.sType + "-" + dir]
    }];
    displayMaster = displayMaster.slice();
  } else {
    aSort = _fnSortFlatten(oSettings);
  }
  for (i = 0, ien = aSort.length; i < ien; i++) {
    sortCol = aSort[i];
    _fnSortData(oSettings, sortCol.col);
  }
  if (_fnDataSource(oSettings) != "ssp" && aSort.length !== 0) {
    for (i = 0, iLen = displayMaster.length; i < iLen; i++) {
      aiOrig[i] = i;
    }
    if (aSort.length && aSort[0].dir === "desc" && oSettings.orderDescReverse) {
      aiOrig.reverse();
    }
    displayMaster.sort(function(a2, b2) {
      var x2, y2, k2, test2, sort, len = aSort.length, dataA = aoData[a2]._aSortData, dataB = aoData[b2]._aSortData;
      for (k2 = 0; k2 < len; k2++) {
        sort = aSort[k2];
        x2 = dataA[sort.col];
        y2 = dataB[sort.col];
        if (sort.sorter) {
          test2 = sort.sorter(x2, y2);
          if (test2 !== 0) {
            return test2;
          }
        } else {
          test2 = x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
          if (test2 !== 0) {
            return sort.dir === "asc" ? test2 : -test2;
          }
        }
      }
      x2 = aiOrig[a2];
      y2 = aiOrig[b2];
      return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
    });
  } else if (aSort.length === 0) {
    displayMaster.sort(function(x2, y2) {
      return x2 < y2 ? -1 : x2 > y2 ? 1 : 0;
    });
  }
  if (col === void 0) {
    oSettings.bSorted = true;
    oSettings.sortDetails = aSort;
    _fnCallbackFire(oSettings, null, "order", [oSettings, aSort]);
  }
  return displayMaster;
}
function _fnSortAdd(settings, colIdx, addIndex, shift) {
  var col = settings.aoColumns[colIdx];
  var sorting = settings.aaSorting;
  var asSorting = col.asSorting;
  var nextSortIdx;
  var next = function(a2, overflow) {
    var idx = a2._idx;
    if (idx === void 0) {
      idx = asSorting.indexOf(a2[1]);
    }
    return idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0;
  };
  if (!col.bSortable) {
    return false;
  }
  if (typeof sorting[0] === "number") {
    sorting = settings.aaSorting = [sorting];
  }
  if ((shift || addIndex) && settings.oFeatures.bSortMulti) {
    var sortIdx = _pluck(sorting, "0").indexOf(colIdx);
    if (sortIdx !== -1) {
      nextSortIdx = next(sorting[sortIdx], true);
      if (nextSortIdx === null && sorting.length === 1) {
        nextSortIdx = 0;
      }
      if (nextSortIdx === null) {
        sorting.splice(sortIdx, 1);
      } else {
        sorting[sortIdx][1] = asSorting[nextSortIdx];
        sorting[sortIdx]._idx = nextSortIdx;
      }
    } else if (shift) {
      sorting.push([colIdx, asSorting[0], 0]);
      sorting[sorting.length - 1]._idx = 0;
    } else {
      sorting.push([colIdx, sorting[0][1], 0]);
      sorting[sorting.length - 1]._idx = 0;
    }
  } else if (sorting.length && sorting[0][0] == colIdx) {
    nextSortIdx = next(sorting[0]);
    sorting.length = 1;
    sorting[0][1] = asSorting[nextSortIdx];
    sorting[0]._idx = nextSortIdx;
  } else {
    sorting.length = 0;
    sorting.push([colIdx, asSorting[0]]);
    sorting[0]._idx = 0;
  }
}
function _fnSortingClasses(settings) {
  var oldSort = settings.aLastSort;
  var sortClass = settings.oClasses.order.position;
  var sort = _fnSortFlatten(settings);
  var features = settings.oFeatures;
  var i, ien, colIdx;
  if (features.bSort && features.bSortClasses) {
    for (i = 0, ien = oldSort.length; i < ien; i++) {
      colIdx = oldSort[i].src;
      $$6(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
    }
    for (i = 0, ien = sort.length; i < ien; i++) {
      colIdx = sort[i].src;
      $$6(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3));
    }
  }
  settings.aLastSort = sort;
}
function _fnSortData(settings, colIdx) {
  var column = settings.aoColumns[colIdx];
  var customSort = DataTable.ext.order[column.sSortDataType];
  var customData;
  if (customSort) {
    customData = customSort.call(
      settings.oInstance,
      settings,
      colIdx,
      _fnColumnIndexToVisible(settings, colIdx)
    );
  }
  var row, cellData;
  var formatter = DataTable.ext.type.order[column.sType + "-pre"];
  var data2 = settings.aoData;
  for (var rowIdx = 0; rowIdx < data2.length; rowIdx++) {
    if (!data2[rowIdx]) {
      continue;
    }
    row = data2[rowIdx];
    if (!row._aSortData) {
      row._aSortData = [];
    }
    if (!row._aSortData[colIdx] || customSort) {
      cellData = customSort ? customData[rowIdx] : (
        // If there was a custom sort function, use data from there
        _fnGetCellData(settings, rowIdx, colIdx, "sort")
      );
      row._aSortData[colIdx] = formatter ? formatter(cellData, settings) : cellData;
    }
  }
}
function _fnSaveState(settings) {
  if (settings._bLoadingState) {
    return;
  }
  var sorting = [];
  _fnSortResolve(settings, sorting, settings.aaSorting);
  var columns = settings.aoColumns;
  var state2 = {
    time: +/* @__PURE__ */ new Date(),
    start: settings._iDisplayStart,
    length: settings._iDisplayLength,
    order: sorting.map(function(sort) {
      return columns[sort[0]] && columns[sort[0]].sName ? [columns[sort[0]].sName, sort[1]] : sort.slice();
    }),
    search: $$6.extend({}, settings.oPreviousSearch),
    columns: settings.aoColumns.map(function(col, i) {
      return {
        name: col.sName,
        visible: col.bVisible,
        search: $$6.extend({}, settings.aoPreSearchCols[i])
      };
    })
  };
  settings.oSavedState = state2;
  _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state2]);
  if (settings.oFeatures.bStateSave && !settings.bDestroying) {
    settings.fnStateSaveCallback.call(settings.oInstance, settings, state2);
  }
}
function _fnLoadState(settings, init2, callback) {
  if (!settings.oFeatures.bStateSave) {
    callback();
    return;
  }
  var loaded = function(state3) {
    _fnImplementState(settings, state3, callback);
  };
  var state2 = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
  if (state2 !== void 0) {
    _fnImplementState(settings, state2, callback);
  }
  return true;
}
function _fnImplementState(settings, s2, callback) {
  var i, ien;
  var columns = settings.aoColumns;
  var currentNames = _pluck(settings.aoColumns, "sName");
  settings._bLoadingState = true;
  var api = settings._bInitComplete ? new DataTable.Api(settings) : null;
  if (!s2 || !s2.time) {
    settings._bLoadingState = false;
    callback();
    return;
  }
  var duration = settings.iStateDuration;
  if (duration > 0 && s2.time < +/* @__PURE__ */ new Date() - duration * 1e3) {
    settings._bLoadingState = false;
    callback();
    return;
  }
  var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, s2]);
  if (abStateLoad.indexOf(false) !== -1) {
    settings._bLoadingState = false;
    callback();
    return;
  }
  settings.oLoadedState = $$6.extend(true, {}, s2);
  _fnCallbackFire(settings, null, "stateLoadInit", [settings, s2], true);
  if (s2.length !== void 0) {
    if (api) {
      api.page.len(s2.length);
    } else {
      settings._iDisplayLength = s2.length;
    }
  }
  if (s2.start !== void 0) {
    if (api === null) {
      settings._iDisplayStart = s2.start;
      settings.iInitDisplayStart = s2.start;
    } else {
      _fnPageChange(settings, s2.start / settings._iDisplayLength);
    }
  }
  if (s2.order !== void 0) {
    settings.aaSorting = [];
    $$6.each(s2.order, function(i2, col2) {
      var set2 = [col2[0], col2[1]];
      if (typeof col2[0] === "string") {
        var idx2 = currentNames.indexOf(col2[0]);
        set2[0] = idx2 >= 0 ? idx2 : 0;
      } else if (set2[0] >= columns.length) {
        set2[0] = 0;
      }
      settings.aaSorting.push(set2);
    });
  }
  if (s2.search !== void 0) {
    $$6.extend(settings.oPreviousSearch, s2.search);
  }
  if (s2.columns) {
    var set = s2.columns;
    var incoming = _pluck(s2.columns, "name");
    if (incoming.join("").length && incoming.join("") !== currentNames.join("")) {
      set = [];
      for (i = 0; i < currentNames.length; i++) {
        if (currentNames[i] != "") {
          var idx = incoming.indexOf(currentNames[i]);
          if (idx >= 0) {
            set.push(s2.columns[idx]);
          } else {
            set.push({});
          }
        } else {
          set.push({});
        }
      }
    }
    if (set.length === columns.length) {
      for (i = 0, ien = set.length; i < ien; i++) {
        var col = set[i];
        if (col.visible !== void 0) {
          if (api) {
            api.column(i).visible(col.visible, false);
          } else {
            columns[i].bVisible = col.visible;
          }
        }
        if (col.search !== void 0) {
          $$6.extend(settings.aoPreSearchCols[i], col.search);
        }
      }
      if (api) {
        api.columns.adjust();
      }
    }
  }
  settings._bLoadingState = false;
  _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, s2]);
  callback();
}
function _fnLog(settings, level, msg, tn) {
  msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg;
  if (tn) {
    msg += ". For more information about this error, please see https://datatables.net/tn/" + tn;
  }
  if (!level) {
    var ext = DataTable.ext;
    var type = ext.sErrMode || ext.errMode;
    if (settings) {
      _fnCallbackFire(settings, null, "dt-error", [settings, tn, msg], true);
    }
    if (type == "alert") {
      alert(msg);
    } else if (type == "throw") {
      throw new Error(msg);
    } else if (typeof type == "function") {
      type(settings, tn, msg);
    }
  } else if (window.console && console.log) {
    console.log(msg);
  }
}
function _fnMap(ret, src, name2, mappedName) {
  if (Array.isArray(name2)) {
    $$6.each(name2, function(i, val) {
      if (Array.isArray(val)) {
        _fnMap(ret, src, val[0], val[1]);
      } else {
        _fnMap(ret, src, val);
      }
    });
    return;
  }
  if (mappedName === void 0) {
    mappedName = name2;
  }
  if (src[name2] !== void 0) {
    ret[mappedName] = src[name2];
  }
}
function _fnExtend(out, extender, breakRefs) {
  var val;
  for (var prop in extender) {
    if (Object.prototype.hasOwnProperty.call(extender, prop)) {
      val = extender[prop];
      if ($$6.isPlainObject(val)) {
        if (!$$6.isPlainObject(out[prop])) {
          out[prop] = {};
        }
        $$6.extend(true, out[prop], val);
      } else if (breakRefs && prop !== "data" && prop !== "aaData" && Array.isArray(val)) {
        out[prop] = val.slice();
      } else {
        out[prop] = val;
      }
    }
  }
  return out;
}
function _fnBindAction(n2, selector, fn3) {
  $$6(n2).on("click.DT", selector, function(e2) {
    fn3(e2);
  }).on("keypress.DT", selector, function(e2) {
    if (e2.which === 13) {
      e2.preventDefault();
      fn3(e2);
    }
  }).on("selectstart.DT", selector, function() {
    return false;
  });
}
function _fnCallbackReg(settings, store, fn3) {
  if (fn3) {
    settings[store].push(fn3);
  }
}
function _fnCallbackFire(settings, callbackArr, eventName, args, bubbles) {
  var ret = [];
  if (callbackArr) {
    ret = settings[callbackArr].slice().reverse().map(function(val) {
      return val.apply(settings.oInstance, args);
    });
  }
  if (eventName !== null) {
    var e2 = $$6.Event(eventName + ".dt");
    var table = $$6(settings.nTable);
    e2.dt = settings.api;
    table[bubbles ? "trigger" : "triggerHandler"](e2, args);
    if (bubbles && table.parents("body").length === 0) {
      $$6("body").trigger(e2, args);
    }
    ret.push(e2.result);
  }
  return ret;
}
function _fnLengthOverflow(settings) {
  var start2 = settings._iDisplayStart, end2 = settings.fnDisplayEnd(), len = settings._iDisplayLength;
  if (start2 >= end2) {
    start2 = end2 - len;
  }
  start2 -= start2 % len;
  if (len === -1 || start2 < 0) {
    start2 = 0;
  }
  settings._iDisplayStart = start2;
}
function _fnRenderer(settings, type) {
  var renderer = settings.renderer;
  var host = DataTable.ext.renderer[type];
  if ($$6.isPlainObject(renderer) && renderer[type]) {
    return host[renderer[type]] || host._;
  } else if (typeof renderer === "string") {
    return host[renderer] || host._;
  }
  return host._;
}
function _fnDataSource(settings) {
  if (settings.oFeatures.bServerSide) {
    return "ssp";
  } else if (settings.ajax) {
    return "ajax";
  }
  return "dom";
}
function _fnMacros(settings, str2, entries) {
  var formatter = settings.fnFormatNumber, start2 = settings._iDisplayStart + 1, len = settings._iDisplayLength, vis = settings.fnRecordsDisplay(), max2 = settings.fnRecordsTotal(), all2 = len === -1;
  return str2.replace(/_START_/g, formatter.call(settings, start2)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, max2)).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all2 ? 1 : Math.ceil(start2 / len))).replace(/_PAGES_/g, formatter.call(settings, all2 ? 1 : Math.ceil(vis / len))).replace(/_ENTRIES_/g, settings.api.i18n("entries", "", entries)).replace(/_ENTRIES-MAX_/g, settings.api.i18n("entries", "", max2)).replace(/_ENTRIES-TOTAL_/g, settings.api.i18n("entries", "", vis));
}
function _fnArrayApply(arr, data2) {
  if (!data2) {
    return;
  }
  if (data2.length < 1e4) {
    arr.push.apply(arr, data2);
  } else {
    for (i = 0; i < data2.length; i++) {
      arr.push(data2[i]);
    }
  }
}
var __apiStruct = [];
var __arrayProto = Array.prototype;
var _toSettings = function(mixed) {
  var idx, jq;
  var settings = DataTable.settings;
  var tables = _pluck(settings, "nTable");
  if (!mixed) {
    return [];
  } else if (mixed.nTable && mixed.oFeatures) {
    return [mixed];
  } else if (mixed.nodeName && mixed.nodeName.toLowerCase() === "table") {
    idx = tables.indexOf(mixed);
    return idx !== -1 ? [settings[idx]] : null;
  } else if (mixed && typeof mixed.settings === "function") {
    return mixed.settings().toArray();
  } else if (typeof mixed === "string") {
    jq = $$6(mixed).get();
  } else if (mixed instanceof $$6) {
    jq = mixed.get();
  }
  if (jq) {
    return settings.filter(function(v2, idx2) {
      return jq.includes(tables[idx2]);
    });
  }
};
_Api = function(context, data2) {
  if (!(this instanceof _Api)) {
    return new _Api(context, data2);
  }
  var i;
  var settings = [];
  var ctxSettings = function(o2) {
    var a2 = _toSettings(o2);
    if (a2) {
      settings.push.apply(settings, a2);
    }
  };
  if (Array.isArray(context)) {
    for (i = 0; i < context.length; i++) {
      ctxSettings(context[i]);
    }
  } else {
    ctxSettings(context);
  }
  this.context = settings.length > 1 ? _unique(settings) : settings;
  _fnArrayApply(this, data2);
  this.selector = {
    rows: null,
    cols: null,
    opts: null
  };
  _Api.extend(this, this, __apiStruct);
};
DataTable.Api = _Api;
$$6.extend(_Api.prototype, {
  any: function() {
    return this.count() !== 0;
  },
  context: [],
  // array of table settings objects
  count: function() {
    return this.flatten().length;
  },
  each: function(fn3) {
    for (var i = 0, ien = this.length; i < ien; i++) {
      fn3.call(this, this[i], i, this);
    }
    return this;
  },
  eq: function(idx) {
    var ctx = this.context;
    return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null;
  },
  filter: function(fn3) {
    var a2 = __arrayProto.filter.call(this, fn3, this);
    return new _Api(this.context, a2);
  },
  flatten: function() {
    var a2 = [];
    return new _Api(this.context, a2.concat.apply(a2, this.toArray()));
  },
  get: function(idx) {
    return this[idx];
  },
  join: __arrayProto.join,
  includes: function(find2) {
    return this.indexOf(find2) === -1 ? false : true;
  },
  indexOf: __arrayProto.indexOf,
  iterator: function(flatten, type, fn3, alwaysNew) {
    var a2 = [], ret, i, ien, j2, jen, context = this.context, rows, items, item2, selector = this.selector;
    if (typeof flatten === "string") {
      alwaysNew = fn3;
      fn3 = type;
      type = flatten;
      flatten = false;
    }
    for (i = 0, ien = context.length; i < ien; i++) {
      var apiInst = new _Api(context[i]);
      if (type === "table") {
        ret = fn3.call(apiInst, context[i], i);
        if (ret !== void 0) {
          a2.push(ret);
        }
      } else if (type === "columns" || type === "rows") {
        ret = fn3.call(apiInst, context[i], this[i], i);
        if (ret !== void 0) {
          a2.push(ret);
        }
      } else if (type === "every" || type === "column" || type === "column-rows" || type === "row" || type === "cell") {
        items = this[i];
        if (type === "column-rows") {
          rows = _selector_row_indexes(context[i], selector.opts);
        }
        for (j2 = 0, jen = items.length; j2 < jen; j2++) {
          item2 = items[j2];
          if (type === "cell") {
            ret = fn3.call(apiInst, context[i], item2.row, item2.column, i, j2);
          } else {
            ret = fn3.call(apiInst, context[i], item2, i, j2, rows);
          }
          if (ret !== void 0) {
            a2.push(ret);
          }
        }
      }
    }
    if (a2.length || alwaysNew) {
      var api = new _Api(context, flatten ? a2.concat.apply([], a2) : a2);
      var apiSelector = api.selector;
      apiSelector.rows = selector.rows;
      apiSelector.cols = selector.cols;
      apiSelector.opts = selector.opts;
      return api;
    }
    return this;
  },
  lastIndexOf: __arrayProto.lastIndexOf,
  length: 0,
  map: function(fn3) {
    var a2 = __arrayProto.map.call(this, fn3, this);
    return new _Api(this.context, a2);
  },
  pluck: function(prop) {
    var fn3 = DataTable.util.get(prop);
    return this.map(function(el) {
      return fn3(el);
    });
  },
  pop: __arrayProto.pop,
  push: __arrayProto.push,
  reduce: __arrayProto.reduce,
  reduceRight: __arrayProto.reduceRight,
  reverse: __arrayProto.reverse,
  // Object with rows, columns and opts
  selector: null,
  shift: __arrayProto.shift,
  slice: function() {
    return new _Api(this.context, this);
  },
  sort: __arrayProto.sort,
  splice: __arrayProto.splice,
  toArray: function() {
    return __arrayProto.slice.call(this);
  },
  to$: function() {
    return $$6(this);
  },
  toJQuery: function() {
    return $$6(this);
  },
  unique: function() {
    return new _Api(this.context, _unique(this.toArray()));
  },
  unshift: __arrayProto.unshift
});
function _api_scope(scope, fn3, struc) {
  return function() {
    var ret = fn3.apply(scope || this, arguments);
    _Api.extend(ret, ret, struc.methodExt);
    return ret;
  };
}
function _api_find(src, name2) {
  for (var i = 0, ien = src.length; i < ien; i++) {
    if (src[i].name === name2) {
      return src[i];
    }
  }
  return null;
}
window.__apiStruct = __apiStruct;
_Api.extend = function(scope, obj, ext) {
  if (!ext.length || !obj || !(obj instanceof _Api) && !obj.__dt_wrapper) {
    return;
  }
  var i, ien, struct;
  for (i = 0, ien = ext.length; i < ien; i++) {
    struct = ext[i];
    if (struct.name === "__proto__") {
      continue;
    }
    obj[struct.name] = struct.type === "function" ? _api_scope(scope, struct.val, struct) : struct.type === "object" ? {} : struct.val;
    obj[struct.name].__dt_wrapper = true;
    _Api.extend(scope, obj[struct.name], struct.propExt);
  }
};
_Api.register = _api_register = function(name2, val) {
  if (Array.isArray(name2)) {
    for (var j2 = 0, jen = name2.length; j2 < jen; j2++) {
      _Api.register(name2[j2], val);
    }
    return;
  }
  var i, ien, heir = name2.split("."), struct = __apiStruct, key, method;
  for (i = 0, ien = heir.length; i < ien; i++) {
    method = heir[i].indexOf("()") !== -1;
    key = method ? heir[i].replace("()", "") : heir[i];
    var src = _api_find(struct, key);
    if (!src) {
      src = {
        name: key,
        val: {},
        methodExt: [],
        propExt: [],
        type: "object"
      };
      struct.push(src);
    }
    if (i === ien - 1) {
      src.val = val;
      src.type = typeof val === "function" ? "function" : $$6.isPlainObject(val) ? "object" : "other";
    } else {
      struct = method ? src.methodExt : src.propExt;
    }
  }
};
_Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
  _Api.register(pluralName, val);
  _Api.register(singularName, function() {
    var ret = val.apply(this, arguments);
    if (ret === this) {
      return this;
    } else if (ret instanceof _Api) {
      return ret.length ? Array.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : (
        // Array results are 'enhanced'
        ret[0]
      ) : void 0;
    }
    return ret;
  });
};
var __table_selector = function(selector, a2) {
  if (Array.isArray(selector)) {
    var result = [];
    selector.forEach(function(sel) {
      var inner = __table_selector(sel, a2);
      _fnArrayApply(result, inner);
    });
    return result.filter(function(item2) {
      return item2;
    });
  }
  if (typeof selector === "number") {
    return [a2[selector]];
  }
  var nodes = a2.map(function(el) {
    return el.nTable;
  });
  return $$6(nodes).filter(selector).map(function() {
    var idx = nodes.indexOf(this);
    return a2[idx];
  }).toArray();
};
_api_register("tables()", function(selector) {
  return selector !== void 0 && selector !== null ? new _Api(__table_selector(selector, this.context)) : this;
});
_api_register("table()", function(selector) {
  var tables = this.tables(selector);
  var ctx = tables.context;
  return ctx.length ? new _Api(ctx[0]) : tables;
});
[
  ["nodes", "node", "nTable"],
  ["body", "body", "nTBody"],
  ["header", "header", "nTHead"],
  ["footer", "footer", "nTFoot"]
].forEach(function(item2) {
  _api_registerPlural(
    "tables()." + item2[0] + "()",
    "table()." + item2[1] + "()",
    function() {
      return this.iterator("table", function(ctx) {
        return ctx[item2[2]];
      }, 1);
    }
  );
});
[
  ["header", "aoHeader"],
  ["footer", "aoFooter"]
].forEach(function(item2) {
  _api_register("table()." + item2[0] + ".structure()", function(selector) {
    var indexes = this.columns(selector).indexes().flatten();
    var ctx = this.context[0];
    return _fnHeaderLayout(ctx, ctx[item2[1]], indexes);
  });
});
_api_registerPlural("tables().containers()", "table().container()", function() {
  return this.iterator("table", function(ctx) {
    return ctx.nTableWrapper;
  }, 1);
});
_api_register("tables().every()", function(fn3) {
  var that = this;
  return this.iterator("table", function(s2, i) {
    fn3.call(that.table(i), i);
  });
});
_api_register("caption()", function(value, side) {
  var context = this.context;
  if (value === void 0) {
    var caption = context[0].captionNode;
    return caption && context.length ? caption.innerHTML : null;
  }
  return this.iterator("table", function(ctx) {
    var table = $$6(ctx.nTable);
    var caption2 = $$6(ctx.captionNode);
    var container = $$6(ctx.nTableWrapper);
    if (!caption2.length) {
      caption2 = $$6("<caption/>").html(value);
      ctx.captionNode = caption2[0];
      if (!side) {
        table.prepend(caption2);
        side = caption2.css("caption-side");
      }
    }
    caption2.html(value);
    if (side) {
      caption2.css("caption-side", side);
      caption2[0]._captionSide = side;
    }
    if (container.find("div.dataTables_scroll").length) {
      var selector = side === "top" ? "Head" : "Foot";
      container.find("div.dataTables_scroll" + selector + " table").prepend(caption2);
    } else {
      table.prepend(caption2);
    }
  }, 1);
});
_api_register("caption.node()", function() {
  var ctx = this.context;
  return ctx.length ? ctx[0].captionNode : null;
});
_api_register("draw()", function(paging) {
  return this.iterator("table", function(settings) {
    if (paging === "page") {
      _fnDraw(settings);
    } else {
      if (typeof paging === "string") {
        paging = paging === "full-hold" ? false : true;
      }
      _fnReDraw(settings, paging === false);
    }
  });
});
_api_register("page()", function(action) {
  if (action === void 0) {
    return this.page.info().page;
  }
  return this.iterator("table", function(settings) {
    _fnPageChange(settings, action);
  });
});
_api_register("page.info()", function() {
  if (this.context.length === 0) {
    return void 0;
  }
  var settings = this.context[0], start2 = settings._iDisplayStart, len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1, visRecords = settings.fnRecordsDisplay(), all2 = len === -1;
  return {
    "page": all2 ? 0 : Math.floor(start2 / len),
    "pages": all2 ? 1 : Math.ceil(visRecords / len),
    "start": start2,
    "end": settings.fnDisplayEnd(),
    "length": len,
    "recordsTotal": settings.fnRecordsTotal(),
    "recordsDisplay": visRecords,
    "serverSide": _fnDataSource(settings) === "ssp"
  };
});
_api_register("page.len()", function(len) {
  if (len === void 0) {
    return this.context.length !== 0 ? this.context[0]._iDisplayLength : void 0;
  }
  return this.iterator("table", function(settings) {
    _fnLengthChange(settings, len);
  });
});
var __reload = function(settings, holdPosition, callback) {
  if (callback) {
    var api = new _Api(settings);
    api.one("draw", function() {
      callback(api.ajax.json());
    });
  }
  if (_fnDataSource(settings) == "ssp") {
    _fnReDraw(settings, holdPosition);
  } else {
    _fnProcessingDisplay(settings, true);
    var xhr = settings.jqXHR;
    if (xhr && xhr.readyState !== 4) {
      xhr.abort();
    }
    _fnBuildAjax(settings, {}, function(json) {
      _fnClearTable(settings);
      var data2 = _fnAjaxDataSrc(settings, json);
      for (var i = 0, ien = data2.length; i < ien; i++) {
        _fnAddData(settings, data2[i]);
      }
      _fnReDraw(settings, holdPosition);
      _fnInitComplete(settings);
      _fnProcessingDisplay(settings, false);
    });
  }
};
_api_register("ajax.json()", function() {
  var ctx = this.context;
  if (ctx.length > 0) {
    return ctx[0].json;
  }
});
_api_register("ajax.params()", function() {
  var ctx = this.context;
  if (ctx.length > 0) {
    return ctx[0].oAjaxData;
  }
});
_api_register("ajax.reload()", function(callback, resetPaging) {
  return this.iterator("table", function(settings) {
    __reload(settings, resetPaging === false, callback);
  });
});
_api_register("ajax.url()", function(url) {
  var ctx = this.context;
  if (url === void 0) {
    if (ctx.length === 0) {
      return void 0;
    }
    ctx = ctx[0];
    return $$6.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax;
  }
  return this.iterator("table", function(settings) {
    if ($$6.isPlainObject(settings.ajax)) {
      settings.ajax.url = url;
    } else {
      settings.ajax = url;
    }
  });
});
_api_register("ajax.url().load()", function(callback, resetPaging) {
  return this.iterator("table", function(ctx) {
    __reload(ctx, resetPaging === false, callback);
  });
});
var _selector_run = function(type, selector, selectFn, settings, opts) {
  var out = [], res2, a2, i, ien, j2, jen, selectorType = typeof selector;
  if (!selector || selectorType === "string" || selectorType === "function" || selector.length === void 0) {
    selector = [selector];
  }
  for (i = 0, ien = selector.length; i < ien; i++) {
    a2 = selector[i] && selector[i].split && !selector[i].match(/[[(:]/) ? selector[i].split(",") : [selector[i]];
    for (j2 = 0, jen = a2.length; j2 < jen; j2++) {
      res2 = selectFn(typeof a2[j2] === "string" ? a2[j2].trim() : a2[j2]);
      res2 = res2.filter(function(item2) {
        return item2 !== null && item2 !== void 0;
      });
      if (res2 && res2.length) {
        out = out.concat(res2);
      }
    }
  }
  var ext = _ext.selector[type];
  if (ext.length) {
    for (i = 0, ien = ext.length; i < ien; i++) {
      out = ext[i](settings, opts, out);
    }
  }
  return _unique(out);
};
var _selector_opts = function(opts) {
  if (!opts) {
    opts = {};
  }
  if (opts.filter && opts.search === void 0) {
    opts.search = opts.filter;
  }
  return $$6.extend({
    search: "none",
    order: "current",
    page: "all"
  }, opts);
};
var _selector_first = function(old2) {
  var inst = new _Api(old2.context[0]);
  if (old2.length) {
    inst.push(old2[0]);
  }
  inst.selector = old2.selector;
  if (inst.length && inst[0].length > 1) {
    inst[0].splice(1);
  }
  return inst;
};
var _selector_row_indexes = function(settings, opts) {
  var i, ien, tmp, a2 = [], displayFiltered = settings.aiDisplay, displayMaster = settings.aiDisplayMaster;
  var search = opts.search, order2 = opts.order, page = opts.page;
  if (_fnDataSource(settings) == "ssp") {
    return search === "removed" ? [] : _range(0, displayMaster.length);
  }
  if (page == "current") {
    for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) {
      a2.push(displayFiltered[i]);
    }
  } else if (order2 == "current" || order2 == "applied") {
    if (search == "none") {
      a2 = displayMaster.slice();
    } else if (search == "applied") {
      a2 = displayFiltered.slice();
    } else if (search == "removed") {
      var displayFilteredMap = {};
      for (i = 0, ien = displayFiltered.length; i < ien; i++) {
        displayFilteredMap[displayFiltered[i]] = null;
      }
      displayMaster.forEach(function(item2) {
        if (!Object.prototype.hasOwnProperty.call(displayFilteredMap, item2)) {
          a2.push(item2);
        }
      });
    }
  } else if (order2 == "index" || order2 == "original") {
    for (i = 0, ien = settings.aoData.length; i < ien; i++) {
      if (!settings.aoData[i]) {
        continue;
      }
      if (search == "none") {
        a2.push(i);
      } else {
        tmp = displayFiltered.indexOf(i);
        if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
          a2.push(i);
        }
      }
    }
  } else if (typeof order2 === "number") {
    var ordered = _fnSort(settings, order2, "asc");
    if (search === "none") {
      a2 = ordered;
    } else {
      for (i = 0; i < ordered.length; i++) {
        tmp = displayFiltered.indexOf(ordered[i]);
        if (tmp === -1 && search == "removed" || tmp >= 0 && search == "applied") {
          a2.push(ordered[i]);
        }
      }
    }
  }
  return a2;
};
var __row_selector = function(settings, selector, opts) {
  var rows;
  var run2 = function(sel) {
    var selInt = _intVal(sel);
    var aoData = settings.aoData;
    if (selInt !== null && !opts) {
      return [selInt];
    }
    if (!rows) {
      rows = _selector_row_indexes(settings, opts);
    }
    if (selInt !== null && rows.indexOf(selInt) !== -1) {
      return [selInt];
    } else if (sel === null || sel === void 0 || sel === "") {
      return rows;
    }
    if (typeof sel === "function") {
      return rows.map(function(idx) {
        var row = aoData[idx];
        return sel(idx, row._aData, row.nTr) ? idx : null;
      });
    }
    if (sel.nodeName) {
      var rowIdx = sel._DT_RowIndex;
      var cellIdx = sel._DT_CellIndex;
      if (rowIdx !== void 0) {
        return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
      } else if (cellIdx) {
        return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel.parentNode ? [cellIdx.row] : [];
      } else {
        var host = $$6(sel).closest("*[data-dt-row]");
        return host.length ? [host.data("dt-row")] : [];
      }
    }
    if (typeof sel === "string" && sel.charAt(0) === "#") {
      var rowObj = settings.aIds[sel.replace(/^#/, "")];
      if (rowObj !== void 0) {
        return [rowObj.idx];
      }
    }
    var nodes = _removeEmpty(
      _pluck_order(settings.aoData, rows, "nTr")
    );
    return $$6(nodes).filter(sel).map(function() {
      return this._DT_RowIndex;
    }).toArray();
  };
  var matched = _selector_run("row", selector, run2, settings, opts);
  if (opts.order === "current" || opts.order === "applied") {
    _fnSortDisplay(settings, matched);
  }
  return matched;
};
_api_register("rows()", function(selector, opts) {
  if (selector === void 0) {
    selector = "";
  } else if ($$6.isPlainObject(selector)) {
    opts = selector;
    selector = "";
  }
  opts = _selector_opts(opts);
  var inst = this.iterator("table", function(settings) {
    return __row_selector(settings, selector, opts);
  }, 1);
  inst.selector.rows = selector;
  inst.selector.opts = opts;
  return inst;
});
_api_register("rows().nodes()", function() {
  return this.iterator("row", function(settings, row) {
    return settings.aoData[row].nTr || void 0;
  }, 1);
});
_api_register("rows().data()", function() {
  return this.iterator(true, "rows", function(settings, rows) {
    return _pluck_order(settings.aoData, rows, "_aData");
  }, 1);
});
_api_registerPlural("rows().cache()", "row().cache()", function(type) {
  return this.iterator("row", function(settings, row) {
    var r2 = settings.aoData[row];
    return type === "search" ? r2._aFilterData : r2._aSortData;
  }, 1);
});
_api_registerPlural("rows().invalidate()", "row().invalidate()", function(src) {
  return this.iterator("row", function(settings, row) {
    _fnInvalidate(settings, row, src);
  });
});
_api_registerPlural("rows().indexes()", "row().index()", function() {
  return this.iterator("row", function(settings, row) {
    return row;
  }, 1);
});
_api_registerPlural("rows().ids()", "row().id()", function(hash2) {
  var a2 = [];
  var context = this.context;
  for (var i = 0, ien = context.length; i < ien; i++) {
    for (var j2 = 0, jen = this[i].length; j2 < jen; j2++) {
      var id = context[i].rowIdFn(context[i].aoData[this[i][j2]]._aData);
      a2.push((hash2 === true ? "#" : "") + id);
    }
  }
  return new _Api(context, a2);
});
_api_registerPlural("rows().remove()", "row().remove()", function() {
  this.iterator("row", function(settings, row) {
    var data2 = settings.aoData;
    var rowData = data2[row];
    var idx = settings.aiDisplayMaster.indexOf(row);
    if (idx !== -1) {
      settings.aiDisplayMaster.splice(idx, 1);
    }
    if (settings._iRecordsDisplay > 0) {
      settings._iRecordsDisplay--;
    }
    _fnLengthOverflow(settings);
    var id = settings.rowIdFn(rowData._aData);
    if (id !== void 0) {
      delete settings.aIds[id];
    }
    data2[row] = null;
  });
  return this;
});
_api_register("rows.add()", function(rows) {
  var newRows = this.iterator("table", function(settings) {
    var row, i, ien;
    var out = [];
    for (i = 0, ien = rows.length; i < ien; i++) {
      row = rows[i];
      if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
        out.push(_fnAddTr(settings, row)[0]);
      } else {
        out.push(_fnAddData(settings, row));
      }
    }
    return out;
  }, 1);
  var modRows = this.rows(-1);
  modRows.pop();
  _fnArrayApply(modRows, newRows);
  return modRows;
});
_api_register("row()", function(selector, opts) {
  return _selector_first(this.rows(selector, opts));
});
_api_register("row().data()", function(data2) {
  var ctx = this.context;
  if (data2 === void 0) {
    return ctx.length && this.length && this[0].length ? ctx[0].aoData[this[0]]._aData : void 0;
  }
  var row = ctx[0].aoData[this[0]];
  row._aData = data2;
  if (Array.isArray(data2) && row.nTr && row.nTr.id) {
    _fnSetObjectDataFn(ctx[0].rowId)(data2, row.nTr.id);
  }
  _fnInvalidate(ctx[0], this[0], "data");
  return this;
});
_api_register("row().node()", function() {
  var ctx = this.context;
  if (ctx.length && this.length && this[0].length) {
    var row = ctx[0].aoData[this[0]];
    if (row && row.nTr) {
      return row.nTr;
    }
  }
  return null;
});
_api_register("row.add()", function(row) {
  if (row instanceof $$6 && row.length) {
    row = row[0];
  }
  var rows = this.iterator("table", function(settings) {
    if (row.nodeName && row.nodeName.toUpperCase() === "TR") {
      return _fnAddTr(settings, row)[0];
    }
    return _fnAddData(settings, row);
  });
  return this.row(rows[0]);
});
$$6(document).on("plugin-init.dt", function(e2, context) {
  var api = new _Api(context);
  api.on("stateSaveParams.DT", function(e3, settings, d2) {
    var idFn = settings.rowIdFn;
    var rows = settings.aiDisplayMaster;
    var ids = [];
    for (var i = 0; i < rows.length; i++) {
      var rowIdx = rows[i];
      var data2 = settings.aoData[rowIdx];
      if (data2._detailsShow) {
        ids.push("#" + idFn(data2._aData));
      }
    }
    d2.childRows = ids;
  });
  api.on("stateLoaded.DT", function(e3, settings, state2) {
    __details_state_load(api, state2);
  });
  __details_state_load(api, api.state.loaded());
});
var __details_state_load = function(api, state2) {
  if (state2 && state2.childRows) {
    api.rows(state2.childRows.map(function(id) {
      return id.replace(/([^:\\]*(?:\\.[^:\\]*)*):/g, "$1\\:");
    })).every(function() {
      _fnCallbackFire(api.settings()[0], null, "requestChild", [this]);
    });
  }
};
var __details_add = function(ctx, row, data2, klass) {
  var rows = [];
  var addRow = function(r2, k2) {
    if (Array.isArray(r2) || r2 instanceof $$6) {
      for (var i = 0, ien = r2.length; i < ien; i++) {
        addRow(r2[i], k2);
      }
      return;
    }
    if (r2.nodeName && r2.nodeName.toLowerCase() === "tr") {
      r2.setAttribute("data-dt-row", row.idx);
      rows.push(r2);
    } else {
      var created = $$6("<tr><td></td></tr>").attr("data-dt-row", row.idx).addClass(k2);
      $$6("td", created).addClass(k2).html(r2)[0].colSpan = _fnVisbleColumns(ctx);
      rows.push(created[0]);
    }
  };
  addRow(data2, klass);
  if (row._details) {
    row._details.detach();
  }
  row._details = $$6(rows);
  if (row._detailsShow) {
    row._details.insertAfter(row.nTr);
  }
};
var __details_state = DataTable.util.throttle(
  function(ctx) {
    _fnSaveState(ctx[0]);
  },
  500
);
var __details_remove = function(api, idx) {
  var ctx = api.context;
  if (ctx.length) {
    var row = ctx[0].aoData[idx !== void 0 ? idx : api[0]];
    if (row && row._details) {
      row._details.remove();
      row._detailsShow = void 0;
      row._details = void 0;
      $$6(row.nTr).removeClass("dt-hasChild");
      __details_state(ctx);
    }
  }
};
var __details_display = function(api, show2) {
  var ctx = api.context;
  if (ctx.length && api.length) {
    var row = ctx[0].aoData[api[0]];
    if (row._details) {
      row._detailsShow = show2;
      if (show2) {
        row._details.insertAfter(row.nTr);
        $$6(row.nTr).addClass("dt-hasChild");
      } else {
        row._details.detach();
        $$6(row.nTr).removeClass("dt-hasChild");
      }
      _fnCallbackFire(ctx[0], null, "childRow", [show2, api.row(api[0])]);
      __details_events(ctx[0]);
      __details_state(ctx);
    }
  }
};
var __details_events = function(settings) {
  var api = new _Api(settings);
  var namespace = ".dt.DT_details";
  var drawEvent = "draw" + namespace;
  var colvisEvent = "column-sizing" + namespace;
  var destroyEvent = "destroy" + namespace;
  var data2 = settings.aoData;
  api.off(drawEvent + " " + colvisEvent + " " + destroyEvent);
  if (_pluck(data2, "_details").length > 0) {
    api.on(drawEvent, function(e2, ctx) {
      if (settings !== ctx) {
        return;
      }
      api.rows({ page: "current" }).eq(0).each(function(idx) {
        var row = data2[idx];
        if (row._detailsShow) {
          row._details.insertAfter(row.nTr);
        }
      });
    });
    api.on(colvisEvent, function(e2, ctx) {
      if (settings !== ctx) {
        return;
      }
      var row, visible = _fnVisbleColumns(ctx);
      for (var i = 0, ien = data2.length; i < ien; i++) {
        row = data2[i];
        if (row && row._details) {
          row._details.each(function() {
            var el = $$6(this).children("td");
            if (el.length == 1) {
              el.attr("colspan", visible);
            }
          });
        }
      }
    });
    api.on(destroyEvent, function(e2, ctx) {
      if (settings !== ctx) {
        return;
      }
      for (var i = 0, ien = data2.length; i < ien; i++) {
        if (data2[i] && data2[i]._details) {
          __details_remove(api, i);
        }
      }
    });
  }
};
var _emp = "";
var _child_obj = _emp + "row().child";
var _child_mth = _child_obj + "()";
_api_register(_child_mth, function(data2, klass) {
  var ctx = this.context;
  if (data2 === void 0) {
    return ctx.length && this.length && ctx[0].aoData[this[0]] ? ctx[0].aoData[this[0]]._details : void 0;
  } else if (data2 === true) {
    this.child.show();
  } else if (data2 === false) {
    __details_remove(this);
  } else if (ctx.length && this.length) {
    __details_add(ctx[0], ctx[0].aoData[this[0]], data2, klass);
  }
  return this;
});
_api_register([
  _child_obj + ".show()",
  _child_mth + ".show()"
  // only when `child()` was called with parameters (without
], function() {
  __details_display(this, true);
  return this;
});
_api_register([
  _child_obj + ".hide()",
  _child_mth + ".hide()"
  // only when `child()` was called with parameters (without
], function() {
  __details_display(this, false);
  return this;
});
_api_register([
  _child_obj + ".remove()",
  _child_mth + ".remove()"
  // only when `child()` was called with parameters (without
], function() {
  __details_remove(this);
  return this;
});
_api_register(_child_obj + ".isShown()", function() {
  var ctx = this.context;
  if (ctx.length && this.length && ctx[0].aoData[this[0]]) {
    return ctx[0].aoData[this[0]]._detailsShow || false;
  }
  return false;
});
var __re_column_selector = /^([^:]+)?:(name|title|visIdx|visible)$/;
var __columnData = function(settings, column, r1, r2, rows, type) {
  var a2 = [];
  for (var row = 0, ien = rows.length; row < ien; row++) {
    a2.push(_fnGetCellData(settings, rows[row], column, type));
  }
  return a2;
};
var __column_header = function(settings, column, row) {
  var header = settings.aoHeader;
  var target = row !== void 0 ? row : settings.bSortCellsTop ? 0 : header.length - 1;
  return header[target][column].cell;
};
var __column_selector = function(settings, selector, opts) {
  var columns = settings.aoColumns, names = _pluck(columns, "sName"), titles = _pluck(columns, "sTitle"), cells = DataTable.util.get("[].[].cell")(settings.aoHeader), nodes = _unique(_flatten([], cells));
  var run2 = function(s2) {
    var selInt = _intVal(s2);
    if (s2 === "") {
      return _range(columns.length);
    }
    if (selInt !== null) {
      return [
        selInt >= 0 ? selInt : (
          // Count from left
          columns.length + selInt
        )
        // Count from right (+ because its a negative value)
      ];
    }
    if (typeof s2 === "function") {
      var rows = _selector_row_indexes(settings, opts);
      return columns.map(function(col, idx2) {
        return s2(
          idx2,
          __columnData(settings, idx2, 0, 0, rows),
          __column_header(settings, idx2)
        ) ? idx2 : null;
      });
    }
    var match = typeof s2 === "string" ? s2.match(__re_column_selector) : "";
    if (match) {
      switch (match[2]) {
        case "visIdx":
        case "visible":
          if (match[1] && match[1].match(/^\d+$/)) {
            var idx = parseInt(match[1], 10);
            if (idx < 0) {
              var visColumns = columns.map(function(col, i) {
                return col.bVisible ? i : null;
              });
              return [visColumns[visColumns.length + idx]];
            }
            return [_fnVisibleToColumnIndex(settings, idx)];
          }
          return columns.map(function(col, idx2) {
            if (!col.bVisible) {
              return null;
            }
            if (match[1]) {
              return $$6(nodes[idx2]).filter(match[1]).length > 0 ? idx2 : null;
            }
            return idx2;
          });
        case "name":
          return names.map(function(name2, i) {
            return name2 === match[1] ? i : null;
          });
        case "title":
          return titles.map(function(title, i) {
            return title === match[1] ? i : null;
          });
        default:
          return [];
      }
    }
    if (s2.nodeName && s2._DT_CellIndex) {
      return [s2._DT_CellIndex.column];
    }
    var jqResult = $$6(nodes).filter(s2).map(function() {
      return _fnColumnsFromHeader(this);
    }).toArray().sort(function(a2, b2) {
      return a2 - b2;
    });
    if (jqResult.length || !s2.nodeName) {
      return jqResult;
    }
    var host = $$6(s2).closest("*[data-dt-column]");
    return host.length ? [host.data("dt-column")] : [];
  };
  return _selector_run("column", selector, run2, settings, opts);
};
var __setColumnVis = function(settings, column, vis) {
  var cols = settings.aoColumns, col = cols[column], data2 = settings.aoData, cells, i, ien, tr;
  if (vis === void 0) {
    return col.bVisible;
  }
  if (col.bVisible === vis) {
    return false;
  }
  if (vis) {
    var insertBefore2 = _pluck(cols, "bVisible").indexOf(true, column + 1);
    for (i = 0, ien = data2.length; i < ien; i++) {
      if (data2[i]) {
        tr = data2[i].nTr;
        cells = data2[i].anCells;
        if (tr) {
          tr.insertBefore(cells[column], cells[insertBefore2] || null);
        }
      }
    }
  } else {
    $$6(_pluck(settings.aoData, "anCells", column)).detach();
  }
  col.bVisible = vis;
  _colGroup(settings);
  return true;
};
_api_register("columns()", function(selector, opts) {
  if (selector === void 0) {
    selector = "";
  } else if ($$6.isPlainObject(selector)) {
    opts = selector;
    selector = "";
  }
  opts = _selector_opts(opts);
  var inst = this.iterator("table", function(settings) {
    return __column_selector(settings, selector, opts);
  }, 1);
  inst.selector.cols = selector;
  inst.selector.opts = opts;
  return inst;
});
_api_registerPlural("columns().header()", "column().header()", function(row) {
  return this.iterator("column", function(settings, column) {
    return __column_header(settings, column, row);
  }, 1);
});
_api_registerPlural("columns().footer()", "column().footer()", function(row) {
  return this.iterator("column", function(settings, column) {
    var footer = settings.aoFooter;
    if (!footer.length) {
      return null;
    }
    return settings.aoFooter[row !== void 0 ? row : 0][column].cell;
  }, 1);
});
_api_registerPlural("columns().data()", "column().data()", function() {
  return this.iterator("column-rows", __columnData, 1);
});
_api_registerPlural("columns().render()", "column().render()", function(type) {
  return this.iterator("column-rows", function(settings, column, i, j2, rows) {
    return __columnData(settings, column, i, j2, rows, type);
  }, 1);
});
_api_registerPlural("columns().dataSrc()", "column().dataSrc()", function() {
  return this.iterator("column", function(settings, column) {
    return settings.aoColumns[column].mData;
  }, 1);
});
_api_registerPlural("columns().cache()", "column().cache()", function(type) {
  return this.iterator("column-rows", function(settings, column, i, j2, rows) {
    return _pluck_order(
      settings.aoData,
      rows,
      type === "search" ? "_aFilterData" : "_aSortData",
      column
    );
  }, 1);
});
_api_registerPlural("columns().init()", "column().init()", function() {
  return this.iterator("column", function(settings, column) {
    return settings.aoColumns[column];
  }, 1);
});
_api_registerPlural("columns().nodes()", "column().nodes()", function() {
  return this.iterator("column-rows", function(settings, column, i, j2, rows) {
    return _pluck_order(settings.aoData, rows, "anCells", column);
  }, 1);
});
_api_registerPlural("columns().titles()", "column().title()", function(title, row) {
  return this.iterator("column", function(settings, column) {
    if (typeof title === "number") {
      row = title;
      title = void 0;
    }
    var span = $$6("span.dt-column-title", this.column(column).header(row));
    if (title !== void 0) {
      span.html(title);
      return this;
    }
    return span.html();
  }, 1);
});
_api_registerPlural("columns().types()", "column().type()", function() {
  return this.iterator("column", function(settings, column) {
    var type = settings.aoColumns[column].sType;
    if (!type) {
      _fnColumnTypes(settings);
    }
    return type;
  }, 1);
});
_api_registerPlural("columns().visible()", "column().visible()", function(vis, calc) {
  var that = this;
  var changed = [];
  var ret = this.iterator("column", function(settings, column) {
    if (vis === void 0) {
      return settings.aoColumns[column].bVisible;
    }
    if (__setColumnVis(settings, column, vis)) {
      changed.push(column);
    }
  });
  if (vis !== void 0) {
    this.iterator("table", function(settings) {
      _fnDrawHead(settings, settings.aoHeader);
      _fnDrawHead(settings, settings.aoFooter);
      if (!settings.aiDisplay.length) {
        $$6(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns(settings));
      }
      _fnSaveState(settings);
      that.iterator("column", function(settings2, column) {
        if (changed.includes(column)) {
          _fnCallbackFire(settings2, null, "column-visibility", [settings2, column, vis, calc]);
        }
      });
      if (changed.length && (calc === void 0 || calc)) {
        that.columns.adjust();
      }
    });
  }
  return ret;
});
_api_registerPlural("columns().widths()", "column().width()", function() {
  var columns = this.columns(":visible").count();
  var row = $$6("<tr>").html("<td>" + Array(columns).join("</td><td>") + "</td>");
  $$6(this.table().body()).append(row);
  var widths = row.children().map(function() {
    return $$6(this).outerWidth();
  });
  row.remove();
  return this.iterator("column", function(settings, column) {
    var visIdx = _fnColumnIndexToVisible(settings, column);
    return visIdx !== null ? widths[visIdx] : 0;
  }, 1);
});
_api_registerPlural("columns().indexes()", "column().index()", function(type) {
  return this.iterator("column", function(settings, column) {
    return type === "visible" ? _fnColumnIndexToVisible(settings, column) : column;
  }, 1);
});
_api_register("columns.adjust()", function() {
  return this.iterator("table", function(settings) {
    settings.containerWidth = -1;
    _fnAdjustColumnSizing(settings);
  }, 1);
});
_api_register("column.index()", function(type, idx) {
  if (this.context.length !== 0) {
    var ctx = this.context[0];
    if (type === "fromVisible" || type === "toData") {
      return _fnVisibleToColumnIndex(ctx, idx);
    } else if (type === "fromData" || type === "toVisible") {
      return _fnColumnIndexToVisible(ctx, idx);
    }
  }
});
_api_register("column()", function(selector, opts) {
  return _selector_first(this.columns(selector, opts));
});
var __cell_selector = function(settings, selector, opts) {
  var data2 = settings.aoData;
  var rows = _selector_row_indexes(settings, opts);
  var cells = _removeEmpty(_pluck_order(data2, rows, "anCells"));
  var allCells = $$6(_flatten([], cells));
  var row;
  var columns = settings.aoColumns.length;
  var a2, i, ien, j2, o2, host;
  var run2 = function(s2) {
    var fnSelector = typeof s2 === "function";
    if (s2 === null || s2 === void 0 || fnSelector) {
      a2 = [];
      for (i = 0, ien = rows.length; i < ien; i++) {
        row = rows[i];
        for (j2 = 0; j2 < columns; j2++) {
          o2 = {
            row,
            column: j2
          };
          if (fnSelector) {
            host = data2[row];
            if (s2(o2, _fnGetCellData(settings, row, j2), host.anCells ? host.anCells[j2] : null)) {
              a2.push(o2);
            }
          } else {
            a2.push(o2);
          }
        }
      }
      return a2;
    }
    if ($$6.isPlainObject(s2)) {
      return s2.column !== void 0 && s2.row !== void 0 && rows.indexOf(s2.row) !== -1 ? [s2] : [];
    }
    var jqResult = allCells.filter(s2).map(function(i2, el) {
      return {
        // use a new object, in case someone changes the values
        row: el._DT_CellIndex.row,
        column: el._DT_CellIndex.column
      };
    }).toArray();
    if (jqResult.length || !s2.nodeName) {
      return jqResult;
    }
    host = $$6(s2).closest("*[data-dt-row]");
    return host.length ? [{
      row: host.data("dt-row"),
      column: host.data("dt-column")
    }] : [];
  };
  return _selector_run("cell", selector, run2, settings, opts);
};
_api_register("cells()", function(rowSelector, columnSelector, opts) {
  if ($$6.isPlainObject(rowSelector)) {
    if (rowSelector.row === void 0) {
      opts = rowSelector;
      rowSelector = null;
    } else {
      opts = columnSelector;
      columnSelector = null;
    }
  }
  if ($$6.isPlainObject(columnSelector)) {
    opts = columnSelector;
    columnSelector = null;
  }
  if (columnSelector === null || columnSelector === void 0) {
    return this.iterator("table", function(settings) {
      return __cell_selector(settings, rowSelector, _selector_opts(opts));
    });
  }
  var internalOpts = opts ? {
    page: opts.page,
    order: opts.order,
    search: opts.search
  } : {};
  var columns = this.columns(columnSelector, internalOpts);
  var rows = this.rows(rowSelector, internalOpts);
  var i, ien, j2, jen;
  var cellsNoOpts = this.iterator("table", function(settings, idx) {
    var a2 = [];
    for (i = 0, ien = rows[idx].length; i < ien; i++) {
      for (j2 = 0, jen = columns[idx].length; j2 < jen; j2++) {
        a2.push({
          row: rows[idx][i],
          column: columns[idx][j2]
        });
      }
    }
    return a2;
  }, 1);
  var cells = opts && opts.selected ? this.cells(cellsNoOpts, opts) : cellsNoOpts;
  $$6.extend(cells.selector, {
    cols: columnSelector,
    rows: rowSelector,
    opts
  });
  return cells;
});
_api_registerPlural("cells().nodes()", "cell().node()", function() {
  return this.iterator("cell", function(settings, row, column) {
    var data2 = settings.aoData[row];
    return data2 && data2.anCells ? data2.anCells[column] : void 0;
  }, 1);
});
_api_register("cells().data()", function() {
  return this.iterator("cell", function(settings, row, column) {
    return _fnGetCellData(settings, row, column);
  }, 1);
});
_api_registerPlural("cells().cache()", "cell().cache()", function(type) {
  type = type === "search" ? "_aFilterData" : "_aSortData";
  return this.iterator("cell", function(settings, row, column) {
    return settings.aoData[row][type][column];
  }, 1);
});
_api_registerPlural("cells().render()", "cell().render()", function(type) {
  return this.iterator("cell", function(settings, row, column) {
    return _fnGetCellData(settings, row, column, type);
  }, 1);
});
_api_registerPlural("cells().indexes()", "cell().index()", function() {
  return this.iterator("cell", function(settings, row, column) {
    return {
      row,
      column,
      columnVisible: _fnColumnIndexToVisible(settings, column)
    };
  }, 1);
});
_api_registerPlural("cells().invalidate()", "cell().invalidate()", function(src) {
  return this.iterator("cell", function(settings, row, column) {
    _fnInvalidate(settings, row, src, column);
  });
});
_api_register("cell()", function(rowSelector, columnSelector, opts) {
  return _selector_first(this.cells(rowSelector, columnSelector, opts));
});
_api_register("cell().data()", function(data2) {
  var ctx = this.context;
  var cell = this[0];
  if (data2 === void 0) {
    return ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : void 0;
  }
  _fnSetCellData(ctx[0], cell[0].row, cell[0].column, data2);
  _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column);
  return this;
});
_api_register("order()", function(order2, dir) {
  var ctx = this.context;
  var args = Array.prototype.slice.call(arguments);
  if (order2 === void 0) {
    return ctx.length !== 0 ? ctx[0].aaSorting : void 0;
  }
  if (typeof order2 === "number") {
    order2 = [[order2, dir]];
  } else if (args.length > 1) {
    order2 = args;
  }
  return this.iterator("table", function(settings) {
    settings.aaSorting = Array.isArray(order2) ? order2.slice() : order2;
  });
});
_api_register("order.listener()", function(node, column, callback) {
  return this.iterator("table", function(settings) {
    _fnSortAttachListener(settings, node, {}, column, callback);
  });
});
_api_register("order.fixed()", function(set) {
  if (!set) {
    var ctx = this.context;
    var fixed = ctx.length ? ctx[0].aaSortingFixed : void 0;
    return Array.isArray(fixed) ? { pre: fixed } : fixed;
  }
  return this.iterator("table", function(settings) {
    settings.aaSortingFixed = $$6.extend(true, {}, set);
  });
});
_api_register([
  "columns().order()",
  "column().order()"
], function(dir) {
  var that = this;
  if (!dir) {
    return this.iterator("column", function(settings, idx) {
      var sort = _fnSortFlatten(settings);
      for (var i = 0, ien = sort.length; i < ien; i++) {
        if (sort[i].col === idx) {
          return sort[i].dir;
        }
      }
      return null;
    }, 1);
  } else {
    return this.iterator("table", function(settings, i) {
      settings.aaSorting = that[i].map(function(col) {
        return [col, dir];
      });
    });
  }
});
_api_registerPlural("columns().orderable()", "column().orderable()", function(directions) {
  return this.iterator("column", function(settings, idx) {
    var col = settings.aoColumns[idx];
    return directions ? col.asSorting : col.bSortable;
  }, 1);
});
_api_register("processing()", function(show2) {
  return this.iterator("table", function(ctx) {
    _fnProcessingDisplay(ctx, show2);
  });
});
_api_register("search()", function(input, regex, smart, caseInsen) {
  var ctx = this.context;
  if (input === void 0) {
    return ctx.length !== 0 ? ctx[0].oPreviousSearch.search : void 0;
  }
  return this.iterator("table", function(settings) {
    if (!settings.oFeatures.bFilter) {
      return;
    }
    if (typeof regex === "object") {
      _fnFilterComplete(settings, $$6.extend(settings.oPreviousSearch, regex, {
        search: input
      }));
    } else {
      _fnFilterComplete(settings, $$6.extend(settings.oPreviousSearch, {
        search: input,
        regex: regex === null ? false : regex,
        smart: smart === null ? true : smart,
        caseInsensitive: caseInsen === null ? true : caseInsen
      }));
    }
  });
});
_api_register("search.fixed()", function(name2, search) {
  var ret = this.iterator(true, "table", function(settings) {
    var fixed = settings.searchFixed;
    if (!name2) {
      return Object.keys(fixed);
    } else if (search === void 0) {
      return fixed[name2];
    } else if (search === null) {
      delete fixed[name2];
    } else {
      fixed[name2] = search;
    }
    return this;
  });
  return name2 !== void 0 && search === void 0 ? ret[0] : ret;
});
_api_registerPlural(
  "columns().search()",
  "column().search()",
  function(input, regex, smart, caseInsen) {
    return this.iterator("column", function(settings, column) {
      var preSearch = settings.aoPreSearchCols;
      if (input === void 0) {
        return preSearch[column].search;
      }
      if (!settings.oFeatures.bFilter) {
        return;
      }
      if (typeof regex === "object") {
        $$6.extend(preSearch[column], regex, {
          search: input
        });
      } else {
        $$6.extend(preSearch[column], {
          search: input,
          regex: regex === null ? false : regex,
          smart: smart === null ? true : smart,
          caseInsensitive: caseInsen === null ? true : caseInsen
        });
      }
      _fnFilterComplete(settings, settings.oPreviousSearch);
    });
  }
);
_api_register(
  [
    "columns().search.fixed()",
    "column().search.fixed()"
  ],
  function(name2, search) {
    var ret = this.iterator(true, "column", function(settings, colIdx) {
      var fixed = settings.aoColumns[colIdx].searchFixed;
      if (!name2) {
        return Object.keys(fixed);
      } else if (search === void 0) {
        return fixed[name2];
      } else if (search === null) {
        delete fixed[name2];
      } else {
        fixed[name2] = search;
      }
      return this;
    });
    return name2 !== void 0 && search === void 0 ? ret[0] : ret;
  }
);
_api_register("state()", function(set, ignoreTime) {
  if (!set) {
    return this.context.length ? this.context[0].oSavedState : null;
  }
  var setMutate = $$6.extend(true, {}, set);
  return this.iterator("table", function(settings) {
    if (ignoreTime !== false) {
      setMutate.time = +/* @__PURE__ */ new Date() + 100;
    }
    _fnImplementState(settings, setMutate, function() {
    });
  });
});
_api_register("state.clear()", function() {
  return this.iterator("table", function(settings) {
    settings.fnStateSaveCallback.call(settings.oInstance, settings, {});
  });
});
_api_register("state.loaded()", function() {
  return this.context.length ? this.context[0].oLoadedState : null;
});
_api_register("state.save()", function() {
  return this.iterator("table", function(settings) {
    _fnSaveState(settings);
  });
});
var __bootstrap;
var __foundation;
DataTable.use = function(arg1, arg2) {
  var module = typeof arg1 === "string" ? arg2 : arg1;
  var type = typeof arg2 === "string" ? arg2 : arg1;
  if (module === void 0 && typeof type === "string") {
    switch (type) {
      case "lib":
      case "jq":
        return $$6;
      case "win":
        return window;
      case "datetime":
        return DataTable.DateTime;
      case "luxon":
        return __luxon;
      case "moment":
        return __moment;
      case "bootstrap":
        return __bootstrap || window.bootstrap;
      case "foundation":
        return __foundation || window.Foundation;
      default:
        return null;
    }
  }
  if (type === "lib" || type === "jq" || module && module.fn && module.fn.jquery) {
    $$6 = module;
  } else if (type === "win" || module && module.document) {
    window = module;
    document = module.document;
  } else if (type === "datetime" || module && module.type === "DateTime") {
    DataTable.DateTime = module;
  } else if (type === "luxon" || module && module.FixedOffsetZone) {
    __luxon = module;
  } else if (type === "moment" || module && module.isMoment) {
    __moment = module;
  } else if (type === "bootstrap" || module && module.Modal && module.Modal.NAME === "modal") {
    __bootstrap = module;
  } else if (type === "foundation" || module && module.Reveal) {
    __foundation = module;
  }
};
DataTable.factory = function(root2, jq) {
  var is2 = false;
  if (root2 && root2.document) {
    window = root2;
    document = root2.document;
  }
  if (jq && jq.fn && jq.fn.jquery) {
    $$6 = jq;
    is2 = true;
  }
  return is2;
};
DataTable.versionCheck = function(version, version2) {
  var aThis = version2 ? version2.split(".") : DataTable.version.split(".");
  var aThat = version.split(".");
  var iThis, iThat;
  for (var i = 0, iLen = aThat.length; i < iLen; i++) {
    iThis = parseInt(aThis[i], 10) || 0;
    iThat = parseInt(aThat[i], 10) || 0;
    if (iThis === iThat) {
      continue;
    }
    return iThis > iThat;
  }
  return true;
};
DataTable.isDataTable = function(table) {
  var t2 = $$6(table).get(0);
  var is2 = false;
  if (table instanceof DataTable.Api) {
    return true;
  }
  $$6.each(DataTable.settings, function(i, o2) {
    var head = o2.nScrollHead ? $$6("table", o2.nScrollHead)[0] : null;
    var foot = o2.nScrollFoot ? $$6("table", o2.nScrollFoot)[0] : null;
    if (o2.nTable === t2 || head === t2 || foot === t2) {
      is2 = true;
    }
  });
  return is2;
};
DataTable.tables = function(visible) {
  var api = false;
  if ($$6.isPlainObject(visible)) {
    api = visible.api;
    visible = visible.visible;
  }
  var a2 = DataTable.settings.filter(function(o2) {
    return !visible || visible && $$6(o2.nTable).is(":visible") ? true : false;
  }).map(function(o2) {
    return o2.nTable;
  });
  return api ? new _Api(a2) : a2;
};
DataTable.camelToHungarian = _fnCamelToHungarian;
_api_register("$()", function(selector, opts) {
  var rows = this.rows(opts).nodes(), jqRows = $$6(rows);
  return $$6([].concat(
    jqRows.filter(selector).toArray(),
    jqRows.find(selector).toArray()
  ));
});
$$6.each(["on", "one", "off"], function(i, key) {
  _api_register(key + "()", function() {
    var args = Array.prototype.slice.call(arguments);
    args[0] = args[0].split(/\s/).map(function(e2) {
      return !e2.match(/\.dt\b/) ? e2 + ".dt" : e2;
    }).join(" ");
    var inst = $$6(this.tables().nodes());
    inst[key].apply(inst, args);
    return this;
  });
});
_api_register("clear()", function() {
  return this.iterator("table", function(settings) {
    _fnClearTable(settings);
  });
});
_api_register("error()", function(msg) {
  return this.iterator("table", function(settings) {
    _fnLog(settings, 0, msg);
  });
});
_api_register("settings()", function() {
  return new _Api(this.context, this.context);
});
_api_register("init()", function() {
  var ctx = this.context;
  return ctx.length ? ctx[0].oInit : null;
});
_api_register("data()", function() {
  return this.iterator("table", function(settings) {
    return _pluck(settings.aoData, "_aData");
  }).flatten();
});
_api_register("trigger()", function(name2, args, bubbles) {
  return this.iterator("table", function(settings) {
    return _fnCallbackFire(settings, null, name2, args, bubbles);
  }).flatten();
});
_api_register("ready()", function(fn3) {
  var ctx = this.context;
  if (!fn3) {
    return ctx.length ? ctx[0]._bInitComplete || false : null;
  }
  return this.tables().every(function() {
    var api = this;
    if (this.context[0]._bInitComplete) {
      fn3.call(api);
    } else {
      this.on("init.dt.DT", function() {
        fn3.call(api);
      });
    }
  });
});
_api_register("destroy()", function(remove) {
  remove = remove || false;
  return this.iterator("table", function(settings) {
    var classes = settings.oClasses;
    var table = settings.nTable;
    var tbody = settings.nTBody;
    var thead = settings.nTHead;
    var tfoot = settings.nTFoot;
    var jqTable = $$6(table);
    var jqTbody = $$6(tbody);
    var jqWrapper = $$6(settings.nTableWrapper);
    var rows = settings.aoData.map(function(r2) {
      return r2 ? r2.nTr : null;
    });
    var orderClasses = classes.order;
    settings.bDestroying = true;
    _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings], true);
    if (!remove) {
      new _Api(settings).columns().visible(true);
    }
    if (settings.resizeObserver) {
      settings.resizeObserver.disconnect();
    }
    jqWrapper.off(".DT").find(":not(tbody *)").off(".DT");
    $$6(window).off(".DT-" + settings.sInstance);
    if (table != thead.parentNode) {
      jqTable.children("thead").detach();
      jqTable.append(thead);
    }
    if (tfoot && table != tfoot.parentNode) {
      jqTable.children("tfoot").detach();
      jqTable.append(tfoot);
    }
    $$6(thead).find("span.dt-column-order").remove();
    $$6(thead).find("span.dt-column-title").each(function() {
      var title = $$6(this).html();
      $$6(this).parent().append(title);
      $$6(this).remove();
    });
    settings.colgroup.remove();
    settings.aaSorting = [];
    settings.aaSortingFixed = [];
    _fnSortingClasses(settings);
    $$6(jqTable).find("th, td").removeClass(
      $$6.map(DataTable.ext.type.className, function(v2) {
        return v2;
      }).join(" ")
    );
    $$6("th, td", thead).removeClass(
      orderClasses.none + " " + orderClasses.canAsc + " " + orderClasses.canDesc + " " + orderClasses.isAsc + " " + orderClasses.isDesc
    ).css("width", "").removeAttr("data-dt-column").removeAttr("aria-sort");
    jqTbody.children().detach();
    jqTbody.append(rows);
    var orig = settings.nTableWrapper.parentNode;
    var insertBefore2 = settings.nTableWrapper.nextSibling;
    var removedMethod = remove ? "remove" : "detach";
    jqTable[removedMethod]();
    jqWrapper[removedMethod]();
    if (!remove && orig) {
      orig.insertBefore(table, insertBefore2);
      jqTable.css("width", settings.sDestroyWidth).removeClass(classes.table);
    }
    var idx = DataTable.settings.indexOf(settings);
    if (idx !== -1) {
      DataTable.settings.splice(idx, 1);
    }
  });
});
$$6.each(["column", "row", "cell"], function(i, type) {
  _api_register(type + "s().every()", function(fn3) {
    var opts = this.selector.opts;
    var api = this;
    var inst;
    var counter = 0;
    return this.iterator("every", function(settings, selectedIdx, tableIdx) {
      inst = api[type](selectedIdx, opts);
      if (type === "cell") {
        fn3.call(inst, inst[0][0].row, inst[0][0].column, tableIdx, counter);
      } else {
        fn3.call(inst, selectedIdx, tableIdx, counter);
      }
      counter++;
    });
  });
});
_api_register("i18n()", function(token, def, plural) {
  var ctx = this.context[0];
  var resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
  if (resolved === void 0) {
    resolved = def;
  }
  if ($$6.isPlainObject(resolved)) {
    resolved = plural !== void 0 && resolved[plural] !== void 0 ? resolved[plural] : resolved._;
  }
  return typeof resolved === "string" ? resolved.replace("%d", plural) : resolved;
});
DataTable.version = "2.2.2";
DataTable.settings = [];
DataTable.models = {};
DataTable.models.oSearch = {
  /**
   * Flag to indicate if the filtering should be case insensitive or not
   */
  "caseInsensitive": true,
  /**
   * Applied search term
   */
  "search": "",
  /**
   * Flag to indicate if the search term should be interpreted as a
   * regular expression (true) or not (false) and therefore and special
   * regex characters escaped.
   */
  "regex": false,
  /**
   * Flag to indicate if DataTables is to use its smart filtering or not.
   */
  "smart": true,
  /**
   * Flag to indicate if DataTables should only trigger a search when
   * the return key is pressed.
   */
  "return": false
};
DataTable.models.oRow = {
  /**
   * TR element for the row
   */
  "nTr": null,
  /**
   * Array of TD elements for each row. This is null until the row has been
   * created.
   */
  "anCells": null,
  /**
   * Data object from the original data source for the row. This is either
   * an array if using the traditional form of DataTables, or an object if
   * using mData options. The exact type will depend on the passed in
   * data from the data source, or will be an array if using DOM a data
   * source.
   */
  "_aData": [],
  /**
   * Sorting data cache - this array is ostensibly the same length as the
   * number of columns (although each index is generated only as it is
   * needed), and holds the data that is used for sorting each column in the
   * row. We do this cache generation at the start of the sort in order that
   * the formatting of the sort data need be done only once for each cell
   * per sort. This array should not be read from or written to by anything
   * other than the master sorting methods.
   */
  "_aSortData": null,
  /**
   * Per cell filtering data cache. As per the sort data cache, used to
   * increase the performance of the filtering in DataTables
   */
  "_aFilterData": null,
  /**
   * Filtering data cache. This is the same as the cell filtering cache, but
   * in this case a string rather than an array. This is easily computed with
   * a join on `_aFilterData`, but is provided as a cache so the join isn't
   * needed on every search (memory traded for performance)
   */
  "_sFilterRow": null,
  /**
   * Denote if the original data source was from the DOM, or the data source
   * object. This is used for invalidating data, so DataTables can
   * automatically read data from the original source, unless uninstructed
   * otherwise.
   */
  "src": null,
  /**
   * Index in the aoData array. This saves an indexOf lookup when we have the
   * object, but want to know the index
   */
  "idx": -1,
  /**
   * Cached display value
   */
  displayData: null
};
DataTable.models.oColumn = {
  /**
   * Column index.
   */
  "idx": null,
  /**
   * A list of the columns that sorting should occur on when this column
   * is sorted. That this property is an array allows multi-column sorting
   * to be defined for a column (for example first name / last name columns
   * would benefit from this). The values are integers pointing to the
   * columns to be sorted on (typically it will be a single integer pointing
   * at itself, but that doesn't need to be the case).
   */
  "aDataSort": null,
  /**
   * Define the sorting directions that are applied to the column, in sequence
   * as the column is repeatedly sorted upon - i.e. the first value is used
   * as the sorting direction when the column if first sorted (clicked on).
   * Sort it again (click again) and it will move on to the next index.
   * Repeat until loop.
   */
  "asSorting": null,
  /**
   * Flag to indicate if the column is searchable, and thus should be included
   * in the filtering or not.
   */
  "bSearchable": null,
  /**
   * Flag to indicate if the column is sortable or not.
   */
  "bSortable": null,
  /**
   * Flag to indicate if the column is currently visible in the table or not
   */
  "bVisible": null,
  /**
   * Store for manual type assignment using the `column.type` option. This
   * is held in store so we can manipulate the column's `sType` property.
   */
  "_sManualType": null,
  /**
   * Flag to indicate if HTML5 data attributes should be used as the data
   * source for filtering or sorting. True is either are.
   */
  "_bAttrSrc": false,
  /**
   * Developer definable function that is called whenever a cell is created (Ajax source,
   * etc) or processed for input (DOM source). This can be used as a compliment to mRender
   * allowing you to modify the DOM element (add background colour for example) when the
   * element is available.
   */
  "fnCreatedCell": null,
  /**
   * Function to get data from a cell in a column. You should <b>never</b>
   * access data directly through _aData internally in DataTables - always use
   * the method attached to this property. It allows mData to function as
   * required. This function is automatically assigned by the column
   * initialisation method
   */
  "fnGetData": null,
  /**
   * Function to set data for a cell in the column. You should <b>never</b>
   * set the data directly to _aData internally in DataTables - always use
   * this method. It allows mData to function as required. This function
   * is automatically assigned by the column initialisation method
   */
  "fnSetData": null,
  /**
   * Property to read the value for the cells in the column from the data
   * source array / object. If null, then the default content is used, if a
   * function is given then the return from the function is used.
   */
  "mData": null,
  /**
   * Partner property to mData which is used (only when defined) to get
   * the data - i.e. it is basically the same as mData, but without the
   * 'set' option, and also the data fed to it is the result from mData.
   * This is the rendering method to match the data method of mData.
   */
  "mRender": null,
  /**
   * The class to apply to all TD elements in the table's TBODY for the column
   */
  "sClass": null,
  /**
   * When DataTables calculates the column widths to assign to each column,
   * it finds the longest string in each column and then constructs a
   * temporary table and reads the widths from that. The problem with this
   * is that "mmm" is much wider then "iiii", but the latter is a longer
   * string - thus the calculation can go wrong (doing it properly and putting
   * it into an DOM object and measuring that is horribly(!) slow). Thus as
   * a "work around" we provide this option. It will append its value to the
   * text that is found to be the longest string for the column - i.e. padding.
   */
  "sContentPadding": null,
  /**
   * Allows a default value to be given for a column's data, and will be used
   * whenever a null data source is encountered (this can be because mData
   * is set to null, or because the data source itself is null).
   */
  "sDefaultContent": null,
  /**
   * Name for the column, allowing reference to the column by name as well as
   * by index (needs a lookup to work by name).
   */
  "sName": null,
  /**
   * Custom sorting data type - defines which of the available plug-ins in
   * afnSortData the custom sorting will use - if any is defined.
   */
  "sSortDataType": "std",
  /**
   * Class to be applied to the header element when sorting on this column
   */
  "sSortingClass": null,
  /**
   * Title of the column - what is seen in the TH element (nTh).
   */
  "sTitle": null,
  /**
   * Column sorting and filtering type
   */
  "sType": null,
  /**
   * Width of the column
   */
  "sWidth": null,
  /**
   * Width of the column when it was first "encountered"
   */
  "sWidthOrig": null,
  /** Cached string which is the longest in the column */
  maxLenString: null,
  /**
   * Store for named searches
   */
  searchFixed: null
};
DataTable.defaults = {
  /**
   * An array of data to use for the table, passed in at initialisation which
   * will be used in preference to any data which is already in the DOM. This is
   * particularly useful for constructing tables purely in Javascript, for
   * example with a custom Ajax call.
   */
  "aaData": null,
  /**
   * If ordering is enabled, then DataTables will perform a first pass sort on
   * initialisation. You can define which column(s) the sort is performed
   * upon, and the sorting direction, with this variable. The `sorting` array
   * should contain an array for each column to be sorted initially containing
   * the column's index and a direction string ('asc' or 'desc').
   */
  "aaSorting": [[0, "asc"]],
  /**
   * This parameter is basically identical to the `sorting` parameter, but
   * cannot be overridden by user interaction with the table. What this means
   * is that you could have a column (visible or hidden) which the sorting
   * will always be forced on first - any sorting after that (from the user)
   * will then be performed as required. This can be useful for grouping rows
   * together.
   */
  "aaSortingFixed": [],
  /**
   * DataTables can be instructed to load data to display in the table from a
   * Ajax source. This option defines how that Ajax call is made and where to.
   *
   * The `ajax` property has three different modes of operation, depending on
   * how it is defined. These are:
   *
   * * `string` - Set the URL from where the data should be loaded from.
   * * `object` - Define properties for `jQuery.ajax`.
   * * `function` - Custom data get function
   *
   * `string`
   * --------
   *
   * As a string, the `ajax` property simply defines the URL from which
   * DataTables will load data.
   *
   * `object`
   * --------
   *
   * As an object, the parameters in the object are passed to
   * [jQuery.ajax](https://api.jquery.com/jQuery.ajax/) allowing fine control
   * of the Ajax request. DataTables has a number of default parameters which
   * you can override using this option. Please refer to the jQuery
   * documentation for a full description of the options available, although
   * the following parameters provide additional options in DataTables or
   * require special consideration:
   *
   * * `data` - As with jQuery, `data` can be provided as an object, but it
   *   can also be used as a function to manipulate the data DataTables sends
   *   to the server. The function takes a single parameter, an object of
   *   parameters with the values that DataTables has readied for sending. An
   *   object may be returned which will be merged into the DataTables
   *   defaults, or you can add the items to the object that was passed in and
   *   not return anything from the function. This supersedes `fnServerParams`
   *   from DataTables 1.9-.
   *
   * * `dataSrc` - By default DataTables will look for the property `data` (or
   *   `aaData` for compatibility with DataTables 1.9-) when obtaining data
   *   from an Ajax source or for server-side processing - this parameter
   *   allows that property to be changed. You can use Javascript dotted
   *   object notation to get a data source for multiple levels of nesting, or
   *   it my be used as a function. As a function it takes a single parameter,
   *   the JSON returned from the server, which can be manipulated as
   *   required, with the returned value being that used by DataTables as the
   *   data source for the table.
   *
   * * `success` - Should not be overridden it is used internally in
   *   DataTables. To manipulate / transform the data returned by the server
   *   use `ajax.dataSrc`, or use `ajax` as a function (see below).
   *
   * `function`
   * ----------
   *
   * As a function, making the Ajax call is left up to yourself allowing
   * complete control of the Ajax request. Indeed, if desired, a method other
   * than Ajax could be used to obtain the required data, such as Web storage
   * or an AIR database.
   *
   * The function is given four parameters and no return is required. The
   * parameters are:
   *
   * 1. _object_ - Data to send to the server
   * 2. _function_ - Callback function that must be executed when the required
   *    data has been obtained. That data should be passed into the callback
   *    as the only parameter
   * 3. _object_ - DataTables settings object for the table
   */
  "ajax": null,
  /**
   * This parameter allows you to readily specify the entries in the length drop
   * down menu that DataTables shows when pagination is enabled. It can be
   * either a 1D array of options which will be used for both the displayed
   * option and the value, or a 2D array which will use the array in the first
   * position as the value, and the array in the second position as the
   * displayed options (useful for language strings such as 'All').
   *
   * Note that the `pageLength` property will be automatically set to the
   * first value given in this array, unless `pageLength` is also provided.
   */
  "aLengthMenu": [10, 25, 50, 100],
  /**
   * The `columns` option in the initialisation parameter allows you to define
   * details about the way individual columns behave. For a full list of
   * column options that can be set, please see
   * {@link DataTable.defaults.column}. Note that if you use `columns` to
   * define your columns, you must have an entry in the array for every single
   * column that you have in your table (these can be null if you don't which
   * to specify any options).
   */
  "aoColumns": null,
  /**
   * Very similar to `columns`, `columnDefs` allows you to target a specific
   * column, multiple columns, or all columns, using the `targets` property of
   * each object in the array. This allows great flexibility when creating
   * tables, as the `columnDefs` arrays can be of any length, targeting the
   * columns you specifically want. `columnDefs` may use any of the column
   * options available: {@link DataTable.defaults.column}, but it _must_
   * have `targets` defined in each object in the array. Values in the `targets`
   * array may be:
   *   <ul>
   *     <li>a string - class name will be matched on the TH for the column</li>
   *     <li>0 or a positive integer - column index counting from the left</li>
   *     <li>a negative integer - column index counting from the right</li>
   *     <li>the string "_all" - all columns (i.e. assign a default)</li>
   *   </ul>
   */
  "aoColumnDefs": null,
  /**
   * Basically the same as `search`, this parameter defines the individual column
   * filtering state at initialisation time. The array must be of the same size
   * as the number of columns, and each element be an object with the parameters
   * `search` and `escapeRegex` (the latter is optional). 'null' is also
   * accepted and the default will be used.
   */
  "aoSearchCols": [],
  /**
   * Enable or disable automatic column width calculation. This can be disabled
   * as an optimisation (it takes some time to calculate the widths) if the
   * tables widths are passed in using `columns`.
   */
  "bAutoWidth": true,
  /**
   * Deferred rendering can provide DataTables with a huge speed boost when you
   * are using an Ajax or JS data source for the table. This option, when set to
   * true, will cause DataTables to defer the creation of the table elements for
   * each row until they are needed for a draw - saving a significant amount of
   * time.
   */
  "bDeferRender": true,
  /**
   * Replace a DataTable which matches the given selector and replace it with
   * one which has the properties of the new initialisation object passed. If no
   * table matches the selector, then the new DataTable will be constructed as
   * per normal.
   */
  "bDestroy": false,
  /**
   * Enable or disable filtering of data. Filtering in DataTables is "smart" in
   * that it allows the end user to input multiple words (space separated) and
   * will match a row containing those words, even if not in the order that was
   * specified (this allow matching across multiple columns). Note that if you
   * wish to use filtering in DataTables this must remain 'true' - to remove the
   * default filtering input box and retain filtering abilities, please use
   * {@link DataTable.defaults.dom}.
   */
  "bFilter": true,
  /**
   * Used only for compatiblity with DT1
   * @deprecated
   */
  "bInfo": true,
  /**
   * Used only for compatiblity with DT1
   * @deprecated
   */
  "bLengthChange": true,
  /**
   * Enable or disable pagination.
   */
  "bPaginate": true,
  /**
   * Enable or disable the display of a 'processing' indicator when the table is
   * being processed (e.g. a sort). This is particularly useful for tables with
   * large amounts of data where it can take a noticeable amount of time to sort
   * the entries.
   */
  "bProcessing": false,
  /**
   * Retrieve the DataTables object for the given selector. Note that if the
   * table has already been initialised, this parameter will cause DataTables
   * to simply return the object that has already been set up - it will not take
   * account of any changes you might have made to the initialisation object
   * passed to DataTables (setting this parameter to true is an acknowledgement
   * that you understand this). `destroy` can be used to reinitialise a table if
   * you need.
   */
  "bRetrieve": false,
  /**
   * When vertical (y) scrolling is enabled, DataTables will force the height of
   * the table's viewport to the given height at all times (useful for layout).
   * However, this can look odd when filtering data down to a small data set,
   * and the footer is left "floating" further down. This parameter (when
   * enabled) will cause DataTables to collapse the table's viewport down when
   * the result set will fit within the given Y height.
   */
  "bScrollCollapse": false,
  /**
   * Configure DataTables to use server-side processing. Note that the
   * `ajax` parameter must also be given in order to give DataTables a
   * source to obtain the required data for each draw.
   */
  "bServerSide": false,
  /**
   * Enable or disable sorting of columns. Sorting of individual columns can be
   * disabled by the `sortable` option for each column.
   */
  "bSort": true,
  /**
   * Enable or display DataTables' ability to sort multiple columns at the
   * same time (activated by shift-click by the user).
   */
  "bSortMulti": true,
  /**
   * Allows control over whether DataTables should use the top (true) unique
   * cell that is found for a single column, or the bottom (false - default).
   * This is useful when using complex headers.
   */
  "bSortCellsTop": null,
  /**
   * Enable or disable the addition of the classes `sorting\_1`, `sorting\_2` and
   * `sorting\_3` to the columns which are currently being sorted on. This is
   * presented as a feature switch as it can increase processing time (while
   * classes are removed and added) so for large data sets you might want to
   * turn this off.
   */
  "bSortClasses": true,
  /**
   * Enable or disable state saving. When enabled HTML5 `localStorage` will be
   * used to save table display information such as pagination information,
   * display length, filtering and sorting. As such when the end user reloads
   * the page the display display will match what thy had previously set up.
   */
  "bStateSave": false,
  /**
   * This function is called when a TR element is created (and all TD child
   * elements have been inserted), or registered if using a DOM source, allowing
   * manipulation of the TR element (adding classes etc).
   */
  "fnCreatedRow": null,
  /**
   * This function is called on every 'draw' event, and allows you to
   * dynamically modify any aspect you want about the created DOM.
   */
  "fnDrawCallback": null,
  /**
   * Identical to fnHeaderCallback() but for the table footer this function
   * allows you to modify the table footer on every 'draw' event.
   */
  "fnFooterCallback": null,
  /**
   * When rendering large numbers in the information element for the table
   * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
   * to have a comma separator for the 'thousands' units (e.g. 1 million is
   * rendered as "1,000,000") to help readability for the end user. This
   * function will override the default method DataTables uses.
   */
  "fnFormatNumber": function(toFormat) {
    return toFormat.toString().replace(
      /\B(?=(\d{3})+(?!\d))/g,
      this.oLanguage.sThousands
    );
  },
  /**
   * This function is called on every 'draw' event, and allows you to
   * dynamically modify the header row. This can be used to calculate and
   * display useful information about the table.
   */
  "fnHeaderCallback": null,
  /**
   * The information element can be used to convey information about the current
   * state of the table. Although the internationalisation options presented by
   * DataTables are quite capable of dealing with most customisations, there may
   * be times where you wish to customise the string further. This callback
   * allows you to do exactly that.
   */
  "fnInfoCallback": null,
  /**
   * Called when the table has been initialised. Normally DataTables will
   * initialise sequentially and there will be no need for this function,
   * however, this does not hold true when using external language information
   * since that is obtained using an async XHR call.
   */
  "fnInitComplete": null,
  /**
   * Called at the very start of each table draw and can be used to cancel the
   * draw by returning false, any other return (including undefined) results in
   * the full draw occurring).
   */
  "fnPreDrawCallback": null,
  /**
   * This function allows you to 'post process' each row after it have been
   * generated for each table draw, but before it is rendered on screen. This
   * function might be used for setting the row class name etc.
   */
  "fnRowCallback": null,
  /**
   * Load the table state. With this function you can define from where, and how, the
   * state of a table is loaded. By default DataTables will load from `localStorage`
   * but you might wish to use a server-side database or cookies.
   */
  "fnStateLoadCallback": function(settings) {
    try {
      return JSON.parse(
        (settings.iStateDuration === -1 ? sessionStorage : localStorage).getItem(
          "DataTables_" + settings.sInstance + "_" + location.pathname
        )
      );
    } catch (e2) {
      return {};
    }
  },
  /**
   * Callback which allows modification of the saved state prior to loading that state.
   * This callback is called when the table is loading state from the stored data, but
   * prior to the settings object being modified by the saved state. Note that for
   * plug-in authors, you should use the `stateLoadParams` event to load parameters for
   * a plug-in.
   */
  "fnStateLoadParams": null,
  /**
   * Callback that is called when the state has been loaded from the state saving method
   * and the DataTables settings object has been modified as a result of the loaded state.
   */
  "fnStateLoaded": null,
  /**
   * Save the table state. This function allows you to define where and how the state
   * information for the table is stored By default DataTables will use `localStorage`
   * but you might wish to use a server-side database or cookies.
   */
  "fnStateSaveCallback": function(settings, data2) {
    try {
      (settings.iStateDuration === -1 ? sessionStorage : localStorage).setItem(
        "DataTables_" + settings.sInstance + "_" + location.pathname,
        JSON.stringify(data2)
      );
    } catch (e2) {
    }
  },
  /**
   * Callback which allows modification of the state to be saved. Called when the table
   * has changed state a new state save is required. This method allows modification of
   * the state saving object prior to actually doing the save, including addition or
   * other state properties or modification. Note that for plug-in authors, you should
   * use the `stateSaveParams` event to save parameters for a plug-in.
   */
  "fnStateSaveParams": null,
  /**
   * Duration for which the saved state information is considered valid. After this period
   * has elapsed the state will be returned to the default.
   * Value is given in seconds.
   */
  "iStateDuration": 7200,
  /**
   * Number of rows to display on a single page when using pagination. If
   * feature enabled (`lengthChange`) then the end user will be able to override
   * this to a custom setting using a pop-up menu.
   */
  "iDisplayLength": 10,
  /**
   * Define the starting point for data display when using DataTables with
   * pagination. Note that this parameter is the number of records, rather than
   * the page number, so if you have 10 records per page and want to start on
   * the third page, it should be "20".
   */
  "iDisplayStart": 0,
  /**
   * By default DataTables allows keyboard navigation of the table (sorting, paging,
   * and filtering) by adding a `tabindex` attribute to the required elements. This
   * allows you to tab through the controls and press the enter key to activate them.
   * The tabindex is default 0, meaning that the tab follows the flow of the document.
   * You can overrule this using this parameter if you wish. Use a value of -1 to
   * disable built-in keyboard navigation.
   */
  "iTabIndex": 0,
  /**
   * Classes that DataTables assigns to the various components and features
   * that it adds to the HTML table. This allows classes to be configured
   * during initialisation in addition to through the static
   * {@link DataTable.ext.oStdClasses} object).
   */
  "oClasses": {},
  /**
   * All strings that DataTables uses in the user interface that it creates
   * are defined in this object, allowing you to modified them individually or
   * completely replace them all as required.
   */
  "oLanguage": {
    /**
     * Strings that are used for WAI-ARIA labels and controls only (these are not
     * actually visible on the page, but will be read by screenreaders, and thus
     * must be internationalised as well).
     */
    "oAria": {
      /**
       * ARIA label that is added to the table headers when the column may be sorted
       */
      "orderable": ": Activate to sort",
      /**
       * ARIA label that is added to the table headers when the column is currently being sorted
       */
      "orderableReverse": ": Activate to invert sorting",
      /**
       * ARIA label that is added to the table headers when the column is currently being 
       * sorted and next step is to remove sorting
       */
      "orderableRemove": ": Activate to remove sorting",
      paginate: {
        first: "First",
        last: "Last",
        next: "Next",
        previous: "Previous",
        number: ""
      }
    },
    /**
     * Pagination string used by DataTables for the built-in pagination
     * control types.
     */
    "oPaginate": {
      /**
       * Label and character for first page button («)
       */
      "sFirst": "«",
      /**
       * Last page button (»)
       */
      "sLast": "»",
      /**
       * Next page button (›)
       */
      "sNext": "›",
      /**
       * Previous page button (‹)
       */
      "sPrevious": "‹"
    },
    /**
     * Plural object for the data type the table is showing
     */
    entries: {
      _: "entries",
      1: "entry"
    },
    /**
     * This string is shown in preference to `zeroRecords` when the table is
     * empty of data (regardless of filtering). Note that this is an optional
     * parameter - if it is not given, the value of `zeroRecords` will be used
     * instead (either the default or given value).
     */
    "sEmptyTable": "No data available in table",
    /**
     * This string gives information to the end user about the information
     * that is current on display on the page. The following tokens can be
     * used in the string and will be dynamically replaced as the table
     * display updates. This tokens can be placed anywhere in the string, or
     * removed as needed by the language requires:
     *
     * * `\_START\_` - Display index of the first record on the current page
     * * `\_END\_` - Display index of the last record on the current page
     * * `\_TOTAL\_` - Number of records in the table after filtering
     * * `\_MAX\_` - Number of records in the table without filtering
     * * `\_PAGE\_` - Current page number
     * * `\_PAGES\_` - Total number of pages of data in the table
     */
    "sInfo": "Showing _START_ to _END_ of _TOTAL_ _ENTRIES-TOTAL_",
    /**
     * Display information string for when the table is empty. Typically the
     * format of this string should match `info`.
     */
    "sInfoEmpty": "Showing 0 to 0 of 0 _ENTRIES-TOTAL_",
    /**
     * When a user filters the information in a table, this string is appended
     * to the information (`info`) to give an idea of how strong the filtering
     * is. The variable _MAX_ is dynamically updated.
     */
    "sInfoFiltered": "(filtered from _MAX_ total _ENTRIES-MAX_)",
    /**
     * If can be useful to append extra information to the info string at times,
     * and this variable does exactly that. This information will be appended to
     * the `info` (`infoEmpty` and `infoFiltered` in whatever combination they are
     * being used) at all times.
     */
    "sInfoPostFix": "",
    /**
     * This decimal place operator is a little different from the other
     * language options since DataTables doesn't output floating point
     * numbers, so it won't ever use this for display of a number. Rather,
     * what this parameter does is modify the sort methods of the table so
     * that numbers which are in a format which has a character other than
     * a period (`.`) as a decimal place will be sorted numerically.
     *
     * Note that numbers with different decimal places cannot be shown in
     * the same table and still be sortable, the table must be consistent.
     * However, multiple different tables on the page can use different
     * decimal place characters.
     */
    "sDecimal": "",
    /**
     * DataTables has a build in number formatter (`formatNumber`) which is
     * used to format large numbers that are used in the table information.
     * By default a comma is used, but this can be trivially changed to any
     * character you wish with this parameter.
     */
    "sThousands": ",",
    /**
     * Detail the action that will be taken when the drop down menu for the
     * pagination length option is changed. The '_MENU_' variable is replaced
     * with a default select list of 10, 25, 50 and 100, and can be replaced
     * with a custom select box if required.
     */
    "sLengthMenu": "_MENU_ _ENTRIES_ per page",
    /**
     * When using Ajax sourced data and during the first draw when DataTables is
     * gathering the data, this message is shown in an empty row in the table to
     * indicate to the end user the the data is being loaded. Note that this
     * parameter is not used when loading data by server-side processing, just
     * Ajax sourced data with client-side processing.
     */
    "sLoadingRecords": "Loading...",
    /**
     * Text which is displayed when the table is processing a user action
     * (usually a sort command or similar).
     */
    "sProcessing": "",
    /**
     * Details the actions that will be taken when the user types into the
     * filtering input text box. The variable "_INPUT_", if used in the string,
     * is replaced with the HTML text box for the filtering input allowing
     * control over where it appears in the string. If "_INPUT_" is not given
     * then the input box is appended to the string automatically.
     */
    "sSearch": "Search:",
    /**
     * Assign a `placeholder` attribute to the search `input` element
     *  @type string
     *  @default 
     *
     *  @dtopt Language
     *  @name DataTable.defaults.language.searchPlaceholder
     */
    "sSearchPlaceholder": "",
    /**
     * All of the language information can be stored in a file on the
     * server-side, which DataTables will look up if this parameter is passed.
     * It must store the URL of the language file, which is in a JSON format,
     * and the object has the same properties as the oLanguage object in the
     * initialiser object (i.e. the above parameters). Please refer to one of
     * the example language files to see how this works in action.
     */
    "sUrl": "",
    /**
     * Text shown inside the table records when the is no information to be
     * displayed after filtering. `emptyTable` is shown when there is simply no
     * information in the table at all (regardless of filtering).
     */
    "sZeroRecords": "No matching records found"
  },
  /** The initial data order is reversed when `desc` ordering */
  orderDescReverse: true,
  /**
   * This parameter allows you to have define the global filtering state at
   * initialisation time. As an object the `search` parameter must be
   * defined, but all other parameters are optional. When `regex` is true,
   * the search string will be treated as a regular expression, when false
   * (default) it will be treated as a straight string. When `smart`
   * DataTables will use it's smart filtering methods (to word match at
   * any point in the data), when false this will not be done.
   */
  "oSearch": $$6.extend({}, DataTable.models.oSearch),
  /**
   * Table and control layout. This replaces the legacy `dom` option.
   */
  layout: {
    topStart: "pageLength",
    topEnd: "search",
    bottomStart: "info",
    bottomEnd: "paging"
  },
  /**
   * Legacy DOM layout option
   */
  "sDom": null,
  /**
   * Search delay option. This will throttle full table searches that use the
   * DataTables provided search input element (it does not effect calls to
   * `dt-api search()`, providing a delay before the search is made.
   */
  "searchDelay": null,
  /**
   * DataTables features six different built-in options for the buttons to
   * display for pagination control:
   *
   * * `numbers` - Page number buttons only
   * * `simple` - 'Previous' and 'Next' buttons only
   * * 'simple_numbers` - 'Previous' and 'Next' buttons, plus page numbers
   * * `full` - 'First', 'Previous', 'Next' and 'Last' buttons
   * * `full_numbers` - 'First', 'Previous', 'Next' and 'Last' buttons, plus page numbers
   * * `first_last_numbers` - 'First' and 'Last' buttons, plus page numbers
   */
  "sPaginationType": "",
  /**
   * Enable horizontal scrolling. When a table is too wide to fit into a
   * certain layout, or you have a large number of columns in the table, you
   * can enable x-scrolling to show the table in a viewport, which can be
   * scrolled. This property can be `true` which will allow the table to
   * scroll horizontally when needed, or any CSS unit, or a number (in which
   * case it will be treated as a pixel measurement). Setting as simply `true`
   * is recommended.
   */
  "sScrollX": "",
  /**
   * This property can be used to force a DataTable to use more width than it
   * might otherwise do when x-scrolling is enabled. For example if you have a
   * table which requires to be well spaced, this parameter is useful for
   * "over-sizing" the table, and thus forcing scrolling. This property can by
   * any CSS unit, or a number (in which case it will be treated as a pixel
   * measurement).
   */
  "sScrollXInner": "",
  /**
   * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
   * to the given height, and enable scrolling for any data which overflows the
   * current viewport. This can be used as an alternative to paging to display
   * a lot of data in a small area (although paging and scrolling can both be
   * enabled at the same time). This property can be any CSS unit, or a number
   * (in which case it will be treated as a pixel measurement).
   */
  "sScrollY": "",
  /**
   * __Deprecated__ The functionality provided by this parameter has now been
   * superseded by that provided through `ajax`, which should be used instead.
   *
   * Set the HTTP method that is used to make the Ajax call for server-side
   * processing or Ajax sourced data.
   */
  "sServerMethod": "GET",
  /**
   * DataTables makes use of renderers when displaying HTML elements for
   * a table. These renderers can be added or modified by plug-ins to
   * generate suitable mark-up for a site. For example the Bootstrap
   * integration plug-in for DataTables uses a paging button renderer to
   * display pagination buttons in the mark-up required by Bootstrap.
   *
   * For further information about the renderers available see
   * DataTable.ext.renderer
   */
  "renderer": null,
  /**
   * Set the data property name that DataTables should use to get a row's id
   * to set as the `id` property in the node.
   */
  "rowId": "DT_RowId",
  /**
   * Caption value
   */
  "caption": null,
  /**
   * For server-side processing - use the data from the DOM for the first draw
   */
  iDeferLoading: null
};
_fnHungarianMap(DataTable.defaults);
DataTable.defaults.column = {
  /**
   * Define which column(s) an order will occur on for this column. This
   * allows a column's ordering to take multiple columns into account when
   * doing a sort or use the data from a different column. For example first
   * name / last name columns make sense to do a multi-column sort over the
   * two columns.
   */
  "aDataSort": null,
  "iDataSort": -1,
  ariaTitle: "",
  /**
   * You can control the default ordering direction, and even alter the
   * behaviour of the sort handler (i.e. only allow ascending ordering etc)
   * using this parameter.
   */
  "asSorting": ["asc", "desc", ""],
  /**
   * Enable or disable filtering on the data in this column.
   */
  "bSearchable": true,
  /**
   * Enable or disable ordering on this column.
   */
  "bSortable": true,
  /**
   * Enable or disable the display of this column.
   */
  "bVisible": true,
  /**
   * Developer definable function that is called whenever a cell is created (Ajax source,
   * etc) or processed for input (DOM source). This can be used as a compliment to mRender
   * allowing you to modify the DOM element (add background colour for example) when the
   * element is available.
   */
  "fnCreatedCell": null,
  /**
   * This property can be used to read data from any data source property,
   * including deeply nested objects / properties. `data` can be given in a
   * number of different ways which effect its behaviour:
   *
   * * `integer` - treated as an array index for the data source. This is the
   *   default that DataTables uses (incrementally increased for each column).
   * * `string` - read an object property from the data source. There are
   *   three 'special' options that can be used in the string to alter how
   *   DataTables reads the data from the source object:
   *    * `.` - Dotted Javascript notation. Just as you use a `.` in
   *      Javascript to read from nested objects, so to can the options
   *      specified in `data`. For example: `browser.version` or
   *      `browser.name`. If your object parameter name contains a period, use
   *      `\\` to escape it - i.e. `first\\.name`.
   *    * `[]` - Array notation. DataTables can automatically combine data
   *      from and array source, joining the data with the characters provided
   *      between the two brackets. For example: `name[, ]` would provide a
   *      comma-space separated list from the source array. If no characters
   *      are provided between the brackets, the original array source is
   *      returned.
   *    * `()` - Function notation. Adding `()` to the end of a parameter will
   *      execute a function of the name given. For example: `browser()` for a
   *      simple function on the data source, `browser.version()` for a
   *      function in a nested property or even `browser().version` to get an
   *      object property if the function called returns an object. Note that
   *      function notation is recommended for use in `render` rather than
   *      `data` as it is much simpler to use as a renderer.
   * * `null` - use the original data source for the row rather than plucking
   *   data directly from it. This action has effects on two other
   *   initialisation options:
   *    * `defaultContent` - When null is given as the `data` option and
   *      `defaultContent` is specified for the column, the value defined by
   *      `defaultContent` will be used for the cell.
   *    * `render` - When null is used for the `data` option and the `render`
   *      option is specified for the column, the whole data source for the
   *      row is used for the renderer.
   * * `function` - the function given will be executed whenever DataTables
   *   needs to set or get the data for a cell in the column. The function
   *   takes three parameters:
   *    * Parameters:
   *      * `{array|object}` The data source for the row
   *      * `{string}` The type call data requested - this will be 'set' when
   *        setting data or 'filter', 'display', 'type', 'sort' or undefined
   *        when gathering data. Note that when `undefined` is given for the
   *        type DataTables expects to get the raw data for the object back<
   *      * `{*}` Data to set when the second parameter is 'set'.
   *    * Return:
   *      * The return value from the function is not required when 'set' is
   *        the type of call, but otherwise the return is what will be used
   *        for the data requested.
   *
   * Note that `data` is a getter and setter option. If you just require
   * formatting of data for output, you will likely want to use `render` which
   * is simply a getter and thus simpler to use.
   *
   * Note that prior to DataTables 1.9.2 `data` was called `mDataProp`. The
   * name change reflects the flexibility of this property and is consistent
   * with the naming of mRender. If 'mDataProp' is given, then it will still
   * be used by DataTables, as it automatically maps the old name to the new
   * if required.
   */
  "mData": null,
  /**
   * This property is the rendering partner to `data` and it is suggested that
   * when you want to manipulate data for display (including filtering,
   * sorting etc) without altering the underlying data for the table, use this
   * property. `render` can be considered to be the the read only companion to
   * `data` which is read / write (then as such more complex). Like `data`
   * this option can be given in a number of different ways to effect its
   * behaviour:
   *
   * * `integer` - treated as an array index for the data source. This is the
   *   default that DataTables uses (incrementally increased for each column).
   * * `string` - read an object property from the data source. There are
   *   three 'special' options that can be used in the string to alter how
   *   DataTables reads the data from the source object:
   *    * `.` - Dotted Javascript notation. Just as you use a `.` in
   *      Javascript to read from nested objects, so to can the options
   *      specified in `data`. For example: `browser.version` or
   *      `browser.name`. If your object parameter name contains a period, use
   *      `\\` to escape it - i.e. `first\\.name`.
   *    * `[]` - Array notation. DataTables can automatically combine data
   *      from and array source, joining the data with the characters provided
   *      between the two brackets. For example: `name[, ]` would provide a
   *      comma-space separated list from the source array. If no characters
   *      are provided between the brackets, the original array source is
   *      returned.
   *    * `()` - Function notation. Adding `()` to the end of a parameter will
   *      execute a function of the name given. For example: `browser()` for a
   *      simple function on the data source, `browser.version()` for a
   *      function in a nested property or even `browser().version` to get an
   *      object property if the function called returns an object.
   * * `object` - use different data for the different data types requested by
   *   DataTables ('filter', 'display', 'type' or 'sort'). The property names
   *   of the object is the data type the property refers to and the value can
   *   defined using an integer, string or function using the same rules as
   *   `render` normally does. Note that an `_` option _must_ be specified.
   *   This is the default value to use if you haven't specified a value for
   *   the data type requested by DataTables.
   * * `function` - the function given will be executed whenever DataTables
   *   needs to set or get the data for a cell in the column. The function
   *   takes three parameters:
   *    * Parameters:
   *      * {array|object} The data source for the row (based on `data`)
   *      * {string} The type call data requested - this will be 'filter',
   *        'display', 'type' or 'sort'.
   *      * {array|object} The full data source for the row (not based on
   *        `data`)
   *    * Return:
   *      * The return value from the function is what will be used for the
   *        data requested.
   */
  "mRender": null,
  /**
   * Change the cell type created for the column - either TD cells or TH cells. This
   * can be useful as TH cells have semantic meaning in the table body, allowing them
   * to act as a header for a row (you may wish to add scope='row' to the TH elements).
   */
  "sCellType": "td",
  /**
   * Class to give to each cell in this column.
   */
  "sClass": "",
  /**
   * When DataTables calculates the column widths to assign to each column,
   * it finds the longest string in each column and then constructs a
   * temporary table and reads the widths from that. The problem with this
   * is that "mmm" is much wider then "iiii", but the latter is a longer
   * string - thus the calculation can go wrong (doing it properly and putting
   * it into an DOM object and measuring that is horribly(!) slow). Thus as
   * a "work around" we provide this option. It will append its value to the
   * text that is found to be the longest string for the column - i.e. padding.
   * Generally you shouldn't need this!
   */
  "sContentPadding": "",
  /**
   * Allows a default value to be given for a column's data, and will be used
   * whenever a null data source is encountered (this can be because `data`
   * is set to null, or because the data source itself is null).
   */
  "sDefaultContent": null,
  /**
   * This parameter is only used in DataTables' server-side processing. It can
   * be exceptionally useful to know what columns are being displayed on the
   * client side, and to map these to database fields. When defined, the names
   * also allow DataTables to reorder information from the server if it comes
   * back in an unexpected order (i.e. if you switch your columns around on the
   * client-side, your server-side code does not also need updating).
   */
  "sName": "",
  /**
   * Defines a data source type for the ordering which can be used to read
   * real-time information from the table (updating the internally cached
   * version) prior to ordering. This allows ordering to occur on user
   * editable elements such as form inputs.
   */
  "sSortDataType": "std",
  /**
   * The title of this column.
   */
  "sTitle": null,
  /**
   * The type allows you to specify how the data for this column will be
   * ordered. Four types (string, numeric, date and html (which will strip
   * HTML tags before ordering)) are currently available. Note that only date
   * formats understood by Javascript's Date() object will be accepted as type
   * date. For example: "Mar 26, 2008 5:03 PM". May take the values: 'string',
   * 'numeric', 'date' or 'html' (by default). Further types can be adding
   * through plug-ins.
   */
  "sType": null,
  /**
   * Defining the width of the column, this parameter may take any CSS value
   * (3em, 20px etc). DataTables applies 'smart' widths to columns which have not
   * been given a specific width through this interface ensuring that the table
   * remains readable.
   */
  "sWidth": null
};
_fnHungarianMap(DataTable.defaults.column);
DataTable.models.oSettings = {
  /**
   * Primary features of DataTables and their enablement state.
   */
  "oFeatures": {
    /**
     * Flag to say if DataTables should automatically try to calculate the
     * optimum table and columns widths (true) or not (false).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bAutoWidth": null,
    /**
     * Delay the creation of TR and TD elements until they are actually
     * needed by a driven page draw. This can give a significant speed
     * increase for Ajax source and Javascript source data, but makes no
     * difference at all for DOM and server-side processing tables.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bDeferRender": null,
    /**
     * Enable filtering on the table or not. Note that if this is disabled
     * then there is no filtering at all on the table, including fnFilter.
     * To just remove the filtering input use sDom and remove the 'f' option.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bFilter": null,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bInfo": true,
    /**
     * Used only for compatiblity with DT1
     * @deprecated
     */
    "bLengthChange": true,
    /**
     * Pagination enabled or not. Note that if this is disabled then length
     * changing must also be disabled.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bPaginate": null,
    /**
     * Processing indicator enable flag whenever DataTables is enacting a
     * user request - typically an Ajax request for server-side processing.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bProcessing": null,
    /**
     * Server-side processing enabled flag - when enabled DataTables will
     * get all data from the server for every draw - there is no filtering,
     * sorting or paging done on the client-side.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bServerSide": null,
    /**
     * Sorting enablement flag.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSort": null,
    /**
     * Multi-column sorting
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortMulti": null,
    /**
     * Apply a class to the columns which are being sorted to provide a
     * visual highlight or not. This can slow things down when enabled since
     * there is a lot of DOM interaction.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bSortClasses": null,
    /**
     * State saving enablement flag.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bStateSave": null
  },
  /**
   * Scrolling settings for a table.
   */
  "oScroll": {
    /**
     * When the table is shorter in height than sScrollY, collapse the
     * table container down to the height of the table (when true).
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "bCollapse": null,
    /**
     * Width of the scrollbar for the web-browser's platform. Calculated
     * during table initialisation.
     */
    "iBarWidth": 0,
    /**
     * Viewport width for horizontal scrolling. Horizontal scrolling is
     * disabled if an empty string.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sX": null,
    /**
     * Width to expand the table to when using x-scrolling. Typically you
     * should not need to use this.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     *  @deprecated
     */
    "sXInner": null,
    /**
     * Viewport height for vertical scrolling. Vertical scrolling is disabled
     * if an empty string.
     * Note that this parameter will be set by the initialisation routine. To
     * set a default use {@link DataTable.defaults}.
     */
    "sY": null
  },
  /**
   * Language information for the table.
   */
  "oLanguage": {
    /**
     * Information callback function. See
     * {@link DataTable.defaults.fnInfoCallback}
     */
    "fnInfoCallback": null
  },
  /**
   * Browser support parameters
   */
  "oBrowser": {
    /**
     * Determine if the vertical scrollbar is on the right or left of the
     * scrolling container - needed for rtl language layout, although not
     * all browsers move the scrollbar (Safari).
     */
    "bScrollbarLeft": false,
    /**
     * Browser scrollbar width
     */
    "barWidth": 0
  },
  "ajax": null,
  /**
   * Array referencing the nodes which are used for the features. The
   * parameters of this object match what is allowed by sDom - i.e.
   *   <ul>
   *     <li>'l' - Length changing</li>
   *     <li>'f' - Filtering input</li>
   *     <li>'t' - The table!</li>
   *     <li>'i' - Information</li>
   *     <li>'p' - Pagination</li>
   *     <li>'r' - pRocessing</li>
   *   </ul>
   */
  "aanFeatures": [],
  /**
   * Store data information - see {@link DataTable.models.oRow} for detailed
   * information.
   */
  "aoData": [],
  /**
   * Array of indexes which are in the current display (after filtering etc)
   */
  "aiDisplay": [],
  /**
   * Array of indexes for display - no filtering
   */
  "aiDisplayMaster": [],
  /**
   * Map of row ids to data indexes
   */
  "aIds": {},
  /**
   * Store information about each column that is in use
   */
  "aoColumns": [],
  /**
   * Store information about the table's header
   */
  "aoHeader": [],
  /**
   * Store information about the table's footer
   */
  "aoFooter": [],
  /**
   * Store the applied global search information in case we want to force a
   * research or compare the old search to a new one.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "oPreviousSearch": {},
  /**
   * Store for named searches
   */
  searchFixed: {},
  /**
   * Store the applied search for each column - see
   * {@link DataTable.models.oSearch} for the format that is used for the
   * filtering information for each column.
   */
  "aoPreSearchCols": [],
  /**
   * Sorting that is applied to the table. Note that the inner arrays are
   * used in the following manner:
   * <ul>
   *   <li>Index 0 - column number</li>
   *   <li>Index 1 - current sorting direction</li>
   * </ul>
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "aaSorting": null,
  /**
   * Sorting that is always applied to the table (i.e. prefixed in front of
   * aaSorting).
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "aaSortingFixed": [],
  /**
   * If restoring a table - we should restore its width
   */
  "sDestroyWidth": 0,
  /**
   * Callback functions array for every time a row is inserted (i.e. on a draw).
   */
  "aoRowCallback": [],
  /**
   * Callback functions for the header on each draw.
   */
  "aoHeaderCallback": [],
  /**
   * Callback function for the footer on each draw.
   */
  "aoFooterCallback": [],
  /**
   * Array of callback functions for draw callback functions
   */
  "aoDrawCallback": [],
  /**
   * Array of callback functions for row created function
   */
  "aoRowCreatedCallback": [],
  /**
   * Callback functions for just before the table is redrawn. A return of
   * false will be used to cancel the draw.
   */
  "aoPreDrawCallback": [],
  /**
   * Callback functions for when the table has been initialised.
   */
  "aoInitComplete": [],
  /**
   * Callbacks for modifying the settings to be stored for state saving, prior to
   * saving state.
   */
  "aoStateSaveParams": [],
  /**
   * Callbacks for modifying the settings that have been stored for state saving
   * prior to using the stored values to restore the state.
   */
  "aoStateLoadParams": [],
  /**
   * Callbacks for operating on the settings object once the saved state has been
   * loaded
   */
  "aoStateLoaded": [],
  /**
   * Cache the table ID for quick access
   */
  "sTableId": "",
  /**
   * The TABLE node for the main table
   */
  "nTable": null,
  /**
   * Permanent ref to the thead element
   */
  "nTHead": null,
  /**
   * Permanent ref to the tfoot element - if it exists
   */
  "nTFoot": null,
  /**
   * Permanent ref to the tbody element
   */
  "nTBody": null,
  /**
   * Cache the wrapper node (contains all DataTables controlled elements)
   */
  "nTableWrapper": null,
  /**
   * Indicate if all required information has been read in
   */
  "bInitialised": false,
  /**
   * Information about open rows. Each object in the array has the parameters
   * 'nTr' and 'nParent'
   */
  "aoOpenRows": [],
  /**
   * Dictate the positioning of DataTables' control elements - see
   * {@link DataTable.model.oInit.sDom}.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "sDom": null,
  /**
   * Search delay (in mS)
   */
  "searchDelay": null,
  /**
   * Which type of pagination should be used.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "sPaginationType": "two_button",
  /**
   * Number of paging controls on the page. Only used for backwards compatibility
   */
  pagingControls: 0,
  /**
   * The state duration (for `stateSave`) in seconds.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "iStateDuration": 0,
  /**
   * Array of callback functions for state saving. Each array element is an
   * object with the following parameters:
   *   <ul>
   *     <li>function:fn - function to call. Takes two parameters, oSettings
   *       and the JSON string to save that has been thus far created. Returns
   *       a JSON string to be inserted into a json object
   *       (i.e. '"param": [ 0, 1, 2]')</li>
   *     <li>string:sName - name of callback</li>
   *   </ul>
   */
  "aoStateSave": [],
  /**
   * Array of callback functions for state loading. Each array element is an
   * object with the following parameters:
   *   <ul>
   *     <li>function:fn - function to call. Takes two parameters, oSettings
   *       and the object stored. May return false to cancel state loading</li>
   *     <li>string:sName - name of callback</li>
   *   </ul>
   */
  "aoStateLoad": [],
  /**
   * State that was saved. Useful for back reference
   */
  "oSavedState": null,
  /**
   * State that was loaded. Useful for back reference
   */
  "oLoadedState": null,
  /**
   * Note if draw should be blocked while getting data
   */
  "bAjaxDataGet": true,
  /**
   * The last jQuery XHR object that was used for server-side data gathering.
   * This can be used for working with the XHR information in one of the
   * callbacks
   */
  "jqXHR": null,
  /**
   * JSON returned from the server in the last Ajax request
   */
  "json": void 0,
  /**
   * Data submitted as part of the last Ajax request
   */
  "oAjaxData": void 0,
  /**
   * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if
   * required).
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "sServerMethod": null,
  /**
   * Format numbers for display.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "fnFormatNumber": null,
  /**
   * List of options that can be used for the user selectable length menu.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "aLengthMenu": null,
  /**
   * Counter for the draws that the table does. Also used as a tracker for
   * server-side processing
   */
  "iDraw": 0,
  /**
   * Indicate if a redraw is being done - useful for Ajax
   */
  "bDrawing": false,
  /**
   * Draw index (iDraw) of the last error when parsing the returned data
   */
  "iDrawError": -1,
  /**
   * Paging display length
   */
  "_iDisplayLength": 10,
  /**
   * Paging start point - aiDisplay index
   */
  "_iDisplayStart": 0,
  /**
   * Server-side processing - number of records in the result set
   * (i.e. before filtering), Use fnRecordsTotal rather than
   * this property to get the value of the number of records, regardless of
   * the server-side processing setting.
   */
  "_iRecordsTotal": 0,
  /**
   * Server-side processing - number of records in the current display set
   * (i.e. after filtering). Use fnRecordsDisplay rather than
   * this property to get the value of the number of records, regardless of
   * the server-side processing setting.
   */
  "_iRecordsDisplay": 0,
  /**
   * The classes to use for the table
   */
  "oClasses": {},
  /**
   * Flag attached to the settings object so you can check in the draw
   * callback if filtering has been done in the draw. Deprecated in favour of
   * events.
   *  @deprecated
   */
  "bFiltered": false,
  /**
   * Flag attached to the settings object so you can check in the draw
   * callback if sorting has been done in the draw. Deprecated in favour of
   * events.
   *  @deprecated
   */
  "bSorted": false,
  /**
   * Indicate that if multiple rows are in the header and there is more than
   * one unique cell per column, if the top one (true) or bottom one (false)
   * should be used for sorting / title by DataTables.
   * Note that this parameter will be set by the initialisation routine. To
   * set a default use {@link DataTable.defaults}.
   */
  "bSortCellsTop": null,
  /**
   * Initialisation object that is used for the table
   */
  "oInit": null,
  /**
   * Destroy callback functions - for plug-ins to attach themselves to the
   * destroy so they can clean up markup and events.
   */
  "aoDestroyCallback": [],
  /**
   * Get the number of records in the current record set, before filtering
   */
  "fnRecordsTotal": function() {
    return _fnDataSource(this) == "ssp" ? this._iRecordsTotal * 1 : this.aiDisplayMaster.length;
  },
  /**
   * Get the number of records in the current record set, after filtering
   */
  "fnRecordsDisplay": function() {
    return _fnDataSource(this) == "ssp" ? this._iRecordsDisplay * 1 : this.aiDisplay.length;
  },
  /**
   * Get the display end point - aiDisplay index
   */
  "fnDisplayEnd": function() {
    var len = this._iDisplayLength, start2 = this._iDisplayStart, calc = start2 + len, records = this.aiDisplay.length, features = this.oFeatures, paginate = features.bPaginate;
    if (features.bServerSide) {
      return paginate === false || len === -1 ? start2 + records : Math.min(start2 + len, this._iRecordsDisplay);
    } else {
      return !paginate || calc > records || len === -1 ? records : calc;
    }
  },
  /**
   * The DataTables object for this table
   */
  "oInstance": null,
  /**
   * Unique identifier for each instance of the DataTables object. If there
   * is an ID on the table node, then it takes that value, otherwise an
   * incrementing internal counter is used.
   */
  "sInstance": null,
  /**
   * tabindex attribute value that is added to DataTables control elements, allowing
   * keyboard navigation of the table and its controls.
   */
  "iTabIndex": 0,
  /**
   * DIV container for the footer scrolling table if scrolling
   */
  "nScrollHead": null,
  /**
   * DIV container for the footer scrolling table if scrolling
   */
  "nScrollFoot": null,
  /**
   * Last applied sort
   */
  "aLastSort": [],
  /**
   * Stored plug-in instances
   */
  "oPlugins": {},
  /**
   * Function used to get a row's id from the row's data
   */
  "rowIdFn": null,
  /**
   * Data location where to store a row's id
   */
  "rowId": null,
  caption: "",
  captionNode: null,
  colgroup: null,
  /** Delay loading of data */
  deferLoading: null,
  /** Allow auto type detection */
  typeDetect: true,
  /** ResizeObserver for the container div */
  resizeObserver: null,
  /** Keep a record of the last size of the container, so we can skip duplicates */
  containerWidth: -1
};
var extPagination = DataTable.ext.pager;
$$6.extend(extPagination, {
  simple: function() {
    return ["previous", "next"];
  },
  full: function() {
    return ["first", "previous", "next", "last"];
  },
  numbers: function() {
    return ["numbers"];
  },
  simple_numbers: function() {
    return ["previous", "numbers", "next"];
  },
  full_numbers: function() {
    return ["first", "previous", "numbers", "next", "last"];
  },
  first_last: function() {
    return ["first", "last"];
  },
  first_last_numbers: function() {
    return ["first", "numbers", "last"];
  },
  // For testing and plug-ins to use
  _numbers: _pagingNumbers,
  // Number of number buttons - legacy, use `numbers` option for paging feature
  numbers_length: 7
});
$$6.extend(true, DataTable.ext.renderer, {
  pagingButton: {
    _: function(settings, buttonType, content, active, disabled) {
      var classes = settings.oClasses.paging;
      var btnClasses = [classes.button];
      var btn;
      if (active) {
        btnClasses.push(classes.active);
      }
      if (disabled) {
        btnClasses.push(classes.disabled);
      }
      if (buttonType === "ellipsis") {
        btn = $$6('<span class="ellipsis"></span>').html(content)[0];
      } else {
        btn = $$6("<button>", {
          class: btnClasses.join(" "),
          role: "link",
          type: "button"
        }).html(content);
      }
      return {
        display: btn,
        clicker: btn
      };
    }
  },
  pagingContainer: {
    _: function(settings, buttons) {
      return buttons;
    }
  }
});
var _filterString = function(stripHtml, normalize2) {
  return function(str2) {
    if (_empty(str2) || typeof str2 !== "string") {
      return str2;
    }
    str2 = str2.replace(_re_new_lines, " ");
    if (stripHtml) {
      str2 = _stripHtml(str2);
    }
    if (normalize2) {
      str2 = _normalize(str2, false);
    }
    return str2;
  };
};
function __mld(dtLib, momentFn, luxonFn, dateFn, arg1) {
  if (__moment) {
    return dtLib[momentFn](arg1);
  } else if (__luxon) {
    return dtLib[luxonFn](arg1);
  }
  return dateFn ? dtLib[dateFn](arg1) : dtLib;
}
var __mlWarning = false;
var __luxon;
var __moment;
function resolveWindowLibs() {
  if (window.luxon && !__luxon) {
    __luxon = window.luxon;
  }
  if (window.moment && !__moment) {
    __moment = window.moment;
  }
}
function __mldObj(d2, format, locale) {
  var dt2;
  resolveWindowLibs();
  if (__moment) {
    dt2 = __moment.utc(d2, format, locale, true);
    if (!dt2.isValid()) {
      return null;
    }
  } else if (__luxon) {
    dt2 = format && typeof d2 === "string" ? __luxon.DateTime.fromFormat(d2, format) : __luxon.DateTime.fromISO(d2);
    if (!dt2.isValid) {
      return null;
    }
    dt2 = dt2.setLocale(locale);
  } else if (!format) {
    dt2 = new Date(d2);
  } else {
    if (!__mlWarning) {
      alert("DataTables warning: Formatted date without Moment.js or Luxon - https://datatables.net/tn/17");
    }
    __mlWarning = true;
  }
  return dt2;
}
function __mlHelper(localeString) {
  return function(from, to, locale, def) {
    if (arguments.length === 0) {
      locale = "en";
      to = null;
      from = null;
    } else if (arguments.length === 1) {
      locale = "en";
      to = from;
      from = null;
    } else if (arguments.length === 2) {
      locale = to;
      to = from;
      from = null;
    }
    var typeName = "datetime" + (to ? "-" + to : "");
    if (!DataTable.ext.type.order[typeName + "-pre"]) {
      DataTable.type(typeName, {
        detect: function(d2) {
          return d2 === typeName ? typeName : false;
        },
        order: {
          pre: function(d2) {
            return d2.valueOf();
          }
        },
        className: "dt-right"
      });
    }
    return function(d2, type) {
      if (d2 === null || d2 === void 0) {
        if (def === "--now") {
          var local = /* @__PURE__ */ new Date();
          d2 = new Date(Date.UTC(
            local.getFullYear(),
            local.getMonth(),
            local.getDate(),
            local.getHours(),
            local.getMinutes(),
            local.getSeconds()
          ));
        } else {
          d2 = "";
        }
      }
      if (type === "type") {
        return typeName;
      }
      if (d2 === "") {
        return type !== "sort" ? "" : __mldObj("0000-01-01 00:00:00", null, locale);
      }
      if (to !== null && from === to && type !== "sort" && type !== "type" && !(d2 instanceof Date)) {
        return d2;
      }
      var dt2 = __mldObj(d2, from, locale);
      if (dt2 === null) {
        return d2;
      }
      if (type === "sort") {
        return dt2;
      }
      var formatted = to === null ? __mld(dt2, "toDate", "toJSDate", "")[localeString]() : __mld(dt2, "format", "toFormat", "toISOString", to);
      return type === "display" ? _escapeHtml(formatted) : formatted;
    };
  };
}
var __thousands = ",";
var __decimal = ".";
if (window.Intl !== void 0) {
  try {
    var num = new Intl.NumberFormat().formatToParts(100000.1);
    for (var i = 0; i < num.length; i++) {
      if (num[i].type === "group") {
        __thousands = num[i].value;
      } else if (num[i].type === "decimal") {
        __decimal = num[i].value;
      }
    }
  } catch (e2) {
  }
}
DataTable.datetime = function(format, locale) {
  var typeName = "datetime-" + format;
  if (!locale) {
    locale = "en";
  }
  if (!DataTable.ext.type.order[typeName]) {
    DataTable.type(typeName, {
      detect: function(d2) {
        var dt2 = __mldObj(d2, format, locale);
        return d2 === "" || dt2 ? typeName : false;
      },
      order: {
        pre: function(d2) {
          return __mldObj(d2, format, locale) || 0;
        }
      },
      className: "dt-right"
    });
  }
};
DataTable.render = {
  date: __mlHelper("toLocaleDateString"),
  datetime: __mlHelper("toLocaleString"),
  time: __mlHelper("toLocaleTimeString"),
  number: function(thousands, decimal, precision, prefix, postfix) {
    if (thousands === null || thousands === void 0) {
      thousands = __thousands;
    }
    if (decimal === null || decimal === void 0) {
      decimal = __decimal;
    }
    return {
      display: function(d2) {
        if (typeof d2 !== "number" && typeof d2 !== "string") {
          return d2;
        }
        if (d2 === "" || d2 === null) {
          return d2;
        }
        var negative = d2 < 0 ? "-" : "";
        var flo = parseFloat(d2);
        var abs = Math.abs(flo);
        if (abs >= 1e11 || abs < 1e-4 && abs !== 0) {
          var exp = flo.toExponential(precision).split(/e\+?/);
          return exp[0] + " x 10<sup>" + exp[1] + "</sup>";
        }
        if (isNaN(flo)) {
          return _escapeHtml(d2);
        }
        flo = flo.toFixed(precision);
        d2 = Math.abs(flo);
        var intPart = parseInt(d2, 10);
        var floatPart = precision ? decimal + (d2 - intPart).toFixed(precision).substring(2) : "";
        if (intPart === 0 && parseFloat(floatPart) === 0) {
          negative = "";
        }
        return negative + (prefix || "") + intPart.toString().replace(
          /\B(?=(\d{3})+(?!\d))/g,
          thousands
        ) + floatPart + (postfix || "");
      }
    };
  },
  text: function() {
    return {
      display: _escapeHtml,
      filter: _escapeHtml
    };
  }
};
var _extTypes = DataTable.ext.type;
DataTable.type = function(name2, prop, val) {
  if (!prop) {
    return {
      className: _extTypes.className[name2],
      detect: _extTypes.detect.find(function(fn3) {
        return fn3._name === name2;
      }),
      order: {
        pre: _extTypes.order[name2 + "-pre"],
        asc: _extTypes.order[name2 + "-asc"],
        desc: _extTypes.order[name2 + "-desc"]
      },
      render: _extTypes.render[name2],
      search: _extTypes.search[name2]
    };
  }
  var setProp = function(prop2, propVal) {
    _extTypes[prop2][name2] = propVal;
  };
  var setDetect = function(detect) {
    Object.defineProperty(detect, "_name", { value: name2 });
    var idx = _extTypes.detect.findIndex(function(item2) {
      return item2._name === name2;
    });
    if (idx === -1) {
      _extTypes.detect.unshift(detect);
    } else {
      _extTypes.detect.splice(idx, 1, detect);
    }
  };
  var setOrder = function(obj) {
    _extTypes.order[name2 + "-pre"] = obj.pre;
    _extTypes.order[name2 + "-asc"] = obj.asc;
    _extTypes.order[name2 + "-desc"] = obj.desc;
  };
  if (val === void 0) {
    val = prop;
    prop = null;
  }
  if (prop === "className") {
    setProp("className", val);
  } else if (prop === "detect") {
    setDetect(val);
  } else if (prop === "order") {
    setOrder(val);
  } else if (prop === "render") {
    setProp("render", val);
  } else if (prop === "search") {
    setProp("search", val);
  } else if (!prop) {
    if (val.className) {
      setProp("className", val.className);
    }
    if (val.detect !== void 0) {
      setDetect(val.detect);
    }
    if (val.order) {
      setOrder(val.order);
    }
    if (val.render !== void 0) {
      setProp("render", val.render);
    }
    if (val.search !== void 0) {
      setProp("search", val.search);
    }
  }
};
DataTable.types = function() {
  return _extTypes.detect.map(function(fn3) {
    return fn3._name;
  });
};
var __diacriticSort = function(a2, b2) {
  a2 = a2 !== null && a2 !== void 0 ? a2.toString().toLowerCase() : "";
  b2 = b2 !== null && b2 !== void 0 ? b2.toString().toLowerCase() : "";
  return a2.localeCompare(b2, navigator.languages[0] || navigator.language, {
    numeric: true,
    ignorePunctuation: true
  });
};
var __diacriticHtmlSort = function(a2, b2) {
  a2 = _stripHtml(a2);
  b2 = _stripHtml(b2);
  return __diacriticSort(a2, b2);
};
DataTable.type("string", {
  detect: function() {
    return "string";
  },
  order: {
    pre: function(a2) {
      return _empty(a2) && typeof a2 !== "boolean" ? "" : typeof a2 === "string" ? a2.toLowerCase() : !a2.toString ? "" : a2.toString();
    }
  },
  search: _filterString(false, true)
});
DataTable.type("string-utf8", {
  detect: {
    allOf: function(d2) {
      return true;
    },
    oneOf: function(d2) {
      return !_empty(d2) && navigator.languages && typeof d2 === "string" && d2.match(/[^\x00-\x7F]/);
    }
  },
  order: {
    asc: __diacriticSort,
    desc: function(a2, b2) {
      return __diacriticSort(a2, b2) * -1;
    }
  },
  search: _filterString(false, true)
});
DataTable.type("html", {
  detect: {
    allOf: function(d2) {
      return _empty(d2) || typeof d2 === "string" && d2.indexOf("<") !== -1;
    },
    oneOf: function(d2) {
      return !_empty(d2) && typeof d2 === "string" && d2.indexOf("<") !== -1;
    }
  },
  order: {
    pre: function(a2) {
      return _empty(a2) ? "" : a2.replace ? _stripHtml(a2).trim().toLowerCase() : a2 + "";
    }
  },
  search: _filterString(true, true)
});
DataTable.type("html-utf8", {
  detect: {
    allOf: function(d2) {
      return _empty(d2) || typeof d2 === "string" && d2.indexOf("<") !== -1;
    },
    oneOf: function(d2) {
      return navigator.languages && !_empty(d2) && typeof d2 === "string" && d2.indexOf("<") !== -1 && typeof d2 === "string" && d2.match(/[^\x00-\x7F]/);
    }
  },
  order: {
    asc: __diacriticHtmlSort,
    desc: function(a2, b2) {
      return __diacriticHtmlSort(a2, b2) * -1;
    }
  },
  search: _filterString(true, true)
});
DataTable.type("date", {
  className: "dt-type-date",
  detect: {
    allOf: function(d2) {
      if (d2 && !(d2 instanceof Date) && !_re_date.test(d2)) {
        return null;
      }
      var parsed = Date.parse(d2);
      return parsed !== null && !isNaN(parsed) || _empty(d2);
    },
    oneOf: function(d2) {
      return d2 instanceof Date || typeof d2 === "string" && _re_date.test(d2);
    }
  },
  order: {
    pre: function(d2) {
      var ts2 = Date.parse(d2);
      return isNaN(ts2) ? -Infinity : ts2;
    }
  }
});
DataTable.type("html-num-fmt", {
  className: "dt-type-numeric",
  detect: {
    allOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal, true, false);
    },
    oneOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal, true, false);
    }
  },
  order: {
    pre: function(d2, s2) {
      var dp = s2.oLanguage.sDecimal;
      return __numericReplace(d2, dp, _re_html, _re_formatted_numeric);
    }
  },
  search: _filterString(true, true)
});
DataTable.type("html-num", {
  className: "dt-type-numeric",
  detect: {
    allOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal, false, true);
    },
    oneOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _htmlNumeric(d2, decimal, false, false);
    }
  },
  order: {
    pre: function(d2, s2) {
      var dp = s2.oLanguage.sDecimal;
      return __numericReplace(d2, dp, _re_html);
    }
  },
  search: _filterString(true, true)
});
DataTable.type("num-fmt", {
  className: "dt-type-numeric",
  detect: {
    allOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal, true, true);
    },
    oneOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal, true, false);
    }
  },
  order: {
    pre: function(d2, s2) {
      var dp = s2.oLanguage.sDecimal;
      return __numericReplace(d2, dp, _re_formatted_numeric);
    }
  }
});
DataTable.type("num", {
  className: "dt-type-numeric",
  detect: {
    allOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal, false, true);
    },
    oneOf: function(d2, settings) {
      var decimal = settings.oLanguage.sDecimal;
      return _isNumber(d2, decimal, false, false);
    }
  },
  order: {
    pre: function(d2, s2) {
      var dp = s2.oLanguage.sDecimal;
      return __numericReplace(d2, dp);
    }
  }
});
var __numericReplace = function(d2, decimalPlace, re1, re2) {
  if (d2 !== 0 && (!d2 || d2 === "-")) {
    return -Infinity;
  }
  var type = typeof d2;
  if (type === "number" || type === "bigint") {
    return d2;
  }
  if (decimalPlace) {
    d2 = _numToDecimal(d2, decimalPlace);
  }
  if (d2.replace) {
    if (re1) {
      d2 = d2.replace(re1, "");
    }
    if (re2) {
      d2 = d2.replace(re2, "");
    }
  }
  return d2 * 1;
};
$$6.extend(true, DataTable.ext.renderer, {
  footer: {
    _: function(settings, cell, classes) {
      cell.addClass(classes.tfoot.cell);
    }
  },
  header: {
    _: function(settings, cell, classes) {
      cell.addClass(classes.thead.cell);
      if (!settings.oFeatures.bSort) {
        cell.addClass(classes.order.none);
      }
      var legacyTop = settings.bSortCellsTop;
      var headerRows = cell.closest("thead").find("tr");
      var rowIdx = cell.parent().index();
      if (
        // Cells and rows which have the attribute to disable the icons
        cell.attr("data-dt-order") === "disable" || cell.parent().attr("data-dt-order") === "disable" || // Legacy support for `orderCellsTop`. If it is set, then cells
        // which are not in the top or bottom row of the header (depending
        // on the value) do not get the sorting classes applied to them
        legacyTop === true && rowIdx !== 0 || legacyTop === false && rowIdx !== headerRows.length - 1
      ) {
        return;
      }
      $$6(settings.nTable).on("order.dt.DT column-visibility.dt.DT", function(e2, ctx) {
        if (settings !== ctx) {
          return;
        }
        var sorting = ctx.sortDetails;
        if (!sorting) {
          return;
        }
        var i;
        var orderClasses = classes.order;
        var columns = ctx.api.columns(cell);
        var col = settings.aoColumns[columns.flatten()[0]];
        var orderable = columns.orderable().includes(true);
        var ariaType = "";
        var indexes = columns.indexes();
        var sortDirs = columns.orderable(true).flatten();
        var orderedColumns = _pluck(sorting, "col");
        var tabIndex = settings.iTabIndex;
        cell.removeClass(
          orderClasses.isAsc + " " + orderClasses.isDesc
        ).toggleClass(orderClasses.none, !orderable).toggleClass(orderClasses.canAsc, orderable && sortDirs.includes("asc")).toggleClass(orderClasses.canDesc, orderable && sortDirs.includes("desc"));
        var isOrdering = true;
        for (i = 0; i < indexes.length; i++) {
          if (!orderedColumns.includes(indexes[i])) {
            isOrdering = false;
          }
        }
        if (isOrdering) {
          var orderDirs = columns.order();
          cell.addClass(
            orderDirs.includes("asc") ? orderClasses.isAsc : "" + orderDirs.includes("desc") ? orderClasses.isDesc : ""
          );
        }
        var firstVis = -1;
        for (i = 0; i < orderedColumns.length; i++) {
          if (settings.aoColumns[orderedColumns[i]].bVisible) {
            firstVis = orderedColumns[i];
            break;
          }
        }
        if (indexes[0] == firstVis) {
          var firstSort = sorting[0];
          var sortOrder = col.asSorting;
          cell.attr("aria-sort", firstSort.dir === "asc" ? "ascending" : "descending");
          ariaType = !sortOrder[firstSort.index + 1] ? "Remove" : "Reverse";
        } else {
          cell.removeAttr("aria-sort");
        }
        if (orderable) {
          var orderSpan = cell.find(".dt-column-order");
          orderSpan.attr("role", "button").attr(
            "aria-label",
            orderable ? col.ariaTitle + ctx.api.i18n("oAria.orderable" + ariaType) : col.ariaTitle
          );
          if (tabIndex !== -1) {
            orderSpan.attr("tabindex", tabIndex);
          }
        }
      });
    }
  },
  layout: {
    _: function(settings, container, items) {
      var classes = settings.oClasses.layout;
      var row = $$6("<div/>").attr("id", items.id || null).addClass(items.className || classes.row).appendTo(container);
      DataTable.ext.renderer.layout._forLayoutRow(items, function(key, val) {
        if (key === "id" || key === "className") {
          return;
        }
        var klass = "";
        if (val.table) {
          row.addClass(classes.tableRow);
          klass += classes.tableCell + " ";
        }
        if (key === "start") {
          klass += classes.start;
        } else if (key === "end") {
          klass += classes.end;
        } else {
          klass += classes.full;
        }
        $$6("<div/>").attr({
          id: val.id || null,
          "class": val.className ? val.className : classes.cell + " " + klass
        }).append(val.contents).appendTo(row);
      });
    },
    // Shared for use by the styling frameworks
    _forLayoutRow: function(items, fn3) {
      var layoutEnum = function(x2) {
        switch (x2) {
          case "":
            return 0;
          case "start":
            return 1;
          case "end":
            return 2;
          default:
            return 3;
        }
      };
      Object.keys(items).sort(function(a2, b2) {
        return layoutEnum(a2) - layoutEnum(b2);
      }).forEach(function(key) {
        fn3(key, items[key]);
      });
    }
  }
});
DataTable.feature = {};
DataTable.feature.register = function(name2, cb, legacy) {
  DataTable.ext.features[name2] = cb;
  if (legacy) {
    _ext.feature.push({
      cFeature: legacy,
      fnInit: cb
    });
  }
};
function _divProp(el, prop, val) {
  if (val) {
    el[prop] = val;
  }
}
DataTable.feature.register("div", function(settings, opts) {
  var n2 = $$6("<div>")[0];
  if (opts) {
    _divProp(n2, "className", opts.className);
    _divProp(n2, "id", opts.id);
    _divProp(n2, "innerHTML", opts.html);
    _divProp(n2, "textContent", opts.text);
  }
  return n2;
});
DataTable.feature.register("info", function(settings, opts) {
  if (!settings.oFeatures.bInfo) {
    return null;
  }
  var lang = settings.oLanguage, tid = settings.sTableId, n2 = $$6("<div/>", {
    "class": settings.oClasses.info.container
  });
  opts = $$6.extend({
    callback: lang.fnInfoCallback,
    empty: lang.sInfoEmpty,
    postfix: lang.sInfoPostFix,
    search: lang.sInfoFiltered,
    text: lang.sInfo
  }, opts);
  settings.aoDrawCallback.push(function(s2) {
    _fnUpdateInfo(s2, opts, n2);
  });
  if (!settings._infoEl) {
    n2.attr({
      "aria-live": "polite",
      id: tid + "_info",
      role: "status"
    });
    $$6(settings.nTable).attr("aria-describedby", tid + "_info");
    settings._infoEl = n2;
  }
  return n2;
}, "i");
function _fnUpdateInfo(settings, opts, node) {
  var start2 = settings._iDisplayStart + 1, end2 = settings.fnDisplayEnd(), max2 = settings.fnRecordsTotal(), total = settings.fnRecordsDisplay(), out = total ? opts.text : opts.empty;
  if (total !== max2) {
    out += " " + opts.search;
  }
  out += opts.postfix;
  out = _fnMacros(settings, out);
  if (opts.callback) {
    out = opts.callback.call(
      settings.oInstance,
      settings,
      start2,
      end2,
      max2,
      total,
      out
    );
  }
  node.html(out);
  _fnCallbackFire(settings, null, "info", [settings, node[0], out]);
}
var __searchCounter = 0;
DataTable.feature.register("search", function(settings, opts) {
  if (!settings.oFeatures.bFilter) {
    return null;
  }
  var classes = settings.oClasses.search;
  var tableId = settings.sTableId;
  var language = settings.oLanguage;
  var previousSearch = settings.oPreviousSearch;
  var input = '<input type="search" class="' + classes.input + '"/>';
  opts = $$6.extend({
    placeholder: language.sSearchPlaceholder,
    processing: false,
    text: language.sSearch
  }, opts);
  if (opts.text.indexOf("_INPUT_") === -1) {
    opts.text += "_INPUT_";
  }
  opts.text = _fnMacros(settings, opts.text);
  var end2 = opts.text.match(/_INPUT_$/);
  var start2 = opts.text.match(/^_INPUT_/);
  var removed = opts.text.replace(/_INPUT_/, "");
  var str2 = "<label>" + opts.text + "</label>";
  if (start2) {
    str2 = "_INPUT_<label>" + removed + "</label>";
  } else if (end2) {
    str2 = "<label>" + removed + "</label>_INPUT_";
  }
  var filter2 = $$6("<div>").addClass(classes.container).append(str2.replace(/_INPUT_/, input));
  filter2.find("label").attr("for", "dt-search-" + __searchCounter);
  filter2.find("input").attr("id", "dt-search-" + __searchCounter);
  __searchCounter++;
  var searchFn = function(event) {
    var val = this.value;
    if (previousSearch.return && event.key !== "Enter") {
      return;
    }
    if (val != previousSearch.search) {
      _fnProcessingRun(settings, opts.processing, function() {
        previousSearch.search = val;
        _fnFilterComplete(settings, previousSearch);
        settings._iDisplayStart = 0;
        _fnDraw(settings);
      });
    }
  };
  var searchDelay = settings.searchDelay !== null ? settings.searchDelay : 0;
  var jqFilter = $$6("input", filter2).val(previousSearch.search).attr("placeholder", opts.placeholder).on(
    "keyup.DT search.DT input.DT paste.DT cut.DT",
    searchDelay ? DataTable.util.debounce(searchFn, searchDelay) : searchFn
  ).on("mouseup.DT", function(e2) {
    setTimeout(function() {
      searchFn.call(jqFilter[0], e2);
    }, 10);
  }).on("keypress.DT", function(e2) {
    if (e2.keyCode == 13) {
      return false;
    }
  }).attr("aria-controls", tableId);
  $$6(settings.nTable).on("search.dt.DT", function(ev, s2) {
    if (settings === s2 && jqFilter[0] !== document.activeElement) {
      jqFilter.val(
        typeof previousSearch.search !== "function" ? previousSearch.search : ""
      );
    }
  });
  return filter2;
}, "f");
DataTable.feature.register("paging", function(settings, opts) {
  if (!settings.oFeatures.bPaginate) {
    return null;
  }
  opts = $$6.extend({
    buttons: DataTable.ext.pager.numbers_length,
    type: settings.sPaginationType,
    boundaryNumbers: true,
    firstLast: true,
    previousNext: true,
    numbers: true
  }, opts);
  var host = $$6("<div/>").addClass(settings.oClasses.paging.container + (opts.type ? " paging_" + opts.type : "")).append(
    $$6("<nav>").attr("aria-label", "pagination").addClass(settings.oClasses.paging.nav)
  );
  var draw = function() {
    _pagingDraw(settings, host.children(), opts);
  };
  settings.aoDrawCallback.push(draw);
  $$6(settings.nTable).on("column-sizing.dt.DT", draw);
  return host;
}, "p");
function _pagingDynamic(opts) {
  var out = [];
  if (opts.numbers) {
    out.push("numbers");
  }
  if (opts.previousNext) {
    out.unshift("previous");
    out.push("next");
  }
  if (opts.firstLast) {
    out.unshift("first");
    out.push("last");
  }
  return out;
}
function _pagingDraw(settings, host, opts) {
  if (!settings._bInitComplete) {
    return;
  }
  var plugin2 = opts.type ? DataTable.ext.pager[opts.type] : _pagingDynamic, aria = settings.oLanguage.oAria.paginate || {}, start2 = settings._iDisplayStart, len = settings._iDisplayLength, visRecords = settings.fnRecordsDisplay(), all2 = len === -1, page = all2 ? 0 : Math.ceil(start2 / len), pages = all2 ? 1 : Math.ceil(visRecords / len), buttons = [], buttonEls = [], buttonsNested = plugin2(opts).map(function(val) {
    return val === "numbers" ? _pagingNumbers(page, pages, opts.buttons, opts.boundaryNumbers) : val;
  });
  buttons = buttons.concat.apply(buttons, buttonsNested);
  for (var i = 0; i < buttons.length; i++) {
    var button = buttons[i];
    var btnInfo = _pagingButtonInfo(settings, button, page, pages);
    var btn = _fnRenderer(settings, "pagingButton")(
      settings,
      button,
      btnInfo.display,
      btnInfo.active,
      btnInfo.disabled
    );
    var ariaLabel = typeof button === "string" ? aria[button] : aria.number ? aria.number + (button + 1) : null;
    $$6(btn.clicker).attr({
      "aria-controls": settings.sTableId,
      "aria-disabled": btnInfo.disabled ? "true" : null,
      "aria-current": btnInfo.active ? "page" : null,
      "aria-label": ariaLabel,
      "data-dt-idx": button,
      "tabIndex": btnInfo.disabled ? -1 : settings.iTabIndex && btn.clicker[0].nodeName.toLowerCase() !== "span" ? settings.iTabIndex : null
      // `0` doesn't need a tabIndex since it is the default
    });
    if (typeof button !== "number") {
      $$6(btn.clicker).addClass(button);
    }
    _fnBindAction(
      btn.clicker,
      { action: button },
      function(e2) {
        e2.preventDefault();
        _fnPageChange(settings, e2.data.action, true);
      }
    );
    buttonEls.push(btn.display);
  }
  var wrapped = _fnRenderer(settings, "pagingContainer")(
    settings,
    buttonEls
  );
  var activeEl = host.find(document.activeElement).data("dt-idx");
  host.empty().append(wrapped);
  if (activeEl !== void 0) {
    host.find("[data-dt-idx=" + activeEl + "]").trigger("focus");
  }
  if (buttonEls.length) {
    var outerHeight = $$6(buttonEls[0]).outerHeight();
    if (opts.buttons > 1 && // prevent infinite
    outerHeight > 0 && // will be 0 if hidden
    $$6(host).height() >= outerHeight * 2 - 10) {
      _pagingDraw(settings, host, $$6.extend({}, opts, { buttons: opts.buttons - 2 }));
    }
  }
}
function _pagingButtonInfo(settings, button, page, pages) {
  var lang = settings.oLanguage.oPaginate;
  var o2 = {
    display: "",
    active: false,
    disabled: false
  };
  switch (button) {
    case "ellipsis":
      o2.display = "&#x2026;";
      break;
    case "first":
      o2.display = lang.sFirst;
      if (page === 0) {
        o2.disabled = true;
      }
      break;
    case "previous":
      o2.display = lang.sPrevious;
      if (page === 0) {
        o2.disabled = true;
      }
      break;
    case "next":
      o2.display = lang.sNext;
      if (pages === 0 || page === pages - 1) {
        o2.disabled = true;
      }
      break;
    case "last":
      o2.display = lang.sLast;
      if (pages === 0 || page === pages - 1) {
        o2.disabled = true;
      }
      break;
    default:
      if (typeof button === "number") {
        o2.display = settings.fnFormatNumber(button + 1);
        if (page === button) {
          o2.active = true;
        }
      }
      break;
  }
  return o2;
}
function _pagingNumbers(page, pages, buttons, addFirstLast) {
  var numbers = [], half = Math.floor(buttons / 2), before = addFirstLast ? 2 : 1, after = addFirstLast ? 1 : 0;
  if (pages <= buttons) {
    numbers = _range(0, pages);
  } else if (buttons === 1) {
    numbers = [page];
  } else if (buttons === 3) {
    if (page <= 1) {
      numbers = [0, 1, "ellipsis"];
    } else if (page >= pages - 2) {
      numbers = _range(pages - 2, pages);
      numbers.unshift("ellipsis");
    } else {
      numbers = ["ellipsis", page, "ellipsis"];
    }
  } else if (page <= half) {
    numbers = _range(0, buttons - before);
    numbers.push("ellipsis");
    if (addFirstLast) {
      numbers.push(pages - 1);
    }
  } else if (page >= pages - 1 - half) {
    numbers = _range(pages - (buttons - before), pages);
    numbers.unshift("ellipsis");
    if (addFirstLast) {
      numbers.unshift(0);
    }
  } else {
    numbers = _range(page - half + before, page + half - after);
    numbers.push("ellipsis");
    numbers.unshift("ellipsis");
    if (addFirstLast) {
      numbers.push(pages - 1);
      numbers.unshift(0);
    }
  }
  return numbers;
}
var __lengthCounter = 0;
DataTable.feature.register("pageLength", function(settings, opts) {
  var features = settings.oFeatures;
  if (!features.bPaginate || !features.bLengthChange) {
    return null;
  }
  opts = $$6.extend({
    menu: settings.aLengthMenu,
    text: settings.oLanguage.sLengthMenu
  }, opts);
  var classes = settings.oClasses.length, tableId = settings.sTableId, menu = opts.menu, lengths = [], language = [], i;
  if (Array.isArray(menu[0])) {
    lengths = menu[0];
    language = menu[1];
  } else {
    for (i = 0; i < menu.length; i++) {
      if ($$6.isPlainObject(menu[i])) {
        lengths.push(menu[i].value);
        language.push(menu[i].label);
      } else {
        lengths.push(menu[i]);
        language.push(menu[i]);
      }
    }
  }
  var end2 = opts.text.match(/_MENU_$/);
  var start2 = opts.text.match(/^_MENU_/);
  var removed = opts.text.replace(/_MENU_/, "");
  var str2 = "<label>" + opts.text + "</label>";
  if (start2) {
    str2 = "_MENU_<label>" + removed + "</label>";
  } else if (end2) {
    str2 = "<label>" + removed + "</label>_MENU_";
  }
  var tmpId = "tmp-" + +/* @__PURE__ */ new Date();
  var div = $$6("<div/>").addClass(classes.container).append(
    str2.replace("_MENU_", '<span id="' + tmpId + '"></span>')
  );
  var textNodes = [];
  Array.prototype.slice.call(div.find("label")[0].childNodes).forEach(function(el) {
    if (el.nodeType === Node.TEXT_NODE) {
      textNodes.push({
        el,
        text: el.textContent
      });
    }
  });
  var updateEntries = function(len) {
    textNodes.forEach(function(node) {
      node.el.textContent = _fnMacros(settings, node.text, len);
    });
  };
  var select = $$6("<select/>", {
    "aria-controls": tableId,
    "class": classes.select
  });
  for (i = 0; i < lengths.length; i++) {
    select[0][i] = new Option(
      typeof language[i] === "number" ? settings.fnFormatNumber(language[i]) : language[i],
      lengths[i]
    );
  }
  div.find("label").attr("for", "dt-length-" + __lengthCounter);
  select.attr("id", "dt-length-" + __lengthCounter);
  __lengthCounter++;
  div.find("#" + tmpId).replaceWith(select);
  $$6("select", div).val(settings._iDisplayLength).on("change.DT", function() {
    _fnLengthChange(settings, $$6(this).val());
    _fnDraw(settings);
  });
  $$6(settings.nTable).on("length.dt.DT", function(e2, s2, len) {
    if (settings === s2) {
      $$6("select", div).val(len);
      updateEntries(len);
    }
  });
  updateEntries(settings._iDisplayLength);
  return div;
}, "l");
$$6.fn.dataTable = DataTable;
DataTable.$ = $$6;
$$6.fn.dataTableSettings = DataTable.settings;
$$6.fn.dataTableExt = DataTable.ext;
$$6.fn.DataTable = function(opts) {
  return $$6(this).dataTable(opts).api();
};
$$6.each(DataTable, function(prop, val) {
  $$6.fn.DataTable[prop] = val;
});
/*! DataTables Bootstrap 5 integration
 * © SpryMedia Ltd - datatables.net/license
 */
let $$5 = jQuery$1;
$$5.extend(true, DataTable.defaults, {
  renderer: "bootstrap"
});
$$5.extend(true, DataTable.ext.classes, {
  container: "dt-container dt-bootstrap5",
  search: {
    input: "form-control form-control-sm"
  },
  length: {
    select: "form-select form-select-sm"
  },
  processing: {
    container: "dt-processing card"
  },
  layout: {
    row: "row mt-2 justify-content-between",
    cell: "d-md-flex justify-content-between align-items-center",
    tableCell: "col-12",
    start: "dt-layout-start col-md-auto me-auto",
    end: "dt-layout-end col-md-auto ms-auto",
    full: "dt-layout-full col-md"
  }
});
DataTable.ext.renderer.pagingButton.bootstrap = function(settings, buttonType, content, active, disabled) {
  var btnClasses = ["dt-paging-button", "page-item"];
  if (active) {
    btnClasses.push("active");
  }
  if (disabled) {
    btnClasses.push("disabled");
  }
  var li2 = $$5("<li>").addClass(btnClasses.join(" "));
  var a2 = $$5("<button>", {
    "class": "page-link",
    role: "link",
    type: "button"
  }).html(content).appendTo(li2);
  return {
    display: li2,
    clicker: a2
  };
};
DataTable.ext.renderer.pagingContainer.bootstrap = function(settings, buttonEls) {
  return $$5("<ul/>").addClass("pagination").append(buttonEls);
};
/*! Buttons for DataTables 3.2.2
 * © SpryMedia Ltd - datatables.net/license
 */
let $$4 = jQuery$1;
var _instCounter = 0;
var _buttonCounter = 0;
var _dtButtons = DataTable.ext.buttons;
var _entityDecoder = null;
function _fadeIn(el, duration, fn3) {
  if ($$4.fn.animate) {
    el.stop().fadeIn(duration, fn3);
  } else {
    el.css("display", "block");
    if (fn3) {
      fn3.call(el);
    }
  }
}
function _fadeOut(el, duration, fn3) {
  if ($$4.fn.animate) {
    el.stop().fadeOut(duration, fn3);
  } else {
    el.css("display", "none");
    if (fn3) {
      fn3.call(el);
    }
  }
}
var Buttons$1 = function(dt2, config2) {
  if (!DataTable.versionCheck("2")) {
    throw "Warning: Buttons requires DataTables 2 or newer";
  }
  if (!(this instanceof Buttons$1)) {
    return function(settings) {
      return new Buttons$1(settings, dt2).container();
    };
  }
  if (typeof config2 === "undefined") {
    config2 = {};
  }
  if (config2 === true) {
    config2 = {};
  }
  if (Array.isArray(config2)) {
    config2 = { buttons: config2 };
  }
  this.c = $$4.extend(true, {}, Buttons$1.defaults, config2);
  if (config2.buttons) {
    this.c.buttons = config2.buttons;
  }
  this.s = {
    dt: new DataTable.Api(dt2),
    buttons: [],
    listenKeys: "",
    namespace: "dtb" + _instCounter++
  };
  this.dom = {
    container: $$4("<" + this.c.dom.container.tag + "/>").addClass(
      this.c.dom.container.className
    )
  };
  this._constructor();
};
$$4.extend(Buttons$1.prototype, {
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Public methods
   */
  /**
   * Get the action of a button
   * @param  {int|string} Button index
   * @return {function}
   */
  /**
  * Set the action of a button
  * @param  {node} node Button element
  * @param  {function} action Function to set
  * @return {Buttons} Self for chaining
  */
  action: function(node, action) {
    var button = this._nodeToButton(node);
    if (action === void 0) {
      return button.conf.action;
    }
    button.conf.action = action;
    return this;
  },
  /**
   * Add an active class to the button to make to look active or get current
   * active state.
   * @param  {node} node Button element
   * @param  {boolean} [flag] Enable / disable flag
   * @return {Buttons} Self for chaining or boolean for getter
   */
  active: function(node, flag) {
    var button = this._nodeToButton(node);
    var klass = this.c.dom.button.active;
    var jqNode = $$4(button.node);
    if (button.inCollection && this.c.dom.collection.button && this.c.dom.collection.button.active !== void 0) {
      klass = this.c.dom.collection.button.active;
    }
    if (flag === void 0) {
      return jqNode.hasClass(klass);
    }
    jqNode.toggleClass(klass, flag === void 0 ? true : flag);
    return this;
  },
  /**
   * Add a new button
   * @param {object} config Button configuration object, base string name or function
   * @param {int|string} [idx] Button index for where to insert the button
   * @param {boolean} [draw=true] Trigger a draw. Set a false when adding
   *   lots of buttons, until the last button.
   * @return {Buttons} Self for chaining
   */
  add: function(config2, idx, draw) {
    var buttons = this.s.buttons;
    if (typeof idx === "string") {
      var split = idx.split("-");
      var base = this.s;
      for (var i = 0, ien = split.length - 1; i < ien; i++) {
        base = base.buttons[split[i] * 1];
      }
      buttons = base.buttons;
      idx = split[split.length - 1] * 1;
    }
    this._expandButton(
      buttons,
      config2,
      config2 !== void 0 ? config2.split : void 0,
      (config2 === void 0 || config2.split === void 0 || config2.split.length === 0) && base !== void 0,
      false,
      idx
    );
    if (draw === void 0 || draw === true) {
      this._draw();
    }
    return this;
  },
  /**
   * Clear buttons from a collection and then insert new buttons
   */
  collectionRebuild: function(node, newButtons) {
    var button = this._nodeToButton(node);
    if (newButtons !== void 0) {
      var i;
      for (i = button.buttons.length - 1; i >= 0; i--) {
        this.remove(button.buttons[i].node);
      }
      if (button.conf.prefixButtons) {
        newButtons.unshift.apply(newButtons, button.conf.prefixButtons);
      }
      if (button.conf.postfixButtons) {
        newButtons.push.apply(newButtons, button.conf.postfixButtons);
      }
      for (i = 0; i < newButtons.length; i++) {
        var newBtn = newButtons[i];
        this._expandButton(
          button.buttons,
          newBtn,
          newBtn !== void 0 && newBtn.config !== void 0 && newBtn.config.split !== void 0,
          true,
          newBtn.parentConf !== void 0 && newBtn.parentConf.split !== void 0,
          null,
          newBtn.parentConf
        );
      }
    }
    this._draw(button.collection, button.buttons);
  },
  /**
   * Get the container node for the buttons
   * @return {jQuery} Buttons node
   */
  container: function() {
    return this.dom.container;
  },
  /**
   * Disable a button
   * @param  {node} node Button node
   * @return {Buttons} Self for chaining
   */
  disable: function(node) {
    var button = this._nodeToButton(node);
    if (button.isSplit) {
      $$4(button.node.childNodes[0]).addClass(this.c.dom.button.disabled).prop("disabled", true);
    } else {
      $$4(button.node).addClass(this.c.dom.button.disabled).prop("disabled", true);
    }
    button.disabled = true;
    this._checkSplitEnable();
    return this;
  },
  /**
   * Destroy the instance, cleaning up event handlers and removing DOM
   * elements
   * @return {Buttons} Self for chaining
   */
  destroy: function() {
    $$4("body").off("keyup." + this.s.namespace);
    var buttons = this.s.buttons.slice();
    var i, ien;
    for (i = 0, ien = buttons.length; i < ien; i++) {
      this.remove(buttons[i].node);
    }
    this.dom.container.remove();
    var buttonInsts = this.s.dt.settings()[0];
    for (i = 0, ien = buttonInsts.length; i < ien; i++) {
      if (buttonInsts.inst === this) {
        buttonInsts.splice(i, 1);
        break;
      }
    }
    return this;
  },
  /**
   * Enable / disable a button
   * @param  {node} node Button node
   * @param  {boolean} [flag=true] Enable / disable flag
   * @return {Buttons} Self for chaining
   */
  enable: function(node, flag) {
    if (flag === false) {
      return this.disable(node);
    }
    var button = this._nodeToButton(node);
    if (button.isSplit) {
      $$4(button.node.childNodes[0]).removeClass(this.c.dom.button.disabled).prop("disabled", false);
    } else {
      $$4(button.node).removeClass(this.c.dom.button.disabled).prop("disabled", false);
    }
    button.disabled = false;
    this._checkSplitEnable();
    return this;
  },
  /**
   * Get a button's index
   *
   * This is internally recursive
   * @param {element} node Button to get the index of
   * @return {string} Button index
   */
  index: function(node, nested, buttons) {
    if (!nested) {
      nested = "";
      buttons = this.s.buttons;
    }
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      var inner = buttons[i].buttons;
      if (buttons[i].node === node) {
        return nested + i;
      }
      if (inner && inner.length) {
        var match = this.index(node, i + "-", inner);
        if (match !== null) {
          return match;
        }
      }
    }
    return null;
  },
  /**
   * Get the instance name for the button set selector
   * @return {string} Instance name
   */
  name: function() {
    return this.c.name;
  },
  /**
   * Get a button's node of the buttons container if no button is given
   * @param  {node} [node] Button node
   * @return {jQuery} Button element, or container
   */
  node: function(node) {
    if (!node) {
      return this.dom.container;
    }
    var button = this._nodeToButton(node);
    return $$4(button.node);
  },
  /**
   * Set / get a processing class on the selected button
   * @param {element} node Triggering button node
   * @param  {boolean} flag true to add, false to remove, undefined to get
   * @return {boolean|Buttons} Getter value or this if a setter.
   */
  processing: function(node, flag) {
    var dt2 = this.s.dt;
    var button = this._nodeToButton(node);
    if (flag === void 0) {
      return $$4(button.node).hasClass("processing");
    }
    $$4(button.node).toggleClass("processing", flag);
    $$4(dt2.table().node()).triggerHandler("buttons-processing.dt", [
      flag,
      dt2.button(node),
      dt2,
      $$4(node),
      button.conf
    ]);
    return this;
  },
  /**
   * Remove a button.
   * @param  {node} node Button node
   * @return {Buttons} Self for chaining
   */
  remove: function(node) {
    var button = this._nodeToButton(node);
    var host = this._nodeToHost(node);
    var dt2 = this.s.dt;
    if (button.buttons.length) {
      for (var i = button.buttons.length - 1; i >= 0; i--) {
        this.remove(button.buttons[i].node);
      }
    }
    button.conf.destroying = true;
    if (button.conf.destroy) {
      button.conf.destroy.call(dt2.button(node), dt2, $$4(node), button.conf);
    }
    this._removeKey(button.conf);
    $$4(button.node).remove();
    var idx = $$4.inArray(button, host);
    host.splice(idx, 1);
    return this;
  },
  /**
   * Get the text for a button
   * @param  {int|string} node Button index
   * @return {string} Button text
   */
  /**
  * Set the text for a button
  * @param  {int|string|function} node Button index
  * @param  {string} label Text
  * @return {Buttons} Self for chaining
  */
  text: function(node, label) {
    var button = this._nodeToButton(node);
    var textNode = button.textNode;
    var dt2 = this.s.dt;
    var jqNode = $$4(button.node);
    var text2 = function(opt) {
      return typeof opt === "function" ? opt(dt2, jqNode, button.conf) : opt;
    };
    if (label === void 0) {
      return text2(button.conf.text);
    }
    button.conf.text = label;
    textNode.html(text2(label));
    return this;
  },
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Constructor
   */
  /**
   * Buttons constructor
   * @private
   */
  _constructor: function() {
    var that = this;
    var dt2 = this.s.dt;
    var dtSettings = dt2.settings()[0];
    var buttons = this.c.buttons;
    if (!dtSettings._buttons) {
      dtSettings._buttons = [];
    }
    dtSettings._buttons.push({
      inst: this,
      name: this.c.name
    });
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      this.add(buttons[i]);
    }
    dt2.on("destroy", function(e2, settings) {
      if (settings === dtSettings) {
        that.destroy();
      }
    });
    $$4("body").on("keyup." + this.s.namespace, function(e2) {
      if (!document.activeElement || document.activeElement === document.body) {
        var character = String.fromCharCode(e2.keyCode).toLowerCase();
        if (that.s.listenKeys.toLowerCase().indexOf(character) !== -1) {
          that._keypress(character, e2);
        }
      }
    });
  },
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Private methods
   */
  /**
   * Add a new button to the key press listener
   * @param {object} conf Resolved button configuration object
   * @private
   */
  _addKey: function(conf) {
    if (conf.key) {
      this.s.listenKeys += $$4.isPlainObject(conf.key) ? conf.key.key : conf.key;
    }
  },
  /**
   * Insert the buttons into the container. Call without parameters!
   * @param  {node} [container] Recursive only - Insert point
   * @param  {array} [buttons] Recursive only - Buttons array
   * @private
   */
  _draw: function(container, buttons) {
    if (!container) {
      container = this.dom.container;
      buttons = this.s.buttons;
    }
    container.children().detach();
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      container.append(buttons[i].inserter);
      container.append(" ");
      if (buttons[i].buttons && buttons[i].buttons.length) {
        this._draw(buttons[i].collection, buttons[i].buttons);
      }
    }
  },
  /**
   * Create buttons from an array of buttons
   * @param  {array} attachTo Buttons array to attach to
   * @param  {object} button Button definition
   * @param  {boolean} inCollection true if the button is in a collection
   * @private
   */
  _expandButton: function(attachTo, button, split, inCollection, inSplit, attachPoint, parentConf) {
    var dt2 = this.s.dt;
    var isSplit = false;
    var domCollection = this.c.dom.collection;
    var buttons = !Array.isArray(button) ? [button] : button;
    if (button === void 0) {
      buttons = !Array.isArray(split) ? [split] : split;
    }
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      var conf = this._resolveExtends(buttons[i]);
      if (!conf) {
        continue;
      }
      isSplit = conf.config && conf.config.split ? true : false;
      if (Array.isArray(conf)) {
        this._expandButton(
          attachTo,
          conf,
          built !== void 0 && built.conf !== void 0 ? built.conf.split : void 0,
          inCollection,
          parentConf !== void 0 && parentConf.split !== void 0,
          attachPoint,
          parentConf
        );
        continue;
      }
      var built = this._buildButton(
        conf,
        inCollection,
        conf.split !== void 0 || conf.config !== void 0 && conf.config.split !== void 0,
        inSplit
      );
      if (!built) {
        continue;
      }
      if (attachPoint !== void 0 && attachPoint !== null) {
        attachTo.splice(attachPoint, 0, built);
        attachPoint++;
      } else {
        attachTo.push(built);
      }
      if (built.conf.dropIcon && !built.conf.split) {
        $$4(built.node).addClass(this.c.dom.button.dropClass).append(this.c.dom.button.dropHtml);
      }
      if (built.conf.buttons) {
        built.collection = $$4(
          "<" + domCollection.container.content.tag + "/>"
        );
        built.conf._collection = built.collection;
        this._expandButton(
          built.buttons,
          built.conf.buttons,
          built.conf.split,
          !isSplit,
          isSplit,
          attachPoint,
          built.conf
        );
      }
      if (built.conf.split) {
        built.collection = $$4("<" + domCollection.container.tag + "/>");
        built.conf._collection = built.collection;
        for (var j2 = 0; j2 < built.conf.split.length; j2++) {
          var item2 = built.conf.split[j2];
          if (typeof item2 === "object") {
            item2.parent = parentConf;
            if (item2.collectionLayout === void 0) {
              item2.collectionLayout = built.conf.collectionLayout;
            }
            if (item2.dropup === void 0) {
              item2.dropup = built.conf.dropup;
            }
            if (item2.fade === void 0) {
              item2.fade = built.conf.fade;
            }
          }
        }
        this._expandButton(
          built.buttons,
          built.conf.buttons,
          built.conf.split,
          !isSplit,
          isSplit,
          attachPoint,
          built.conf
        );
      }
      built.conf.parent = parentConf;
      if (conf.init) {
        conf.init.call(dt2.button(built.node), dt2, $$4(built.node), conf);
      }
    }
  },
  /**
   * Create an individual button
   * @param  {object} config            Resolved button configuration
   * @param  {boolean} inCollection `true` if a collection button
   * @return {object} Completed button description object
   * @private
   */
  _buildButton: function(config2, inCollection, isSplit, inSplit) {
    var that = this;
    var configDom = this.c.dom;
    var textNode;
    var dt2 = this.s.dt;
    var text2 = function(opt) {
      return typeof opt === "function" ? opt(dt2, button, config2) : opt;
    };
    var dom = $$4.extend(true, {}, configDom.button);
    if (inCollection && isSplit && configDom.collection.split) {
      $$4.extend(true, dom, configDom.collection.split.action);
    } else if (inSplit || inCollection) {
      $$4.extend(true, dom, configDom.collection.button);
    } else if (isSplit) {
      $$4.extend(true, dom, configDom.split.button);
    }
    if (config2.spacer) {
      var spacer = $$4("<" + dom.spacer.tag + "/>").addClass(
        "dt-button-spacer " + config2.style + " " + dom.spacer.className
      ).html(text2(config2.text));
      return {
        conf: config2,
        node: spacer,
        inserter: spacer,
        buttons: [],
        inCollection,
        isSplit,
        collection: null,
        textNode: spacer
      };
    }
    if (config2.available && !config2.available(dt2, config2) && !config2.html) {
      return false;
    }
    var button;
    if (!config2.html) {
      var run2 = function(e2, dt3, button2, config3, done) {
        config3.action.call(dt3.button(button2), e2, dt3, button2, config3, done);
        $$4(dt3.table().node()).triggerHandler("buttons-action.dt", [
          dt3.button(button2),
          dt3,
          button2,
          config3
        ]);
      };
      var action = function(e2, dt3, button2, config3) {
        if (config3.async) {
          that.processing(button2[0], true);
          setTimeout(function() {
            run2(e2, dt3, button2, config3, function() {
              that.processing(button2[0], false);
            });
          }, config3.async);
        } else {
          run2(e2, dt3, button2, config3, function() {
          });
        }
      };
      var tag = config2.tag || dom.tag;
      var clickBlurs = config2.clickBlurs === void 0 ? true : config2.clickBlurs;
      button = $$4("<" + tag + "/>").addClass(dom.className).attr("tabindex", this.s.dt.settings()[0].iTabIndex).attr("aria-controls", this.s.dt.table().node().id).on("click.dtb", function(e2) {
        e2.preventDefault();
        if (!button.hasClass(dom.disabled) && config2.action) {
          action(e2, dt2, button, config2);
        }
        if (clickBlurs) {
          button.trigger("blur");
        }
      }).on("keypress.dtb", function(e2) {
        if (e2.keyCode === 13) {
          e2.preventDefault();
          if (!button.hasClass(dom.disabled) && config2.action) {
            action(e2, dt2, button, config2);
          }
        }
      });
      if (tag.toLowerCase() === "a") {
        button.attr("href", "#");
      }
      if (tag.toLowerCase() === "button") {
        button.attr("type", "button");
      }
      if (dom.liner.tag) {
        var liner = $$4("<" + dom.liner.tag + "/>").html(text2(config2.text)).addClass(dom.liner.className);
        if (dom.liner.tag.toLowerCase() === "a") {
          liner.attr("href", "#");
        }
        button.append(liner);
        textNode = liner;
      } else {
        button.html(text2(config2.text));
        textNode = button;
      }
      if (config2.enabled === false) {
        button.addClass(dom.disabled);
      }
      if (config2.className) {
        button.addClass(config2.className);
      }
      if (config2.titleAttr) {
        button.attr("title", text2(config2.titleAttr));
      }
      if (config2.attr) {
        button.attr(config2.attr);
      }
      if (!config2.namespace) {
        config2.namespace = ".dt-button-" + _buttonCounter++;
      }
      if (config2.config !== void 0 && config2.config.split) {
        config2.split = config2.config.split;
      }
    } else {
      button = $$4(config2.html);
    }
    var buttonContainer = this.c.dom.buttonContainer;
    var inserter;
    if (buttonContainer && buttonContainer.tag) {
      inserter = $$4("<" + buttonContainer.tag + "/>").addClass(buttonContainer.className).append(button);
    } else {
      inserter = button;
    }
    this._addKey(config2);
    if (this.c.buttonCreated) {
      inserter = this.c.buttonCreated(config2, inserter);
    }
    var splitDiv;
    if (isSplit) {
      var dropdownConf = inCollection ? $$4.extend(true, this.c.dom.split, this.c.dom.collection.split) : this.c.dom.split;
      var wrapperConf = dropdownConf.wrapper;
      splitDiv = $$4("<" + wrapperConf.tag + "/>").addClass(wrapperConf.className).append(button);
      var dropButtonConfig = $$4.extend(config2, {
        autoClose: true,
        align: dropdownConf.dropdown.align,
        attr: {
          "aria-haspopup": "dialog",
          "aria-expanded": false
        },
        className: dropdownConf.dropdown.className,
        closeButton: false,
        splitAlignClass: dropdownConf.dropdown.splitAlignClass,
        text: dropdownConf.dropdown.text
      });
      this._addKey(dropButtonConfig);
      var splitAction = function(e2, dt3, button2, config3) {
        _dtButtons.split.action.call(
          dt3.button(splitDiv),
          e2,
          dt3,
          button2,
          config3
        );
        $$4(dt3.table().node()).triggerHandler("buttons-action.dt", [
          dt3.button(button2),
          dt3,
          button2,
          config3
        ]);
        button2.attr("aria-expanded", true);
      };
      var dropButton = $$4(
        '<button class="' + dropdownConf.dropdown.className + ' dt-button"></button>'
      ).html(this.c.dom.button.dropHtml).addClass(this.c.dom.button.dropClass).on("click.dtb", function(e2) {
        e2.preventDefault();
        e2.stopPropagation();
        if (!dropButton.hasClass(dom.disabled)) {
          splitAction(e2, dt2, dropButton, dropButtonConfig);
        }
        if (clickBlurs) {
          dropButton.trigger("blur");
        }
      }).on("keypress.dtb", function(e2) {
        if (e2.keyCode === 13) {
          e2.preventDefault();
          if (!dropButton.hasClass(dom.disabled)) {
            splitAction(e2, dt2, dropButton, dropButtonConfig);
          }
        }
      });
      if (config2.split.length === 0) {
        dropButton.addClass("dtb-hide-drop");
      }
      splitDiv.append(dropButton).attr(dropButtonConfig.attr);
    }
    return {
      conf: config2,
      node: isSplit ? splitDiv.get(0) : button.get(0),
      inserter: isSplit ? splitDiv : inserter,
      buttons: [],
      inCollection,
      isSplit,
      inSplit,
      collection: null,
      textNode
    };
  },
  /**
   * Spin over buttons checking if splits should be enabled or not.
   * @param {*} buttons Array of buttons to check
   */
  _checkSplitEnable: function(buttons) {
    if (!buttons) {
      buttons = this.s.buttons;
    }
    for (var i = 0; i < buttons.length; i++) {
      var button = buttons[i];
      if (button.isSplit) {
        var splitBtn = button.node.childNodes[1];
        if (this._checkAnyEnabled(button.buttons)) {
          $$4(splitBtn).removeClass(this.c.dom.button.disabled).prop("disabled", false);
        } else {
          $$4(splitBtn).addClass(this.c.dom.button.disabled).prop("disabled", false);
        }
      } else if (button.isCollection) {
        this._checkSplitEnable(button.buttons);
      }
    }
  },
  /**
   * Check an array of buttons and see if any are enabled in it
   * @param {*} buttons Button array
   * @returns true if a button is enabled, false otherwise
   */
  _checkAnyEnabled: function(buttons) {
    for (var i = 0; i < buttons.length; i++) {
      if (!buttons[i].disabled) {
        return true;
      }
    }
    return false;
  },
  /**
   * Get the button object from a node (recursive)
   * @param  {node} node Button node
   * @param  {array} [buttons] Button array, uses base if not defined
   * @return {object} Button object
   * @private
   */
  _nodeToButton: function(node, buttons) {
    if (!buttons) {
      buttons = this.s.buttons;
    }
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      if (buttons[i].node === node || $$4(buttons[i].node).children().eq(0).get(0) === node) {
        return buttons[i];
      }
      if (buttons[i].buttons.length) {
        var ret = this._nodeToButton(node, buttons[i].buttons);
        if (ret) {
          return ret;
        }
      }
    }
  },
  /**
   * Get container array for a button from a button node (recursive)
   * @param  {node} node Button node
   * @param  {array} [buttons] Button array, uses base if not defined
   * @return {array} Button's host array
   * @private
   */
  _nodeToHost: function(node, buttons) {
    if (!buttons) {
      buttons = this.s.buttons;
    }
    for (var i = 0, ien = buttons.length; i < ien; i++) {
      if (buttons[i].node === node) {
        return buttons;
      }
      if (buttons[i].buttons.length) {
        var ret = this._nodeToHost(node, buttons[i].buttons);
        if (ret) {
          return ret;
        }
      }
    }
  },
  /**
   * Handle a key press - determine if any button's key configured matches
   * what was typed and trigger the action if so.
   * @param  {string} character The character pressed
   * @param  {object} e Key event that triggered this call
   * @private
   */
  _keypress: function(character, e2) {
    if (e2._buttonsHandled) {
      return;
    }
    var run2 = function(conf, node) {
      if (!conf.key) {
        return;
      }
      if (conf.key === character) {
        e2._buttonsHandled = true;
        $$4(node).click();
      } else if ($$4.isPlainObject(conf.key)) {
        if (conf.key.key !== character) {
          return;
        }
        if (conf.key.shiftKey && !e2.shiftKey) {
          return;
        }
        if (conf.key.altKey && !e2.altKey) {
          return;
        }
        if (conf.key.ctrlKey && !e2.ctrlKey) {
          return;
        }
        if (conf.key.metaKey && !e2.metaKey) {
          return;
        }
        e2._buttonsHandled = true;
        $$4(node).click();
      }
    };
    var recurse = function(a2) {
      for (var i = 0, ien = a2.length; i < ien; i++) {
        run2(a2[i].conf, a2[i].node);
        if (a2[i].buttons.length) {
          recurse(a2[i].buttons);
        }
      }
    };
    recurse(this.s.buttons);
  },
  /**
   * Remove a key from the key listener for this instance (to be used when a
   * button is removed)
   * @param  {object} conf Button configuration
   * @private
   */
  _removeKey: function(conf) {
    if (conf.key) {
      var character = $$4.isPlainObject(conf.key) ? conf.key.key : conf.key;
      var a2 = this.s.listenKeys.split("");
      var idx = $$4.inArray(character, a2);
      a2.splice(idx, 1);
      this.s.listenKeys = a2.join("");
    }
  },
  /**
   * Resolve a button configuration
   * @param  {string|function|object} conf Button config to resolve
   * @return {object} Button configuration
   * @private
   */
  _resolveExtends: function(conf) {
    var that = this;
    var dt2 = this.s.dt;
    var i, ien;
    var toConfObject = function(base) {
      var loop = 0;
      while (!$$4.isPlainObject(base) && !Array.isArray(base)) {
        if (base === void 0) {
          return;
        }
        if (typeof base === "function") {
          base = base.call(that, dt2, conf);
          if (!base) {
            return false;
          }
        } else if (typeof base === "string") {
          if (!_dtButtons[base]) {
            return { html: base };
          }
          base = _dtButtons[base];
        }
        loop++;
        if (loop > 30) {
          throw "Buttons: Too many iterations";
        }
      }
      return Array.isArray(base) ? base : $$4.extend({}, base);
    };
    conf = toConfObject(conf);
    while (conf && conf.extend) {
      if (!_dtButtons[conf.extend]) {
        throw "Cannot extend unknown button type: " + conf.extend;
      }
      var objArray = toConfObject(_dtButtons[conf.extend]);
      if (Array.isArray(objArray)) {
        return objArray;
      } else if (!objArray) {
        return false;
      }
      var originalClassName = objArray.className;
      if (conf.config !== void 0 && objArray.config !== void 0) {
        conf.config = $$4.extend({}, objArray.config, conf.config);
      }
      conf = $$4.extend({}, objArray, conf);
      if (originalClassName && conf.className !== originalClassName) {
        conf.className = originalClassName + " " + conf.className;
      }
      conf.extend = objArray.extend;
    }
    var postfixButtons = conf.postfixButtons;
    if (postfixButtons) {
      if (!conf.buttons) {
        conf.buttons = [];
      }
      for (i = 0, ien = postfixButtons.length; i < ien; i++) {
        conf.buttons.push(postfixButtons[i]);
      }
    }
    var prefixButtons = conf.prefixButtons;
    if (prefixButtons) {
      if (!conf.buttons) {
        conf.buttons = [];
      }
      for (i = 0, ien = prefixButtons.length; i < ien; i++) {
        conf.buttons.splice(i, 0, prefixButtons[i]);
      }
    }
    return conf;
  },
  /**
   * Display (and replace if there is an existing one) a popover attached to a button
   * @param {string|node} content Content to show
   * @param {DataTable.Api} hostButton DT API instance of the button
   * @param {object} inOpts Options (see object below for all options)
   */
  _popover: function(content, hostButton, inOpts) {
    var dt2 = hostButton;
    var c2 = this.c;
    var closed = false;
    var options = $$4.extend(
      {
        align: "button-left",
        // button-right, dt-container, split-left, split-right
        autoClose: false,
        background: true,
        backgroundClassName: "dt-button-background",
        closeButton: true,
        containerClassName: c2.dom.collection.container.className,
        contentClassName: c2.dom.collection.container.content.className,
        collectionLayout: "",
        collectionTitle: "",
        dropup: false,
        fade: 400,
        popoverTitle: "",
        rightAlignClassName: "dt-button-right",
        tag: c2.dom.collection.container.tag
      },
      inOpts
    );
    var containerSelector = options.tag + "." + options.containerClassName.replace(/ /g, ".");
    var hostButtonNode = hostButton.node();
    var hostNode = options.collectionLayout.includes("fixed") ? $$4("body") : hostButton.node();
    var close2 = function() {
      closed = true;
      _fadeOut($$4(containerSelector), options.fade, function() {
        $$4(this).detach();
      });
      $$4(
        dt2.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()
      ).attr("aria-expanded", "false");
      $$4("div.dt-button-background").off("click.dtb-collection");
      Buttons$1.background(
        false,
        options.backgroundClassName,
        options.fade,
        hostNode
      );
      $$4(window).off("resize.resize.dtb-collection");
      $$4("body").off(".dtb-collection");
      dt2.off("buttons-action.b-internal");
      dt2.off("destroy");
      $$4("body").trigger("buttons-popover-hide.dt");
    };
    if (content === false) {
      close2();
      return;
    }
    var existingExpanded = $$4(
      dt2.buttons('[aria-haspopup="dialog"][aria-expanded="true"]').nodes()
    );
    if (existingExpanded.length) {
      if (hostNode.closest(containerSelector).length) {
        hostNode = existingExpanded.eq(0);
      }
      close2();
    }
    if (options.sort) {
      var elements = $$4("button", content).map(function(idx, el) {
        return {
          text: $$4(el).text(),
          el
        };
      }).toArray();
      elements.sort(function(a2, b2) {
        return a2.text.localeCompare(b2.text);
      });
      $$4(content).append(elements.map(function(v2) {
        return v2.el;
      }));
    }
    var cnt = $$4(".dt-button", content).length;
    var mod = "";
    if (cnt === 3) {
      mod = "dtb-b3";
    } else if (cnt === 2) {
      mod = "dtb-b2";
    } else if (cnt === 1) {
      mod = "dtb-b1";
    }
    var display = $$4("<" + options.tag + "/>").addClass(options.containerClassName).addClass(options.collectionLayout).addClass(options.splitAlignClass).addClass(mod).css("display", "none").attr({
      "aria-modal": true,
      role: "dialog"
    });
    content = $$4(content).addClass(options.contentClassName).attr("role", "menu").appendTo(display);
    hostButtonNode.attr("aria-expanded", "true");
    if (hostNode.parents("body")[0] !== document.body) {
      hostNode = $$4(document.body).children("div, section, p").last();
    }
    if (options.popoverTitle) {
      display.prepend(
        '<div class="dt-button-collection-title">' + options.popoverTitle + "</div>"
      );
    } else if (options.collectionTitle) {
      display.prepend(
        '<div class="dt-button-collection-title">' + options.collectionTitle + "</div>"
      );
    }
    if (options.closeButton) {
      display.prepend('<div class="dtb-popover-close">&times;</div>').addClass("dtb-collection-closeable");
    }
    _fadeIn(display.insertAfter(hostNode), options.fade);
    var tableContainer = $$4(hostButton.table().container());
    var position = display.css("position");
    if (options.span === "container" || options.align === "dt-container") {
      hostNode = hostNode.parent();
      display.css("width", tableContainer.width());
    }
    if (position === "absolute") {
      var offsetParent = $$4(hostNode[0].offsetParent);
      var buttonPosition = hostNode.position();
      var buttonOffset = hostNode.offset();
      var tableSizes = offsetParent.offset();
      var containerPosition = offsetParent.position();
      var computed = window.getComputedStyle(offsetParent[0]);
      tableSizes.height = offsetParent.outerHeight();
      tableSizes.width = offsetParent.width() + parseFloat(computed.paddingLeft);
      tableSizes.right = tableSizes.left + tableSizes.width;
      tableSizes.bottom = tableSizes.top + tableSizes.height;
      var top2 = buttonPosition.top + hostNode.outerHeight();
      var left2 = buttonPosition.left;
      display.css({
        top: top2,
        left: left2
      });
      computed = window.getComputedStyle(display[0]);
      var popoverSizes = display.offset();
      popoverSizes.height = display.outerHeight();
      popoverSizes.width = display.outerWidth();
      popoverSizes.right = popoverSizes.left + popoverSizes.width;
      popoverSizes.bottom = popoverSizes.top + popoverSizes.height;
      popoverSizes.marginTop = parseFloat(computed.marginTop);
      popoverSizes.marginBottom = parseFloat(computed.marginBottom);
      if (options.dropup) {
        top2 = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
      }
      if (options.align === "button-right" || display.hasClass(options.rightAlignClassName)) {
        left2 = buttonPosition.left - popoverSizes.width + hostNode.outerWidth();
      }
      if (options.align === "dt-container" || options.align === "container") {
        if (left2 < buttonPosition.left) {
          left2 = -buttonPosition.left;
        }
      }
      if (containerPosition.left + left2 + popoverSizes.width > $$4(window).width()) {
        left2 = $$4(window).width() - popoverSizes.width - containerPosition.left;
      }
      if (buttonOffset.left + left2 < 0) {
        left2 = -buttonOffset.left;
      }
      if (containerPosition.top + top2 + popoverSizes.height > $$4(window).height() + $$4(window).scrollTop()) {
        top2 = buttonPosition.top - popoverSizes.height - popoverSizes.marginTop - popoverSizes.marginBottom;
      }
      if (offsetParent.offset().top + top2 < $$4(window).scrollTop()) {
        top2 = buttonPosition.top + hostNode.outerHeight();
      }
      display.css({
        top: top2,
        left: left2
      });
    } else {
      var place = function() {
        var half = $$4(window).height() / 2;
        var top3 = display.height() / 2;
        if (top3 > half) {
          top3 = half;
        }
        display.css("marginTop", top3 * -1);
      };
      place();
      $$4(window).on("resize.dtb-collection", function() {
        place();
      });
    }
    if (options.background) {
      Buttons$1.background(
        true,
        options.backgroundClassName,
        options.fade,
        options.backgroundHost || hostNode
      );
    }
    $$4("div.dt-button-background").on(
      "click.dtb-collection",
      function() {
      }
    );
    if (options.autoClose) {
      setTimeout(function() {
        dt2.on("buttons-action.b-internal", function(e2, btn, dt3, node) {
          if (node[0] === hostNode[0]) {
            return;
          }
          close2();
        });
      }, 0);
    }
    $$4(display).trigger("buttons-popover.dt");
    dt2.on("destroy", close2);
    setTimeout(function() {
      closed = false;
      $$4("body").on("click.dtb-collection", function(e2) {
        if (closed) {
          return;
        }
        var back = $$4.fn.addBack ? "addBack" : "andSelf";
        var parent = $$4(e2.target).parent()[0];
        if (!$$4(e2.target).parents()[back]().filter(content).length && !$$4(parent).hasClass("dt-buttons") || $$4(e2.target).hasClass("dt-button-background")) {
          close2();
        }
      }).on("keyup.dtb-collection", function(e2) {
        if (e2.keyCode === 27) {
          close2();
        }
      }).on("keydown.dtb-collection", function(e2) {
        var elements2 = $$4("a, button", content);
        var active = document.activeElement;
        if (e2.keyCode !== 9) {
          return;
        }
        if (elements2.index(active) === -1) {
          elements2.first().focus();
          e2.preventDefault();
        } else if (e2.shiftKey) {
          if (active === elements2[0]) {
            elements2.last().focus();
            e2.preventDefault();
          }
        } else {
          if (active === elements2.last()[0]) {
            elements2.first().focus();
            e2.preventDefault();
          }
        }
      });
    }, 0);
  }
});
Buttons$1.background = function(show2, className, fade, insertPoint) {
  if (fade === void 0) {
    fade = 400;
  }
  if (!insertPoint) {
    insertPoint = document.body;
  }
  if (show2) {
    _fadeIn(
      $$4("<div/>").addClass(className).css("display", "none").insertAfter(insertPoint),
      fade
    );
  } else {
    _fadeOut($$4("div." + className), fade, function() {
      $$4(this).removeClass(className).remove();
    });
  }
};
Buttons$1.instanceSelector = function(group, buttons) {
  if (group === void 0 || group === null) {
    return $$4.map(buttons, function(v2) {
      return v2.inst;
    });
  }
  var ret = [];
  var names = $$4.map(buttons, function(v2) {
    return v2.name;
  });
  var process2 = function(input) {
    if (Array.isArray(input)) {
      for (var i = 0, ien = input.length; i < ien; i++) {
        process2(input[i]);
      }
      return;
    }
    if (typeof input === "string") {
      if (input.indexOf(",") !== -1) {
        process2(input.split(","));
      } else {
        var idx = $$4.inArray(input.trim(), names);
        if (idx !== -1) {
          ret.push(buttons[idx].inst);
        }
      }
    } else if (typeof input === "number") {
      ret.push(buttons[input].inst);
    } else if (typeof input === "object" && input.nodeName) {
      for (var j2 = 0; j2 < buttons.length; j2++) {
        if (buttons[j2].inst.dom.container[0] === input) {
          ret.push(buttons[j2].inst);
        }
      }
    } else if (typeof input === "object") {
      ret.push(input);
    }
  };
  process2(group);
  return ret;
};
Buttons$1.buttonSelector = function(insts, selector) {
  var ret = [];
  var nodeBuilder = function(a2, buttons, baseIdx) {
    var button;
    var idx;
    for (var i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
      button = buttons[i2];
      if (button) {
        idx = baseIdx !== void 0 ? baseIdx + i2 : i2 + "";
        a2.push({
          node: button.node,
          name: button.conf.name,
          idx
        });
        if (button.buttons) {
          nodeBuilder(a2, button.buttons, idx + "-");
        }
      }
    }
  };
  var run2 = function(selector2, inst2) {
    var i2, ien2;
    var buttons = [];
    nodeBuilder(buttons, inst2.s.buttons);
    var nodes = $$4.map(buttons, function(v2) {
      return v2.node;
    });
    if (Array.isArray(selector2) || selector2 instanceof $$4) {
      for (i2 = 0, ien2 = selector2.length; i2 < ien2; i2++) {
        run2(selector2[i2], inst2);
      }
      return;
    }
    if (selector2 === null || selector2 === void 0 || selector2 === "*") {
      for (i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
        ret.push({
          inst: inst2,
          node: buttons[i2].node
        });
      }
    } else if (typeof selector2 === "number") {
      if (inst2.s.buttons[selector2]) {
        ret.push({
          inst: inst2,
          node: inst2.s.buttons[selector2].node
        });
      }
    } else if (typeof selector2 === "string") {
      if (selector2.indexOf(",") !== -1) {
        var a2 = selector2.split(",");
        for (i2 = 0, ien2 = a2.length; i2 < ien2; i2++) {
          run2(a2[i2].trim(), inst2);
        }
      } else if (selector2.match(/^\d+(\-\d+)*$/)) {
        var indexes = $$4.map(buttons, function(v2) {
          return v2.idx;
        });
        ret.push({
          inst: inst2,
          node: buttons[$$4.inArray(selector2, indexes)].node
        });
      } else if (selector2.indexOf(":name") !== -1) {
        var name2 = selector2.replace(":name", "");
        for (i2 = 0, ien2 = buttons.length; i2 < ien2; i2++) {
          if (buttons[i2].name === name2) {
            ret.push({
              inst: inst2,
              node: buttons[i2].node
            });
          }
        }
      } else {
        $$4(nodes).filter(selector2).each(function() {
          ret.push({
            inst: inst2,
            node: this
          });
        });
      }
    } else if (typeof selector2 === "object" && selector2.nodeName) {
      var idx = $$4.inArray(selector2, nodes);
      if (idx !== -1) {
        ret.push({
          inst: inst2,
          node: nodes[idx]
        });
      }
    }
  };
  for (var i = 0, ien = insts.length; i < ien; i++) {
    var inst = insts[i];
    run2(selector, inst);
  }
  return ret;
};
Buttons$1.stripData = function(str2, config2) {
  if (str2 !== null && typeof str2 === "object" && str2.nodeName && str2.nodeType) {
    str2 = str2.innerHTML;
  }
  if (typeof str2 !== "string") {
    return str2;
  }
  str2 = Buttons$1.stripHtmlScript(str2);
  str2 = Buttons$1.stripHtmlComments(str2);
  if (!config2 || config2.stripHtml) {
    str2 = DataTable.util.stripHtml(str2);
  }
  if (!config2 || config2.trim) {
    str2 = str2.trim();
  }
  if (!config2 || config2.stripNewlines) {
    str2 = str2.replace(/\n/g, " ");
  }
  if (!config2 || config2.decodeEntities) {
    if (_entityDecoder) {
      str2 = _entityDecoder(str2);
    } else {
      _exportTextarea.innerHTML = str2;
      str2 = _exportTextarea.value;
    }
  }
  if (!config2 || config2.escapeExcelFormula) {
    if (str2.match(/^[=+\-@\t\r]/)) {
      console.log("matching and updateing");
      str2 = "'" + str2;
    }
  }
  return str2;
};
Buttons$1.entityDecoder = function(fn3) {
  _entityDecoder = fn3;
};
Buttons$1.stripHtmlComments = function(input) {
  var previous;
  do {
    previous = input;
    input = input.replace(/(<!--.*?--!?>)|(<!--[\S\s]+?--!?>)|(<!--[\S\s]*?$)/g, "");
  } while (input !== previous);
  return input;
};
Buttons$1.stripHtmlScript = function(input) {
  var previous;
  do {
    previous = input;
    input = input.replace(/<script\b[^<]*(?:(?!<\/script[^>]*>)<[^<]*)*<\/script[^>]*>/gi, "");
  } while (input !== previous);
  return input;
};
Buttons$1.defaults = {
  buttons: ["copy", "excel", "csv", "pdf", "print"],
  name: "main",
  tabIndex: 0,
  dom: {
    container: {
      tag: "div",
      className: "dt-buttons"
    },
    collection: {
      container: {
        // The element used for the dropdown
        className: "dt-button-collection",
        content: {
          className: "",
          tag: "div"
        },
        tag: "div"
      }
      // optionally
      // , button: IButton - buttons inside the collection container
      // , split: ISplit - splits inside the collection container
    },
    button: {
      tag: "button",
      className: "dt-button",
      active: "dt-button-active",
      // class name
      disabled: "disabled",
      // class name
      spacer: {
        className: "dt-button-spacer",
        tag: "span"
      },
      liner: {
        tag: "span",
        className: ""
      },
      dropClass: "",
      dropHtml: '<span class="dt-button-down-arrow">&#x25BC;</span>'
    },
    split: {
      action: {
        // action button
        className: "dt-button-split-drop-button dt-button",
        tag: "button"
      },
      dropdown: {
        // button to trigger the dropdown
        align: "split-right",
        className: "dt-button-split-drop",
        splitAlignClass: "dt-button-split-left",
        tag: "button"
      },
      wrapper: {
        // wrap around both
        className: "dt-button-split",
        tag: "div"
      }
    }
  }
};
Buttons$1.version = "3.2.2";
$$4.extend(_dtButtons, {
  collection: {
    text: function(dt2) {
      return dt2.i18n("buttons.collection", "Collection");
    },
    className: "buttons-collection",
    closeButton: false,
    dropIcon: true,
    init: function(dt2, button) {
      button.attr("aria-expanded", false);
    },
    action: function(e2, dt2, button, config2) {
      if (config2._collection.parents("body").length) {
        this.popover(false, config2);
      } else {
        this.popover(config2._collection, config2);
      }
      if (e2.type === "keypress") {
        $$4("a, button", config2._collection).eq(0).focus();
      }
    },
    attr: {
      "aria-haspopup": "dialog"
    }
    // Also the popover options, defined in Buttons.popover
  },
  split: {
    text: function(dt2) {
      return dt2.i18n("buttons.split", "Split");
    },
    className: "buttons-split",
    closeButton: false,
    init: function(dt2, button) {
      return button.attr("aria-expanded", false);
    },
    action: function(e2, dt2, button, config2) {
      this.popover(config2._collection, config2);
    },
    attr: {
      "aria-haspopup": "dialog"
    }
    // Also the popover options, defined in Buttons.popover
  },
  copy: function() {
    if (_dtButtons.copyHtml5) {
      return "copyHtml5";
    }
  },
  csv: function(dt2, conf) {
    if (_dtButtons.csvHtml5 && _dtButtons.csvHtml5.available(dt2, conf)) {
      return "csvHtml5";
    }
  },
  excel: function(dt2, conf) {
    if (_dtButtons.excelHtml5 && _dtButtons.excelHtml5.available(dt2, conf)) {
      return "excelHtml5";
    }
  },
  pdf: function(dt2, conf) {
    if (_dtButtons.pdfHtml5 && _dtButtons.pdfHtml5.available(dt2, conf)) {
      return "pdfHtml5";
    }
  },
  pageLength: function(dt2) {
    var lengthMenu = dt2.settings()[0].aLengthMenu;
    var vals = [];
    var lang = [];
    var text2 = function(dt3) {
      return dt3.i18n(
        "buttons.pageLength",
        {
          "-1": "Show all rows",
          _: "Show %d rows"
        },
        dt3.page.len()
      );
    };
    if (Array.isArray(lengthMenu[0])) {
      vals = lengthMenu[0];
      lang = lengthMenu[1];
    } else {
      for (var i = 0; i < lengthMenu.length; i++) {
        var option2 = lengthMenu[i];
        if ($$4.isPlainObject(option2)) {
          vals.push(option2.value);
          lang.push(option2.label);
        } else {
          vals.push(option2);
          lang.push(option2);
        }
      }
    }
    return {
      extend: "collection",
      text: text2,
      className: "buttons-page-length",
      autoClose: true,
      buttons: $$4.map(vals, function(val, i2) {
        return {
          text: lang[i2],
          className: "button-page-length",
          action: function(e2, dt3) {
            dt3.page.len(val).draw();
          },
          init: function(dt3, node, conf) {
            var that = this;
            var fn3 = function() {
              that.active(dt3.page.len() === val);
            };
            dt3.on("length.dt" + conf.namespace, fn3);
            fn3();
          },
          destroy: function(dt3, node, conf) {
            dt3.off("length.dt" + conf.namespace);
          }
        };
      }),
      init: function(dt3, node, conf) {
        var that = this;
        dt3.on("length.dt" + conf.namespace, function() {
          that.text(conf.text);
        });
      },
      destroy: function(dt3, node, conf) {
        dt3.off("length.dt" + conf.namespace);
      }
    };
  },
  spacer: {
    style: "empty",
    spacer: true,
    text: function(dt2) {
      return dt2.i18n("buttons.spacer", "");
    }
  }
});
DataTable.Api.register("buttons()", function(group, selector) {
  if (selector === void 0) {
    selector = group;
    group = void 0;
  }
  this.selector.buttonGroup = group;
  var res2 = this.iterator(
    true,
    "table",
    function(ctx) {
      if (ctx._buttons) {
        return Buttons$1.buttonSelector(
          Buttons$1.instanceSelector(group, ctx._buttons),
          selector
        );
      }
    },
    true
  );
  res2._groupSelector = group;
  return res2;
});
DataTable.Api.register("button()", function(group, selector) {
  var buttons = this.buttons(group, selector);
  if (buttons.length > 1) {
    buttons.splice(1, buttons.length);
  }
  return buttons;
});
DataTable.Api.registerPlural(
  "buttons().active()",
  "button().active()",
  function(flag) {
    if (flag === void 0) {
      return this.map(function(set) {
        return set.inst.active(set.node);
      });
    }
    return this.each(function(set) {
      set.inst.active(set.node, flag);
    });
  }
);
DataTable.Api.registerPlural(
  "buttons().action()",
  "button().action()",
  function(action) {
    if (action === void 0) {
      return this.map(function(set) {
        return set.inst.action(set.node);
      });
    }
    return this.each(function(set) {
      set.inst.action(set.node, action);
    });
  }
);
DataTable.Api.registerPlural(
  "buttons().collectionRebuild()",
  "button().collectionRebuild()",
  function(buttons) {
    return this.each(function(set) {
      for (var i = 0; i < buttons.length; i++) {
        if (typeof buttons[i] === "object") {
          buttons[i].parentConf = set;
        }
      }
      set.inst.collectionRebuild(set.node, buttons);
    });
  }
);
DataTable.Api.register(
  ["buttons().enable()", "button().enable()"],
  function(flag) {
    return this.each(function(set) {
      set.inst.enable(set.node, flag);
    });
  }
);
DataTable.Api.register(
  ["buttons().disable()", "button().disable()"],
  function() {
    return this.each(function(set) {
      set.inst.disable(set.node);
    });
  }
);
DataTable.Api.register("button().index()", function() {
  var idx = null;
  this.each(function(set) {
    var res2 = set.inst.index(set.node);
    if (res2 !== null) {
      idx = res2;
    }
  });
  return idx;
});
DataTable.Api.registerPlural(
  "buttons().nodes()",
  "button().node()",
  function() {
    var jq = $$4();
    $$4(
      this.each(function(set) {
        jq = jq.add(set.inst.node(set.node));
      })
    );
    return jq;
  }
);
DataTable.Api.registerPlural(
  "buttons().processing()",
  "button().processing()",
  function(flag) {
    if (flag === void 0) {
      return this.map(function(set) {
        return set.inst.processing(set.node);
      });
    }
    return this.each(function(set) {
      set.inst.processing(set.node, flag);
    });
  }
);
DataTable.Api.registerPlural(
  "buttons().text()",
  "button().text()",
  function(label) {
    if (label === void 0) {
      return this.map(function(set) {
        return set.inst.text(set.node);
      });
    }
    return this.each(function(set) {
      set.inst.text(set.node, label);
    });
  }
);
DataTable.Api.registerPlural(
  "buttons().trigger()",
  "button().trigger()",
  function() {
    return this.each(function(set) {
      set.inst.node(set.node).trigger("click");
    });
  }
);
DataTable.Api.register("button().popover()", function(content, options) {
  return this.map(function(set) {
    return set.inst._popover(content, this.button(this[0].node), options);
  });
});
DataTable.Api.register("buttons().containers()", function() {
  var jq = $$4();
  var groupSelector = this._groupSelector;
  this.iterator(true, "table", function(ctx) {
    if (ctx._buttons) {
      var insts = Buttons$1.instanceSelector(groupSelector, ctx._buttons);
      for (var i = 0, ien = insts.length; i < ien; i++) {
        jq = jq.add(insts[i].container());
      }
    }
  });
  return jq;
});
DataTable.Api.register("buttons().container()", function() {
  return this.containers().eq(0);
});
DataTable.Api.register("button().add()", function(idx, conf, draw) {
  var ctx = this.context;
  if (ctx.length) {
    var inst = Buttons$1.instanceSelector(
      this._groupSelector,
      ctx[0]._buttons
    );
    if (inst.length) {
      inst[0].add(conf, idx, draw);
    }
  }
  return this.button(this._groupSelector, idx);
});
DataTable.Api.register("buttons().destroy()", function() {
  this.pluck("inst").unique().each(function(inst) {
    inst.destroy();
  });
  return this;
});
DataTable.Api.registerPlural(
  "buttons().remove()",
  "buttons().remove()",
  function() {
    this.each(function(set) {
      set.inst.remove(set.node);
    });
    return this;
  }
);
var _infoTimer;
DataTable.Api.register("buttons.info()", function(title, message, time) {
  var that = this;
  if (title === false) {
    this.off("destroy.btn-info");
    _fadeOut($$4("#datatables_buttons_info"), 400, function() {
      $$4(this).remove();
    });
    clearTimeout(_infoTimer);
    _infoTimer = null;
    return this;
  }
  if (_infoTimer) {
    clearTimeout(_infoTimer);
  }
  if ($$4("#datatables_buttons_info").length) {
    $$4("#datatables_buttons_info").remove();
  }
  title = title ? "<h2>" + title + "</h2>" : "";
  _fadeIn(
    $$4('<div id="datatables_buttons_info" class="dt-button-info"/>').html(title).append(
      $$4("<div/>")[typeof message === "string" ? "html" : "append"](
        message
      )
    ).css("display", "none").appendTo("body")
  );
  if (time !== void 0 && time !== 0) {
    _infoTimer = setTimeout(function() {
      that.buttons.info(false);
    }, time);
  }
  this.on("destroy.btn-info", function() {
    that.buttons.info(false);
  });
  return this;
});
DataTable.Api.register("buttons.exportData()", function(options) {
  if (this.context.length) {
    return _exportData(new DataTable.Api(this.context[0]), options);
  }
});
DataTable.Api.register("buttons.exportInfo()", function(conf) {
  if (!conf) {
    conf = {};
  }
  return {
    filename: _filename(conf, this),
    title: _title(conf, this),
    messageTop: _message(this, conf, conf.message || conf.messageTop, "top"),
    messageBottom: _message(this, conf, conf.messageBottom, "bottom")
  };
});
var _filename = function(config2, dt2) {
  var filename = config2.filename === "*" && config2.title !== "*" && config2.title !== void 0 && config2.title !== null && config2.title !== "" ? config2.title : config2.filename;
  if (typeof filename === "function") {
    filename = filename(config2, dt2);
  }
  if (filename === void 0 || filename === null) {
    return null;
  }
  if (filename.indexOf("*") !== -1) {
    filename = filename.replace(/\*/g, $$4("head > title").text()).trim();
  }
  filename = filename.replace(/[^a-zA-Z0-9_\u00A1-\uFFFF\.,\-_ !\(\)]/g, "");
  var extension = _stringOrFunction(config2.extension, config2, dt2);
  if (!extension) {
    extension = "";
  }
  return filename + extension;
};
var _stringOrFunction = function(option2, config2, dt2) {
  if (option2 === null || option2 === void 0) {
    return null;
  } else if (typeof option2 === "function") {
    return option2(config2, dt2);
  }
  return option2;
};
var _title = function(config2, dt2) {
  var title = _stringOrFunction(config2.title, config2, dt2);
  return title === null ? null : title.indexOf("*") !== -1 ? title.replace(/\*/g, $$4("head > title").text() || "Exported data") : title;
};
var _message = function(dt2, config2, option2, position) {
  var message = _stringOrFunction(option2, config2, dt2);
  if (message === null) {
    return null;
  }
  var caption = $$4("caption", dt2.table().container()).eq(0);
  if (message === "*") {
    var side = caption.css("caption-side");
    if (side !== position) {
      return null;
    }
    return caption.length ? caption.text() : "";
  }
  return message;
};
var _exportTextarea = $$4("<textarea/>")[0];
var _exportData = function(dt2, inOpts) {
  var config2 = $$4.extend(
    true,
    {},
    {
      rows: null,
      columns: "",
      modifier: {
        search: "applied",
        order: "applied"
      },
      orthogonal: "display",
      stripHtml: true,
      stripNewlines: true,
      decodeEntities: true,
      escapeExcelFormula: false,
      trim: true,
      format: {
        header: function(d2) {
          return Buttons$1.stripData(d2, config2);
        },
        footer: function(d2) {
          return Buttons$1.stripData(d2, config2);
        },
        body: function(d2) {
          return Buttons$1.stripData(d2, config2);
        }
      },
      customizeData: null,
      customizeZip: null
    },
    inOpts
  );
  var header = dt2.columns(config2.columns).indexes().map(function(idx) {
    var col = dt2.column(idx);
    return config2.format.header(col.title(), idx, col.header());
  }).toArray();
  var footer = dt2.table().footer() ? dt2.columns(config2.columns).indexes().map(function(idx) {
    var el = dt2.column(idx).footer();
    var val = "";
    if (el) {
      var inner = $$4(".dt-column-title", el);
      val = inner.length ? inner.html() : $$4(el).html();
    }
    return config2.format.footer(val, idx, el);
  }).toArray() : null;
  var modifier = $$4.extend({}, config2.modifier);
  if (dt2.select && typeof dt2.select.info === "function" && modifier.selected === void 0) {
    if (dt2.rows(config2.rows, $$4.extend({ selected: true }, modifier)).any()) {
      $$4.extend(modifier, { selected: true });
    }
  }
  var rowIndexes = dt2.rows(config2.rows, modifier).indexes().toArray();
  var selectedCells = dt2.cells(rowIndexes, config2.columns, {
    order: modifier.order
  });
  var cells = selectedCells.render(config2.orthogonal).toArray();
  var cellNodes = selectedCells.nodes().toArray();
  var cellIndexes = selectedCells.indexes().toArray();
  var columns = dt2.columns(config2.columns).count();
  var rows = columns > 0 ? cells.length / columns : 0;
  var body = [];
  var cellCounter = 0;
  for (var i = 0, ien = rows; i < ien; i++) {
    var row = [columns];
    for (var j2 = 0; j2 < columns; j2++) {
      row[j2] = config2.format.body(
        cells[cellCounter],
        cellIndexes[cellCounter].row,
        cellIndexes[cellCounter].column,
        cellNodes[cellCounter]
      );
      cellCounter++;
    }
    body[i] = row;
  }
  var data2 = {
    header,
    headerStructure: _headerFormatter(
      config2.format.header,
      dt2.table().header.structure(config2.columns)
    ),
    footer,
    footerStructure: _headerFormatter(
      config2.format.footer,
      dt2.table().footer.structure(config2.columns)
    ),
    body
  };
  if (config2.customizeData) {
    config2.customizeData(data2);
  }
  return data2;
};
function _headerFormatter(formatter, struct) {
  for (var i = 0; i < struct.length; i++) {
    for (var j2 = 0; j2 < struct[i].length; j2++) {
      var item2 = struct[i][j2];
      if (item2) {
        item2.title = formatter(
          item2.title,
          j2,
          item2.cell
        );
      }
    }
  }
  return struct;
}
$$4.fn.dataTable.Buttons = Buttons$1;
$$4.fn.DataTable.Buttons = Buttons$1;
$$4(document).on("init.dt plugin-init.dt", function(e2, settings) {
  if (e2.namespace !== "dt") {
    return;
  }
  var opts = settings.oInit.buttons || DataTable.defaults.buttons;
  if (opts && !settings._buttons) {
    new Buttons$1(settings, opts).container();
  }
});
function _init(settings, options) {
  var api = new DataTable.Api(settings);
  var opts = options ? options : api.init().buttons || DataTable.defaults.buttons;
  return new Buttons$1(api, opts).container();
}
DataTable.ext.feature.push({
  fnInit: _init,
  cFeature: "B"
});
if (DataTable.feature) {
  DataTable.feature.register("buttons", _init);
}
/*! Bootstrap integration for DataTables' Buttons
 * © SpryMedia Ltd - datatables.net/license
 */
let $$3 = jQuery$1;
$$3.extend(true, DataTable.Buttons.defaults, {
  dom: {
    container: {
      className: "dt-buttons btn-group flex-wrap"
    },
    button: {
      className: "btn btn-secondary",
      active: "active",
      dropHtml: "",
      dropClass: "dropdown-toggle"
    },
    collection: {
      container: {
        tag: "div",
        className: "dropdown-menu dt-button-collection"
      },
      closeButton: false,
      button: {
        tag: "a",
        className: "dt-button dropdown-item",
        active: "dt-button-active",
        disabled: "disabled",
        spacer: {
          className: "dropdown-divider",
          tag: "hr"
        }
      }
    },
    split: {
      action: {
        tag: "a",
        className: "btn btn-secondary dt-button-split-drop-button",
        closeButton: false
      },
      dropdown: {
        tag: "button",
        className: "btn btn-secondary dt-button-split-drop dropdown-toggle-split",
        closeButton: false,
        align: "split-left",
        splitAlignClass: "dt-button-split-left"
      },
      wrapper: {
        tag: "div",
        className: "dt-button-split btn-group",
        closeButton: false
      }
    }
  },
  buttonCreated: function(config2, button) {
    return config2.buttons ? $$3('<div class="btn-group"/>').append(button) : button;
  }
});
DataTable.ext.buttons.collection.rightAlignClassName = "dropdown-menu-right";
/*! Responsive 3.0.4
 * © SpryMedia Ltd - datatables.net/license
 */
let $$2 = jQuery$1;
var Responsive = function(settings, opts) {
  if (!DataTable.versionCheck || !DataTable.versionCheck("2")) {
    throw "DataTables Responsive requires DataTables 2 or newer";
  }
  this.s = {
    childNodeStore: {},
    columns: [],
    current: [],
    dt: new DataTable.Api(settings)
  };
  if (this.s.dt.settings()[0].responsive) {
    return;
  }
  if (opts && typeof opts.details === "string") {
    opts.details = { type: opts.details };
  } else if (opts && opts.details === false) {
    opts.details = { type: false };
  } else if (opts && opts.details === true) {
    opts.details = { type: "inline" };
  }
  this.c = $$2.extend(
    true,
    {},
    Responsive.defaults,
    DataTable.defaults.responsive,
    opts
  );
  settings.responsive = this;
  this._constructor();
};
$$2.extend(Responsive.prototype, {
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Constructor
   */
  /**
   * Initialise the Responsive instance
   *
   * @private
   */
  _constructor: function() {
    var that = this;
    var dt2 = this.s.dt;
    var oldWindowWidth = $$2(window).innerWidth();
    dt2.settings()[0]._responsive = this;
    $$2(window).on(
      "orientationchange.dtr",
      DataTable.util.throttle(function() {
        var width = $$2(window).innerWidth();
        if (width !== oldWindowWidth) {
          that._resize();
          oldWindowWidth = width;
        }
      })
    );
    dt2.on("row-created.dtr", function(e2, tr, data2, idx) {
      if ($$2.inArray(false, that.s.current) !== -1) {
        $$2(">td, >th", tr).each(function(i) {
          var idx2 = dt2.column.index("toData", i);
          if (that.s.current[idx2] === false) {
            $$2(this).css("display", "none").addClass("dtr-hidden");
          }
        });
      }
    });
    dt2.on("destroy.dtr", function() {
      dt2.off(".dtr");
      $$2(dt2.table().body()).off(".dtr");
      $$2(window).off("resize.dtr orientationchange.dtr");
      dt2.cells(".dtr-control").nodes().to$().removeClass("dtr-control");
      $$2(dt2.table().node()).removeClass("dtr-inline collapsed");
      $$2.each(that.s.current, function(i, val) {
        if (val === false) {
          that._setColumnVis(i, true);
        }
      });
    });
    this.c.breakpoints.sort(function(a2, b2) {
      return a2.width < b2.width ? 1 : a2.width > b2.width ? -1 : 0;
    });
    this._classLogic();
    var details = this.c.details;
    if (details.type !== false) {
      that._detailsInit();
      dt2.on("column-visibility.dtr", function() {
        if (that._timer) {
          clearTimeout(that._timer);
        }
        that._timer = setTimeout(function() {
          that._timer = null;
          that._classLogic();
          that._resizeAuto();
          that._resize(true);
          that._redrawChildren();
        }, 100);
      });
      dt2.on("draw.dtr", function() {
        that._redrawChildren();
      });
      $$2(dt2.table().node()).addClass("dtr-" + details.type);
    }
    dt2.on("column-calc.dt", function(e2, d2) {
      var curr = that.s.current;
      for (var i = 0; i < curr.length; i++) {
        var idx = d2.visible.indexOf(i);
        if (curr[i] === false && idx >= 0) {
          d2.visible.splice(idx, 1);
        }
      }
    });
    dt2.on("preXhr.dtr", function() {
      var rowIds = [];
      dt2.rows().every(function() {
        if (this.child.isShown()) {
          rowIds.push(this.id(true));
        }
      });
      dt2.one("draw.dtr", function() {
        that._resizeAuto();
        that._resize();
        dt2.rows(rowIds).every(function() {
          that._detailsDisplay(this, false);
        });
      });
    });
    dt2.on("draw.dtr", function() {
      that._controlClass();
    }).ready(function() {
      that._resizeAuto();
      that._resize();
      dt2.on("column-reorder.dtr", function(e2, settings, details2) {
        that._classLogic();
        that._resizeAuto();
        that._resize(true);
      });
      dt2.on("column-sizing.dtr", function() {
        that._resizeAuto();
        that._resize();
      });
    });
  },
  /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
   * Private methods
   */
  /**
   * Insert a `col` tag into the correct location in a `colgroup`.
   *
   * @param {jQuery} colGroup The `colgroup` tag
   * @param {jQuery} colEl The `col` tag
   */
  _colGroupAttach: function(colGroup, colEls, idx) {
    var found = null;
    if (colEls[idx].get(0).parentNode === colGroup[0]) {
      return;
    }
    for (var i = idx + 1; i < colEls.length; i++) {
      if (colGroup[0] === colEls[i].get(0).parentNode) {
        found = i;
        break;
      }
    }
    if (found !== null) {
      colEls[idx].insertBefore(colEls[found][0]);
    } else {
      colGroup.append(colEls[idx]);
    }
  },
  /**
   * Get and store nodes from a cell - use for node moving renderers
   *
   * @param {*} dt DT instance
   * @param {*} row Row index
   * @param {*} col Column index
   */
  _childNodes: function(dt2, row, col) {
    var name2 = row + "-" + col;
    if (this.s.childNodeStore[name2]) {
      return this.s.childNodeStore[name2];
    }
    var nodes = [];
    var children = dt2.cell(row, col).node().childNodes;
    for (var i = 0, ien = children.length; i < ien; i++) {
      nodes.push(children[i]);
    }
    this.s.childNodeStore[name2] = nodes;
    return nodes;
  },
  /**
   * Restore nodes from the cache to a table cell
   *
   * @param {*} dt DT instance
   * @param {*} row Row index
   * @param {*} col Column index
   */
  _childNodesRestore: function(dt2, row, col) {
    var name2 = row + "-" + col;
    if (!this.s.childNodeStore[name2]) {
      return;
    }
    var node = dt2.cell(row, col).node();
    var store = this.s.childNodeStore[name2];
    if (store.length > 0) {
      var parent = store[0].parentNode;
      var parentChildren = parent.childNodes;
      var a2 = [];
      for (var i = 0, ien = parentChildren.length; i < ien; i++) {
        a2.push(parentChildren[i]);
      }
      for (var j2 = 0, jen = a2.length; j2 < jen; j2++) {
        node.appendChild(a2[j2]);
      }
    }
    this.s.childNodeStore[name2] = void 0;
  },
  /**
   * Calculate the visibility for the columns in a table for a given
   * breakpoint. The result is pre-determined based on the class logic if
   * class names are used to control all columns, but the width of the table
   * is also used if there are columns which are to be automatically shown
   * and hidden.
   *
   * @param  {string} breakpoint Breakpoint name to use for the calculation
   * @return {array} Array of boolean values initiating the visibility of each
   *   column.
   *  @private
   */
  _columnsVisiblity: function(breakpoint) {
    var dt2 = this.s.dt;
    var columns = this.s.columns;
    var i, ien;
    var order2 = columns.map(function(col, idx) {
      return {
        columnIdx: idx,
        priority: col.priority
      };
    }).sort(function(a2, b2) {
      if (a2.priority !== b2.priority) {
        return a2.priority - b2.priority;
      }
      return a2.columnIdx - b2.columnIdx;
    });
    var display = $$2.map(columns, function(col, i2) {
      if (dt2.column(i2).visible() === false) {
        return "not-visible";
      }
      return col.auto && col.minWidth === null ? false : col.auto === true ? "-" : $$2.inArray(breakpoint, col.includeIn) !== -1;
    });
    var requiredWidth = 0;
    for (i = 0, ien = display.length; i < ien; i++) {
      if (display[i] === true) {
        requiredWidth += columns[i].minWidth;
      }
    }
    var scrolling = dt2.settings()[0].oScroll;
    var bar = scrolling.sY || scrolling.sX ? scrolling.iBarWidth : 0;
    var widthAvailable = dt2.table().container().offsetWidth - bar;
    var usedWidth = widthAvailable - requiredWidth;
    for (i = 0, ien = display.length; i < ien; i++) {
      if (columns[i].control) {
        usedWidth -= columns[i].minWidth;
      }
    }
    var empty = false;
    for (i = 0, ien = order2.length; i < ien; i++) {
      var colIdx = order2[i].columnIdx;
      if (display[colIdx] === "-" && !columns[colIdx].control && columns[colIdx].minWidth) {
        if (empty || usedWidth - columns[colIdx].minWidth < 0) {
          empty = true;
          display[colIdx] = false;
        } else {
          display[colIdx] = true;
        }
        usedWidth -= columns[colIdx].minWidth;
      }
    }
    var showControl = false;
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (!columns[i].control && !columns[i].never && display[i] === false) {
        showControl = true;
        break;
      }
    }
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (columns[i].control) {
        display[i] = showControl;
      }
      if (display[i] === "not-visible") {
        display[i] = false;
      }
    }
    if ($$2.inArray(true, display) === -1) {
      display[0] = true;
    }
    return display;
  },
  /**
   * Create the internal `columns` array with information about the columns
   * for the table. This includes determining which breakpoints the column
   * will appear in, based upon class names in the column, which makes up the
   * vast majority of this method.
   *
   * @private
   */
  _classLogic: function() {
    var that = this;
    var breakpoints = this.c.breakpoints;
    var dt2 = this.s.dt;
    var columns = dt2.columns().eq(0).map(function(i) {
      var column2 = this.column(i);
      var className = column2.header().className;
      var priority = column2.init().responsivePriority;
      var dataPriority = column2.header().getAttribute("data-priority");
      if (priority === void 0) {
        priority = dataPriority === void 0 || dataPriority === null ? 1e4 : dataPriority * 1;
      }
      return {
        className,
        includeIn: [],
        auto: false,
        control: false,
        never: className.match(/\b(dtr\-)?never\b/) ? true : false,
        priority
      };
    });
    var add = function(colIdx, name2) {
      var includeIn = columns[colIdx].includeIn;
      if ($$2.inArray(name2, includeIn) === -1) {
        includeIn.push(name2);
      }
    };
    var column = function(colIdx, name2, operator, matched) {
      var size, i, ien;
      if (!operator) {
        columns[colIdx].includeIn.push(name2);
      } else if (operator === "max-") {
        size = that._find(name2).width;
        for (i = 0, ien = breakpoints.length; i < ien; i++) {
          if (breakpoints[i].width <= size) {
            add(colIdx, breakpoints[i].name);
          }
        }
      } else if (operator === "min-") {
        size = that._find(name2).width;
        for (i = 0, ien = breakpoints.length; i < ien; i++) {
          if (breakpoints[i].width >= size) {
            add(colIdx, breakpoints[i].name);
          }
        }
      } else if (operator === "not-") {
        for (i = 0, ien = breakpoints.length; i < ien; i++) {
          if (breakpoints[i].name.indexOf(matched) === -1) {
            add(colIdx, breakpoints[i].name);
          }
        }
      }
    };
    columns.each(function(col, i) {
      var classNames2 = col.className.split(" ");
      var hasClass2 = false;
      for (var k2 = 0, ken = classNames2.length; k2 < ken; k2++) {
        var className = classNames2[k2].trim();
        if (className === "all" || className === "dtr-all") {
          hasClass2 = true;
          col.includeIn = $$2.map(breakpoints, function(a2) {
            return a2.name;
          });
          return;
        } else if (className === "none" || className === "dtr-none" || col.never) {
          hasClass2 = true;
          return;
        } else if (className === "control" || className === "dtr-control") {
          hasClass2 = true;
          col.control = true;
          return;
        }
        $$2.each(breakpoints, function(j2, breakpoint) {
          var brokenPoint = breakpoint.name.split("-");
          var re2 = new RegExp(
            "(min\\-|max\\-|not\\-)?(" + brokenPoint[0] + ")(\\-[_a-zA-Z0-9])?"
          );
          var match = className.match(re2);
          if (match) {
            hasClass2 = true;
            if (match[2] === brokenPoint[0] && match[3] === "-" + brokenPoint[1]) {
              column(
                i,
                breakpoint.name,
                match[1],
                match[2] + match[3]
              );
            } else if (match[2] === brokenPoint[0] && !match[3]) {
              column(i, breakpoint.name, match[1], match[2]);
            }
          }
        });
      }
      if (!hasClass2) {
        col.auto = true;
      }
    });
    this.s.columns = columns;
  },
  /**
   * Update the cells to show the correct control class / button
   * @private
   */
  _controlClass: function() {
    if (this.c.details.type === "inline") {
      var dt2 = this.s.dt;
      var columnsVis = this.s.current;
      var firstVisible = $$2.inArray(true, columnsVis);
      dt2.cells(
        null,
        function(idx) {
          return idx !== firstVisible;
        },
        { page: "current" }
      ).nodes().to$().filter(".dtr-control").removeClass("dtr-control");
      if (firstVisible >= 0) {
        dt2.cells(null, firstVisible, { page: "current" }).nodes().to$().addClass("dtr-control");
      }
    }
    this._tabIndexes();
  },
  /**
   * Show the details for the child row
   *
   * @param  {DataTables.Api} row    API instance for the row
   * @param  {boolean}        update Update flag
   * @private
   */
  _detailsDisplay: function(row, update2) {
    var that = this;
    var dt2 = this.s.dt;
    var details = this.c.details;
    var event = function(res3) {
      $$2(row.node()).toggleClass("dtr-expanded", res3 !== false);
      $$2(dt2.table().node()).triggerHandler("responsive-display.dt", [
        dt2,
        row,
        res3,
        update2
      ]);
    };
    if (details && details.type !== false) {
      var renderer = typeof details.renderer === "string" ? Responsive.renderer[details.renderer]() : details.renderer;
      var res2 = details.display(
        row,
        update2,
        function() {
          return renderer.call(
            that,
            dt2,
            row[0][0],
            that._detailsObj(row[0])
          );
        },
        function() {
          event(false);
        }
      );
      if (typeof res2 === "boolean") {
        event(res2);
      }
    }
  },
  /**
   * Initialisation for the details handler
   *
   * @private
   */
  _detailsInit: function() {
    var that = this;
    var dt2 = this.s.dt;
    var details = this.c.details;
    if (details.type === "inline") {
      details.target = "td.dtr-control, th.dtr-control";
    }
    $$2(dt2.table().body()).on("keyup.dtr", "td, th", function(e2) {
      if (e2.keyCode === 13 && $$2(this).data("dtr-keyboard")) {
        $$2(this).click();
      }
    });
    var target = details.target;
    var selector = typeof target === "string" ? target : "td, th";
    if (target !== void 0 || target !== null) {
      $$2(dt2.table().body()).on(
        "click.dtr mousedown.dtr mouseup.dtr",
        selector,
        function(e2) {
          if (!$$2(dt2.table().node()).hasClass("collapsed")) {
            return;
          }
          if ($$2.inArray(
            $$2(this).closest("tr").get(0),
            dt2.rows().nodes().toArray()
          ) === -1) {
            return;
          }
          if (typeof target === "number") {
            var targetIdx = target < 0 ? dt2.columns().eq(0).length + target : target;
            if (dt2.cell(this).index().column !== targetIdx) {
              return;
            }
          }
          var row = dt2.row($$2(this).closest("tr"));
          if (e2.type === "click") {
            that._detailsDisplay(row, false);
          } else if (e2.type === "mousedown") {
            $$2(this).css("outline", "none");
          } else if (e2.type === "mouseup") {
            $$2(this).trigger("blur").css("outline", "");
          }
        }
      );
    }
  },
  /**
   * Get the details to pass to a renderer for a row
   * @param  {int} rowIdx Row index
   * @private
   */
  _detailsObj: function(rowIdx) {
    var that = this;
    var dt2 = this.s.dt;
    return $$2.map(this.s.columns, function(col, i) {
      if (col.never || col.control) {
        return;
      }
      var dtCol = dt2.settings()[0].aoColumns[i];
      return {
        className: dtCol.sClass,
        columnIndex: i,
        data: dt2.cell(rowIdx, i).render(that.c.orthogonal),
        hidden: dt2.column(i).visible() && !that.s.current[i],
        rowIndex: rowIdx,
        title: dt2.column(i).title()
      };
    });
  },
  /**
   * Find a breakpoint object from a name
   *
   * @param  {string} name Breakpoint name to find
   * @return {object}      Breakpoint description object
   * @private
   */
  _find: function(name2) {
    var breakpoints = this.c.breakpoints;
    for (var i = 0, ien = breakpoints.length; i < ien; i++) {
      if (breakpoints[i].name === name2) {
        return breakpoints[i];
      }
    }
  },
  /**
   * Re-create the contents of the child rows as the display has changed in
   * some way.
   *
   * @private
   */
  _redrawChildren: function() {
    var that = this;
    var dt2 = this.s.dt;
    dt2.rows({ page: "current" }).iterator("row", function(settings, idx) {
      that._detailsDisplay(dt2.row(idx), true);
    });
  },
  /**
   * Alter the table display for a resized viewport. This involves first
   * determining what breakpoint the window currently is in, getting the
   * column visibilities to apply and then setting them.
   *
   * @param  {boolean} forceRedraw Force a redraw
   * @private
   */
  _resize: function(forceRedraw) {
    var that = this;
    var dt2 = this.s.dt;
    var width = $$2(window).innerWidth();
    var breakpoints = this.c.breakpoints;
    var breakpoint = breakpoints[0].name;
    var columns = this.s.columns;
    var i, ien;
    var oldVis = this.s.current.slice();
    for (i = breakpoints.length - 1; i >= 0; i--) {
      if (width <= breakpoints[i].width) {
        breakpoint = breakpoints[i].name;
        break;
      }
    }
    var columnsVis = this._columnsVisiblity(breakpoint);
    this.s.current = columnsVis;
    var collapsedClass = false;
    for (i = 0, ien = columns.length; i < ien; i++) {
      if (columnsVis[i] === false && !columns[i].never && !columns[i].control && !dt2.column(i).visible() === false) {
        collapsedClass = true;
        break;
      }
    }
    $$2(dt2.table().node()).toggleClass("collapsed", collapsedClass);
    var changed = false;
    var visible = 0;
    var dtSettings = dt2.settings()[0];
    var colGroup = $$2(dt2.table().node()).children("colgroup");
    var colEls = dtSettings.aoColumns.map(function(col) {
      return col.colEl;
    });
    dt2.columns().eq(0).each(function(colIdx, i2) {
      if (!dt2.column(colIdx).visible()) {
        return;
      }
      if (columnsVis[i2] === true) {
        visible++;
      }
      if (forceRedraw || columnsVis[i2] !== oldVis[i2]) {
        changed = true;
        that._setColumnVis(colIdx, columnsVis[i2]);
      }
      if (!columnsVis[i2]) {
        colEls[i2].detach();
      } else {
        that._colGroupAttach(colGroup, colEls, i2);
      }
    });
    if (changed) {
      dt2.columns.adjust();
      this._redrawChildren();
      $$2(dt2.table().node()).trigger("responsive-resize.dt", [
        dt2,
        this._responsiveOnlyHidden()
      ]);
      if (dt2.page.info().recordsDisplay === 0) {
        $$2("td", dt2.table().body()).eq(0).attr("colspan", visible);
      }
    }
    that._controlClass();
  },
  /**
   * Determine the width of each column in the table so the auto column hiding
   * has that information to work with. This method is never going to be 100%
   * perfect since column widths can change slightly per page, but without
   * seriously compromising performance this is quite effective.
   *
   * @private
   */
  _resizeAuto: function() {
    var dt2 = this.s.dt;
    var columns = this.s.columns;
    var that = this;
    var visibleColumns = dt2.columns().indexes().filter(function(idx) {
      return dt2.column(idx).visible();
    });
    if (!this.c.auto) {
      return;
    }
    if ($$2.inArray(
      true,
      $$2.map(columns, function(c2) {
        return c2.auto;
      })
    ) === -1) {
      return;
    }
    var clonedTable = dt2.table().node().cloneNode(false);
    var clonedHeader = $$2(dt2.table().header().cloneNode(false)).appendTo(
      clonedTable
    );
    var clonedFooter = $$2(dt2.table().footer().cloneNode(false)).appendTo(
      clonedTable
    );
    var clonedBody = $$2(dt2.table().body()).clone(false, false).empty().appendTo(clonedTable);
    clonedTable.style.width = "auto";
    dt2.table().header.structure(visibleColumns).forEach((row) => {
      var cells = row.filter(function(el) {
        return el ? true : false;
      }).map(function(el) {
        return $$2(el.cell).clone(false).css("display", "table-cell").css("width", "auto").css("min-width", 0);
      });
      $$2("<tr/>").append(cells).appendTo(clonedHeader);
    });
    var emptyRow = $$2("<tr/>").appendTo(clonedBody);
    for (var i = 0; i < visibleColumns.count(); i++) {
      emptyRow.append("<td/>");
    }
    if (this.c.details.renderer._responsiveMovesNodes) {
      dt2.rows({ page: "current" }).every(function(rowIdx) {
        var node = this.node();
        if (!node) {
          return;
        }
        var tr = node.cloneNode(false);
        dt2.cells(rowIdx, visibleColumns).every(function(rowIdx2, colIdx) {
          var store = that.s.childNodeStore[rowIdx + "-" + colIdx];
          if (store) {
            $$2(this.node().cloneNode(false)).append($$2(store).clone()).appendTo(tr);
          } else {
            $$2(this.node()).clone(false).appendTo(tr);
          }
        });
        clonedBody.append(tr);
      });
    } else {
      $$2(clonedBody).append($$2(dt2.rows({ page: "current" }).nodes()).clone(false)).find("th, td").css("display", "");
    }
    clonedBody.find("th, td").css("display", "");
    dt2.table().footer.structure(visibleColumns).forEach((row) => {
      var cells = row.filter(function(el) {
        return el ? true : false;
      }).map(function(el) {
        return $$2(el.cell).clone(false).css("display", "table-cell").css("width", "auto").css("min-width", 0);
      });
      $$2("<tr/>").append(cells).appendTo(clonedFooter);
    });
    if (this.c.details.type === "inline") {
      $$2(clonedTable).addClass("dtr-inline collapsed");
    }
    $$2(clonedTable).find("[name]").removeAttr("name");
    $$2(clonedTable).css("position", "relative");
    var inserted = $$2("<div/>").css({
      width: 1,
      height: 1,
      overflow: "hidden",
      clear: "both"
    }).append(clonedTable);
    inserted.insertBefore(dt2.table().node());
    emptyRow.children().each(function(i2) {
      var idx = dt2.column.index("fromVisible", i2);
      columns[idx].minWidth = this.offsetWidth || 0;
    });
    inserted.remove();
  },
  /**
   * Get the state of the current hidden columns - controlled by Responsive only
   */
  _responsiveOnlyHidden: function() {
    var dt2 = this.s.dt;
    return $$2.map(this.s.current, function(v2, i) {
      if (dt2.column(i).visible() === false) {
        return true;
      }
      return v2;
    });
  },
  /**
   * Set a column's visibility.
   *
   * We don't use DataTables' column visibility controls in order to ensure
   * that column visibility can Responsive can no-exist. Since only IE8+ is
   * supported (and all evergreen browsers of course) the control of the
   * display attribute works well.
   *
   * @param {integer} col      Column index
   * @param {boolean} showHide Show or hide (true or false)
   * @private
   */
  _setColumnVis: function(col, showHide) {
    var that = this;
    var dt2 = this.s.dt;
    var display = showHide ? "" : "none";
    this._setHeaderVis(col, showHide, dt2.table().header.structure());
    this._setHeaderVis(col, showHide, dt2.table().footer.structure());
    dt2.column(col).nodes().to$().css("display", display).toggleClass("dtr-hidden", !showHide);
    if (!$$2.isEmptyObject(this.s.childNodeStore)) {
      dt2.cells(null, col).indexes().each(function(idx) {
        that._childNodesRestore(dt2, idx.row, idx.column);
      });
    }
  },
  /**
   * Set the a column's visibility, taking into account multiple rows
   * in a header / footer and colspan attributes
   * @param {*} col
   * @param {*} showHide
   * @param {*} structure
   */
  _setHeaderVis: function(col, showHide, structure) {
    var that = this;
    var display = showHide ? "" : "none";
    structure.forEach(function(row, rowIdx) {
      for (var col2 = 0; col2 < row.length; col2++) {
        if (row[col2] && row[col2].rowspan > 1) {
          var span = row[col2].rowspan;
          for (var i = 1; i < span; i++) {
            structure[rowIdx + i][col2] = {};
          }
        }
      }
    });
    structure.forEach(function(row) {
      if (row[col] && row[col].cell) {
        $$2(row[col].cell).css("display", display).toggleClass("dtr-hidden", !showHide);
      } else {
        var search = col;
        while (search >= 0) {
          if (row[search] && row[search].cell) {
            row[search].cell.colSpan = that._colspan(row, search);
            break;
          }
          search--;
        }
      }
    });
  },
  /**
   * How many columns should this cell span
   *
   * @param {*} row Header structure row
   * @param {*} idx The column index of the cell to span
   */
  _colspan: function(row, idx) {
    var colspan = 1;
    for (var col = idx + 1; col < row.length; col++) {
      if (row[col] === null && this.s.current[col]) {
        colspan++;
      } else if (row[col]) {
        break;
      }
    }
    return colspan;
  },
  /**
   * Update the cell tab indexes for keyboard accessibility. This is called on
   * every table draw - that is potentially inefficient, but also the least
   * complex option given that column visibility can change on the fly. Its a
   * shame user-focus was removed from CSS 3 UI, as it would have solved this
   * issue with a single CSS statement.
   *
   * @private
   */
  _tabIndexes: function() {
    var dt2 = this.s.dt;
    var cells = dt2.cells({ page: "current" }).nodes().to$();
    var ctx = dt2.settings()[0];
    var target = this.c.details.target;
    cells.filter("[data-dtr-keyboard]").removeData("[data-dtr-keyboard]");
    if (typeof target === "number") {
      dt2.cells(null, target, { page: "current" }).nodes().to$().attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
    } else {
      if (target === "td:first-child, th:first-child") {
        target = ">td:first-child, >th:first-child";
      }
      var rows = dt2.rows({ page: "current" }).nodes();
      var nodes = target === "tr" ? $$2(rows) : $$2(target, rows);
      nodes.attr("tabIndex", ctx.iTabIndex).data("dtr-keyboard", 1);
    }
  }
});
Responsive.breakpoints = [
  { name: "desktop", width: Infinity },
  { name: "tablet-l", width: 1024 },
  { name: "tablet-p", width: 768 },
  { name: "mobile-l", width: 480 },
  { name: "mobile-p", width: 320 }
];
Responsive.display = {
  childRow: function(row, update2, render2) {
    var rowNode = $$2(row.node());
    if (update2) {
      if (rowNode.hasClass("dtr-expanded")) {
        row.child(render2(), "child").show();
        return true;
      }
    } else {
      if (!rowNode.hasClass("dtr-expanded")) {
        var rendered = render2();
        if (rendered === false) {
          return false;
        }
        row.child(rendered, "child").show();
        return true;
      } else {
        row.child(false);
        return false;
      }
    }
  },
  childRowImmediate: function(row, update2, render2) {
    var rowNode = $$2(row.node());
    if (!update2 && rowNode.hasClass("dtr-expanded") || !row.responsive.hasHidden()) {
      row.child(false);
      return false;
    } else {
      var rendered = render2();
      if (rendered === false) {
        return false;
      }
      row.child(rendered, "child").show();
      return true;
    }
  },
  // This is a wrapper so the modal options for Bootstrap and jQuery UI can
  // have options passed into them. This specific one doesn't need to be a
  // function but it is for consistency in the `modal` name
  modal: function(options) {
    return function(row, update2, render2, closeCallback) {
      var modal2;
      var rendered = render2();
      if (rendered === false) {
        return false;
      }
      if (!update2) {
        var close2 = function() {
          modal2.remove();
          $$2(document).off("keypress.dtr");
          $$2(row.node()).removeClass("dtr-expanded");
          closeCallback();
        };
        modal2 = $$2('<div class="dtr-modal"/>').append(
          $$2('<div class="dtr-modal-display"/>').append(
            $$2('<div class="dtr-modal-content"/>').data("dtr-row-idx", row.index()).append(rendered)
          ).append(
            $$2(
              '<div class="dtr-modal-close">&times;</div>'
            ).click(function() {
              close2();
            })
          )
        ).append(
          $$2('<div class="dtr-modal-background"/>').click(
            function() {
              close2();
            }
          )
        ).appendTo("body");
        $$2(row.node()).addClass("dtr-expanded");
        $$2(document).on("keyup.dtr", function(e2) {
          if (e2.keyCode === 27) {
            e2.stopPropagation();
            close2();
          }
        });
      } else {
        modal2 = $$2("div.dtr-modal-content");
        if (modal2.length && row.index() === modal2.data("dtr-row-idx")) {
          modal2.empty().append(rendered);
        } else {
          return null;
        }
      }
      if (options && options.header) {
        $$2("div.dtr-modal-content").prepend(
          "<h2>" + options.header(row) + "</h2>"
        );
      }
      return true;
    };
  }
};
Responsive.renderer = {
  listHiddenNodes: function() {
    var fn3 = function(api, rowIdx, columns) {
      var that = this;
      var ul = $$2(
        '<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
      );
      var found = false;
      $$2.each(columns, function(i, col) {
        if (col.hidden) {
          var klass = col.className ? 'class="' + col.className + '"' : "";
          $$2(
            "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + "</span> </li>"
          ).append(
            $$2('<span class="dtr-data"/>').append(
              that._childNodes(
                api,
                col.rowIndex,
                col.columnIndex
              )
            )
          ).appendTo(ul);
          found = true;
        }
      });
      return found ? ul : false;
    };
    fn3._responsiveMovesNodes = true;
    return fn3;
  },
  listHidden: function() {
    return function(api, rowIdx, columns) {
      var data2 = $$2.map(columns, function(col) {
        var klass = col.className ? 'class="' + col.className + '"' : "";
        return col.hidden ? "<li " + klass + ' data-dtr-index="' + col.columnIndex + '" data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><span class="dtr-title">' + col.title + '</span> <span class="dtr-data">' + col.data + "</span></li>" : "";
      }).join("");
      return data2 ? $$2(
        '<ul data-dtr-index="' + rowIdx + '" class="dtr-details"/>'
      ).append(data2) : false;
    };
  },
  tableAll: function(options) {
    options = $$2.extend(
      {
        tableClass: ""
      },
      options
    );
    return function(api, rowIdx, columns) {
      var data2 = $$2.map(columns, function(col) {
        var klass = col.className ? 'class="' + col.className + '"' : "";
        return "<tr " + klass + ' data-dt-row="' + col.rowIndex + '" data-dt-column="' + col.columnIndex + '"><td>' + ("" !== col.title ? col.title + ":" : "") + "</td> <td>" + col.data + "</td></tr>";
      }).join("");
      return $$2(
        '<table class="' + options.tableClass + ' dtr-details" width="100%"/>'
      ).append(data2);
    };
  }
};
Responsive.defaults = {
  /**
   * List of breakpoints for the instance. Note that this means that each
   * instance can have its own breakpoints. Additionally, the breakpoints
   * cannot be changed once an instance has been creased.
   *
   * @type {Array}
   * @default Takes the value of `Responsive.breakpoints`
   */
  breakpoints: Responsive.breakpoints,
  /**
   * Enable / disable auto hiding calculations. It can help to increase
   * performance slightly if you disable this option, but all columns would
   * need to have breakpoint classes assigned to them
   *
   * @type {Boolean}
   * @default  `true`
   */
  auto: true,
  /**
   * Details control. If given as a string value, the `type` property of the
   * default object is set to that value, and the defaults used for the rest
   * of the object - this is for ease of implementation.
   *
   * The object consists of the following properties:
   *
   * * `display` - A function that is used to show and hide the hidden details
   * * `renderer` - function that is called for display of the child row data.
   *   The default function will show the data from the hidden columns
   * * `target` - Used as the selector for what objects to attach the child
   *   open / close to
   * * `type` - `false` to disable the details display, `inline` or `column`
   *   for the two control types
   *
   * @type {Object|string}
   */
  details: {
    display: Responsive.display.childRow,
    renderer: Responsive.renderer.listHidden(),
    target: 0,
    type: "inline"
  },
  /**
   * Orthogonal data request option. This is used to define the data type
   * requested when Responsive gets the data to show in the child row.
   *
   * @type {String}
   */
  orthogonal: "display"
};
var Api = $$2.fn.dataTable.Api;
Api.register("responsive()", function() {
  return this;
});
Api.register("responsive.index()", function(li2) {
  li2 = $$2(li2);
  return {
    column: li2.data("dtr-index"),
    row: li2.parent().data("dtr-index")
  };
});
Api.register("responsive.rebuild()", function() {
  return this.iterator("table", function(ctx) {
    if (ctx._responsive) {
      ctx._responsive._classLogic();
    }
  });
});
Api.register("responsive.recalc()", function() {
  return this.iterator("table", function(ctx) {
    if (ctx._responsive) {
      ctx._responsive._resizeAuto();
      ctx._responsive._resize();
    }
  });
});
Api.register("responsive.hasHidden()", function() {
  var ctx = this.context[0];
  return ctx._responsive ? $$2.inArray(false, ctx._responsive._responsiveOnlyHidden()) !== -1 : false;
});
Api.registerPlural(
  "columns().responsiveHidden()",
  "column().responsiveHidden()",
  function() {
    return this.iterator(
      "column",
      function(settings, column) {
        return settings._responsive ? settings._responsive._responsiveOnlyHidden()[column] : false;
      },
      1
    );
  }
);
Responsive.version = "3.0.4";
$$2.fn.dataTable.Responsive = Responsive;
$$2.fn.DataTable.Responsive = Responsive;
$$2(document).on("preInit.dt.dtr", function(e2, settings, json) {
  if (e2.namespace !== "dt") {
    return;
  }
  if ($$2(settings.nTable).hasClass("responsive") || $$2(settings.nTable).hasClass("dt-responsive") || settings.oInit.responsive || DataTable.defaults.responsive) {
    var init2 = settings.oInit.responsive;
    if (init2 !== false) {
      new Responsive(settings, $$2.isPlainObject(init2) ? init2 : {});
    }
  }
});
/*! Bootstrap 5 integration for DataTables' Responsive
 * © SpryMedia Ltd - datatables.net/license
 */
let $$1 = jQuery$1;
var _display = DataTable.Responsive.display;
var _original = _display.modal;
var _modal = $$1(
  '<div class="modal fade dtr-bs-modal" role="dialog"><div class="modal-dialog" role="document"><div class="modal-content"><div class="modal-header"><button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button></div><div class="modal-body"/></div></div></div>'
);
var modal;
var _bs = window.bootstrap;
DataTable.Responsive.bootstrap = function(bs) {
  _bs = bs;
};
function getBs() {
  let dtBs = DataTable.use("bootstrap");
  if (dtBs) {
    return dtBs;
  }
  if (_bs) {
    return _bs;
  }
  throw new Error("No Bootstrap library. Set it with `DataTable.use(bootstrap);`");
}
_display.modal = function(options) {
  if (!modal && _bs.Modal) {
    let localBs = getBs();
    modal = new localBs.Modal(_modal[0]);
  }
  return function(row, update2, render2, closeCallback) {
    if (!modal) {
      return _original(row, update2, render2, closeCallback);
    } else {
      var rendered = render2();
      if (rendered === false) {
        return false;
      }
      if (!update2) {
        if (options && options.header) {
          var header = _modal.find("div.modal-header");
          var button = header.find("button").detach();
          header.empty().append('<h4 class="modal-title">' + options.header(row) + "</h4>").append(button);
        }
        _modal.find("div.modal-body").empty().append(rendered);
        _modal.data("dtr-row-idx", row.index()).one("hidden.bs.modal", closeCallback).appendTo("body");
        modal.show();
      } else {
        if ($$1.contains(document, _modal[0]) && row.index() === _modal.data("dtr-row-idx")) {
          _modal.find("div.modal-body").empty().append(rendered);
        } else {
          return null;
        }
      }
      return true;
    }
  };
};
const fetchPage = ($url) => {
  const headers = {
    "X-Citadel-Request": "page"
  };
  return axios.get($url, { headers }).then((response2) => {
    console.log("Status:", response2.status);
    console.log("Headers:", response2.headers);
    console.log("Data:", response2.data);
    return response2.data;
  }).catch((error2) => {
    if (error2.response) {
      console.error("Error Status:", error2.response.status);
      console.error("Error Data:", error2.response.data);
      console.error("Error Headers:", error2.response.headers);
    } else if (error2.request) {
      console.error("No Response:", error2.request);
    } else {
      console.error("Error Message:", error2.message);
    }
    return error2.response;
  });
};
const isEmpty$1 = (value) => {
  if (value == null)
    return true;
  if (Array.isArray(value)) {
    return value.length === 0;
  } else if (typeof value === "object") {
    return Object.keys(value).length === 0;
  }
  return false;
};
function getFormData($form) {
  const formData = {};
  $form.serializeArray().forEach((n2) => {
    const name2 = n2.name.endsWith("[]") ? n2.name.slice(0, -2) : n2.name;
    formData[name2] = formData[name2] ? Array.isArray(formData[name2]) ? formData[name2].concat(n2.value) : [formData[name2], n2.value] : n2.value;
  });
  return formData;
}
function handleMutations(mutationsList) {
  for (const mutation of mutationsList) {
    if (mutation.type === "childList") {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === "CITADEL-WIDGET") {
          handleNewWidget(node);
        }
      });
    }
  }
}
function startObserver() {
  const observer = new MutationObserver(handleMutations);
  const targetNode = document.body;
  const config2 = { childList: true, subtree: true };
  observer.observe(targetNode, config2);
}
function addQueryParams(url, newParams) {
  let urlObj = new URL(url, window.location.origin);
  $.each(newParams, function(key, value) {
    urlObj.searchParams.set(key, value);
  });
  return urlObj.toString();
}
function citadelFetchComponentLifeCycle(c2, f2 = "reactive") {
  return addQueryParams(location.href, { f: f2, c: c2 });
}
function initGlobalFunction($2) {
  console.log("INIT GLOBAL FUNCTION", $2);
  window.number_format = (number, decimals, dec_point, thousands_sep) => {
    number = (number + "").replace(/[^0-9+\-Ee.]/g, "");
    var n2 = !isFinite(+number) ? 0 : +number, prec = !isFinite(+decimals) ? 0 : Math.abs(decimals), sep = typeof thousands_sep === "undefined" ? "," : thousands_sep, dec = typeof dec_point === "undefined" ? "." : dec_point, s2 = "", toFixedFix = function(n3, prec2) {
      var k2 = Math.pow(10, prec2);
      return "" + Math.round(n3 * k2) / k2;
    };
    s2 = (prec ? toFixedFix(n2, prec) : "" + Math.round(n2)).split(".");
    if (s2[0].length > 3) {
      s2[0] = s2[0].replace(/\B(?=(?:\d{3})+(?!\d))/g, sep);
    }
    if ((s2[1] || "").length < prec) {
      s2[1] = s2[1] || "";
      s2[1] += new Array(prec - s2[1].length + 1).join("0");
    }
    return s2.join(dec);
  };
  window.formatCurrency = (value) => {
    return number_format(value, 0, ",", ".");
  };
  window.formatVolume = (value) => {
    return number_format(value, 3, ",", ".");
  };
  window.isPromise = (p2) => {
    return p2 && Object.prototype.toString.call(p2) === "[object Promise]";
  };
  window.showModal = async (event) => {
    const $el = $2(event.target);
    const modal_target = $el.data("modal-target");
    const $modal = $2(modal_target);
    const before_show = $modal.data("before-show");
    const modal_param = $el.data("modal-param");
    console.log(before_show);
    if (before_show) {
      let res2;
      if (modal_param === "" || modal_param === void 0 || modal_param === null) {
        res2 = window[before_show]();
      } else {
        res2 = ajaxItem(modal_param);
      }
      if (isPromise(res2)) {
        console.log("IS PROMISE: ", $2, window.$);
        $2("body").loadingOverlay();
        await res2;
      }
      if (!res2) {
        $2("body").loadingOverlay("remove");
        return;
      }
    }
    $modal.appendTo("body").modal("show");
    $2("body").loadingOverlay("remove");
  };
  window.ModalTable = async (table, url) => {
    let $table = $2(table);
    $table.attr("id");
    $table.attr("id");
    $table.attr("afterEffect") || "";
    return await $2.get(url + "?get_config=1").done((data2) => {
      $table.attr("config", {
        method: "get",
        config: {
          refresh: url
        }
      });
      CitadelTable($table);
      return true;
    }).fail(function() {
      return false;
    });
  };
}
function bootstrapHelperOnce() {
  if (window.bootstrapHelperOnceCalled == true)
    return;
  document.addEventListener("click", function(e2) {
    const toggleBtn = e2.target.closest('[data-bs-toggle="dropdown"]');
    if (toggleBtn) {
      const dd = bootstrap.Dropdown.getOrCreateInstance(toggleBtn);
      dd.toggle();
    }
  });
  window.bootstrapHelperOnceCalled = true;
}
function initSummerNote($2) {
  $2(".summer").summernote({
    height: "200px",
    toolbar: [
      // [groupName, [list of button]]
      ["style", ["bold", "italic", "underline", "clear"]],
      ["font", ["strikethrough", "superscript", "subscript"]],
      ["fontsize", ["fontsize"]],
      ["color", ["color"]],
      ["para", ["ul", "ol", "paragraph"]],
      ["height", ["height"]],
      ["table", ["table"]],
      ["undo"],
      ["redo"]
    ],
    shortcuts: true,
    lineHeights: [
      "0.2",
      "0.3",
      "0.4",
      "0.5",
      "0.6",
      "0.8",
      "1.0",
      "1.2",
      "1.4",
      "1.5",
      "2.0",
      "3.0"
    ],
    popover: {
      table: [
        ["add", ["addRowDown", "addRowUp", "addColLeft", "addColRight"]],
        ["delete", ["deleteRow", "deleteCol", "deleteTable"]]
      ],
      air: [
        ["color", ["color"]],
        ["font", ["bold", "underline", "clear"]],
        ["para", ["ul", "paragraph"]],
        ["table", ["table"]]
      ]
    }
  });
}
function initBootstrapComponents() {
  bootstrapHelperOnce();
  $('[data-bs-toggle="dropdown"]').each(function() {
    var _a2;
    (_a2 = bootstrap.Dropdown.getInstance(this)) == null ? void 0 : _a2.dispose();
    bootstrap.Dropdown.getOrCreateInstance(this);
  });
  document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach((el) => {
    new bootstrap.Tooltip(el);
  });
  document.querySelectorAll('[data-bs-toggle="popover"]').forEach((el) => {
    new bootstrap.Popover(el);
  });
  document.querySelectorAll('[data-bs-toggle="tab"]').forEach((el) => {
    new bootstrap.Tab(el);
  });
  document.querySelectorAll('[data-bs-toggle="collapse"]').forEach((el) => {
    new bootstrap.Collapse(el, { toggle: false });
  });
}
function formSubmit$1(form_target, after_submit, getPlugins2) {
  const $form = $(form_target);
  const data2 = serializeFormData($form.serializeArray());
  let url = $form.attr("action");
  let method = $form.attr("method");
  if (window.main_form_data) {
    data2.raw = {
      ...window.main_form_data
    };
  }
  Pace.track(function() {
    $form.find('input, button[type="submit"]').prop("disabled", true);
    submitFormAction(url, method, data2, { citadel: { sweet_alert: { after_confirm: after_submit } } }, getPlugins2);
    $form.find('input, button[type="submit"]').prop("disabled", false);
  });
}
function submitFormAction(url, method, data2, config2 = {}, getPlugins2) {
  let headers = {
    "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr(
      "content"
    ),
    "Content-Type": config2.contentType ?? "application/json",
    "x-request-via": "citadel-form-wrapped"
  };
  $.LoadingOverlay();
  return $.ajax({
    url,
    headers,
    type: method,
    data: JSON.stringify(data2),
    success: function(json) {
      $.LoadingOverlay("remove");
      if (json.swal) {
        Swal.fire(json.swal).then(() => {
          if (json.swal.redirectUrl) {
            window.location.href = json.swal.redirectUrl;
          }
        });
        return json;
      }
      if (json.citadel) {
        getPlugins2(json.citadel).set(config2.citadel).init();
      } else if (json.status == "success") {
        Swal.fire(config2.swalSuccessMessage);
      } else {
        if (config2.swalErrorMessage) {
          Swal.fire(config2.swalErrorMessage);
        } else {
          Swal.fire({
            type: "error",
            html: json.error_message
          });
        }
      }
      return json;
    },
    error: function(res2) {
      const json = res2.responseJSON;
      $.LoadingOverlay("remove");
      if (res2.status == 422) {
        showFormValidationError(json);
        return;
      }
      if (json.citadel) {
        getPlugins2(json.citadel).set(config2.citadel).init();
      } else if (config2.swalFatalErrorMessage) {
        Swal.fire(config2.swalFatalErrorMessage);
      } else if (json.error) {
        Swal.fire({
          type: "error",
          html: json.error.message
        });
      } else {
        if (json.message) {
          Swal.fire({
            type: "error",
            title: "Terjadi kesalahan.",
            html: json.message
          });
        } else {
          Swal.fire({
            type: "error",
            html: "Terjadi kesalahan."
          });
        }
      }
    },
    complete: () => {
      $.LoadingOverlay("remove");
    }
  });
}
function serializeFormData(array) {
  return array.reduce((acc, input) => {
    $(`input[name="${input.name}"]`).removeClass("invalid");
    const isArrayKey = input.name.endsWith("[]");
    const key = isArrayKey ? input.name.slice(0, -2) : input.name;
    acc[key] = isArrayKey ? (acc[key] || []).concat(input.value) : input.value;
    return acc;
  }, {});
}
async function CitadelSwal(args) {
  var _a2;
  const { method, config: config2, after_confirm, after_confirm_args, id, name: name2 } = args;
  if (config2.view) {
    $.LoadingOverlay();
    config2.html = await $.get(config2.view);
    $.LoadingOverlay("remove");
  }
  const isForm = $(config2.html).find("form").length > 0;
  if ((_a2 = config2.sections) == null ? void 0 : _a2.script) {
    const className = "script-" + name2;
    if ($("." + className).length === 0) {
      var script = document.createElement("script");
      script.type = "text/javascript";
      script.className = className;
      var scriptContent = config2.sections.script.match(/<script\b[^>]*>([\s\S]*?)<\/script>/i);
      if (scriptContent && scriptContent[1]) {
        script.text = scriptContent[1];
        document.body.appendChild(script);
      } else {
        console.error("No script content found");
      }
    }
  }
  const preConfirm = async () => {
    const form = $("#swal2-content form");
    if (!form)
      return;
    let headers = {
      "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr(
        "content"
      ),
      "Content-Type": "application/json",
      "X-REQUEST-VIA": "citadel-ajax"
    };
    var data2 = getFormData(form);
    const url = form.attr("action");
    const ajax_config = {
      url,
      headers,
      method: form.attr("method") || "GET",
      data: JSON.stringify(data2)
    };
    try {
      const response2 = await $.ajax(ajax_config).done(function(response3) {
        return response3;
      }).fail(function(res2) {
        if (res2.citadel) {
          getPlugins(res2.citadel).init();
        }
        return false;
      });
      return response2;
    } catch (error2) {
      if (error2.responseJSON.citadel) {
        getPlugins(error2.responseJSON.citadel).init();
        return false;
      }
      Swal.showValidationMessage(`Request error: ${error2.message}`);
      return false;
    }
  };
  Swal.fire({
    ...config2,
    showLoaderOnConfirm: isForm,
    allowOutsideClick: () => !Swal.isLoading(),
    preConfirm: isForm ? preConfirm : void 0
  }).then((result) => {
    console.log(result);
    if (result.dismiss == "cancel" || result.dismiss == "backdrop" || result.dismiss == "esc") {
      $("body").LoadingOverlay("remove");
      return;
    }
    if (after_confirm == "reload") {
      $("body").LoadingOverlay();
      window.location.reload();
    }
    if (after_confirm == "redirect") {
      window.location.href = after_confirm_args;
    }
    if ((after_confirm == null ? void 0 : after_confirm.toUpperCase()) == "POST") {
      let headers = {
        "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr(
          "content"
        ),
        "Content-Type": "application/json",
        "X-REQUEST-VIA": "citadel-ajax"
      };
      console.log();
      Pace.track(function() {
        return new Promise((resolve, reject) => {
          $.ajax({
            method: "POST",
            headers,
            url: after_confirm_args
          }).done(function(res2) {
            if (res2.citadel) {
              getPlugins(res2.citadel).init();
            }
            resolve(res2);
          }).fail(function(res2) {
            if (res2.citadel) {
              getPlugins(res2.citadel).init();
            }
            reject(res2);
          }).always(function() {
            $.LoadingOverlay("hide");
          });
        });
      }).then((response2) => {
        console.log("Request was successful:", response2);
        if (response2.citadel.args) {
          const sw = response2.citadel.args;
          if (sw.config) {
            Swal.fire(sw.config).then((r2) => {
              afterConfirm(sw);
            }).catch((e2) => {
              console.log(e2);
            });
          }
        }
      }).catch((error2) => {
        console.log("Request failed:", error2);
      });
    }
    if (after_confirm == "plugins") {
      getPlugins(after_confirm_args).init();
    }
    if (result.value && result.value.citadel) {
      if (result.value.citadel.component) {
        handleComponent(result.value.citadel);
      } else {
        getPlugins(result.value.citadel).init();
      }
    }
  });
  function afterConfirm({ after_confirm: after_confirm2, after_confirm_args: after_confirm_args2, redirectUrl, useEvent }) {
    if (useEvent) {
      let def = useEvent;
      handleEvent(def, "");
    }
    if (redirectUrl) {
      $("body").LoadingOverlay();
      window.location.href = redirectUrl;
    }
    if (after_confirm2 == "none")
      return;
    if (after_confirm2 == "reload") {
      $("body").LoadingOverlay();
      window.location.reload();
    }
  }
}
const plugins = {
  ajax_request: {
    async init(context) {
      $.LoadingOverlay("show");
      const { url, method } = this.args;
      const ajaxConfig = {
        url,
        headers: {
          "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr(
            "content"
          ),
          "X-REQUEST-VIA": "citadel-ajax"
        },
        method: method || "GET"
      };
      const response2 = await $.ajax(ajaxConfig).done(url, function(response3) {
        return response3;
      }).fail(function() {
        toastr["error"](`Failed Ajax Request to: ${url}`);
      }).always(function() {
        $.LoadingOverlay("hide");
      });
      if (response2.citadel) {
        getPlugins(response2.citadel).init();
      }
    },
    args: {}
  },
  citadel_widget: {
    async init(context) {
      return await CitadelWidget(context, this.args);
    },
    args: {}
  },
  toastr: {
    async init() {
      const { type, message } = this.args;
      toastr[type || "info"](message || "test");
    },
    args: {}
  },
  sweet_alert: {
    async init() {
      return await CitadelSwal(this.args);
    },
    args: {}
  },
  form_submit: {
    async init(context) {
      const { form_target, after_submit } = this.args;
      return formSubmit$1(form_target, after_submit, getPlugins);
    },
    args: {}
  }
};
const components = {
  sweetalert: {
    init(args) {
      CitadelSwal(args);
    }
  }
};
function handleComponent(def) {
  components[def.component].init(def.args);
}
function getPlugins(object, context) {
  let available_plugins = {};
  if (typeof object === "string" || object instanceof String)
    object = JSON.parse(object);
  Object.keys(object).forEach((k2) => {
    let plugin2 = plugins[k2];
    if (plugin2 !== void 0) {
      plugin2.args = object[k2];
      available_plugins[k2] = plugin2;
    }
  });
  return {
    init() {
      var _a2;
      for (const [key, value] of Object.entries(this.available_plugins)) {
        (_a2 = this.available_plugins[key]) == null ? void 0 : _a2.init(this.context);
      }
      return this;
    },
    available_plugins,
    context,
    set(citadel) {
      for (const [key, value] of Object.entries(this.available_plugins)) {
        this.available_plugins[key] = { ...value, ...citadel[key] };
      }
      return this;
    }
  };
}
function CitadelButton(element, type) {
  const $el = element;
  let def = JSON.parse($el.attr("data-ct-onclick") || null);
  const disabled = $el.attr("disabled");
  if (disabled == "" | disabled != void 0) {
    $el.on("click", function(e2) {
      e2.preventDefault();
    });
    return;
  }
  if (def == null)
    return;
  $el.on("click", function(e2) {
    e2.preventDefault();
    if (def.event) {
      handleEvent(def, $el);
      return;
    }
    if (def.component) {
      handleComponent(def);
      return;
    }
    if (e2.target.getAttribute("href")) {
      window.location.href = e2.target.getAttribute("href");
      return;
    }
  });
  return $el;
}
function handleEvent(def, $el) {
  const event = new CustomEvent(def.event, {
    detail: { ...def, srcElement: $el }
  });
  window.dispatchEvent(event);
}
const basic = {
  layout: {
    topStart: null,
    bottom: {
      div: {
        className: "bottom-center-table"
      }
    },
    bottomStart: null,
    bottomEnd: null
  },
  paging: false,
  searching: false
};
function CitadelTableWatchEvent() {
  window.addEventListener(
    "CTable:reload",
    async (e2) => {
      const detail = e2.detail;
      const filter_form = $("#" + detail.form_name);
      const args = serializeFormData(filter_form.serializeArray());
      const table = new DataTable.Api("table#" + detail.table_name);
      const url = table.ajax.url();
      table.processing(true);
      await table.ajax.url(addQueryParams(url, args)).load();
      table.processing(false);
    }
  );
  window.addEventListener(
    "CTable:apply-filter",
    async (e2) => {
      const detail = e2.detail;
      const filter_form = $("#" + detail.form_name);
      const args = serializeFormData(filter_form.serializeArray());
      const table = new DataTable.Api("table#" + detail.table_name);
      const url = table.ajax.url();
      table.processing(true);
      await table.ajax.url(addQueryParams(url, args)).load();
      table.processing(false);
    }
  );
  window.addEventListener(
    "CTable:reset-filter",
    async (e2) => {
      const detail = e2.detail;
      const filter_form = $("#" + detail.form_name);
      filter_form.find("select, input").each(function() {
        var _a2;
        $(this).val("").trigger("change");
        (_a2 = this.selectize) == null ? void 0 : _a2.clear();
      });
      const args = serializeFormData(filter_form.serializeArray());
      const table = new DataTable.Api("table#" + detail.table_name);
      const url = table.ajax.url();
      table.processing(true);
      await table.ajax.url(addQueryParams(url, args)).load();
      table.processing(false);
    }
  );
}
function CitadelTable(el) {
  init$2(el);
}
function refresh($table) {
  const name2 = $table.attr("citadel-name");
  const tableInstance = $table;
  if (!tableInstance) {
    console.error(`Table instance "${name2}" not found.`);
    return;
  }
  $table.bootstrapTable("refresh", {
    url: $table.data("current-url"),
    // Access href property
    queryParams: $table.data("query-params")
  });
}
function defaultSources(name2) {
  return {
    "parser": location.href + "?f=parser&c=" + name2,
    "refresh": addQueryParams(location.href, {
      f: "reactive",
      c: name2
    }),
    config: basic
  };
}
function init$2($table) {
  if ($table.is("[citadel-table]")) {
    return old$4($table);
  }
  const name2 = $table.attr("id");
  const c2 = JSON.parse($table.attr("config"));
  const custom = $.extend(defaultSources(name2), c2);
  const dt2 = new DataTable(
    $table,
    $.extend(c2.config, {
      ajax: c2.method == "get" ? {
        url: custom.refresh
      } : {
        url: custom.refresh,
        type: "POST",
        beforeSend: function(request) {
          request.setRequestHeader("X-CSRF-TOKEN", $('meta[name="csrf-token"]').attr("content"));
        }
      }
    })
  );
  dt2.on("draw", function() {
    initBootstrapComponents();
    $(`table#${$table.attr("id")} [data-ct-onclick]`).each(function() {
      CitadelButton($(this));
    });
  });
  if (c2.numbering) {
    numbering(dt2);
    dt2.on("draw", function() {
      numbering(dt2);
    });
  }
  function numbering(dt3) {
    var i = dt3.page.info().start + 1;
    dt3.cells(null, 0, { search: "applied", order: "applied" }).every(function(cell) {
      this.data(i++);
    });
  }
  const filterControl = $("#control-" + name2).removeClass("d-none").detach();
  const filterTarget = $("#button-filter-" + name2);
  filterTarget.html(filterControl);
}
function old$4($table) {
  function init2($table2) {
    const tableUrl = new URL($table2.attr("citadel-src"));
    const configUrl = new URL($table2.attr("citadel-src"));
    const afterEffect = $table2.attr("data-after-effect");
    const filterSelector = $table2.attr("citadel-filter");
    const name2 = $table2.attr("citadel-name");
    const $filter = $(filterSelector);
    if ($table2.hasClass("citadel-created")) {
      return;
    } else {
      $table2.addClass("citadel-created");
    }
    const queryParams = (params) => {
      $filter.find('select, input[type!="button"]').each(function() {
        params[$(this).attr("name")] = $(this).val() || void 0;
      });
      params.context = "get_data";
      params.origin_url = window.location.href;
      params.citadel_component = name2;
      return params;
    };
    const countFilter = () => {
      let total = 0;
      $filter.find('select, input[type!="button"]').each(function() {
        var value = $(this).val();
        if (value.length !== 0) {
          total += !!$(this).val();
        }
      });
      $filter.find(".count-filter").text(total);
    };
    countFilter();
    $filter.on("change", "select, input", countFilter);
    $filter.on("click", "[citadel-apply-filter]", () => refresh($table2));
    $filter.on("click", "[citadel-remove-filter]", () => {
      $filter.find("select, input").each(function() {
        $(this).val("").trigger("change");
      });
      refresh($table2);
    });
    $filter.on("click", "[citadel-toggle-filter]", () => {
      $filter.closest(".bootstrap-table-filter-container").toggleClass("filter-hide");
    });
    configUrl.searchParams.append("citadel_component", name2);
    configUrl.searchParams.append("origin_url", window.location.href);
    configUrl.searchParams.append("context", "get_config");
    $table2.LoadingOverlay("show");
    $.get(configUrl.href).done((data2) => {
      const { tableConfig, filters: filters2 } = data2;
      $table2.bootstrapTable({
        toolbar: filterSelector,
        url: tableUrl.href,
        queryParams,
        cookieIdTable: $table2.attr("id"),
        // Get ID directly from $table
        ...tableConfig,
        onLoadSuccess: window[afterEffect]
        // Ensure afterEffect is a function
      });
      if (tableConfig.clickToSelect) {
        const $selector = $(`#table-container-${name2} [name=${name2}]`);
        $selector.selectize({
          maxItems: tableConfig.singleSelect ? 1 : null,
          valueField: "id",
          labelField: "title",
          options: [],
          create: false,
          persist: false
        });
        $selector.siblings(".selectize-control").removeClass("d-none");
        $selector[0].selectize.lock();
        $table2.on("check.bs.table", function(row, $el) {
          const { idField, valueField } = tableConfig.selectOption;
          function extractField(str2) {
            if (str2.startsWith("$")) {
              return [str2.substring(1), true];
            } else {
              return [str2, false];
            }
          }
          const compileNotation = function(prev, i) {
            const [string, isVar] = extractField(i);
            prev += isVar ? $el[string] : string;
            return prev;
          };
          const id = Array.isArray(idField) ? idField.reduce(compileNotation, "") : [idField].reduce(compileNotation, "");
          const title = Array.isArray(valueField) ? valueField.reduce(compileNotation, "") : [valueField].reduce(compileNotation, "");
          $selector[0].selectize.addOption({
            id,
            title
          });
          $selector[0].selectize.setValue(id);
        });
      }
      const filterId = `#filter_container_${$table2.attr("id")}`;
      $(filters2).insertBefore(filterId);
      $(filterId).find(".select2").select2({
        placeholder: "Pilih opsi",
        width: "100%"
      });
    }).fail(() => {
      console.error(`Failed to fetch table config from ${configUrl.href}`);
    }).always(() => {
      $table2.LoadingOverlay("hide");
    });
    $table2.data("current-url", tableUrl.href);
    $table2.data("query-params", JSON.stringify(queryParams));
  }
  init2($table);
  $table.parent().append(`<div class='text-warning'><i class="ft-alert-triangle"></i>Deprecated table components</div>`);
}
const filepond_min = "";
/*!
 * FilePond 4.32.7
 * Licensed under MIT, https://opensource.org/licenses/MIT/
 * Please visit https://pqina.nl/filepond/ for details.
 */
const isNode = (value) => value instanceof HTMLElement;
const createStore = (initialState, queries2 = [], actions2 = []) => {
  const state2 = {
    ...initialState
  };
  const actionQueue = [];
  const dispatchQueue = [];
  const getState = () => ({ ...state2 });
  const processActionQueue = () => {
    const queue = [...actionQueue];
    actionQueue.length = 0;
    return queue;
  };
  const processDispatchQueue = () => {
    const queue = [...dispatchQueue];
    dispatchQueue.length = 0;
    queue.forEach(({ type, data: data2 }) => {
      dispatch(type, data2);
    });
  };
  const dispatch = (type, data2, isBlocking) => {
    if (isBlocking && !document.hidden) {
      dispatchQueue.push({ type, data: data2 });
      return;
    }
    if (actionHandlers[type]) {
      actionHandlers[type](data2);
    }
    actionQueue.push({
      type,
      data: data2
    });
  };
  const query = (str2, ...args) => queryHandles[str2] ? queryHandles[str2](...args) : null;
  const api = {
    getState,
    processActionQueue,
    processDispatchQueue,
    dispatch,
    query
  };
  let queryHandles = {};
  queries2.forEach((query2) => {
    queryHandles = {
      ...query2(state2),
      ...queryHandles
    };
  });
  let actionHandlers = {};
  actions2.forEach((action) => {
    actionHandlers = {
      ...action(dispatch, query, state2),
      ...actionHandlers
    };
  });
  return api;
};
const defineProperty = (obj, property, definition) => {
  if (typeof definition === "function") {
    obj[property] = definition;
    return;
  }
  Object.defineProperty(obj, property, { ...definition });
};
const forin = (obj, cb) => {
  for (const key in obj) {
    if (!obj.hasOwnProperty(key)) {
      continue;
    }
    cb(key, obj[key]);
  }
};
const createObject = (definition) => {
  const obj = {};
  forin(definition, (property) => {
    defineProperty(obj, property, definition[property]);
  });
  return obj;
};
const attr = (node, name2, value = null) => {
  if (value === null) {
    return node.getAttribute(name2) || node.hasAttribute(name2);
  }
  node.setAttribute(name2, value);
};
const ns = "http://www.w3.org/2000/svg";
const svgElements = ["svg", "path"];
const isSVGElement = (tag) => svgElements.includes(tag);
const createElement = (tag, className, attributes = {}) => {
  if (typeof className === "object") {
    attributes = className;
    className = null;
  }
  const element = isSVGElement(tag) ? document.createElementNS(ns, tag) : document.createElement(tag);
  if (className) {
    if (isSVGElement(tag)) {
      attr(element, "class", className);
    } else {
      element.className = className;
    }
  }
  forin(attributes, (name2, value) => {
    attr(element, name2, value);
  });
  return element;
};
const appendChild = (parent) => (child, index) => {
  if (typeof index !== "undefined" && parent.children[index]) {
    parent.insertBefore(child, parent.children[index]);
  } else {
    parent.appendChild(child);
  }
};
const appendChildView = (parent, childViews) => (view, index) => {
  if (typeof index !== "undefined") {
    childViews.splice(index, 0, view);
  } else {
    childViews.push(view);
  }
  return view;
};
const removeChildView = (parent, childViews) => (view) => {
  childViews.splice(childViews.indexOf(view), 1);
  if (view.element.parentNode) {
    parent.removeChild(view.element);
  }
  return view;
};
const IS_BROWSER = (() => typeof window !== "undefined" && typeof window.document !== "undefined")();
const isBrowser = () => IS_BROWSER;
const testElement = isBrowser() ? createElement("svg") : {};
const getChildCount = "children" in testElement ? (el) => el.children.length : (el) => el.childNodes.length;
const getViewRect = (elementRect, childViews, offset2, scale) => {
  const left2 = offset2[0] || elementRect.left;
  const top2 = offset2[1] || elementRect.top;
  const right2 = left2 + elementRect.width;
  const bottom2 = top2 + elementRect.height * (scale[1] || 1);
  const rect = {
    // the rectangle of the element itself
    element: {
      ...elementRect
    },
    // the rectangle of the element expanded to contain its children, does not include any margins
    inner: {
      left: elementRect.left,
      top: elementRect.top,
      right: elementRect.right,
      bottom: elementRect.bottom
    },
    // the rectangle of the element expanded to contain its children including own margin and child margins
    // margins will be added after we've recalculated the size
    outer: {
      left: left2,
      top: top2,
      right: right2,
      bottom: bottom2
    }
  };
  childViews.filter((childView) => !childView.isRectIgnored()).map((childView) => childView.rect).forEach((childViewRect) => {
    expandRect(rect.inner, { ...childViewRect.inner });
    expandRect(rect.outer, { ...childViewRect.outer });
  });
  calculateRectSize(rect.inner);
  rect.outer.bottom += rect.element.marginBottom;
  rect.outer.right += rect.element.marginRight;
  calculateRectSize(rect.outer);
  return rect;
};
const expandRect = (parent, child) => {
  child.top += parent.top;
  child.right += parent.left;
  child.bottom += parent.top;
  child.left += parent.left;
  if (child.bottom > parent.bottom) {
    parent.bottom = child.bottom;
  }
  if (child.right > parent.right) {
    parent.right = child.right;
  }
};
const calculateRectSize = (rect) => {
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
};
const isNumber$1 = (value) => typeof value === "number";
const thereYet = (position, destination, velocity, errorMargin = 1e-3) => {
  return Math.abs(position - destination) < errorMargin && Math.abs(velocity) < errorMargin;
};
const spring = (
  // default options
  ({ stiffness = 0.5, damping = 0.75, mass = 10 } = {}) => {
    let target = null;
    let position = null;
    let velocity = 0;
    let resting = false;
    const interpolate = (ts2, skipToEndState) => {
      if (resting)
        return;
      if (!(isNumber$1(target) && isNumber$1(position))) {
        resting = true;
        velocity = 0;
        return;
      }
      const f2 = -(position - target) * stiffness;
      velocity += f2 / mass;
      position += velocity;
      velocity *= damping;
      if (thereYet(position, target, velocity) || skipToEndState) {
        position = target;
        velocity = 0;
        resting = true;
        api.onupdate(position);
        api.oncomplete(position);
      } else {
        api.onupdate(position);
      }
    };
    const setTarget = (value) => {
      if (isNumber$1(value) && !isNumber$1(position)) {
        position = value;
      }
      if (target === null) {
        target = value;
        position = value;
      }
      target = value;
      if (position === target || typeof target === "undefined") {
        resting = true;
        velocity = 0;
        api.onupdate(position);
        api.oncomplete(position);
        return;
      }
      resting = false;
    };
    const api = createObject({
      interpolate,
      target: {
        set: setTarget,
        get: () => target
      },
      resting: {
        get: () => resting
      },
      onupdate: (value) => {
      },
      oncomplete: (value) => {
      }
    });
    return api;
  }
);
const easeInOutQuad = (t2) => t2 < 0.5 ? 2 * t2 * t2 : -1 + (4 - 2 * t2) * t2;
const tween = (
  // default values
  ({ duration = 500, easing = easeInOutQuad, delay = 0 } = {}) => {
    let start2 = null;
    let t2;
    let p2;
    let resting = true;
    let reverse = false;
    let target = null;
    const interpolate = (ts2, skipToEndState) => {
      if (resting || target === null)
        return;
      if (start2 === null) {
        start2 = ts2;
      }
      if (ts2 - start2 < delay)
        return;
      t2 = ts2 - start2 - delay;
      if (t2 >= duration || skipToEndState) {
        t2 = 1;
        p2 = reverse ? 0 : 1;
        api.onupdate(p2 * target);
        api.oncomplete(p2 * target);
        resting = true;
      } else {
        p2 = t2 / duration;
        api.onupdate((t2 >= 0 ? easing(reverse ? 1 - p2 : p2) : 0) * target);
      }
    };
    const api = createObject({
      interpolate,
      target: {
        get: () => reverse ? 0 : target,
        set: (value) => {
          if (target === null) {
            target = value;
            api.onupdate(value);
            api.oncomplete(value);
            return;
          }
          if (value < target) {
            target = 1;
            reverse = true;
          } else {
            reverse = false;
            target = value;
          }
          resting = false;
          start2 = null;
        }
      },
      resting: {
        get: () => resting
      },
      onupdate: (value) => {
      },
      oncomplete: (value) => {
      }
    });
    return api;
  }
);
const animator = {
  spring,
  tween
};
const createAnimator = (definition, category, property) => {
  const def = definition[category] && typeof definition[category][property] === "object" ? definition[category][property] : definition[category] || definition;
  const type = typeof def === "string" ? def : def.type;
  const props = typeof def === "object" ? { ...def } : {};
  return animator[type] ? animator[type](props) : null;
};
const addGetSet = (keys, obj, props, overwrite = false) => {
  obj = Array.isArray(obj) ? obj : [obj];
  obj.forEach((o2) => {
    keys.forEach((key) => {
      let name2 = key;
      let getter = () => props[key];
      let setter = (value) => props[key] = value;
      if (typeof key === "object") {
        name2 = key.key;
        getter = key.getter || getter;
        setter = key.setter || setter;
      }
      if (o2[name2] && !overwrite) {
        return;
      }
      o2[name2] = {
        get: getter,
        set: setter
      };
    });
  });
};
const animations = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI }) => {
  const initialProps = { ...viewProps };
  const animations2 = [];
  forin(mixinConfig, (property, animation) => {
    const animator2 = createAnimator(animation);
    if (!animator2) {
      return;
    }
    animator2.onupdate = (value) => {
      viewProps[property] = value;
    };
    animator2.target = initialProps[property];
    const prop = {
      key: property,
      setter: (value) => {
        if (animator2.target === value) {
          return;
        }
        animator2.target = value;
      },
      getter: () => viewProps[property]
    };
    addGetSet([prop], [viewInternalAPI, viewExternalAPI], viewProps, true);
    animations2.push(animator2);
  });
  return {
    write: (ts2) => {
      let skipToEndState = document.hidden;
      let resting = true;
      animations2.forEach((animation) => {
        if (!animation.resting)
          resting = false;
        animation.interpolate(ts2, skipToEndState);
      });
      return resting;
    },
    destroy: () => {
    }
  };
};
const addEvent$6 = (element) => (type, fn3) => {
  element.addEventListener(type, fn3);
};
const removeEvent = (element) => (type, fn3) => {
  element.removeEventListener(type, fn3);
};
const listeners = ({
  mixinConfig,
  viewProps,
  viewInternalAPI,
  viewExternalAPI,
  viewState,
  view
}) => {
  const events = [];
  const add = addEvent$6(view.element);
  const remove = removeEvent(view.element);
  viewExternalAPI.on = (type, fn3) => {
    events.push({
      type,
      fn: fn3
    });
    add(type, fn3);
  };
  viewExternalAPI.off = (type, fn3) => {
    events.splice(events.findIndex((event) => event.type === type && event.fn === fn3), 1);
    remove(type, fn3);
  };
  return {
    write: () => {
      return true;
    },
    destroy: () => {
      events.forEach((event) => {
        remove(event.type, event.fn);
      });
    }
  };
};
const apis = ({ mixinConfig, viewProps, viewExternalAPI }) => {
  addGetSet(mixinConfig, viewExternalAPI, viewProps);
};
const isDefined = (value) => value != null;
const defaults$3 = {
  opacity: 1,
  scaleX: 1,
  scaleY: 1,
  translateX: 0,
  translateY: 0,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  originX: 0,
  originY: 0
};
const styles = ({ mixinConfig, viewProps, viewInternalAPI, viewExternalAPI, view }) => {
  const initialProps = { ...viewProps };
  const currentProps = {};
  addGetSet(mixinConfig, [viewInternalAPI, viewExternalAPI], viewProps);
  const getOffset = () => [viewProps["translateX"] || 0, viewProps["translateY"] || 0];
  const getScale = () => [viewProps["scaleX"] || 0, viewProps["scaleY"] || 0];
  const getRect = () => view.rect ? getViewRect(view.rect, view.childViews, getOffset(), getScale()) : null;
  viewInternalAPI.rect = { get: getRect };
  viewExternalAPI.rect = { get: getRect };
  mixinConfig.forEach((key) => {
    viewProps[key] = typeof initialProps[key] === "undefined" ? defaults$3[key] : initialProps[key];
  });
  return {
    write: () => {
      if (!propsHaveChanged(currentProps, viewProps)) {
        return;
      }
      applyStyles$2(view.element, viewProps);
      Object.assign(currentProps, { ...viewProps });
      return true;
    },
    destroy: () => {
    }
  };
};
const propsHaveChanged = (currentProps, newProps) => {
  if (Object.keys(currentProps).length !== Object.keys(newProps).length) {
    return true;
  }
  for (const prop in newProps) {
    if (newProps[prop] !== currentProps[prop]) {
      return true;
    }
  }
  return false;
};
const applyStyles$2 = (element, {
  opacity,
  perspective,
  translateX,
  translateY,
  scaleX,
  scaleY,
  rotateX,
  rotateY,
  rotateZ,
  originX,
  originY,
  width,
  height
}) => {
  let transforms = "";
  let styles2 = "";
  if (isDefined(originX) || isDefined(originY)) {
    styles2 += `transform-origin: ${originX || 0}px ${originY || 0}px;`;
  }
  if (isDefined(perspective)) {
    transforms += `perspective(${perspective}px) `;
  }
  if (isDefined(translateX) || isDefined(translateY)) {
    transforms += `translate3d(${translateX || 0}px, ${translateY || 0}px, 0) `;
  }
  if (isDefined(scaleX) || isDefined(scaleY)) {
    transforms += `scale3d(${isDefined(scaleX) ? scaleX : 1}, ${isDefined(scaleY) ? scaleY : 1}, 1) `;
  }
  if (isDefined(rotateZ)) {
    transforms += `rotateZ(${rotateZ}rad) `;
  }
  if (isDefined(rotateX)) {
    transforms += `rotateX(${rotateX}rad) `;
  }
  if (isDefined(rotateY)) {
    transforms += `rotateY(${rotateY}rad) `;
  }
  if (transforms.length) {
    styles2 += `transform:${transforms};`;
  }
  if (isDefined(opacity)) {
    styles2 += `opacity:${opacity};`;
    if (opacity === 0) {
      styles2 += `visibility:hidden;`;
    }
    if (opacity < 1) {
      styles2 += `pointer-events:none;`;
    }
  }
  if (isDefined(height)) {
    styles2 += `height:${height}px;`;
  }
  if (isDefined(width)) {
    styles2 += `width:${width}px;`;
  }
  const elementCurrentStyle = element.elementCurrentStyle || "";
  if (styles2.length !== elementCurrentStyle.length || styles2 !== elementCurrentStyle) {
    element.style.cssText = styles2;
    element.elementCurrentStyle = styles2;
  }
};
const Mixins = {
  styles,
  listeners,
  animations,
  apis
};
const updateRect = (rect = {}, element = {}, style = {}) => {
  if (!element.layoutCalculated) {
    rect.paddingTop = parseInt(style.paddingTop, 10) || 0;
    rect.marginTop = parseInt(style.marginTop, 10) || 0;
    rect.marginRight = parseInt(style.marginRight, 10) || 0;
    rect.marginBottom = parseInt(style.marginBottom, 10) || 0;
    rect.marginLeft = parseInt(style.marginLeft, 10) || 0;
    element.layoutCalculated = true;
  }
  rect.left = element.offsetLeft || 0;
  rect.top = element.offsetTop || 0;
  rect.width = element.offsetWidth || 0;
  rect.height = element.offsetHeight || 0;
  rect.right = rect.left + rect.width;
  rect.bottom = rect.top + rect.height;
  rect.scrollTop = element.scrollTop;
  rect.hidden = element.offsetParent === null;
  return rect;
};
const createView = (
  // default view definition
  ({
    // element definition
    tag = "div",
    name: name2 = null,
    attributes = {},
    // view interaction
    read: read2 = () => {
    },
    write: write2 = () => {
    },
    create: create2 = () => {
    },
    destroy: destroy2 = () => {
    },
    // hooks
    filterFrameActionsForChild = (child, actions2) => actions2,
    didCreateView = () => {
    },
    didWriteView = () => {
    },
    // rect related
    ignoreRect = false,
    ignoreRectUpdate = false,
    // mixins
    mixins = []
  } = {}) => (store, props = {}) => {
    const element = createElement(tag, `filepond--${name2}`, attributes);
    const style = window.getComputedStyle(element, null);
    const rect = updateRect();
    let frameRect = null;
    let isResting = false;
    const childViews = [];
    const activeMixins = [];
    const ref = {};
    const state2 = {};
    const writers = [
      write2
      // default writer
    ];
    const readers = [
      read2
      // default reader
    ];
    const destroyers = [
      destroy2
      // default destroy
    ];
    const getElement2 = () => element;
    const getChildViews = () => childViews.concat();
    const getReference = () => ref;
    const createChildView = (store2) => (view, props2) => view(store2, props2);
    const getRect = () => {
      if (frameRect) {
        return frameRect;
      }
      frameRect = getViewRect(rect, childViews, [0, 0], [1, 1]);
      return frameRect;
    };
    const getStyle = () => style;
    const _read = () => {
      frameRect = null;
      childViews.forEach((child) => child._read());
      const shouldUpdate = !(ignoreRectUpdate && rect.width && rect.height);
      if (shouldUpdate) {
        updateRect(rect, element, style);
      }
      const api = { root: internalAPI, props, rect };
      readers.forEach((reader) => reader(api));
    };
    const _write = (ts2, frameActions, shouldOptimize) => {
      let resting = frameActions.length === 0;
      writers.forEach((writer) => {
        const writerResting = writer({
          props,
          root: internalAPI,
          actions: frameActions,
          timestamp: ts2,
          shouldOptimize
        });
        if (writerResting === false) {
          resting = false;
        }
      });
      activeMixins.forEach((mixin2) => {
        const mixinResting = mixin2.write(ts2);
        if (mixinResting === false) {
          resting = false;
        }
      });
      childViews.filter((child) => !!child.element.parentNode).forEach((child) => {
        const childResting = child._write(
          ts2,
          filterFrameActionsForChild(child, frameActions),
          shouldOptimize
        );
        if (!childResting) {
          resting = false;
        }
      });
      childViews.forEach((child, index) => {
        if (child.element.parentNode) {
          return;
        }
        internalAPI.appendChild(child.element, index);
        child._read();
        child._write(
          ts2,
          filterFrameActionsForChild(child, frameActions),
          shouldOptimize
        );
        resting = false;
      });
      isResting = resting;
      didWriteView({
        props,
        root: internalAPI,
        actions: frameActions,
        timestamp: ts2
      });
      return resting;
    };
    const _destroy2 = () => {
      activeMixins.forEach((mixin2) => mixin2.destroy());
      destroyers.forEach((destroyer) => {
        destroyer({ root: internalAPI, props });
      });
      childViews.forEach((child) => child._destroy());
    };
    const sharedAPIDefinition = {
      element: {
        get: getElement2
      },
      style: {
        get: getStyle
      },
      childViews: {
        get: getChildViews
      }
    };
    const internalAPIDefinition = {
      ...sharedAPIDefinition,
      rect: {
        get: getRect
      },
      // access to custom children references
      ref: {
        get: getReference
      },
      // dom modifiers
      is: (needle) => name2 === needle,
      appendChild: appendChild(element),
      createChildView: createChildView(store),
      linkView: (view) => {
        childViews.push(view);
        return view;
      },
      unlinkView: (view) => {
        childViews.splice(childViews.indexOf(view), 1);
      },
      appendChildView: appendChildView(element, childViews),
      removeChildView: removeChildView(element, childViews),
      registerWriter: (writer) => writers.push(writer),
      registerReader: (reader) => readers.push(reader),
      registerDestroyer: (destroyer) => destroyers.push(destroyer),
      invalidateLayout: () => element.layoutCalculated = false,
      // access to data store
      dispatch: store.dispatch,
      query: store.query
    };
    const externalAPIDefinition = {
      element: {
        get: getElement2
      },
      childViews: {
        get: getChildViews
      },
      rect: {
        get: getRect
      },
      resting: {
        get: () => isResting
      },
      isRectIgnored: () => ignoreRect,
      _read,
      _write,
      _destroy: _destroy2
    };
    const mixinAPIDefinition = {
      ...sharedAPIDefinition,
      rect: {
        get: () => rect
      }
    };
    Object.keys(mixins).sort((a2, b2) => {
      if (a2 === "styles") {
        return 1;
      } else if (b2 === "styles") {
        return -1;
      }
      return 0;
    }).forEach((key) => {
      const mixinAPI = Mixins[key]({
        mixinConfig: mixins[key],
        viewProps: props,
        viewState: state2,
        viewInternalAPI: internalAPIDefinition,
        viewExternalAPI: externalAPIDefinition,
        view: createObject(mixinAPIDefinition)
      });
      if (mixinAPI) {
        activeMixins.push(mixinAPI);
      }
    });
    const internalAPI = createObject(internalAPIDefinition);
    create2({
      root: internalAPI,
      props
    });
    const childCount = getChildCount(element);
    childViews.forEach((child, index) => {
      internalAPI.appendChild(child.element, childCount + index);
    });
    didCreateView(internalAPI);
    return createObject(externalAPIDefinition);
  }
);
const createPainter = (read2, write2, fps = 60) => {
  const name2 = "__framePainter";
  if (window[name2]) {
    window[name2].readers.push(read2);
    window[name2].writers.push(write2);
    return;
  }
  window[name2] = {
    readers: [read2],
    writers: [write2]
  };
  const painter = window[name2];
  const interval = 1e3 / fps;
  let last = null;
  let id = null;
  let requestTick = null;
  let cancelTick = null;
  const setTimerType = () => {
    if (document.hidden) {
      requestTick = () => window.setTimeout(() => tick(performance.now()), interval);
      cancelTick = () => window.clearTimeout(id);
    } else {
      requestTick = () => window.requestAnimationFrame(tick);
      cancelTick = () => window.cancelAnimationFrame(id);
    }
  };
  document.addEventListener("visibilitychange", () => {
    if (cancelTick)
      cancelTick();
    setTimerType();
    tick(performance.now());
  });
  const tick = (ts2) => {
    id = requestTick(tick);
    if (!last) {
      last = ts2;
    }
    const delta = ts2 - last;
    if (delta <= interval) {
      return;
    }
    last = ts2 - delta % interval;
    painter.readers.forEach((read3) => read3());
    painter.writers.forEach((write3) => write3(ts2));
  };
  setTimerType();
  tick(performance.now());
  return {
    pause: () => {
      cancelTick(id);
    }
  };
};
const createRoute = (routes, fn3) => ({ root: root2, props, actions: actions2 = [], timestamp, shouldOptimize }) => {
  actions2.filter((action) => routes[action.type]).forEach(
    (action) => routes[action.type]({ root: root2, props, action: action.data, timestamp, shouldOptimize })
  );
  if (fn3) {
    fn3({ root: root2, props, actions: actions2, timestamp, shouldOptimize });
  }
};
const insertBefore$1 = (newNode, referenceNode) => referenceNode.parentNode.insertBefore(newNode, referenceNode);
const insertAfter$1 = (newNode, referenceNode) => {
  return referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
};
const isArray$1 = (value) => Array.isArray(value);
const isEmpty = (value) => value == null;
const trim$1 = (str2) => str2.trim();
const toString$1 = (value) => "" + value;
const toArray$1 = (value, splitter = ",") => {
  if (isEmpty(value)) {
    return [];
  }
  if (isArray$1(value)) {
    return value;
  }
  return toString$1(value).split(splitter).map(trim$1).filter((str2) => str2.length);
};
const isBoolean$1 = (value) => typeof value === "boolean";
const toBoolean = (value) => isBoolean$1(value) ? value : value === "true";
const isString$1 = (value) => typeof value === "string";
const toNumber = (value) => isNumber$1(value) ? value : isString$1(value) ? toString$1(value).replace(/[a-z]+/gi, "") : 0;
const toInt = (value) => parseInt(toNumber(value), 10);
const toFloat = (value) => parseFloat(toNumber(value));
const isInt = (value) => isNumber$1(value) && isFinite(value) && Math.floor(value) === value;
const toBytes = (value, base = 1e3) => {
  if (isInt(value)) {
    return value;
  }
  let naturalFileSize = toString$1(value).trim();
  if (/MB$/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/MB$i/, "").trim();
    return toInt(naturalFileSize) * base * base;
  }
  if (/KB/i.test(naturalFileSize)) {
    naturalFileSize = naturalFileSize.replace(/KB$i/, "").trim();
    return toInt(naturalFileSize) * base;
  }
  return toInt(naturalFileSize);
};
const isFunction$1 = (value) => typeof value === "function";
const toFunctionReference = (string) => {
  let ref = self;
  let levels = string.split(".");
  let level = null;
  while (level = levels.shift()) {
    ref = ref[level];
    if (!ref) {
      return null;
    }
  }
  return ref;
};
const methods = {
  process: "POST",
  patch: "PATCH",
  revert: "DELETE",
  fetch: "GET",
  restore: "GET",
  load: "GET"
};
const createServerAPI = (outline) => {
  const api = {};
  api.url = isString$1(outline) ? outline : outline.url || "";
  api.timeout = outline.timeout ? parseInt(outline.timeout, 10) : 0;
  api.headers = outline.headers ? outline.headers : {};
  forin(methods, (key) => {
    api[key] = createAction(key, outline[key], methods[key], api.timeout, api.headers);
  });
  api.process = outline.process || isString$1(outline) || outline.url ? api.process : null;
  api.remove = outline.remove || null;
  delete api.headers;
  return api;
};
const createAction = (name2, outline, method, timeout2, headers) => {
  if (outline === null) {
    return null;
  }
  if (typeof outline === "function") {
    return outline;
  }
  const action = {
    url: method === "GET" || method === "PATCH" ? `?${name2}=` : "",
    method,
    headers,
    withCredentials: false,
    timeout: timeout2,
    onload: null,
    ondata: null,
    onerror: null
  };
  if (isString$1(outline)) {
    action.url = outline;
    return action;
  }
  Object.assign(action, outline);
  if (isString$1(action.headers)) {
    const parts = action.headers.split(/:(.+)/);
    action.headers = {
      header: parts[0],
      value: parts[1]
    };
  }
  action.withCredentials = toBoolean(action.withCredentials);
  return action;
};
const toServerAPI = (value) => createServerAPI(value);
const isNull = (value) => value === null;
const isObject$1 = (value) => typeof value === "object" && value !== null;
const isAPI = (value) => {
  return isObject$1(value) && isString$1(value.url) && isObject$1(value.process) && isObject$1(value.revert) && isObject$1(value.restore) && isObject$1(value.fetch);
};
const getType = (value) => {
  if (isArray$1(value)) {
    return "array";
  }
  if (isNull(value)) {
    return "null";
  }
  if (isInt(value)) {
    return "int";
  }
  if (/^[0-9]+ ?(?:GB|MB|KB)$/gi.test(value)) {
    return "bytes";
  }
  if (isAPI(value)) {
    return "api";
  }
  return typeof value;
};
const replaceSingleQuotes = (str2) => str2.replace(/{\s*'/g, '{"').replace(/'\s*}/g, '"}').replace(/'\s*:/g, '":').replace(/:\s*'/g, ':"').replace(/,\s*'/g, ',"').replace(/'\s*,/g, '",');
const conversionTable = {
  array: toArray$1,
  boolean: toBoolean,
  int: (value) => getType(value) === "bytes" ? toBytes(value) : toInt(value),
  number: toFloat,
  float: toFloat,
  bytes: toBytes,
  string: (value) => isFunction$1(value) ? value : toString$1(value),
  function: (value) => toFunctionReference(value),
  serverapi: toServerAPI,
  object: (value) => {
    try {
      return JSON.parse(replaceSingleQuotes(value));
    } catch (e2) {
      return null;
    }
  }
};
const convertTo = (value, type) => conversionTable[type](value);
const getValueByType = (newValue, defaultValue, valueType) => {
  if (newValue === defaultValue) {
    return newValue;
  }
  let newValueType = getType(newValue);
  if (newValueType !== valueType) {
    const convertedValue = convertTo(newValue, valueType);
    newValueType = getType(convertedValue);
    if (convertedValue === null) {
      throw `Trying to assign value with incorrect type to "${option}", allowed type: "${valueType}"`;
    } else {
      newValue = convertedValue;
    }
  }
  return newValue;
};
const createOption = (defaultValue, valueType) => {
  let currentValue = defaultValue;
  return {
    enumerable: true,
    get: () => currentValue,
    set: (newValue) => {
      currentValue = getValueByType(newValue, defaultValue, valueType);
    }
  };
};
const createOptions = (options) => {
  const obj = {};
  forin(options, (prop) => {
    const optionDefinition = options[prop];
    obj[prop] = createOption(optionDefinition[0], optionDefinition[1]);
  });
  return createObject(obj);
};
const createInitialState = (options) => ({
  // model
  items: [],
  // timeout used for calling update items
  listUpdateTimeout: null,
  // timeout used for stacking metadata updates
  itemUpdateTimeout: null,
  // queue of items waiting to be processed
  processingQueue: [],
  // options
  options: createOptions(options)
});
const fromCamels = (string, separator = "-") => string.split(/(?=[A-Z])/).map((part) => part.toLowerCase()).join(separator);
const createOptionAPI = (store, options) => {
  const obj = {};
  forin(options, (key) => {
    obj[key] = {
      get: () => store.getState().options[key],
      set: (value) => {
        store.dispatch(`SET_${fromCamels(key, "_").toUpperCase()}`, {
          value
        });
      }
    };
  });
  return obj;
};
const createOptionActions = (options) => (dispatch, query, state2) => {
  const obj = {};
  forin(options, (key) => {
    const name2 = fromCamels(key, "_").toUpperCase();
    obj[`SET_${name2}`] = (action) => {
      try {
        state2.options[key] = action.value;
      } catch (e2) {
      }
      dispatch(`DID_SET_${name2}`, { value: state2.options[key] });
    };
  });
  return obj;
};
const createOptionQueries = (options) => (state2) => {
  const obj = {};
  forin(options, (key) => {
    obj[`GET_${fromCamels(key, "_").toUpperCase()}`] = (action) => state2.options[key];
  });
  return obj;
};
const InteractionMethod = {
  API: 1,
  DROP: 2,
  BROWSE: 3,
  PASTE: 4,
  NONE: 5
};
const getUniqueId = () => Math.random().toString(36).substring(2, 11);
const arrayRemove = (arr, index) => arr.splice(index, 1);
const run = (cb, sync) => {
  if (sync) {
    cb();
  } else if (document.hidden) {
    Promise.resolve(1).then(cb);
  } else {
    setTimeout(cb, 0);
  }
};
const on = () => {
  const listeners2 = [];
  const off2 = (event, cb) => {
    arrayRemove(
      listeners2,
      listeners2.findIndex((listener) => listener.event === event && (listener.cb === cb || !cb))
    );
  };
  const fire2 = (event, args, sync) => {
    listeners2.filter((listener) => listener.event === event).map((listener) => listener.cb).forEach((cb) => run(() => cb(...args), sync));
  };
  return {
    fireSync: (event, ...args) => {
      fire2(event, args, true);
    },
    fire: (event, ...args) => {
      fire2(event, args, false);
    },
    on: (event, cb) => {
      listeners2.push({ event, cb });
    },
    onOnce: (event, cb) => {
      listeners2.push({
        event,
        cb: (...args) => {
          off2(event, cb);
          cb(...args);
        }
      });
    },
    off: off2
  };
};
const copyObjectPropertiesToObject = (src, target, excluded) => {
  Object.getOwnPropertyNames(src).filter((property) => !excluded.includes(property)).forEach(
    (key) => Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(src, key))
  );
};
const PRIVATE = [
  "fire",
  "process",
  "revert",
  "load",
  "on",
  "off",
  "onOnce",
  "retryLoad",
  "extend",
  "archive",
  "archived",
  "release",
  "released",
  "requestProcessing",
  "freeze"
];
const createItemAPI = (item2) => {
  const api = {};
  copyObjectPropertiesToObject(item2, api, PRIVATE);
  return api;
};
const removeReleasedItems = (items) => {
  items.forEach((item2, index) => {
    if (item2.released) {
      arrayRemove(items, index);
    }
  });
};
const ItemStatus = {
  INIT: 1,
  IDLE: 2,
  PROCESSING_QUEUED: 9,
  PROCESSING: 3,
  PROCESSING_COMPLETE: 5,
  PROCESSING_ERROR: 6,
  PROCESSING_REVERT_ERROR: 10,
  LOADING: 7,
  LOAD_ERROR: 8
};
const FileOrigin = {
  INPUT: 1,
  LIMBO: 2,
  LOCAL: 3
};
const getNonNumeric = (str2) => /[^0-9]+/.exec(str2);
const getDecimalSeparator = () => getNonNumeric(1.1.toLocaleString())[0];
const getThousandsSeparator = () => {
  const decimalSeparator = getDecimalSeparator();
  const thousandsStringWithSeparator = 1e3.toLocaleString();
  const thousandsStringWithoutSeparator = 1e3.toString();
  if (thousandsStringWithSeparator !== thousandsStringWithoutSeparator) {
    return getNonNumeric(thousandsStringWithSeparator)[0];
  }
  return decimalSeparator === "." ? "," : ".";
};
const Type = {
  BOOLEAN: "boolean",
  INT: "int",
  NUMBER: "number",
  STRING: "string",
  ARRAY: "array",
  OBJECT: "object",
  FUNCTION: "function",
  ACTION: "action",
  SERVER_API: "serverapi",
  REGEX: "regex"
};
const filters = [];
const applyFilterChain = (key, value, utils2) => new Promise((resolve, reject) => {
  const matchingFilters = filters.filter((f2) => f2.key === key).map((f2) => f2.cb);
  if (matchingFilters.length === 0) {
    resolve(value);
    return;
  }
  const initialFilter = matchingFilters.shift();
  matchingFilters.reduce(
    // loop over promises passing value to next promise
    (current, next) => current.then((value2) => next(value2, utils2)),
    // call initial filter, will return a promise
    initialFilter(value, utils2)
    // all executed
  ).then((value2) => resolve(value2)).catch((error2) => reject(error2));
});
const applyFilters = (key, value, utils2) => filters.filter((f2) => f2.key === key).map((f2) => f2.cb(value, utils2));
const addFilter = (key, cb) => filters.push({ key, cb });
const extendDefaultOptions = (additionalOptions) => Object.assign(defaultOptions, additionalOptions);
const getOptions = () => ({ ...defaultOptions });
const setOptions = (opts) => {
  forin(opts, (key, value) => {
    if (!defaultOptions[key]) {
      return;
    }
    defaultOptions[key][0] = getValueByType(
      value,
      defaultOptions[key][0],
      defaultOptions[key][1]
    );
  });
};
const defaultOptions = {
  // the id to add to the root element
  id: [null, Type.STRING],
  // input field name to use
  name: ["filepond", Type.STRING],
  // disable the field
  disabled: [false, Type.BOOLEAN],
  // classname to put on wrapper
  className: [null, Type.STRING],
  // is the field required
  required: [false, Type.BOOLEAN],
  // Allow media capture when value is set
  captureMethod: [null, Type.STRING],
  // - "camera", "microphone" or "camcorder",
  // - Does not work with multiple on apple devices
  // - If set, acceptedFileTypes must be made to match with media wildcard "image/*", "audio/*" or "video/*"
  // sync `acceptedFileTypes` property with `accept` attribute
  allowSyncAcceptAttribute: [true, Type.BOOLEAN],
  // Feature toggles
  allowDrop: [true, Type.BOOLEAN],
  // Allow dropping of files
  allowBrowse: [true, Type.BOOLEAN],
  // Allow browsing the file system
  allowPaste: [true, Type.BOOLEAN],
  // Allow pasting files
  allowMultiple: [false, Type.BOOLEAN],
  // Allow multiple files (disabled by default, as multiple attribute is also required on input to allow multiple)
  allowReplace: [true, Type.BOOLEAN],
  // Allow dropping a file on other file to replace it (only works when multiple is set to false)
  allowRevert: [true, Type.BOOLEAN],
  // Allows user to revert file upload
  allowRemove: [true, Type.BOOLEAN],
  // Allow user to remove a file
  allowProcess: [true, Type.BOOLEAN],
  // Allows user to process a file, when set to false, this removes the file upload button
  allowReorder: [false, Type.BOOLEAN],
  // Allow reordering of files
  allowDirectoriesOnly: [false, Type.BOOLEAN],
  // Allow only selecting directories with browse (no support for filtering dnd at this point)
  // Try store file if `server` not set
  storeAsFile: [false, Type.BOOLEAN],
  // Revert mode
  forceRevert: [false, Type.BOOLEAN],
  // Set to 'force' to require the file to be reverted before removal
  // Input requirements
  maxFiles: [null, Type.INT],
  // Max number of files
  checkValidity: [false, Type.BOOLEAN],
  // Enables custom validity messages
  // Where to put file
  itemInsertLocationFreedom: [true, Type.BOOLEAN],
  // Set to false to always add items to begin or end of list
  itemInsertLocation: ["before", Type.STRING],
  // Default index in list to add items that have been dropped at the top of the list
  itemInsertInterval: [75, Type.INT],
  // Drag 'n Drop related
  dropOnPage: [false, Type.BOOLEAN],
  // Allow dropping of files anywhere on page (prevents browser from opening file if dropped outside of Up)
  dropOnElement: [true, Type.BOOLEAN],
  // Drop needs to happen on element (set to false to also load drops outside of Up)
  dropValidation: [false, Type.BOOLEAN],
  // Enable or disable validating files on drop
  ignoredFiles: [[".ds_store", "thumbs.db", "desktop.ini"], Type.ARRAY],
  // Upload related
  instantUpload: [true, Type.BOOLEAN],
  // Should upload files immediately on drop
  maxParallelUploads: [2, Type.INT],
  // Maximum files to upload in parallel
  allowMinimumUploadDuration: [true, Type.BOOLEAN],
  // if true uploads take at least 750 ms, this ensures the user sees the upload progress giving trust the upload actually happened
  // Chunks
  chunkUploads: [false, Type.BOOLEAN],
  // Enable chunked uploads
  chunkForce: [false, Type.BOOLEAN],
  // Force use of chunk uploads even for files smaller than chunk size
  chunkSize: [5e6, Type.INT],
  // Size of chunks (5MB default)
  chunkRetryDelays: [[500, 1e3, 3e3], Type.ARRAY],
  // Amount of times to retry upload of a chunk when it fails
  // The server api end points to use for uploading (see docs)
  server: [null, Type.SERVER_API],
  // File size calculations, can set to 1024, this is only used for display, properties use file size base 1000
  fileSizeBase: [1e3, Type.INT],
  // Labels and status messages
  labelFileSizeBytes: ["bytes", Type.STRING],
  labelFileSizeKilobytes: ["KB", Type.STRING],
  labelFileSizeMegabytes: ["MB", Type.STRING],
  labelFileSizeGigabytes: ["GB", Type.STRING],
  labelDecimalSeparator: [getDecimalSeparator(), Type.STRING],
  // Default is locale separator
  labelThousandsSeparator: [getThousandsSeparator(), Type.STRING],
  // Default is locale separator
  labelIdle: [
    'Drag & Drop your files or <span class="filepond--label-action">Browse</span>',
    Type.STRING
  ],
  labelInvalidField: ["Field contains invalid files", Type.STRING],
  labelFileWaitingForSize: ["Waiting for size", Type.STRING],
  labelFileSizeNotAvailable: ["Size not available", Type.STRING],
  labelFileCountSingular: ["file in list", Type.STRING],
  labelFileCountPlural: ["files in list", Type.STRING],
  labelFileLoading: ["Loading", Type.STRING],
  labelFileAdded: ["Added", Type.STRING],
  // assistive only
  labelFileLoadError: ["Error during load", Type.STRING],
  labelFileRemoved: ["Removed", Type.STRING],
  // assistive only
  labelFileRemoveError: ["Error during remove", Type.STRING],
  labelFileProcessing: ["Uploading", Type.STRING],
  labelFileProcessingComplete: ["Upload complete", Type.STRING],
  labelFileProcessingAborted: ["Upload cancelled", Type.STRING],
  labelFileProcessingError: ["Error during upload", Type.STRING],
  labelFileProcessingRevertError: ["Error during revert", Type.STRING],
  labelTapToCancel: ["tap to cancel", Type.STRING],
  labelTapToRetry: ["tap to retry", Type.STRING],
  labelTapToUndo: ["tap to undo", Type.STRING],
  labelButtonRemoveItem: ["Remove", Type.STRING],
  labelButtonAbortItemLoad: ["Abort", Type.STRING],
  labelButtonRetryItemLoad: ["Retry", Type.STRING],
  labelButtonAbortItemProcessing: ["Cancel", Type.STRING],
  labelButtonUndoItemProcessing: ["Undo", Type.STRING],
  labelButtonRetryItemProcessing: ["Retry", Type.STRING],
  labelButtonProcessItem: ["Upload", Type.STRING],
  // make sure width and height plus viewpox are even numbers so icons are nicely centered
  iconRemove: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M11.586 13l-2.293 2.293a1 1 0 0 0 1.414 1.414L13 14.414l2.293 2.293a1 1 0 0 0 1.414-1.414L14.414 13l2.293-2.293a1 1 0 0 0-1.414-1.414L13 11.586l-2.293-2.293a1 1 0 0 0-1.414 1.414L11.586 13z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconProcess: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M14 10.414v3.585a1 1 0 0 1-2 0v-3.585l-1.293 1.293a1 1 0 0 1-1.414-1.415l3-3a1 1 0 0 1 1.414 0l3 3a1 1 0 0 1-1.414 1.415L14 10.414zM9 18a1 1 0 0 1 0-2h8a1 1 0 0 1 0 2H9z" fill="currentColor" fill-rule="evenodd"/></svg>',
    Type.STRING
  ],
  iconRetry: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M10.81 9.185l-.038.02A4.997 4.997 0 0 0 8 13.683a5 5 0 0 0 5 5 5 5 0 0 0 5-5 1 1 0 0 1 2 0A7 7 0 1 1 9.722 7.496l-.842-.21a.999.999 0 1 1 .484-1.94l3.23.806c.535.133.86.675.73 1.21l-.804 3.233a.997.997 0 0 1-1.21.73.997.997 0 0 1-.73-1.21l.23-.928v-.002z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconUndo: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M9.185 10.81l.02-.038A4.997 4.997 0 0 1 13.683 8a5 5 0 0 1 5 5 5 5 0 0 1-5 5 1 1 0 0 0 0 2A7 7 0 1 0 7.496 9.722l-.21-.842a.999.999 0 1 0-1.94.484l.806 3.23c.133.535.675.86 1.21.73l3.233-.803a.997.997 0 0 0 .73-1.21.997.997 0 0 0-1.21-.73l-.928.23-.002-.001z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  iconDone: [
    '<svg width="26" height="26" viewBox="0 0 26 26" xmlns="http://www.w3.org/2000/svg"><path d="M18.293 9.293a1 1 0 0 1 1.414 1.414l-7.002 7a1 1 0 0 1-1.414 0l-3.998-4a1 1 0 1 1 1.414-1.414L12 15.586l6.294-6.293z" fill="currentColor" fill-rule="nonzero"/></svg>',
    Type.STRING
  ],
  // event handlers
  oninit: [null, Type.FUNCTION],
  onwarning: [null, Type.FUNCTION],
  onerror: [null, Type.FUNCTION],
  onactivatefile: [null, Type.FUNCTION],
  oninitfile: [null, Type.FUNCTION],
  onaddfilestart: [null, Type.FUNCTION],
  onaddfileprogress: [null, Type.FUNCTION],
  onaddfile: [null, Type.FUNCTION],
  onprocessfilestart: [null, Type.FUNCTION],
  onprocessfileprogress: [null, Type.FUNCTION],
  onprocessfileabort: [null, Type.FUNCTION],
  onprocessfilerevert: [null, Type.FUNCTION],
  onprocessfile: [null, Type.FUNCTION],
  onprocessfiles: [null, Type.FUNCTION],
  onremovefile: [null, Type.FUNCTION],
  onpreparefile: [null, Type.FUNCTION],
  onupdatefiles: [null, Type.FUNCTION],
  onreorderfiles: [null, Type.FUNCTION],
  // hooks
  beforeDropFile: [null, Type.FUNCTION],
  beforeAddFile: [null, Type.FUNCTION],
  beforeRemoveFile: [null, Type.FUNCTION],
  beforePrepareFile: [null, Type.FUNCTION],
  // styles
  stylePanelLayout: [null, Type.STRING],
  // null 'integrated', 'compact', 'circle'
  stylePanelAspectRatio: [null, Type.STRING],
  // null or '3:2' or 1
  styleItemPanelAspectRatio: [null, Type.STRING],
  styleButtonRemoveItemPosition: ["left", Type.STRING],
  styleButtonProcessItemPosition: ["right", Type.STRING],
  styleLoadIndicatorPosition: ["right", Type.STRING],
  styleProgressIndicatorPosition: ["right", Type.STRING],
  styleButtonRemoveItemAlign: [false, Type.BOOLEAN],
  // custom initial files array
  files: [[], Type.ARRAY],
  // show support by displaying credits
  credits: [["https://pqina.nl/", "Powered by PQINA"], Type.ARRAY]
};
const getItemByQuery = (items, query) => {
  if (isEmpty(query)) {
    return items[0] || null;
  }
  if (isInt(query)) {
    return items[query] || null;
  }
  if (typeof query === "object") {
    query = query.id;
  }
  return items.find((item2) => item2.id === query) || null;
};
const getNumericAspectRatioFromString = (aspectRatio) => {
  if (isEmpty(aspectRatio)) {
    return aspectRatio;
  }
  if (/:/.test(aspectRatio)) {
    const parts = aspectRatio.split(":");
    return parts[1] / parts[0];
  }
  return parseFloat(aspectRatio);
};
const getActiveItems = (items) => items.filter((item2) => !item2.archived);
const Status = {
  EMPTY: 0,
  IDLE: 1,
  // waiting
  ERROR: 2,
  // a file is in error state
  BUSY: 3,
  // busy processing or loading
  READY: 4
  // all files uploaded
};
let res = null;
const canUpdateFileInput = () => {
  if (res === null) {
    try {
      const dataTransfer = new DataTransfer();
      dataTransfer.items.add(new File(["hello world"], "This_Works.txt"));
      const el = document.createElement("input");
      el.setAttribute("type", "file");
      el.files = dataTransfer.files;
      res = el.files.length === 1;
    } catch (err) {
      res = false;
    }
  }
  return res;
};
const ITEM_ERROR = [
  ItemStatus.LOAD_ERROR,
  ItemStatus.PROCESSING_ERROR,
  ItemStatus.PROCESSING_REVERT_ERROR
];
const ITEM_BUSY = [
  ItemStatus.LOADING,
  ItemStatus.PROCESSING,
  ItemStatus.PROCESSING_QUEUED,
  ItemStatus.INIT
];
const ITEM_READY = [ItemStatus.PROCESSING_COMPLETE];
const isItemInErrorState = (item2) => ITEM_ERROR.includes(item2.status);
const isItemInBusyState = (item2) => ITEM_BUSY.includes(item2.status);
const isItemInReadyState = (item2) => ITEM_READY.includes(item2.status);
const isAsync = (state2) => isObject$1(state2.options.server) && (isObject$1(state2.options.server.process) || isFunction$1(state2.options.server.process));
const queries = (state2) => ({
  GET_STATUS: () => {
    const items = getActiveItems(state2.items);
    const { EMPTY, ERROR, BUSY, IDLE, READY } = Status;
    if (items.length === 0)
      return EMPTY;
    if (items.some(isItemInErrorState))
      return ERROR;
    if (items.some(isItemInBusyState))
      return BUSY;
    if (items.some(isItemInReadyState))
      return READY;
    return IDLE;
  },
  GET_ITEM: (query) => getItemByQuery(state2.items, query),
  GET_ACTIVE_ITEM: (query) => getItemByQuery(getActiveItems(state2.items), query),
  GET_ACTIVE_ITEMS: () => getActiveItems(state2.items),
  GET_ITEMS: () => state2.items,
  GET_ITEM_NAME: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.filename : null;
  },
  GET_ITEM_SIZE: (query) => {
    const item2 = getItemByQuery(state2.items, query);
    return item2 ? item2.fileSize : null;
  },
  GET_STYLES: () => Object.keys(state2.options).filter((key) => /^style/.test(key)).map((option2) => ({
    name: option2,
    value: state2.options[option2]
  })),
  GET_PANEL_ASPECT_RATIO: () => {
    const isShapeCircle = /circle/.test(state2.options.stylePanelLayout);
    const aspectRatio = isShapeCircle ? 1 : getNumericAspectRatioFromString(state2.options.stylePanelAspectRatio);
    return aspectRatio;
  },
  GET_ITEM_PANEL_ASPECT_RATIO: () => state2.options.styleItemPanelAspectRatio,
  GET_ITEMS_BY_STATUS: (status) => getActiveItems(state2.items).filter((item2) => item2.status === status),
  GET_TOTAL_ITEMS: () => getActiveItems(state2.items).length,
  SHOULD_UPDATE_FILE_INPUT: () => state2.options.storeAsFile && canUpdateFileInput() && !isAsync(state2),
  IS_ASYNC: () => isAsync(state2),
  GET_FILE_SIZE_LABELS: (query) => ({
    labelBytes: query("GET_LABEL_FILE_SIZE_BYTES") || void 0,
    labelKilobytes: query("GET_LABEL_FILE_SIZE_KILOBYTES") || void 0,
    labelMegabytes: query("GET_LABEL_FILE_SIZE_MEGABYTES") || void 0,
    labelGigabytes: query("GET_LABEL_FILE_SIZE_GIGABYTES") || void 0
  })
});
const hasRoomForItem = (state2) => {
  const count = getActiveItems(state2.items).length;
  if (!state2.options.allowMultiple) {
    return count === 0;
  }
  const maxFileCount = state2.options.maxFiles;
  if (maxFileCount === null) {
    return true;
  }
  if (count < maxFileCount) {
    return true;
  }
  return false;
};
const limit = (value, min2, max2) => Math.max(Math.min(max2, value), min2);
const arrayInsert = (arr, index, item2) => arr.splice(index, 0, item2);
const insertItem = (items, item2, index) => {
  if (isEmpty(item2)) {
    return null;
  }
  if (typeof index === "undefined") {
    items.push(item2);
    return item2;
  }
  index = limit(index, 0, items.length);
  arrayInsert(items, index, item2);
  return item2;
};
const isBase64DataURI = (str2) => /^\s*data:([a-z]+\/[a-z0-9-+.]+(;[a-z-]+=[a-z0-9-]+)?)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s]*)\s*$/i.test(
  str2
);
const getFilenameFromURL = (url) => `${url}`.split("/").pop().split("?").shift();
const getExtensionFromFilename = (name2) => name2.split(".").pop();
const guesstimateExtension = (type) => {
  if (typeof type !== "string") {
    return "";
  }
  const subtype = type.split("/").pop();
  if (/svg/.test(subtype)) {
    return "svg";
  }
  if (/zip|compressed/.test(subtype)) {
    return "zip";
  }
  if (/plain/.test(subtype)) {
    return "txt";
  }
  if (/msword/.test(subtype)) {
    return "doc";
  }
  if (/[a-z]+/.test(subtype)) {
    if (subtype === "jpeg") {
      return "jpg";
    }
    return subtype;
  }
  return "";
};
const leftPad = (value, padding = "") => (padding + value).slice(-padding.length);
const getDateString = (date = /* @__PURE__ */ new Date()) => `${date.getFullYear()}-${leftPad(date.getMonth() + 1, "00")}-${leftPad(
  date.getDate(),
  "00"
)}_${leftPad(date.getHours(), "00")}-${leftPad(date.getMinutes(), "00")}-${leftPad(
  date.getSeconds(),
  "00"
)}`;
const getFileFromBlob = (blob2, filename, type = null, extension = null) => {
  const file2 = typeof type === "string" ? blob2.slice(0, blob2.size, type) : blob2.slice(0, blob2.size, blob2.type);
  file2.lastModifiedDate = /* @__PURE__ */ new Date();
  if (blob2._relativePath)
    file2._relativePath = blob2._relativePath;
  if (!isString$1(filename)) {
    filename = getDateString();
  }
  if (filename && extension === null && getExtensionFromFilename(filename)) {
    file2.name = filename;
  } else {
    extension = extension || guesstimateExtension(file2.type);
    file2.name = filename + (extension ? "." + extension : "");
  }
  return file2;
};
const getBlobBuilder = () => {
  return window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
};
const createBlob = (arrayBuffer, mimeType) => {
  const BB = getBlobBuilder();
  if (BB) {
    const bb = new BB();
    bb.append(arrayBuffer);
    return bb.getBlob(mimeType);
  }
  return new Blob([arrayBuffer], {
    type: mimeType
  });
};
const getBlobFromByteStringWithMimeType = (byteString, mimeType) => {
  const ab = new ArrayBuffer(byteString.length);
  const ia2 = new Uint8Array(ab);
  for (let i = 0; i < byteString.length; i++) {
    ia2[i] = byteString.charCodeAt(i);
  }
  return createBlob(ab, mimeType);
};
const getMimeTypeFromBase64DataURI = (dataURI) => {
  return (/^data:(.+);/.exec(dataURI) || [])[1] || null;
};
const getBase64DataFromBase64DataURI = (dataURI) => {
  const data2 = dataURI.split(",")[1];
  return data2.replace(/\s/g, "");
};
const getByteStringFromBase64DataURI = (dataURI) => {
  return atob(getBase64DataFromBase64DataURI(dataURI));
};
const getBlobFromBase64DataURI = (dataURI) => {
  const mimeType = getMimeTypeFromBase64DataURI(dataURI);
  const byteString = getByteStringFromBase64DataURI(dataURI);
  return getBlobFromByteStringWithMimeType(byteString, mimeType);
};
const getFileFromBase64DataURI = (dataURI, filename, extension) => {
  return getFileFromBlob(getBlobFromBase64DataURI(dataURI), filename, null, extension);
};
const getFileNameFromHeader = (header) => {
  if (!/^content-disposition:/i.test(header))
    return null;
  const matches = header.split(/filename=|filename\*=.+''/).splice(1).map((name2) => name2.trim().replace(/^["']|[;"']{0,2}$/g, "")).filter((name2) => name2.length);
  return matches.length ? decodeURI(matches[matches.length - 1]) : null;
};
const getFileSizeFromHeader = (header) => {
  if (/content-length:/i.test(header)) {
    const size = header.match(/[0-9]+/)[0];
    return size ? parseInt(size, 10) : null;
  }
  return null;
};
const getTranfserIdFromHeader = (header) => {
  if (/x-content-transfer-id:/i.test(header)) {
    const id = (header.split(":")[1] || "").trim();
    return id || null;
  }
  return null;
};
const getFileInfoFromHeaders = (headers) => {
  const info = {
    source: null,
    name: null,
    size: null
  };
  const rows = headers.split("\n");
  for (let header of rows) {
    const name2 = getFileNameFromHeader(header);
    if (name2) {
      info.name = name2;
      continue;
    }
    const size = getFileSizeFromHeader(header);
    if (size) {
      info.size = size;
      continue;
    }
    const source = getTranfserIdFromHeader(header);
    if (source) {
      info.source = source;
      continue;
    }
  }
  return info;
};
const createFileLoader = (fetchFn) => {
  const state2 = {
    source: null,
    complete: false,
    progress: 0,
    size: null,
    timestamp: null,
    duration: 0,
    request: null
  };
  const getProgress = () => state2.progress;
  const abort = () => {
    if (state2.request && state2.request.abort) {
      state2.request.abort();
    }
  };
  const load = () => {
    const source = state2.source;
    api.fire("init", source);
    if (source instanceof File) {
      api.fire("load", source);
    } else if (source instanceof Blob) {
      api.fire("load", getFileFromBlob(source, source.name));
    } else if (isBase64DataURI(source)) {
      api.fire("load", getFileFromBase64DataURI(source));
    } else {
      loadURL(source);
    }
  };
  const loadURL = (url) => {
    if (!fetchFn) {
      api.fire("error", {
        type: "error",
        body: "Can't load URL",
        code: 400
      });
      return;
    }
    state2.timestamp = Date.now();
    state2.request = fetchFn(
      url,
      (response2) => {
        state2.duration = Date.now() - state2.timestamp;
        state2.complete = true;
        if (response2 instanceof Blob) {
          response2 = getFileFromBlob(response2, response2.name || getFilenameFromURL(url));
        }
        api.fire(
          "load",
          // if has received blob, we go with blob, if no response, we return null
          response2 instanceof Blob ? response2 : response2 ? response2.body : null
        );
      },
      (error2) => {
        api.fire(
          "error",
          typeof error2 === "string" ? {
            type: "error",
            code: 0,
            body: error2
          } : error2
        );
      },
      (computable, current, total) => {
        if (total) {
          state2.size = total;
        }
        state2.duration = Date.now() - state2.timestamp;
        if (!computable) {
          state2.progress = null;
          return;
        }
        state2.progress = current / total;
        api.fire("progress", state2.progress);
      },
      () => {
        api.fire("abort");
      },
      (response2) => {
        const fileinfo = getFileInfoFromHeaders(
          typeof response2 === "string" ? response2 : response2.headers
        );
        api.fire("meta", {
          size: state2.size || fileinfo.size,
          filename: fileinfo.name,
          source: fileinfo.source
        });
      }
    );
  };
  const api = {
    ...on(),
    setSource: (source) => state2.source = source,
    getProgress,
    // file load progress
    abort,
    // abort file load
    load
    // start load
  };
  return api;
};
const isGet = (method) => /GET|HEAD/.test(method);
const sendRequest = (data2, url, options) => {
  const api = {
    onheaders: () => {
    },
    onprogress: () => {
    },
    onload: () => {
    },
    ontimeout: () => {
    },
    onerror: () => {
    },
    onabort: () => {
    },
    abort: () => {
      aborted = true;
      xhr.abort();
    }
  };
  let aborted = false;
  let headersReceived = false;
  options = {
    method: "POST",
    headers: {},
    withCredentials: false,
    ...options
  };
  url = encodeURI(url);
  if (isGet(options.method) && data2) {
    url = `${url}${encodeURIComponent(typeof data2 === "string" ? data2 : JSON.stringify(data2))}`;
  }
  const xhr = new XMLHttpRequest();
  const process2 = isGet(options.method) ? xhr : xhr.upload;
  process2.onprogress = (e2) => {
    if (aborted) {
      return;
    }
    api.onprogress(e2.lengthComputable, e2.loaded, e2.total);
  };
  xhr.onreadystatechange = () => {
    if (xhr.readyState < 2) {
      return;
    }
    if (xhr.readyState === 4 && xhr.status === 0) {
      return;
    }
    if (headersReceived) {
      return;
    }
    headersReceived = true;
    api.onheaders(xhr);
  };
  xhr.onload = () => {
    if (xhr.status >= 200 && xhr.status < 300) {
      api.onload(xhr);
    } else {
      api.onerror(xhr);
    }
  };
  xhr.onerror = () => api.onerror(xhr);
  xhr.onabort = () => {
    aborted = true;
    api.onabort();
  };
  xhr.ontimeout = () => api.ontimeout(xhr);
  xhr.open(options.method, url, true);
  if (isInt(options.timeout)) {
    xhr.timeout = options.timeout;
  }
  Object.keys(options.headers).forEach((key) => {
    const value = unescape(encodeURIComponent(options.headers[key]));
    xhr.setRequestHeader(key, value);
  });
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.withCredentials) {
    xhr.withCredentials = true;
  }
  xhr.send(data2);
  return api;
};
const createResponse = (type, code, body, headers) => ({
  type,
  code,
  body,
  headers
});
const createTimeoutResponse = (cb) => (xhr) => {
  cb(createResponse("error", 0, "Timeout", xhr.getAllResponseHeaders()));
};
const hasQS = (str2) => /\?/.test(str2);
const buildURL$1 = (...parts) => {
  let url = "";
  parts.forEach((part) => {
    url += hasQS(url) && hasQS(part) ? part.replace(/\?/, "&") : part;
  });
  return url;
};
const createFetchFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString$1(action.url)) {
    return null;
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (url, load, error2, progress, abort, headers) => {
    const request = sendRequest(url, buildURL$1(apiUrl, action.url), {
      ...action,
      responseType: "blob"
    });
    request.onload = (xhr) => {
      const headers2 = xhr.getAllResponseHeaders();
      const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
      load(
        createResponse(
          "load",
          xhr.status,
          action.method === "HEAD" ? null : getFileFromBlob(onload(xhr.response), filename),
          headers2
        )
      );
    };
    request.onerror = (xhr) => {
      error2(
        createResponse(
          "error",
          xhr.status,
          onerror(xhr.response) || xhr.statusText,
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.onheaders = (xhr) => {
      headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
    };
    request.ontimeout = createTimeoutResponse(error2);
    request.onprogress = progress;
    request.onabort = abort;
    return request;
  };
};
const ChunkStatus = {
  QUEUED: 0,
  COMPLETE: 1,
  PROCESSING: 2,
  ERROR: 3,
  WAITING: 4
};
const processFileChunked = (apiUrl, action, name2, file2, metadata, load, error2, progress, abort, transfer, options) => {
  const chunks = [];
  const { chunkTransferId, chunkServer, chunkSize, chunkRetryDelays } = options;
  const state2 = {
    serverId: chunkTransferId,
    aborted: false
  };
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((xhr, method) => method === "HEAD" ? xhr.getResponseHeader("Upload-Offset") : xhr.response);
  const onerror = action.onerror || ((res2) => null);
  const requestTransferId = (cb) => {
    const formData = new FormData();
    if (isObject$1(metadata))
      formData.append(name2, JSON.stringify(metadata));
    const headers = typeof action.headers === "function" ? action.headers(file2, metadata) : {
      ...action.headers,
      "Upload-Length": file2.size
    };
    const requestParams = {
      ...action,
      headers
    };
    const request = sendRequest(ondata(formData), buildURL$1(apiUrl, action.url), requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
    request.ontimeout = createTimeoutResponse(error2);
  };
  const requestTransferOffset = (cb) => {
    const requestUrl = buildURL$1(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof action.headers === "function" ? action.headers(state2.serverId) : {
      ...action.headers
    };
    const requestParams = {
      headers,
      method: "HEAD"
    };
    const request = sendRequest(null, requestUrl, requestParams);
    request.onload = (xhr) => cb(onload(xhr, requestParams.method));
    request.onerror = (xhr) => error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
    request.ontimeout = createTimeoutResponse(error2);
  };
  const lastChunkIndex = Math.floor(file2.size / chunkSize);
  for (let i = 0; i <= lastChunkIndex; i++) {
    const offset2 = i * chunkSize;
    const data2 = file2.slice(offset2, offset2 + chunkSize, "application/offset+octet-stream");
    chunks[i] = {
      index: i,
      size: data2.size,
      offset: offset2,
      data: data2,
      file: file2,
      progress: 0,
      retries: [...chunkRetryDelays],
      status: ChunkStatus.QUEUED,
      error: null,
      request: null,
      timeout: null
    };
  }
  const completeProcessingChunks = () => load(state2.serverId);
  const canProcessChunk = (chunk) => chunk.status === ChunkStatus.QUEUED || chunk.status === ChunkStatus.ERROR;
  const processChunk = (chunk) => {
    if (state2.aborted)
      return;
    chunk = chunk || chunks.find(canProcessChunk);
    if (!chunk) {
      if (chunks.every((chunk2) => chunk2.status === ChunkStatus.COMPLETE)) {
        completeProcessingChunks();
      }
      return;
    }
    chunk.status = ChunkStatus.PROCESSING;
    chunk.progress = null;
    const ondata2 = chunkServer.ondata || ((fd) => fd);
    const onerror2 = chunkServer.onerror || ((res2) => null);
    const onload2 = chunkServer.onload || (() => {
    });
    const requestUrl = buildURL$1(apiUrl, chunkServer.url, state2.serverId);
    const headers = typeof chunkServer.headers === "function" ? chunkServer.headers(chunk) : {
      ...chunkServer.headers,
      "Content-Type": "application/offset+octet-stream",
      "Upload-Offset": chunk.offset,
      "Upload-Length": file2.size,
      "Upload-Name": file2.name
    };
    const request = chunk.request = sendRequest(ondata2(chunk.data), requestUrl, {
      ...chunkServer,
      headers
    });
    request.onload = (xhr) => {
      onload2(xhr, chunk.index, chunks.length);
      chunk.status = ChunkStatus.COMPLETE;
      chunk.request = null;
      processChunks();
    };
    request.onprogress = (lengthComputable, loaded, total) => {
      chunk.progress = lengthComputable ? loaded : null;
      updateTotalProgress();
    };
    request.onerror = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      chunk.error = onerror2(xhr.response) || xhr.statusText;
      if (!retryProcessChunk(chunk)) {
        error2(
          createResponse(
            "error",
            xhr.status,
            onerror2(xhr.response) || xhr.statusText,
            xhr.getAllResponseHeaders()
          )
        );
      }
    };
    request.ontimeout = (xhr) => {
      chunk.status = ChunkStatus.ERROR;
      chunk.request = null;
      if (!retryProcessChunk(chunk)) {
        createTimeoutResponse(error2)(xhr);
      }
    };
    request.onabort = () => {
      chunk.status = ChunkStatus.QUEUED;
      chunk.request = null;
      abort();
    };
  };
  const retryProcessChunk = (chunk) => {
    if (chunk.retries.length === 0)
      return false;
    chunk.status = ChunkStatus.WAITING;
    clearTimeout(chunk.timeout);
    chunk.timeout = setTimeout(() => {
      processChunk(chunk);
    }, chunk.retries.shift());
    return true;
  };
  const updateTotalProgress = () => {
    const totalBytesTransfered = chunks.reduce((p2, chunk) => {
      if (p2 === null || chunk.progress === null)
        return null;
      return p2 + chunk.progress;
    }, 0);
    if (totalBytesTransfered === null)
      return progress(false, 0, 0);
    const totalSize = chunks.reduce((total, chunk) => total + chunk.size, 0);
    progress(true, totalBytesTransfered, totalSize);
  };
  const processChunks = () => {
    const totalProcessing = chunks.filter((chunk) => chunk.status === ChunkStatus.PROCESSING).length;
    if (totalProcessing >= 1)
      return;
    processChunk();
  };
  const abortChunks = () => {
    chunks.forEach((chunk) => {
      clearTimeout(chunk.timeout);
      if (chunk.request) {
        chunk.request.abort();
      }
    });
  };
  if (!state2.serverId) {
    requestTransferId((serverId) => {
      if (state2.aborted)
        return;
      transfer(serverId);
      state2.serverId = serverId;
      processChunks();
    });
  } else {
    requestTransferOffset((offset2) => {
      if (state2.aborted)
        return;
      chunks.filter((chunk) => chunk.offset < offset2).forEach((chunk) => {
        chunk.status = ChunkStatus.COMPLETE;
        chunk.progress = chunk.size;
      });
      processChunks();
    });
  }
  return {
    abort: () => {
      state2.aborted = true;
      abortChunks();
    }
  };
};
const createFileProcessorFunction = (apiUrl, action, name2, options) => (file2, metadata, load, error2, progress, abort, transfer) => {
  if (!file2)
    return;
  const canChunkUpload = options.chunkUploads;
  const shouldChunkUpload = canChunkUpload && file2.size > options.chunkSize;
  const willChunkUpload = canChunkUpload && (shouldChunkUpload || options.chunkForce);
  if (file2 instanceof Blob && willChunkUpload)
    return processFileChunked(
      apiUrl,
      action,
      name2,
      file2,
      metadata,
      load,
      error2,
      progress,
      abort,
      transfer,
      options
    );
  const ondata = action.ondata || ((fd) => fd);
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  const headers = typeof action.headers === "function" ? action.headers(file2, metadata) || {} : {
    ...action.headers
  };
  const requestParams = {
    ...action,
    headers
  };
  var formData = new FormData();
  if (isObject$1(metadata)) {
    formData.append(name2, JSON.stringify(metadata));
  }
  (file2 instanceof Blob ? [{ name: null, file: file2 }] : file2).forEach((item2) => {
    formData.append(
      name2,
      item2.file,
      item2.name === null ? item2.file.name : `${item2.name}${item2.file.name}`
    );
  });
  const request = sendRequest(ondata(formData), buildURL$1(apiUrl, action.url), requestParams);
  request.onload = (xhr) => {
    load(createResponse("load", xhr.status, onload(xhr.response), xhr.getAllResponseHeaders()));
  };
  request.onerror = (xhr) => {
    error2(
      createResponse(
        "error",
        xhr.status,
        onerror(xhr.response) || xhr.statusText,
        xhr.getAllResponseHeaders()
      )
    );
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
const createProcessorFunction = (apiUrl = "", action, name2, options) => {
  if (typeof action === "function")
    return (...params) => action(name2, ...params, options);
  if (!action || !isString$1(action.url))
    return null;
  return createFileProcessorFunction(apiUrl, action, name2, options);
};
const createRevertFunction = (apiUrl = "", action) => {
  if (typeof action === "function") {
    return action;
  }
  if (!action || !isString$1(action.url)) {
    return (uniqueFileId, load) => load();
  }
  const onload = action.onload || ((res2) => res2);
  const onerror = action.onerror || ((res2) => null);
  return (uniqueFileId, load, error2) => {
    const request = sendRequest(
      uniqueFileId,
      apiUrl + action.url,
      action
      // contains method, headers and withCredentials properties
    );
    request.onload = (xhr) => {
      load(
        createResponse(
          "load",
          xhr.status,
          onload(xhr.response),
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.onerror = (xhr) => {
      error2(
        createResponse(
          "error",
          xhr.status,
          onerror(xhr.response) || xhr.statusText,
          xhr.getAllResponseHeaders()
        )
      );
    };
    request.ontimeout = createTimeoutResponse(error2);
    return request;
  };
};
const getRandomNumber = (min2 = 0, max2 = 1) => min2 + Math.random() * (max2 - min2);
const createPerceivedPerformanceUpdater = (cb, duration = 1e3, offset2 = 0, tickMin = 25, tickMax = 250) => {
  let timeout2 = null;
  const start2 = Date.now();
  const tick = () => {
    let runtime = Date.now() - start2;
    let delay = getRandomNumber(tickMin, tickMax);
    if (runtime + delay > duration) {
      delay = runtime + delay - duration;
    }
    let progress = runtime / duration;
    if (progress >= 1 || document.hidden) {
      cb(1);
      return;
    }
    cb(progress);
    timeout2 = setTimeout(tick, delay);
  };
  if (duration > 0)
    tick();
  return {
    clear: () => {
      clearTimeout(timeout2);
    }
  };
};
const createFileProcessor = (processFn, options) => {
  const state2 = {
    complete: false,
    perceivedProgress: 0,
    perceivedPerformanceUpdater: null,
    progress: null,
    timestamp: null,
    perceivedDuration: 0,
    duration: 0,
    request: null,
    response: null
  };
  const { allowMinimumUploadDuration } = options;
  const process2 = (file2, metadata) => {
    const progressFn = () => {
      if (state2.duration === 0 || state2.progress === null)
        return;
      api.fire("progress", api.getProgress());
    };
    const completeFn = () => {
      state2.complete = true;
      api.fire("load-perceived", state2.response.body);
    };
    api.fire("start");
    state2.timestamp = Date.now();
    state2.perceivedPerformanceUpdater = createPerceivedPerformanceUpdater(
      (progress) => {
        state2.perceivedProgress = progress;
        state2.perceivedDuration = Date.now() - state2.timestamp;
        progressFn();
        if (state2.response && state2.perceivedProgress === 1 && !state2.complete) {
          completeFn();
        }
      },
      // random delay as in a list of files you start noticing
      // files uploading at the exact same speed
      allowMinimumUploadDuration ? getRandomNumber(750, 1500) : 0
    );
    state2.request = processFn(
      // the file to process
      file2,
      // the metadata to send along
      metadata,
      // callbacks (load, error, progress, abort, transfer)
      // load expects the body to be a server id if
      // you want to make use of revert
      (response2) => {
        state2.response = isObject$1(response2) ? response2 : {
          type: "load",
          code: 200,
          body: `${response2}`,
          headers: {}
        };
        state2.duration = Date.now() - state2.timestamp;
        state2.progress = 1;
        api.fire("load", state2.response.body);
        if (!allowMinimumUploadDuration || allowMinimumUploadDuration && state2.perceivedProgress === 1) {
          completeFn();
        }
      },
      // error is expected to be an object with type, code, body
      (error2) => {
        state2.perceivedPerformanceUpdater.clear();
        api.fire(
          "error",
          isObject$1(error2) ? error2 : {
            type: "error",
            code: 0,
            body: `${error2}`
          }
        );
      },
      // actual processing progress
      (computable, current, total) => {
        state2.duration = Date.now() - state2.timestamp;
        state2.progress = computable ? current / total : null;
        progressFn();
      },
      // abort does not expect a value
      () => {
        state2.perceivedPerformanceUpdater.clear();
        api.fire("abort", state2.response ? state2.response.body : null);
      },
      // register the id for this transfer
      (transferId) => {
        api.fire("transfer", transferId);
      }
    );
  };
  const abort = () => {
    if (!state2.request)
      return;
    state2.perceivedPerformanceUpdater.clear();
    if (state2.request.abort)
      state2.request.abort();
    state2.complete = true;
  };
  const reset = () => {
    abort();
    state2.complete = false;
    state2.perceivedProgress = 0;
    state2.progress = 0;
    state2.timestamp = null;
    state2.perceivedDuration = 0;
    state2.duration = 0;
    state2.request = null;
    state2.response = null;
  };
  const getProgress = allowMinimumUploadDuration ? () => state2.progress ? Math.min(state2.progress, state2.perceivedProgress) : null : () => state2.progress || null;
  const getDuration = allowMinimumUploadDuration ? () => Math.min(state2.duration, state2.perceivedDuration) : () => state2.duration;
  const api = {
    ...on(),
    process: process2,
    // start processing file
    abort,
    // abort active process request
    getProgress,
    getDuration,
    reset
  };
  return api;
};
const getFilenameWithoutExtension = (name2) => name2.substring(0, name2.lastIndexOf(".")) || name2;
const createFileStub = (source) => {
  let data2 = [source.name, source.size, source.type];
  if (source instanceof Blob || isBase64DataURI(source)) {
    data2[0] = source.name || getDateString();
  } else if (isBase64DataURI(source)) {
    data2[1] = source.length;
    data2[2] = getMimeTypeFromBase64DataURI(source);
  } else if (isString$1(source)) {
    data2[0] = getFilenameFromURL(source);
    data2[1] = 0;
    data2[2] = "application/octet-stream";
  }
  return {
    name: data2[0],
    size: data2[1],
    type: data2[2]
  };
};
const isFile$1 = (value) => !!(value instanceof File || value instanceof Blob && value.name);
const deepCloneObject = (src) => {
  if (!isObject$1(src))
    return src;
  const target = isArray$1(src) ? [] : {};
  for (const key in src) {
    if (!src.hasOwnProperty(key))
      continue;
    const v2 = src[key];
    target[key] = v2 && isObject$1(v2) ? deepCloneObject(v2) : v2;
  }
  return target;
};
const createItem = (origin2 = null, serverFileReference = null, file2 = null) => {
  const id = getUniqueId();
  const state2 = {
    // is archived
    archived: false,
    // if is frozen, no longer fires events
    frozen: false,
    // removed from view
    released: false,
    // original source
    source: null,
    // file model reference
    file: file2,
    // id of file on server
    serverFileReference,
    // id of file transfer on server
    transferId: null,
    // is aborted
    processingAborted: false,
    // current item status
    status: serverFileReference ? ItemStatus.PROCESSING_COMPLETE : ItemStatus.INIT,
    // active processes
    activeLoader: null,
    activeProcessor: null
  };
  let abortProcessingRequestComplete = null;
  const metadata = {};
  const setStatus = (status) => state2.status = status;
  const fire2 = (event, ...params) => {
    if (state2.released || state2.frozen)
      return;
    api.fire(event, ...params);
  };
  const getFileExtension = () => getExtensionFromFilename(state2.file.name);
  const getFileType = () => state2.file.type;
  const getFileSize = () => state2.file.size;
  const getFile = () => state2.file;
  const load = (source, loader, onload) => {
    state2.source = source;
    api.fireSync("init");
    if (state2.file) {
      api.fireSync("load-skip");
      return;
    }
    state2.file = createFileStub(source);
    loader.on("init", () => {
      fire2("load-init");
    });
    loader.on("meta", (meta) => {
      state2.file.size = meta.size;
      state2.file.filename = meta.filename;
      if (meta.source) {
        origin2 = FileOrigin.LIMBO;
        state2.serverFileReference = meta.source;
        state2.status = ItemStatus.PROCESSING_COMPLETE;
      }
      fire2("load-meta");
    });
    loader.on("progress", (progress) => {
      setStatus(ItemStatus.LOADING);
      fire2("load-progress", progress);
    });
    loader.on("error", (error2) => {
      setStatus(ItemStatus.LOAD_ERROR);
      fire2("load-request-error", error2);
    });
    loader.on("abort", () => {
      setStatus(ItemStatus.INIT);
      fire2("load-abort");
    });
    loader.on("load", (file3) => {
      state2.activeLoader = null;
      const success = (result) => {
        state2.file = isFile$1(result) ? result : state2.file;
        if (origin2 === FileOrigin.LIMBO && state2.serverFileReference) {
          setStatus(ItemStatus.PROCESSING_COMPLETE);
        } else {
          setStatus(ItemStatus.IDLE);
        }
        fire2("load");
      };
      const error2 = (result) => {
        state2.file = file3;
        fire2("load-meta");
        setStatus(ItemStatus.LOAD_ERROR);
        fire2("load-file-error", result);
      };
      if (state2.serverFileReference) {
        success(file3);
        return;
      }
      onload(file3, success, error2);
    });
    loader.setSource(source);
    state2.activeLoader = loader;
    loader.load();
  };
  const retryLoad = () => {
    if (!state2.activeLoader) {
      return;
    }
    state2.activeLoader.load();
  };
  const abortLoad = () => {
    if (state2.activeLoader) {
      state2.activeLoader.abort();
      return;
    }
    setStatus(ItemStatus.INIT);
    fire2("load-abort");
  };
  const process2 = (processor, onprocess) => {
    if (state2.processingAborted) {
      state2.processingAborted = false;
      return;
    }
    setStatus(ItemStatus.PROCESSING);
    abortProcessingRequestComplete = null;
    if (!(state2.file instanceof Blob)) {
      api.on("load", () => {
        process2(processor, onprocess);
      });
      return;
    }
    processor.on("load", (serverFileReference2) => {
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
    });
    processor.on("transfer", (transferId) => {
      state2.transferId = transferId;
    });
    processor.on("load-perceived", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.transferId = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.PROCESSING_COMPLETE);
      fire2("process-complete", serverFileReference2);
    });
    processor.on("start", () => {
      fire2("process-start");
    });
    processor.on("error", (error3) => {
      state2.activeProcessor = null;
      setStatus(ItemStatus.PROCESSING_ERROR);
      fire2("process-error", error3);
    });
    processor.on("abort", (serverFileReference2) => {
      state2.activeProcessor = null;
      state2.serverFileReference = serverFileReference2;
      setStatus(ItemStatus.IDLE);
      fire2("process-abort");
      if (abortProcessingRequestComplete) {
        abortProcessingRequestComplete();
      }
    });
    processor.on("progress", (progress) => {
      fire2("process-progress", progress);
    });
    const success = (file3) => {
      if (state2.archived)
        return;
      processor.process(file3, { ...metadata });
    };
    const error2 = console.error;
    onprocess(state2.file, success, error2);
    state2.activeProcessor = processor;
  };
  const requestProcessing = () => {
    state2.processingAborted = false;
    setStatus(ItemStatus.PROCESSING_QUEUED);
  };
  const abortProcessing = () => new Promise((resolve) => {
    if (!state2.activeProcessor) {
      state2.processingAborted = true;
      setStatus(ItemStatus.IDLE);
      fire2("process-abort");
      resolve();
      return;
    }
    abortProcessingRequestComplete = () => {
      resolve();
    };
    state2.activeProcessor.abort();
  });
  const revert = (revertFileUpload, forceRevert) => new Promise((resolve, reject) => {
    const serverTransferId = state2.serverFileReference !== null ? state2.serverFileReference : state2.transferId;
    if (serverTransferId === null) {
      resolve();
      return;
    }
    revertFileUpload(
      serverTransferId,
      () => {
        state2.serverFileReference = null;
        state2.transferId = null;
        resolve();
      },
      (error2) => {
        if (!forceRevert) {
          resolve();
          return;
        }
        setStatus(ItemStatus.PROCESSING_REVERT_ERROR);
        fire2("process-revert-error");
        reject(error2);
      }
    );
    setStatus(ItemStatus.IDLE);
    fire2("process-revert");
  });
  const setMetadata = (key, value, silent) => {
    const keys = key.split(".");
    const root2 = keys[0];
    const last = keys.pop();
    let data2 = metadata;
    keys.forEach((key2) => data2 = data2[key2]);
    if (JSON.stringify(data2[last]) === JSON.stringify(value))
      return;
    data2[last] = value;
    fire2("metadata-update", {
      key: root2,
      value: metadata[root2],
      silent
    });
  };
  const getMetadata = (key) => deepCloneObject(key ? metadata[key] : metadata);
  const api = {
    id: { get: () => id },
    origin: { get: () => origin2, set: (value) => origin2 = value },
    serverId: { get: () => state2.serverFileReference },
    transferId: { get: () => state2.transferId },
    status: { get: () => state2.status },
    filename: { get: () => state2.file.name },
    filenameWithoutExtension: { get: () => getFilenameWithoutExtension(state2.file.name) },
    fileExtension: { get: getFileExtension },
    fileType: { get: getFileType },
    fileSize: { get: getFileSize },
    file: { get: getFile },
    relativePath: { get: () => state2.file._relativePath },
    source: { get: () => state2.source },
    getMetadata,
    setMetadata: (key, value, silent) => {
      if (isObject$1(key)) {
        const data2 = key;
        Object.keys(data2).forEach((key2) => {
          setMetadata(key2, data2[key2], value);
        });
        return key;
      }
      setMetadata(key, value, silent);
      return value;
    },
    extend: (name2, handler) => itemAPI[name2] = handler,
    abortLoad,
    retryLoad,
    requestProcessing,
    abortProcessing,
    load,
    process: process2,
    revert,
    ...on(),
    freeze: () => state2.frozen = true,
    release: () => state2.released = true,
    released: { get: () => state2.released },
    archive: () => state2.archived = true,
    archived: { get: () => state2.archived },
    // replace source and file object
    setFile: (file3) => state2.file = file3
  };
  const itemAPI = createObject(api);
  return itemAPI;
};
const getItemIndexByQuery = (items, query) => {
  if (isEmpty(query)) {
    return 0;
  }
  if (!isString$1(query)) {
    return -1;
  }
  return items.findIndex((item2) => item2.id === query);
};
const getItemById = (items, itemId) => {
  const index = getItemIndexByQuery(items, itemId);
  if (index < 0) {
    return;
  }
  return items[index] || null;
};
const fetchBlob = (url, load, error2, progress, abort, headers) => {
  const request = sendRequest(null, url, {
    method: "GET",
    responseType: "blob"
  });
  request.onload = (xhr) => {
    const headers2 = xhr.getAllResponseHeaders();
    const filename = getFileInfoFromHeaders(headers2).name || getFilenameFromURL(url);
    load(createResponse("load", xhr.status, getFileFromBlob(xhr.response, filename), headers2));
  };
  request.onerror = (xhr) => {
    error2(createResponse("error", xhr.status, xhr.statusText, xhr.getAllResponseHeaders()));
  };
  request.onheaders = (xhr) => {
    headers(createResponse("headers", xhr.status, null, xhr.getAllResponseHeaders()));
  };
  request.ontimeout = createTimeoutResponse(error2);
  request.onprogress = progress;
  request.onabort = abort;
  return request;
};
const getDomainFromURL = (url) => {
  if (url.indexOf("//") === 0) {
    url = location.protocol + url;
  }
  return url.toLowerCase().replace("blob:", "").replace(/([a-z])?:\/\//, "$1").split("/")[0];
};
const isExternalURL = (url) => (url.indexOf(":") > -1 || url.indexOf("//") > -1) && getDomainFromURL(location.href) !== getDomainFromURL(url);
const dynamicLabel = (label) => (...params) => isFunction$1(label) ? label(...params) : label;
const isMockItem = (item2) => !isFile$1(item2.file);
const listUpdated = (dispatch, state2) => {
  clearTimeout(state2.listUpdateTimeout);
  state2.listUpdateTimeout = setTimeout(() => {
    dispatch("DID_UPDATE_ITEMS", { items: getActiveItems(state2.items) });
  }, 0);
};
const optionalPromise = (fn3, ...params) => new Promise((resolve) => {
  if (!fn3) {
    return resolve(true);
  }
  const result = fn3(...params);
  if (result == null) {
    return resolve(true);
  }
  if (typeof result === "boolean") {
    return resolve(result);
  }
  if (typeof result.then === "function") {
    result.then(resolve);
  }
});
const sortItems = (state2, compare) => {
  state2.items.sort((a2, b2) => compare(createItemAPI(a2), createItemAPI(b2)));
};
const getItemByQueryFromState = (state2, itemHandler) => ({
  query,
  success = () => {
  },
  failure = () => {
  },
  ...options
} = {}) => {
  const item2 = getItemByQuery(state2.items, query);
  if (!item2) {
    failure({
      error: createResponse("error", 0, "Item not found"),
      file: null
    });
    return;
  }
  itemHandler(item2, success, failure, options || {});
};
const actions = (dispatch, query, state2) => ({
  /**
   * Aborts all ongoing processes
   */
  ABORT_ALL: () => {
    getActiveItems(state2.items).forEach((item2) => {
      item2.freeze();
      item2.abortLoad();
      item2.abortProcessing();
    });
  },
  /**
   * Sets initial files
   */
  DID_SET_FILES: ({ value = [] }) => {
    const files = value.map((file2) => ({
      source: file2.source ? file2.source : file2,
      options: file2.options
    }));
    let activeItems = getActiveItems(state2.items);
    activeItems.forEach((item2) => {
      if (!files.find((file2) => file2.source === item2.source || file2.source === item2.file)) {
        dispatch("REMOVE_ITEM", { query: item2, remove: false });
      }
    });
    activeItems = getActiveItems(state2.items);
    files.forEach((file2, index) => {
      if (activeItems.find((item2) => item2.source === file2.source || item2.file === file2.source))
        return;
      dispatch("ADD_ITEM", {
        ...file2,
        interactionMethod: InteractionMethod.NONE,
        index
      });
    });
  },
  DID_UPDATE_ITEM_METADATA: ({ id, action, change }) => {
    if (change.silent)
      return;
    clearTimeout(state2.itemUpdateTimeout);
    state2.itemUpdateTimeout = setTimeout(() => {
      const item2 = getItemById(state2.items, id);
      if (!query("IS_ASYNC")) {
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, {
          item: item2,
          query,
          action,
          change
        }).then((shouldPrepareOutput) => {
          const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
          if (beforePrepareFile)
            shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
          if (!shouldPrepareOutput)
            return;
          dispatch(
            "REQUEST_PREPARE_OUTPUT",
            {
              query: id,
              item: item2,
              success: (file2) => {
                dispatch("DID_PREPARE_OUTPUT", { id, file: file2 });
              }
            },
            true
          );
        });
        return;
      }
      if (item2.origin === FileOrigin.LOCAL) {
        dispatch("DID_LOAD_ITEM", {
          id: item2.id,
          error: null,
          serverFileReference: item2.source
        });
      }
      const upload = () => {
        setTimeout(() => {
          dispatch("REQUEST_ITEM_PROCESSING", { query: id });
        }, 32);
      };
      const revert = (doUpload) => {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        ).then(doUpload ? upload : () => {
        }).catch(() => {
        });
      };
      const abort = (doUpload) => {
        item2.abortProcessing().then(doUpload ? upload : () => {
        });
      };
      if (item2.status === ItemStatus.PROCESSING_COMPLETE) {
        return revert(state2.options.instantUpload);
      }
      if (item2.status === ItemStatus.PROCESSING) {
        return abort(state2.options.instantUpload);
      }
      if (state2.options.instantUpload) {
        upload();
      }
    }, 0);
  },
  MOVE_ITEM: ({ query: query2, index }) => {
    const item2 = getItemByQuery(state2.items, query2);
    if (!item2)
      return;
    const currentIndex = state2.items.indexOf(item2);
    index = limit(index, 0, state2.items.length - 1);
    if (currentIndex === index)
      return;
    state2.items.splice(index, 0, state2.items.splice(currentIndex, 1)[0]);
  },
  SORT: ({ compare }) => {
    sortItems(state2, compare);
    dispatch("DID_SORT_ITEMS", {
      items: query("GET_ACTIVE_ITEMS")
    });
  },
  ADD_ITEMS: ({ items, index, interactionMethod, success = () => {
  }, failure = () => {
  } }) => {
    let currentIndex = index;
    if (index === -1 || typeof index === "undefined") {
      const insertLocation = query("GET_ITEM_INSERT_LOCATION");
      const totalItems = query("GET_TOTAL_ITEMS");
      currentIndex = insertLocation === "before" ? 0 : totalItems;
    }
    const ignoredFiles = query("GET_IGNORED_FILES");
    const isValidFile = (source) => isFile$1(source) ? !ignoredFiles.includes(source.name.toLowerCase()) : !isEmpty(source);
    const validItems = items.filter(isValidFile);
    const promises = validItems.map(
      (source) => new Promise((resolve, reject) => {
        dispatch("ADD_ITEM", {
          interactionMethod,
          source: source.source || source,
          success: resolve,
          failure: reject,
          index: currentIndex++,
          options: source.options || {}
        });
      })
    );
    Promise.all(promises).then(success).catch(failure);
  },
  /**
   * @param source
   * @param index
   * @param interactionMethod
   */
  ADD_ITEM: ({
    source,
    index = -1,
    interactionMethod,
    success = () => {
    },
    failure = () => {
    },
    options = {}
  }) => {
    if (isEmpty(source)) {
      failure({
        error: createResponse("error", 0, "No source"),
        file: null
      });
      return;
    }
    if (isFile$1(source) && state2.options.ignoredFiles.includes(source.name.toLowerCase())) {
      return;
    }
    if (!hasRoomForItem(state2)) {
      if (state2.options.allowMultiple || !state2.options.allowMultiple && !state2.options.allowReplace) {
        const error2 = createResponse("warning", 0, "Max files");
        dispatch("DID_THROW_MAX_FILES", {
          source,
          error: error2
        });
        failure({ error: error2, file: null });
        return;
      }
      const item3 = getActiveItems(state2.items)[0];
      if (item3.status === ItemStatus.PROCESSING_COMPLETE || item3.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        const forceRevert = query("GET_FORCE_REVERT");
        item3.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          forceRevert
        ).then(() => {
          if (!forceRevert)
            return;
          dispatch("ADD_ITEM", {
            source,
            index,
            interactionMethod,
            success,
            failure,
            options
          });
        }).catch(() => {
        });
        if (forceRevert)
          return;
      }
      dispatch("REMOVE_ITEM", { query: item3.id });
    }
    const origin2 = options.type === "local" ? FileOrigin.LOCAL : options.type === "limbo" ? FileOrigin.LIMBO : FileOrigin.INPUT;
    const item2 = createItem(
      // where did this file come from
      origin2,
      // an input file never has a server file reference
      origin2 === FileOrigin.INPUT ? null : source,
      // file mock data, if defined
      options.file
    );
    Object.keys(options.metadata || {}).forEach((key) => {
      item2.setMetadata(key, options.metadata[key]);
    });
    applyFilters("DID_CREATE_ITEM", item2, { query, dispatch });
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (!state2.options.itemInsertLocationFreedom) {
      index = itemInsertLocation === "before" ? -1 : state2.items.length;
    }
    insertItem(state2.items, item2, index);
    if (isFunction$1(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    const id = item2.id;
    item2.on("init", () => {
      dispatch("DID_INIT_ITEM", { id });
    });
    item2.on("load-init", () => {
      dispatch("DID_START_ITEM_LOAD", { id });
    });
    item2.on("load-meta", () => {
      dispatch("DID_UPDATE_ITEM_META", { id });
    });
    item2.on("load-progress", (progress) => {
      dispatch("DID_UPDATE_ITEM_LOAD_PROGRESS", { id, progress });
    });
    item2.on("load-request-error", (error2) => {
      const mainStatus = dynamicLabel(state2.options.labelFileLoadError)(error2);
      if (error2.code >= 400 && error2.code < 500) {
        dispatch("DID_THROW_ITEM_INVALID", {
          id,
          error: error2,
          status: {
            main: mainStatus,
            sub: `${error2.code} (${error2.body})`
          }
        });
        failure({ error: error2, file: createItemAPI(item2) });
        return;
      }
      dispatch("DID_THROW_ITEM_LOAD_ERROR", {
        id,
        error: error2,
        status: {
          main: mainStatus,
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("load-file-error", (error2) => {
      dispatch("DID_THROW_ITEM_INVALID", {
        id,
        error: error2.status,
        status: error2.status
      });
      failure({ error: error2.status, file: createItemAPI(item2) });
    });
    item2.on("load-abort", () => {
      dispatch("REMOVE_ITEM", { query: id });
    });
    item2.on("load-skip", () => {
      item2.on("metadata-update", (change) => {
        if (!isFile$1(item2.file))
          return;
        dispatch("DID_UPDATE_ITEM_METADATA", { id, change });
      });
      dispatch("COMPLETE_LOAD_ITEM", {
        query: id,
        item: item2,
        data: {
          source,
          success
        }
      });
    });
    item2.on("load", () => {
      const handleAdd = (shouldAdd) => {
        if (!shouldAdd) {
          dispatch("REMOVE_ITEM", {
            query: id
          });
          return;
        }
        item2.on("metadata-update", (change) => {
          dispatch("DID_UPDATE_ITEM_METADATA", { id, change });
        });
        applyFilterChain("SHOULD_PREPARE_OUTPUT", false, { item: item2, query }).then(
          (shouldPrepareOutput) => {
            const beforePrepareFile = query("GET_BEFORE_PREPARE_FILE");
            if (beforePrepareFile)
              shouldPrepareOutput = beforePrepareFile(item2, shouldPrepareOutput);
            const loadComplete = () => {
              dispatch("COMPLETE_LOAD_ITEM", {
                query: id,
                item: item2,
                data: {
                  source,
                  success
                }
              });
              listUpdated(dispatch, state2);
            };
            if (shouldPrepareOutput) {
              dispatch(
                "REQUEST_PREPARE_OUTPUT",
                {
                  query: id,
                  item: item2,
                  success: (file2) => {
                    dispatch("DID_PREPARE_OUTPUT", { id, file: file2 });
                    loadComplete();
                  }
                },
                true
              );
              return;
            }
            loadComplete();
          }
        );
      };
      applyFilterChain("DID_LOAD_ITEM", item2, { query, dispatch }).then(() => {
        optionalPromise(query("GET_BEFORE_ADD_FILE"), createItemAPI(item2)).then(
          handleAdd
        );
      }).catch((e2) => {
        if (!e2 || !e2.error || !e2.status)
          return handleAdd(false);
        dispatch("DID_THROW_ITEM_INVALID", {
          id,
          error: e2.error,
          status: e2.status
        });
      });
    });
    item2.on("process-start", () => {
      dispatch("DID_START_ITEM_PROCESSING", { id });
    });
    item2.on("process-progress", (progress) => {
      dispatch("DID_UPDATE_ITEM_PROCESS_PROGRESS", { id, progress });
    });
    item2.on("process-error", (error2) => {
      dispatch("DID_THROW_ITEM_PROCESSING_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-revert-error", (error2) => {
      dispatch("DID_THROW_ITEM_PROCESSING_REVERT_ERROR", {
        id,
        error: error2,
        status: {
          main: dynamicLabel(state2.options.labelFileProcessingRevertError)(error2),
          sub: state2.options.labelTapToRetry
        }
      });
    });
    item2.on("process-complete", (serverFileReference) => {
      dispatch("DID_COMPLETE_ITEM_PROCESSING", {
        id,
        error: null,
        serverFileReference
      });
      dispatch("DID_DEFINE_VALUE", { id, value: serverFileReference });
    });
    item2.on("process-abort", () => {
      dispatch("DID_ABORT_ITEM_PROCESSING", { id });
    });
    item2.on("process-revert", () => {
      dispatch("DID_REVERT_ITEM_PROCESSING", { id });
      dispatch("DID_DEFINE_VALUE", { id, value: null });
    });
    dispatch("DID_ADD_ITEM", { id, index, interactionMethod });
    listUpdated(dispatch, state2);
    const { url, load, restore, fetch: fetch2 } = state2.options.server || {};
    item2.load(
      source,
      // this creates a function that loads the file based on the type of file (string, base64, blob, file) and location of file (local, remote, limbo)
      createFileLoader(
        origin2 === FileOrigin.INPUT ? (
          // input, if is remote, see if should use custom fetch, else use default fetchBlob
          isString$1(source) && isExternalURL(source) ? fetch2 ? createFetchFunction(url, fetch2) : fetchBlob : fetchBlob
        ) : (
          // limbo or local
          origin2 === FileOrigin.LIMBO ? createFetchFunction(url, restore) : createFetchFunction(url, load)
        )
        // local
      ),
      // called when the file is loaded so it can be piped through the filters
      (file2, success2, error2) => {
        applyFilterChain("LOAD_FILE", file2, { query }).then(success2).catch(error2);
      }
    );
  },
  REQUEST_PREPARE_OUTPUT: ({ item: item2, success, failure = () => {
  } }) => {
    const err = {
      error: createResponse("error", 0, "Item not found"),
      file: null
    };
    if (item2.archived)
      return failure(err);
    applyFilterChain("PREPARE_OUTPUT", item2.file, { query, item: item2 }).then((result) => {
      applyFilterChain("COMPLETE_PREPARE_OUTPUT", result, { query, item: item2 }).then((result2) => {
        if (item2.archived)
          return failure(err);
        success(result2);
      });
    });
  },
  COMPLETE_LOAD_ITEM: ({ item: item2, data: data2 }) => {
    const { success, source } = data2;
    const itemInsertLocation = query("GET_ITEM_INSERT_LOCATION");
    if (isFunction$1(itemInsertLocation) && source) {
      sortItems(state2, itemInsertLocation);
    }
    dispatch("DID_LOAD_ITEM", {
      id: item2.id,
      error: null,
      serverFileReference: item2.origin === FileOrigin.INPUT ? null : source
    });
    success(createItemAPI(item2));
    if (item2.origin === FileOrigin.LOCAL) {
      dispatch("DID_LOAD_LOCAL_ITEM", { id: item2.id });
      return;
    }
    if (item2.origin === FileOrigin.LIMBO) {
      dispatch("DID_COMPLETE_ITEM_PROCESSING", {
        id: item2.id,
        error: null,
        serverFileReference: source
      });
      dispatch("DID_DEFINE_VALUE", {
        id: item2.id,
        value: item2.serverId || source
      });
      return;
    }
    if (query("IS_ASYNC") && state2.options.instantUpload) {
      dispatch("REQUEST_ITEM_PROCESSING", { query: item2.id });
    }
  },
  RETRY_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.retryLoad();
  }),
  REQUEST_ITEM_PREPARE: getItemByQueryFromState(state2, (item2, success, failure) => {
    dispatch(
      "REQUEST_PREPARE_OUTPUT",
      {
        query: item2.id,
        item: item2,
        success: (file2) => {
          dispatch("DID_PREPARE_OUTPUT", { id: item2.id, file: file2 });
          success({
            file: item2,
            output: file2
          });
        },
        failure
      },
      true
    );
  }),
  REQUEST_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2, success, failure) => {
    const itemCanBeQueuedForProcessing = (
      // waiting for something
      item2.status === ItemStatus.IDLE || // processing went wrong earlier
      item2.status === ItemStatus.PROCESSING_ERROR
    );
    if (!itemCanBeQueuedForProcessing) {
      const processNow = () => dispatch("REQUEST_ITEM_PROCESSING", { query: item2, success, failure });
      const process2 = () => document.hidden ? processNow() : setTimeout(processNow, 32);
      if (item2.status === ItemStatus.PROCESSING_COMPLETE || item2.status === ItemStatus.PROCESSING_REVERT_ERROR) {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        ).then(process2).catch(() => {
        });
      } else if (item2.status === ItemStatus.PROCESSING) {
        item2.abortProcessing().then(process2);
      }
      return;
    }
    if (item2.status === ItemStatus.PROCESSING_QUEUED)
      return;
    item2.requestProcessing();
    dispatch("DID_REQUEST_ITEM_PROCESSING", { id: item2.id });
    dispatch("PROCESS_ITEM", { query: item2, success, failure }, true);
  }),
  PROCESS_ITEM: getItemByQueryFromState(state2, (item2, success, failure) => {
    const maxParallelUploads = query("GET_MAX_PARALLEL_UPLOADS");
    const totalCurrentUploads = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING).length;
    if (totalCurrentUploads === maxParallelUploads) {
      state2.processingQueue.push({
        id: item2.id,
        success,
        failure
      });
      return;
    }
    if (item2.status === ItemStatus.PROCESSING)
      return;
    const processNext = () => {
      const queueEntry = state2.processingQueue.shift();
      if (!queueEntry)
        return;
      const { id, success: success2, failure: failure2 } = queueEntry;
      const itemReference = getItemByQuery(state2.items, id);
      if (!itemReference || itemReference.archived) {
        processNext();
        return;
      }
      dispatch("PROCESS_ITEM", { query: id, success: success2, failure: failure2 }, true);
    };
    item2.onOnce("process-complete", () => {
      success(createItemAPI(item2));
      processNext();
      const server = state2.options.server;
      const instantUpload = state2.options.instantUpload;
      if (instantUpload && item2.origin === FileOrigin.LOCAL && isFunction$1(server.remove)) {
        const noop2 = () => {
        };
        item2.origin = FileOrigin.LIMBO;
        state2.options.server.remove(item2.source, noop2, noop2);
      }
      const allItemsProcessed = query("GET_ITEMS_BY_STATUS", ItemStatus.PROCESSING_COMPLETE).length === state2.items.length;
      if (allItemsProcessed) {
        dispatch("DID_COMPLETE_ITEM_PROCESSING_ALL");
      }
    });
    item2.onOnce("process-error", (error2) => {
      failure({ error: error2, file: createItemAPI(item2) });
      processNext();
    });
    const options = state2.options;
    item2.process(
      createFileProcessor(
        createProcessorFunction(options.server.url, options.server.process, options.name, {
          chunkTransferId: item2.transferId,
          chunkServer: options.server.patch,
          chunkUploads: options.chunkUploads,
          chunkForce: options.chunkForce,
          chunkSize: options.chunkSize,
          chunkRetryDelays: options.chunkRetryDelays
        }),
        {
          allowMinimumUploadDuration: query("GET_ALLOW_MINIMUM_UPLOAD_DURATION")
        }
      ),
      // called when the file is about to be processed so it can be piped through the transform filters
      (file2, success2, error2) => {
        applyFilterChain("PREPARE_OUTPUT", file2, { query, item: item2 }).then((file3) => {
          dispatch("DID_PREPARE_OUTPUT", { id: item2.id, file: file3 });
          success2(file3);
        }).catch(error2);
      }
    );
  }),
  RETRY_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    dispatch("REQUEST_ITEM_PROCESSING", { query: item2 });
  }),
  REQUEST_REMOVE_ITEM: getItemByQueryFromState(state2, (item2) => {
    optionalPromise(query("GET_BEFORE_REMOVE_FILE"), createItemAPI(item2)).then((shouldRemove) => {
      if (!shouldRemove) {
        return;
      }
      dispatch("REMOVE_ITEM", { query: item2 });
    });
  }),
  RELEASE_ITEM: getItemByQueryFromState(state2, (item2) => {
    item2.release();
  }),
  REMOVE_ITEM: getItemByQueryFromState(state2, (item2, success, failure, options) => {
    const removeFromView = () => {
      const id = item2.id;
      getItemById(state2.items, id).archive();
      dispatch("DID_REMOVE_ITEM", { error: null, id, item: item2 });
      listUpdated(dispatch, state2);
      success(createItemAPI(item2));
    };
    const server = state2.options.server;
    if (item2.origin === FileOrigin.LOCAL && server && isFunction$1(server.remove) && options.remove !== false) {
      dispatch("DID_START_ITEM_REMOVE", { id: item2.id });
      server.remove(
        item2.source,
        () => removeFromView(),
        (status) => {
          dispatch("DID_THROW_ITEM_REMOVE_ERROR", {
            id: item2.id,
            error: createResponse("error", 0, status, null),
            status: {
              main: dynamicLabel(state2.options.labelFileRemoveError)(status),
              sub: state2.options.labelTapToRetry
            }
          });
        }
      );
    } else {
      if (options.revert && item2.origin !== FileOrigin.LOCAL && item2.serverId !== null || // if chunked uploads are enabled and we're uploading in chunks for this specific file
      // or if the file isn't big enough for chunked uploads but chunkForce is set then call
      // revert before removing from the view...
      state2.options.chunkUploads && item2.file.size > state2.options.chunkSize || state2.options.chunkUploads && state2.options.chunkForce) {
        item2.revert(
          createRevertFunction(state2.options.server.url, state2.options.server.revert),
          query("GET_FORCE_REVERT")
        );
      }
      removeFromView();
    }
  }),
  ABORT_ITEM_LOAD: getItemByQueryFromState(state2, (item2) => {
    item2.abortLoad();
  }),
  ABORT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (item2.serverId) {
      dispatch("REVERT_ITEM_PROCESSING", { id: item2.id });
      return;
    }
    item2.abortProcessing().then(() => {
      const shouldRemove = state2.options.instantUpload;
      if (shouldRemove) {
        dispatch("REMOVE_ITEM", { query: item2.id });
      }
    });
  }),
  REQUEST_REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    if (!state2.options.instantUpload) {
      dispatch("REVERT_ITEM_PROCESSING", { query: item2 });
      return;
    }
    const handleRevert = (shouldRevert) => {
      if (!shouldRevert)
        return;
      dispatch("REVERT_ITEM_PROCESSING", { query: item2 });
    };
    const fn3 = query("GET_BEFORE_REMOVE_FILE");
    if (!fn3) {
      return handleRevert(true);
    }
    const requestRemoveResult = fn3(createItemAPI(item2));
    if (requestRemoveResult == null) {
      return handleRevert(true);
    }
    if (typeof requestRemoveResult === "boolean") {
      return handleRevert(requestRemoveResult);
    }
    if (typeof requestRemoveResult.then === "function") {
      requestRemoveResult.then(handleRevert);
    }
  }),
  REVERT_ITEM_PROCESSING: getItemByQueryFromState(state2, (item2) => {
    item2.revert(
      createRevertFunction(state2.options.server.url, state2.options.server.revert),
      query("GET_FORCE_REVERT")
    ).then(() => {
      const shouldRemove = state2.options.instantUpload || isMockItem(item2);
      if (shouldRemove) {
        dispatch("REMOVE_ITEM", { query: item2.id });
      }
    }).catch(() => {
    });
  }),
  SET_OPTIONS: ({ options }) => {
    const optionKeys = Object.keys(options);
    const prioritizedOptionKeys = PrioritizedOptions.filter((key) => optionKeys.includes(key));
    const orderedOptionKeys = [
      // add prioritized first if passed to options, else remove
      ...prioritizedOptionKeys,
      // prevent duplicate keys
      ...Object.keys(options).filter((key) => !prioritizedOptionKeys.includes(key))
    ];
    orderedOptionKeys.forEach((key) => {
      dispatch(`SET_${fromCamels(key, "_").toUpperCase()}`, {
        value: options[key]
      });
    });
  }
});
const PrioritizedOptions = [
  "server"
  // must be processed before "files"
];
const formatFilename = (name2) => name2;
const createElement$1 = (tagName) => {
  return document.createElement(tagName);
};
const text = (node, value) => {
  let textNode = node.childNodes[0];
  if (!textNode) {
    textNode = document.createTextNode(value);
    node.appendChild(textNode);
  } else if (value !== textNode.nodeValue) {
    textNode.nodeValue = value;
  }
};
const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {
  const angleInRadians = (angleInDegrees % 360 - 90) * Math.PI / 180;
  return {
    x: centerX + radius * Math.cos(angleInRadians),
    y: centerY + radius * Math.sin(angleInRadians)
  };
};
const describeArc = (x2, y2, radius, startAngle, endAngle, arcSweep) => {
  const start2 = polarToCartesian(x2, y2, radius, endAngle);
  const end2 = polarToCartesian(x2, y2, radius, startAngle);
  return ["M", start2.x, start2.y, "A", radius, radius, 0, arcSweep, 0, end2.x, end2.y].join(" ");
};
const percentageArc = (x2, y2, radius, from, to) => {
  let arcSweep = 1;
  if (to > from && to - from <= 0.5) {
    arcSweep = 0;
  }
  if (from > to && from - to >= 0.5) {
    arcSweep = 0;
  }
  return describeArc(
    x2,
    y2,
    radius,
    Math.min(0.9999, from) * 360,
    Math.min(0.9999, to) * 360,
    arcSweep
  );
};
const create = ({ root: root2, props }) => {
  props.spin = false;
  props.progress = 0;
  props.opacity = 0;
  const svg = createElement("svg");
  root2.ref.path = createElement("path", {
    "stroke-width": 2,
    "stroke-linecap": "round"
  });
  svg.appendChild(root2.ref.path);
  root2.ref.svg = svg;
  root2.appendChild(svg);
};
const write$1 = ({ root: root2, props }) => {
  if (props.opacity === 0) {
    return;
  }
  if (props.align) {
    root2.element.dataset.align = props.align;
  }
  const ringStrokeWidth = parseInt(attr(root2.ref.path, "stroke-width"), 10);
  const size = root2.rect.element.width * 0.5;
  let ringFrom = 0;
  let ringTo = 0;
  if (props.spin) {
    ringFrom = 0;
    ringTo = 0.5;
  } else {
    ringFrom = 0;
    ringTo = props.progress;
  }
  const coordinates = percentageArc(size, size, size - ringStrokeWidth, ringFrom, ringTo);
  attr(root2.ref.path, "d", coordinates);
  attr(root2.ref.path, "stroke-opacity", props.spin || props.progress > 0 ? 1 : 0);
};
const progressIndicator = createView({
  tag: "div",
  name: "progress-indicator",
  ignoreRectUpdate: true,
  ignoreRect: true,
  create,
  write: write$1,
  mixins: {
    apis: ["progress", "spin", "align"],
    styles: ["opacity"],
    animations: {
      opacity: { type: "tween", duration: 500 },
      progress: {
        type: "spring",
        stiffness: 0.95,
        damping: 0.65,
        mass: 10
      }
    }
  }
});
const create$1 = ({ root: root2, props }) => {
  root2.element.innerHTML = (props.icon || "") + `<span>${props.label}</span>`;
  props.isDisabled = false;
};
const write$1$1 = ({ root: root2, props }) => {
  const { isDisabled: isDisabled2 } = props;
  const shouldDisable = root2.query("GET_DISABLED") || props.opacity === 0;
  if (shouldDisable && !isDisabled2) {
    props.isDisabled = true;
    attr(root2.element, "disabled", "disabled");
  } else if (!shouldDisable && isDisabled2) {
    props.isDisabled = false;
    root2.element.removeAttribute("disabled");
  }
};
const fileActionButton = createView({
  tag: "button",
  attributes: {
    type: "button"
  },
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "file-action-button",
  mixins: {
    apis: ["label"],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: { type: "tween", duration: 250 }
    },
    listeners: true
  },
  create: create$1,
  write: write$1$1
});
const toNaturalFileSize = (bytes, decimalSeparator = ".", base = 1e3, options = {}) => {
  const {
    labelBytes = "bytes",
    labelKilobytes = "KB",
    labelMegabytes = "MB",
    labelGigabytes = "GB"
  } = options;
  bytes = Math.round(Math.abs(bytes));
  const KB = base;
  const MB = base * base;
  const GB = base * base * base;
  if (bytes < KB) {
    return `${bytes} ${labelBytes}`;
  }
  if (bytes < MB) {
    return `${Math.floor(bytes / KB)} ${labelKilobytes}`;
  }
  if (bytes < GB) {
    return `${removeDecimalsWhenZero(bytes / MB, 1, decimalSeparator)} ${labelMegabytes}`;
  }
  return `${removeDecimalsWhenZero(bytes / GB, 2, decimalSeparator)} ${labelGigabytes}`;
};
const removeDecimalsWhenZero = (value, decimalCount, separator) => {
  return value.toFixed(decimalCount).split(".").filter((part) => part !== "0").join(separator);
};
const create$2 = ({ root: root2, props }) => {
  const fileName = createElement$1("span");
  fileName.className = "filepond--file-info-main";
  attr(fileName, "aria-hidden", "true");
  root2.appendChild(fileName);
  root2.ref.fileName = fileName;
  const fileSize = createElement$1("span");
  fileSize.className = "filepond--file-info-sub";
  root2.appendChild(fileSize);
  root2.ref.fileSize = fileSize;
  text(fileSize, root2.query("GET_LABEL_FILE_WAITING_FOR_SIZE"));
  text(fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const updateFile = ({ root: root2, props }) => {
  text(
    root2.ref.fileSize,
    toNaturalFileSize(
      root2.query("GET_ITEM_SIZE", props.id),
      ".",
      root2.query("GET_FILE_SIZE_BASE"),
      root2.query("GET_FILE_SIZE_LABELS", root2.query)
    )
  );
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const updateFileSizeOnError = ({ root: root2, props }) => {
  if (isInt(root2.query("GET_ITEM_SIZE", props.id))) {
    updateFile({ root: root2, props });
    return;
  }
  text(root2.ref.fileSize, root2.query("GET_LABEL_FILE_SIZE_NOT_AVAILABLE"));
};
const fileInfo = createView({
  name: "file-info",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: updateFile,
    DID_UPDATE_ITEM_META: updateFile,
    DID_THROW_ITEM_LOAD_ERROR: updateFileSizeOnError,
    DID_THROW_ITEM_INVALID: updateFileSizeOnError
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  create: create$2,
  mixins: {
    styles: ["translateX", "translateY"],
    animations: {
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const toPercentage = (value) => Math.round(value * 100);
const create$3 = ({ root: root2 }) => {
  const main2 = createElement$1("span");
  main2.className = "filepond--file-status-main";
  root2.appendChild(main2);
  root2.ref.main = main2;
  const sub = createElement$1("span");
  sub.className = "filepond--file-status-sub";
  root2.appendChild(sub);
  root2.ref.sub = sub;
  didSetItemLoadProgress({ root: root2, action: { progress: null } });
};
const didSetItemLoadProgress = ({ root: root2, action }) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_LOADING") : `${root2.query("GET_LABEL_FILE_LOADING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didSetItemProcessProgress = ({ root: root2, action }) => {
  const title = action.progress === null ? root2.query("GET_LABEL_FILE_PROCESSING") : `${root2.query("GET_LABEL_FILE_PROCESSING")} ${toPercentage(action.progress)}%`;
  text(root2.ref.main, title);
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didRequestItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_CANCEL"));
};
const didAbortItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_ABORTED"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_RETRY"));
};
const didCompleteItemProcessing = ({ root: root2 }) => {
  text(root2.ref.main, root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE"));
  text(root2.ref.sub, root2.query("GET_LABEL_TAP_TO_UNDO"));
};
const clear = ({ root: root2 }) => {
  text(root2.ref.main, "");
  text(root2.ref.sub, "");
};
const error = ({ root: root2, action }) => {
  text(root2.ref.main, action.status.main);
  text(root2.ref.sub, action.status.sub);
};
const fileStatus = createView({
  name: "file-status",
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: clear,
    DID_REVERT_ITEM_PROCESSING: clear,
    DID_REQUEST_ITEM_PROCESSING: didRequestItemProcessing,
    DID_ABORT_ITEM_PROCESSING: didAbortItemProcessing,
    DID_COMPLETE_ITEM_PROCESSING: didCompleteItemProcessing,
    DID_UPDATE_ITEM_PROCESS_PROGRESS: didSetItemProcessProgress,
    DID_UPDATE_ITEM_LOAD_PROGRESS: didSetItemLoadProgress,
    DID_THROW_ITEM_LOAD_ERROR: error,
    DID_THROW_ITEM_INVALID: error,
    DID_THROW_ITEM_PROCESSING_ERROR: error,
    DID_THROW_ITEM_PROCESSING_REVERT_ERROR: error,
    DID_THROW_ITEM_REMOVE_ERROR: error
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  create: create$3,
  mixins: {
    styles: ["translateX", "translateY", "opacity"],
    animations: {
      opacity: { type: "tween", duration: 250 },
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const Buttons = {
  AbortItemLoad: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_LOAD",
    action: "ABORT_ITEM_LOAD",
    className: "filepond--action-abort-item-load",
    align: "LOAD_INDICATOR_POSITION"
    // right
  },
  RetryItemLoad: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_LOAD",
    action: "RETRY_ITEM_LOAD",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-load",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RemoveItem: {
    label: "GET_LABEL_BUTTON_REMOVE_ITEM",
    action: "REQUEST_REMOVE_ITEM",
    icon: "GET_ICON_REMOVE",
    className: "filepond--action-remove-item",
    align: "BUTTON_REMOVE_ITEM_POSITION"
    // left
  },
  ProcessItem: {
    label: "GET_LABEL_BUTTON_PROCESS_ITEM",
    action: "REQUEST_ITEM_PROCESSING",
    icon: "GET_ICON_PROCESS",
    className: "filepond--action-process-item",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  AbortItemProcessing: {
    label: "GET_LABEL_BUTTON_ABORT_ITEM_PROCESSING",
    action: "ABORT_ITEM_PROCESSING",
    className: "filepond--action-abort-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RetryItemProcessing: {
    label: "GET_LABEL_BUTTON_RETRY_ITEM_PROCESSING",
    action: "RETRY_ITEM_PROCESSING",
    icon: "GET_ICON_RETRY",
    className: "filepond--action-retry-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  },
  RevertItemProcessing: {
    label: "GET_LABEL_BUTTON_UNDO_ITEM_PROCESSING",
    action: "REQUEST_REVERT_ITEM_PROCESSING",
    icon: "GET_ICON_UNDO",
    className: "filepond--action-revert-item-processing",
    align: "BUTTON_PROCESS_ITEM_POSITION"
    // right
  }
};
const ButtonKeys = [];
forin(Buttons, (key) => {
  ButtonKeys.push(key);
});
const calculateFileInfoOffset = (root2) => {
  if (getRemoveIndicatorAligment(root2) === "right")
    return 0;
  const buttonRect = root2.ref.buttonRemoveItem.rect.element;
  return buttonRect.hidden ? null : buttonRect.width + buttonRect.left;
};
const calculateButtonWidth = (root2) => {
  const buttonRect = root2.ref.buttonAbortItemLoad.rect.element;
  return buttonRect.width;
};
const calculateFileVerticalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.height / 4);
const calculateFileHorizontalCenterOffset = (root2) => Math.floor(root2.ref.buttonRemoveItem.rect.element.left / 2);
const getLoadIndicatorAlignment = (root2) => root2.query("GET_STYLE_LOAD_INDICATOR_POSITION");
const getProcessIndicatorAlignment = (root2) => root2.query("GET_STYLE_PROGRESS_INDICATOR_POSITION");
const getRemoveIndicatorAligment = (root2) => root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_POSITION");
const DefaultStyle = {
  buttonAbortItemLoad: { opacity: 0 },
  buttonRetryItemLoad: { opacity: 0 },
  buttonRemoveItem: { opacity: 0 },
  buttonProcessItem: { opacity: 0 },
  buttonAbortItemProcessing: { opacity: 0 },
  buttonRetryItemProcessing: { opacity: 0 },
  buttonRevertItemProcessing: { opacity: 0 },
  loadProgressIndicator: { opacity: 0, align: getLoadIndicatorAlignment },
  processProgressIndicator: { opacity: 0, align: getProcessIndicatorAlignment },
  processingCompleteIndicator: { opacity: 0, scaleX: 0.75, scaleY: 0.75 },
  info: { translateX: 0, translateY: 0, opacity: 0 },
  status: { translateX: 0, translateY: 0, opacity: 0 }
};
const IdleStyle = {
  buttonRemoveItem: { opacity: 1 },
  buttonProcessItem: { opacity: 1 },
  info: { translateX: calculateFileInfoOffset },
  status: { translateX: calculateFileInfoOffset }
};
const ProcessingStyle = {
  buttonAbortItemProcessing: { opacity: 1 },
  processProgressIndicator: { opacity: 1 },
  status: { opacity: 1 }
};
const StyleMap = {
  DID_THROW_ITEM_INVALID: {
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { translateX: calculateFileInfoOffset, opacity: 1 }
  },
  DID_START_ITEM_LOAD: {
    buttonAbortItemLoad: { opacity: 1 },
    loadProgressIndicator: { opacity: 1 },
    status: { opacity: 1 }
  },
  DID_THROW_ITEM_LOAD_ERROR: {
    buttonRetryItemLoad: { opacity: 1 },
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1 }
  },
  DID_START_ITEM_REMOVE: {
    processProgressIndicator: { opacity: 1, align: getRemoveIndicatorAligment },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 0 }
  },
  DID_THROW_ITEM_REMOVE_ERROR: {
    processProgressIndicator: { opacity: 0, align: getRemoveIndicatorAligment },
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1, translateX: calculateFileInfoOffset }
  },
  DID_LOAD_ITEM: IdleStyle,
  DID_LOAD_LOCAL_ITEM: {
    buttonRemoveItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { translateX: calculateFileInfoOffset }
  },
  DID_START_ITEM_PROCESSING: ProcessingStyle,
  DID_REQUEST_ITEM_PROCESSING: ProcessingStyle,
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ProcessingStyle,
  DID_COMPLETE_ITEM_PROCESSING: {
    buttonRevertItemProcessing: { opacity: 1 },
    info: { opacity: 1 },
    status: { opacity: 1 }
  },
  DID_THROW_ITEM_PROCESSING_ERROR: {
    buttonRemoveItem: { opacity: 1 },
    buttonRetryItemProcessing: { opacity: 1 },
    status: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset }
  },
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: {
    buttonRevertItemProcessing: { opacity: 1 },
    status: { opacity: 1 },
    info: { opacity: 1 }
  },
  DID_ABORT_ITEM_PROCESSING: {
    buttonRemoveItem: { opacity: 1 },
    buttonProcessItem: { opacity: 1 },
    info: { translateX: calculateFileInfoOffset },
    status: { opacity: 1 }
  },
  DID_REVERT_ITEM_PROCESSING: IdleStyle
};
const processingCompleteIndicatorView = createView({
  create: ({ root: root2 }) => {
    root2.element.innerHTML = root2.query("GET_ICON_DONE");
  },
  name: "processing-complete-indicator",
  ignoreRect: true,
  mixins: {
    styles: ["scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      opacity: { type: "tween", duration: 250 }
    }
  }
});
const create$4 = ({ root: root2, props }) => {
  const LocalButtons = Object.keys(Buttons).reduce((prev, curr) => {
    prev[curr] = { ...Buttons[curr] };
    return prev;
  }, {});
  const { id } = props;
  const allowRevert = root2.query("GET_ALLOW_REVERT");
  const allowRemove = root2.query("GET_ALLOW_REMOVE");
  const allowProcess = root2.query("GET_ALLOW_PROCESS");
  const instantUpload = root2.query("GET_INSTANT_UPLOAD");
  const isAsync2 = root2.query("IS_ASYNC");
  const alignRemoveItemButton = root2.query("GET_STYLE_BUTTON_REMOVE_ITEM_ALIGN");
  let buttonFilter;
  if (isAsync2) {
    if (allowProcess && !allowRevert) {
      buttonFilter = (key) => !/RevertItemProcessing/.test(key);
    } else if (!allowProcess && allowRevert) {
      buttonFilter = (key) => !/ProcessItem|RetryItemProcessing|AbortItemProcessing/.test(key);
    } else if (!allowProcess && !allowRevert) {
      buttonFilter = (key) => !/Process/.test(key);
    }
  } else {
    buttonFilter = (key) => !/Process/.test(key);
  }
  const enabledButtons = buttonFilter ? ButtonKeys.filter(buttonFilter) : ButtonKeys.concat();
  if (instantUpload && allowRevert) {
    LocalButtons["RevertItemProcessing"].label = "GET_LABEL_BUTTON_REMOVE_ITEM";
    LocalButtons["RevertItemProcessing"].icon = "GET_ICON_REMOVE";
  }
  if (isAsync2 && !allowRevert) {
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileHorizontalCenterOffset;
    map2.info.translateY = calculateFileVerticalCenterOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
  }
  if (isAsync2 && !allowProcess) {
    [
      "DID_START_ITEM_PROCESSING",
      "DID_REQUEST_ITEM_PROCESSING",
      "DID_UPDATE_ITEM_PROCESS_PROGRESS",
      "DID_THROW_ITEM_PROCESSING_ERROR"
    ].forEach((key) => {
      StyleMap[key].status.translateY = calculateFileVerticalCenterOffset;
    });
    StyleMap["DID_THROW_ITEM_PROCESSING_ERROR"].status.translateX = calculateButtonWidth;
  }
  if (alignRemoveItemButton && allowRevert) {
    LocalButtons["RevertItemProcessing"].align = "BUTTON_REMOVE_ITEM_POSITION";
    const map2 = StyleMap["DID_COMPLETE_ITEM_PROCESSING"];
    map2.info.translateX = calculateFileInfoOffset;
    map2.status.translateY = calculateFileVerticalCenterOffset;
    map2.processingCompleteIndicator = { opacity: 1, scaleX: 1, scaleY: 1 };
  }
  if (!allowRemove) {
    LocalButtons["RemoveItem"].disabled = true;
  }
  forin(LocalButtons, (key, definition) => {
    const buttonView = root2.createChildView(fileActionButton, {
      label: root2.query(definition.label),
      icon: root2.query(definition.icon),
      opacity: 0
    });
    if (enabledButtons.includes(key)) {
      root2.appendChildView(buttonView);
    }
    if (definition.disabled) {
      buttonView.element.setAttribute("disabled", "disabled");
      buttonView.element.setAttribute("hidden", "hidden");
    }
    buttonView.element.dataset.align = root2.query(`GET_STYLE_${definition.align}`);
    buttonView.element.classList.add(definition.className);
    buttonView.on("click", (e2) => {
      e2.stopPropagation();
      if (definition.disabled)
        return;
      root2.dispatch(definition.action, { query: id });
    });
    root2.ref[`button${key}`] = buttonView;
  });
  root2.ref.processingCompleteIndicator = root2.appendChildView(
    root2.createChildView(processingCompleteIndicatorView)
  );
  root2.ref.processingCompleteIndicator.element.dataset.align = root2.query(
    `GET_STYLE_BUTTON_PROCESS_ITEM_POSITION`
  );
  root2.ref.info = root2.appendChildView(root2.createChildView(fileInfo, { id }));
  root2.ref.status = root2.appendChildView(root2.createChildView(fileStatus, { id }));
  const loadIndicatorView = root2.appendChildView(
    root2.createChildView(progressIndicator, {
      opacity: 0,
      align: root2.query(`GET_STYLE_LOAD_INDICATOR_POSITION`)
    })
  );
  loadIndicatorView.element.classList.add("filepond--load-indicator");
  root2.ref.loadProgressIndicator = loadIndicatorView;
  const progressIndicatorView = root2.appendChildView(
    root2.createChildView(progressIndicator, {
      opacity: 0,
      align: root2.query(`GET_STYLE_PROGRESS_INDICATOR_POSITION`)
    })
  );
  progressIndicatorView.element.classList.add("filepond--process-indicator");
  root2.ref.processProgressIndicator = progressIndicatorView;
  root2.ref.activeStyles = [];
};
const write$2 = ({ root: root2, actions: actions2, props }) => {
  route({ root: root2, actions: actions2, props });
  let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StyleMap[action2.type]);
  if (action) {
    root2.ref.activeStyles = [];
    const stylesToApply = StyleMap[action.type];
    forin(DefaultStyle, (name2, defaultStyles) => {
      const control = root2.ref[name2];
      forin(defaultStyles, (key, defaultValue) => {
        const value = stylesToApply[name2] && typeof stylesToApply[name2][key] !== "undefined" ? stylesToApply[name2][key] : defaultValue;
        root2.ref.activeStyles.push({ control, key, value });
      });
    });
  }
  root2.ref.activeStyles.forEach(({ control, key, value }) => {
    control[key] = typeof value === "function" ? value(root2) : value;
  });
};
const route = createRoute({
  DID_SET_LABEL_BUTTON_ABORT_ITEM_PROCESSING: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemProcessing.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_LOAD: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemLoad.label = action.value;
  },
  DID_SET_LABEL_BUTTON_ABORT_ITEM_REMOVAL: ({ root: root2, action }) => {
    root2.ref.buttonAbortItemRemoval.label = action.value;
  },
  DID_REQUEST_ITEM_PROCESSING: ({ root: root2 }) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_START_ITEM_LOAD: ({ root: root2 }) => {
    root2.ref.loadProgressIndicator.spin = true;
    root2.ref.loadProgressIndicator.progress = 0;
  },
  DID_START_ITEM_REMOVE: ({ root: root2 }) => {
    root2.ref.processProgressIndicator.spin = true;
    root2.ref.processProgressIndicator.progress = 0;
  },
  DID_UPDATE_ITEM_LOAD_PROGRESS: ({ root: root2, action }) => {
    root2.ref.loadProgressIndicator.spin = false;
    root2.ref.loadProgressIndicator.progress = action.progress;
  },
  DID_UPDATE_ITEM_PROCESS_PROGRESS: ({ root: root2, action }) => {
    root2.ref.processProgressIndicator.spin = false;
    root2.ref.processProgressIndicator.progress = action.progress;
  }
});
const file = createView({
  create: create$4,
  write: write$2,
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  name: "file"
});
const create$5 = ({ root: root2, props }) => {
  root2.ref.fileName = createElement$1("legend");
  root2.appendChild(root2.ref.fileName);
  root2.ref.file = root2.appendChildView(root2.createChildView(file, { id: props.id }));
  root2.ref.data = false;
};
const didLoadItem = ({ root: root2, props }) => {
  text(root2.ref.fileName, formatFilename(root2.query("GET_ITEM_NAME", props.id)));
};
const fileWrapper = createView({
  create: create$5,
  ignoreRect: true,
  write: createRoute({
    DID_LOAD_ITEM: didLoadItem
  }),
  didCreateView: (root2) => {
    applyFilters("CREATE_VIEW", { ...root2, view: root2 });
  },
  tag: "fieldset",
  name: "file-wrapper"
});
const PANEL_SPRING_PROPS = { type: "spring", damping: 0.6, mass: 7 };
const create$6 = ({ root: root2, props }) => {
  [
    {
      name: "top"
    },
    {
      name: "center",
      props: {
        translateY: null,
        scaleY: null
      },
      mixins: {
        animations: {
          scaleY: PANEL_SPRING_PROPS
        },
        styles: ["translateY", "scaleY"]
      }
    },
    {
      name: "bottom",
      props: {
        translateY: null
      },
      mixins: {
        animations: {
          translateY: PANEL_SPRING_PROPS
        },
        styles: ["translateY"]
      }
    }
  ].forEach((section) => {
    createSection(root2, section, props.name);
  });
  root2.element.classList.add(`filepond--${props.name}`);
  root2.ref.scalable = null;
};
const createSection = (root2, section, className) => {
  const viewConstructor = createView({
    name: `panel-${section.name} filepond--${className}`,
    mixins: section.mixins,
    ignoreRectUpdate: true
  });
  const view = root2.createChildView(viewConstructor, section.props);
  root2.ref[section.name] = root2.appendChildView(view);
};
const write$3 = ({ root: root2, props }) => {
  if (root2.ref.scalable === null || props.scalable !== root2.ref.scalable) {
    root2.ref.scalable = isBoolean$1(props.scalable) ? props.scalable : true;
    root2.element.dataset.scalable = root2.ref.scalable;
  }
  if (!props.height)
    return;
  const topRect = root2.ref.top.rect.element;
  const bottomRect = root2.ref.bottom.rect.element;
  const height = Math.max(topRect.height + bottomRect.height, props.height);
  root2.ref.center.translateY = topRect.height;
  root2.ref.center.scaleY = (height - topRect.height - bottomRect.height) / 100;
  root2.ref.bottom.translateY = height - bottomRect.height;
};
const panel = createView({
  name: "panel",
  read: ({ root: root2, props }) => props.heightCurrent = root2.ref.bottom.translateY,
  write: write$3,
  create: create$6,
  ignoreRect: true,
  mixins: {
    apis: ["height", "heightCurrent", "scalable"]
  }
});
const createDragHelper = (items) => {
  const itemIds = items.map((item2) => item2.id);
  let prevIndex = void 0;
  return {
    setIndex: (index) => {
      prevIndex = index;
    },
    getIndex: () => prevIndex,
    getItemIndex: (item2) => itemIds.indexOf(item2.id)
  };
};
const ITEM_TRANSLATE_SPRING = {
  type: "spring",
  stiffness: 0.75,
  damping: 0.45,
  mass: 10
};
const ITEM_SCALE_SPRING = "spring";
const StateMap = {
  DID_START_ITEM_LOAD: "busy",
  DID_UPDATE_ITEM_LOAD_PROGRESS: "loading",
  DID_THROW_ITEM_INVALID: "load-invalid",
  DID_THROW_ITEM_LOAD_ERROR: "load-error",
  DID_LOAD_ITEM: "idle",
  DID_THROW_ITEM_REMOVE_ERROR: "remove-error",
  DID_START_ITEM_REMOVE: "busy",
  DID_START_ITEM_PROCESSING: "busy processing",
  DID_REQUEST_ITEM_PROCESSING: "busy processing",
  DID_UPDATE_ITEM_PROCESS_PROGRESS: "processing",
  DID_COMPLETE_ITEM_PROCESSING: "processing-complete",
  DID_THROW_ITEM_PROCESSING_ERROR: "processing-error",
  DID_THROW_ITEM_PROCESSING_REVERT_ERROR: "processing-revert-error",
  DID_ABORT_ITEM_PROCESSING: "cancelled",
  DID_REVERT_ITEM_PROCESSING: "idle"
};
const create$7 = ({ root: root2, props }) => {
  root2.ref.handleClick = (e2) => root2.dispatch("DID_ACTIVATE_ITEM", { id: props.id });
  root2.element.id = `filepond--item-${props.id}`;
  root2.element.addEventListener("click", root2.ref.handleClick);
  root2.ref.container = root2.appendChildView(root2.createChildView(fileWrapper, { id: props.id }));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "item-panel" }));
  root2.ref.panel.height = null;
  props.markedForRemoval = false;
  if (!root2.query("GET_ALLOW_REORDER"))
    return;
  root2.element.dataset.dragState = "idle";
  const grab = (e2) => {
    if (!e2.isPrimary)
      return;
    let removedActivateListener = false;
    const origin2 = {
      x: e2.pageX,
      y: e2.pageY
    };
    props.dragOrigin = {
      x: root2.translateX,
      y: root2.translateY
    };
    props.dragCenter = {
      x: e2.offsetX,
      y: e2.offsetY
    };
    const dragState = createDragHelper(root2.query("GET_ACTIVE_ITEMS"));
    root2.dispatch("DID_GRAB_ITEM", { id: props.id, dragState });
    const drag = (e3) => {
      if (!e3.isPrimary)
        return;
      e3.stopPropagation();
      e3.preventDefault();
      props.dragOffset = {
        x: e3.pageX - origin2.x,
        y: e3.pageY - origin2.y
      };
      const dist = props.dragOffset.x * props.dragOffset.x + props.dragOffset.y * props.dragOffset.y;
      if (dist > 16 && !removedActivateListener) {
        removedActivateListener = true;
        root2.element.removeEventListener("click", root2.ref.handleClick);
      }
      root2.dispatch("DID_DRAG_ITEM", { id: props.id, dragState });
    };
    const drop2 = (e3) => {
      if (!e3.isPrimary)
        return;
      props.dragOffset = {
        x: e3.pageX - origin2.x,
        y: e3.pageY - origin2.y
      };
      reset();
    };
    const cancel = () => {
      reset();
    };
    const reset = () => {
      document.removeEventListener("pointercancel", cancel);
      document.removeEventListener("pointermove", drag);
      document.removeEventListener("pointerup", drop2);
      root2.dispatch("DID_DROP_ITEM", { id: props.id, dragState });
      if (removedActivateListener) {
        setTimeout(() => root2.element.addEventListener("click", root2.ref.handleClick), 0);
      }
    };
    document.addEventListener("pointercancel", cancel);
    document.addEventListener("pointermove", drag);
    document.addEventListener("pointerup", drop2);
  };
  root2.element.addEventListener("pointerdown", grab);
};
const route$1 = createRoute({
  DID_UPDATE_PANEL_HEIGHT: ({ root: root2, action }) => {
    root2.height = action.height;
  }
});
const write$4 = createRoute(
  {
    DID_GRAB_ITEM: ({ root: root2, props }) => {
      props.dragOrigin = {
        x: root2.translateX,
        y: root2.translateY
      };
    },
    DID_DRAG_ITEM: ({ root: root2 }) => {
      root2.element.dataset.dragState = "drag";
    },
    DID_DROP_ITEM: ({ root: root2, props }) => {
      props.dragOffset = null;
      props.dragOrigin = null;
      root2.element.dataset.dragState = "drop";
    }
  },
  ({ root: root2, actions: actions2, props, shouldOptimize }) => {
    if (root2.element.dataset.dragState === "drop") {
      if (root2.scaleX <= 1) {
        root2.element.dataset.dragState = "idle";
      }
    }
    let action = actions2.concat().filter((action2) => /^DID_/.test(action2.type)).reverse().find((action2) => StateMap[action2.type]);
    if (action && action.type !== props.currentState) {
      props.currentState = action.type;
      root2.element.dataset.filepondItemState = StateMap[props.currentState] || "";
    }
    const aspectRatio = root2.query("GET_ITEM_PANEL_ASPECT_RATIO") || root2.query("GET_PANEL_ASPECT_RATIO");
    if (!aspectRatio) {
      route$1({ root: root2, actions: actions2, props });
      if (!root2.height && root2.ref.container.rect.element.height > 0) {
        root2.height = root2.ref.container.rect.element.height;
      }
    } else if (!shouldOptimize) {
      root2.height = root2.rect.element.width * aspectRatio;
    }
    if (shouldOptimize) {
      root2.ref.panel.height = null;
    }
    root2.ref.panel.height = root2.height;
  }
);
const item = createView({
  create: create$7,
  write: write$4,
  destroy: ({ root: root2, props }) => {
    root2.element.removeEventListener("click", root2.ref.handleClick);
    root2.dispatch("RELEASE_ITEM", { query: props.id });
  },
  tag: "li",
  name: "item",
  mixins: {
    apis: [
      "id",
      "interactionMethod",
      "markedForRemoval",
      "spawnDate",
      "dragCenter",
      "dragOrigin",
      "dragOffset"
    ],
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity", "height"],
    animations: {
      scaleX: ITEM_SCALE_SPRING,
      scaleY: ITEM_SCALE_SPRING,
      translateX: ITEM_TRANSLATE_SPRING,
      translateY: ITEM_TRANSLATE_SPRING,
      opacity: { type: "tween", duration: 150 }
    }
  }
});
var getItemsPerRow = (horizontalSpace, itemWidth) => {
  return Math.max(1, Math.floor((horizontalSpace + 1) / itemWidth));
};
const getItemIndexByPosition = (view, children, positionInView) => {
  if (!positionInView)
    return;
  const horizontalSpace = view.rect.element.width;
  const l2 = children.length;
  let last = null;
  if (l2 === 0 || positionInView.top < children[0].rect.element.top)
    return -1;
  const item2 = children[0];
  const itemRect = item2.rect.element;
  const itemHorizontalMargin = itemRect.marginLeft + itemRect.marginRight;
  const itemWidth = itemRect.width + itemHorizontalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    for (let index = 0; index < l2; index++) {
      const child = children[index];
      const childMid = child.rect.outer.top + child.rect.element.height * 0.5;
      if (positionInView.top < childMid) {
        return index;
      }
    }
    return l2;
  }
  const itemVerticalMargin = itemRect.marginTop + itemRect.marginBottom;
  const itemHeight = itemRect.height + itemVerticalMargin;
  for (let index = 0; index < l2; index++) {
    const indexX = index % itemsPerRow;
    const indexY = Math.floor(index / itemsPerRow);
    const offsetX = indexX * itemWidth;
    const offsetY = indexY * itemHeight;
    const itemTop = offsetY - itemRect.marginTop;
    const itemRight = offsetX + itemWidth;
    const itemBottom = offsetY + itemHeight + itemRect.marginBottom;
    if (positionInView.top < itemBottom && positionInView.top > itemTop) {
      if (positionInView.left < itemRight) {
        return index;
      } else if (index !== l2 - 1) {
        last = index;
      } else {
        last = null;
      }
    }
  }
  if (last !== null) {
    return last;
  }
  return l2;
};
const dropAreaDimensions = {
  height: 0,
  width: 0,
  get getHeight() {
    return this.height;
  },
  set setHeight(val) {
    if (this.height === 0 || val === 0)
      this.height = val;
  },
  get getWidth() {
    return this.width;
  },
  set setWidth(val) {
    if (this.width === 0 || val === 0)
      this.width = val;
  },
  setDimensions: function(height, width) {
    if (this.height === 0 || height === 0)
      this.height = height;
    if (this.width === 0 || width === 0)
      this.width = width;
  }
};
const create$8 = ({ root: root2 }) => {
  attr(root2.element, "role", "list");
  root2.ref.lastItemSpanwDate = Date.now();
};
const addItemView = ({ root: root2, action }) => {
  const { id, index, interactionMethod } = action;
  root2.ref.addIndex = index;
  const now = Date.now();
  let spawnDate = now;
  let opacity = 1;
  if (interactionMethod !== InteractionMethod.NONE) {
    opacity = 0;
    const cooldown = root2.query("GET_ITEM_INSERT_INTERVAL");
    const dist = now - root2.ref.lastItemSpanwDate;
    spawnDate = dist < cooldown ? now + (cooldown - dist) : now;
  }
  root2.ref.lastItemSpanwDate = spawnDate;
  root2.appendChildView(
    root2.createChildView(
      // view type
      item,
      // props
      {
        spawnDate,
        id,
        opacity,
        interactionMethod
      }
    ),
    index
  );
};
const moveItem = (item2, x2, y2, vx = 0, vy = 1) => {
  if (item2.dragOffset) {
    item2.translateX = null;
    item2.translateY = null;
    item2.translateX = item2.dragOrigin.x + item2.dragOffset.x;
    item2.translateY = item2.dragOrigin.y + item2.dragOffset.y;
    item2.scaleX = 1.025;
    item2.scaleY = 1.025;
  } else {
    item2.translateX = x2;
    item2.translateY = y2;
    if (Date.now() > item2.spawnDate) {
      if (item2.opacity === 0) {
        introItemView(item2, x2, y2, vx, vy);
      }
      item2.scaleX = 1;
      item2.scaleY = 1;
      item2.opacity = 1;
    }
  }
};
const introItemView = (item2, x2, y2, vx, vy) => {
  if (item2.interactionMethod === InteractionMethod.NONE) {
    item2.translateX = null;
    item2.translateX = x2;
    item2.translateY = null;
    item2.translateY = y2;
  } else if (item2.interactionMethod === InteractionMethod.DROP) {
    item2.translateX = null;
    item2.translateX = x2 - vx * 20;
    item2.translateY = null;
    item2.translateY = y2 - vy * 10;
    item2.scaleX = 0.8;
    item2.scaleY = 0.8;
  } else if (item2.interactionMethod === InteractionMethod.BROWSE) {
    item2.translateY = null;
    item2.translateY = y2 - 30;
  } else if (item2.interactionMethod === InteractionMethod.API) {
    item2.translateX = null;
    item2.translateX = x2 - 30;
    item2.translateY = null;
  }
};
const removeItemView = ({ root: root2, action }) => {
  const { id } = action;
  const view = root2.childViews.find((child) => child.id === id);
  if (!view) {
    return;
  }
  view.scaleX = 0.9;
  view.scaleY = 0.9;
  view.opacity = 0;
  view.markedForRemoval = true;
};
const getItemHeight = (child) => child.rect.element.height + child.rect.element.marginBottom * 0.5 + child.rect.element.marginTop * 0.5;
const getItemWidth = (child) => child.rect.element.width + child.rect.element.marginLeft * 0.5 + child.rect.element.marginRight * 0.5;
const dragItem = ({ root: root2, action }) => {
  const { id, dragState } = action;
  const item2 = root2.query("GET_ITEM", { id });
  const view = root2.childViews.find((child) => child.id === id);
  const numItems = root2.childViews.length;
  const oldIndex = dragState.getItemIndex(item2);
  if (!view)
    return;
  const dragPosition = {
    x: view.dragOrigin.x + view.dragOffset.x + view.dragCenter.x,
    y: view.dragOrigin.y + view.dragOffset.y + view.dragCenter.y
  };
  const dragHeight = getItemHeight(view);
  const dragWidth = getItemWidth(view);
  let cols = Math.floor(root2.rect.outer.width / dragWidth);
  if (cols > numItems)
    cols = numItems;
  const rows = Math.floor(numItems / cols + 1);
  dropAreaDimensions.setHeight = dragHeight * rows;
  dropAreaDimensions.setWidth = dragWidth * cols;
  var location2 = {
    y: Math.floor(dragPosition.y / dragHeight),
    x: Math.floor(dragPosition.x / dragWidth),
    getGridIndex: function getGridIndex() {
      if (dragPosition.y > dropAreaDimensions.getHeight || dragPosition.y < 0 || dragPosition.x > dropAreaDimensions.getWidth || dragPosition.x < 0)
        return oldIndex;
      return this.y * cols + this.x;
    },
    getColIndex: function getColIndex() {
      const items = root2.query("GET_ACTIVE_ITEMS");
      const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
      const children = items.map(
        (item3) => visibleChildren.find((childView) => childView.id === item3.id)
      );
      const currentIndex2 = children.findIndex((child) => child === view);
      const dragHeight2 = getItemHeight(view);
      const l2 = children.length;
      let idx = l2;
      let childHeight = 0;
      let childBottom = 0;
      let childTop = 0;
      for (let i = 0; i < l2; i++) {
        childHeight = getItemHeight(children[i]);
        childTop = childBottom;
        childBottom = childTop + childHeight;
        if (dragPosition.y < childBottom) {
          if (currentIndex2 > i) {
            if (dragPosition.y < childTop + dragHeight2) {
              idx = i;
              break;
            }
            continue;
          }
          idx = i;
          break;
        }
      }
      return idx;
    }
  };
  const index = cols > 1 ? location2.getGridIndex() : location2.getColIndex();
  root2.dispatch("MOVE_ITEM", { query: view, index });
  const currentIndex = dragState.getIndex();
  if (currentIndex === void 0 || currentIndex !== index) {
    dragState.setIndex(index);
    if (currentIndex === void 0)
      return;
    root2.dispatch("DID_REORDER_ITEMS", {
      items: root2.query("GET_ACTIVE_ITEMS"),
      origin: oldIndex,
      target: index
    });
  }
};
const route$2 = createRoute({
  DID_ADD_ITEM: addItemView,
  DID_REMOVE_ITEM: removeItemView,
  DID_DRAG_ITEM: dragItem
});
const write$5 = ({ root: root2, props, actions: actions2, shouldOptimize }) => {
  route$2({ root: root2, props, actions: actions2 });
  const { dragCoordinates } = props;
  const horizontalSpace = root2.rect.element.width;
  const visibleChildren = root2.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  const dragIndex = dragCoordinates ? getItemIndexByPosition(root2, children, dragCoordinates) : null;
  const addIndex = root2.ref.addIndex || null;
  root2.ref.addIndex = null;
  let dragIndexOffset = 0;
  let removeIndexOffset = 0;
  let addIndexOffset = 0;
  if (children.length === 0)
    return;
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    let offsetY = 0;
    let dragOffset = 0;
    children.forEach((child, index) => {
      if (dragIndex) {
        let dist = index - dragIndex;
        if (dist === -2) {
          dragOffset = -itemVerticalMargin * 0.25;
        } else if (dist === -1) {
          dragOffset = -itemVerticalMargin * 0.75;
        } else if (dist === 0) {
          dragOffset = itemVerticalMargin * 0.75;
        } else if (dist === 1) {
          dragOffset = itemVerticalMargin * 0.25;
        } else {
          dragOffset = 0;
        }
      }
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      if (!child.markedForRemoval) {
        moveItem(child, 0, offsetY + dragOffset);
      }
      let itemHeight2 = child.rect.element.height + itemVerticalMargin;
      let visualHeight = itemHeight2 * (child.markedForRemoval ? child.opacity : 1);
      offsetY += visualHeight;
    });
  } else {
    let prevX = 0;
    let prevY = 0;
    children.forEach((child, index) => {
      if (index === dragIndex) {
        dragIndexOffset = 1;
      }
      if (index === addIndex) {
        addIndexOffset += 1;
      }
      if (child.markedForRemoval && child.opacity < 0.5) {
        removeIndexOffset -= 1;
      }
      const visualIndex = index + addIndexOffset + dragIndexOffset + removeIndexOffset;
      const indexX = visualIndex % itemsPerRow;
      const indexY = Math.floor(visualIndex / itemsPerRow);
      const offsetX = indexX * itemWidth;
      const offsetY = indexY * itemHeight;
      const vectorX = Math.sign(offsetX - prevX);
      const vectorY = Math.sign(offsetY - prevY);
      prevX = offsetX;
      prevY = offsetY;
      if (child.markedForRemoval)
        return;
      if (shouldOptimize) {
        child.translateX = null;
        child.translateY = null;
      }
      moveItem(child, offsetX, offsetY, vectorX, vectorY);
    });
  }
};
const filterSetItemActions = (child, actions2) => actions2.filter((action) => {
  if (action.data && action.data.id) {
    return child.id === action.data.id;
  }
  return true;
});
const list = createView({
  create: create$8,
  write: write$5,
  tag: "ul",
  name: "list",
  didWriteView: ({ root: root2 }) => {
    root2.childViews.filter((view) => view.markedForRemoval && view.opacity === 0 && view.resting).forEach((view) => {
      view._destroy();
      root2.removeChildView(view);
    });
  },
  filterFrameActionsForChild: filterSetItemActions,
  mixins: {
    apis: ["dragCoordinates"]
  }
});
const create$9 = ({ root: root2, props }) => {
  root2.ref.list = root2.appendChildView(root2.createChildView(list));
  props.dragCoordinates = null;
  props.overflowing = false;
};
const storeDragCoordinates = ({ root: root2, props, action }) => {
  if (!root2.query("GET_ITEM_INSERT_LOCATION_FREEDOM"))
    return;
  props.dragCoordinates = {
    left: action.position.scopeLeft - root2.ref.list.rect.element.left,
    top: action.position.scopeTop - (root2.rect.outer.top + root2.rect.element.marginTop + root2.rect.element.scrollTop)
  };
};
const clearDragCoordinates = ({ props }) => {
  props.dragCoordinates = null;
};
const route$3 = createRoute({
  DID_DRAG: storeDragCoordinates,
  DID_END_DRAG: clearDragCoordinates
});
const write$6 = ({ root: root2, props, actions: actions2 }) => {
  route$3({ root: root2, props, actions: actions2 });
  root2.ref.list.dragCoordinates = props.dragCoordinates;
  if (props.overflowing && !props.overflow) {
    props.overflowing = false;
    root2.element.dataset.state = "";
    root2.height = null;
  }
  if (props.overflow) {
    const newHeight = Math.round(props.overflow);
    if (newHeight !== root2.height) {
      props.overflowing = true;
      root2.element.dataset.state = "overflow";
      root2.height = newHeight;
    }
  }
};
const listScroller = createView({
  create: create$9,
  write: write$6,
  name: "list-scroller",
  mixins: {
    apis: ["overflow", "dragCoordinates"],
    styles: ["height", "translateY"],
    animations: {
      translateY: "spring"
    }
  }
});
const attrToggle = (element, name2, state2, enabledValue = "") => {
  if (state2) {
    attr(element, name2, enabledValue);
  } else {
    element.removeAttribute(name2);
  }
};
const resetFileInput = (input) => {
  if (!input || input.value === "") {
    return;
  }
  try {
    input.value = "";
  } catch (err) {
  }
  if (input.value) {
    const form = createElement$1("form");
    const parentNode = input.parentNode;
    const ref = input.nextSibling;
    form.appendChild(input);
    form.reset();
    if (ref) {
      parentNode.insertBefore(input, ref);
    } else {
      parentNode.appendChild(input);
    }
  }
};
const create$a = ({ root: root2, props }) => {
  root2.element.id = `filepond--browser-${props.id}`;
  attr(root2.element, "name", root2.query("GET_NAME"));
  attr(root2.element, "aria-controls", `filepond--assistant-${props.id}`);
  attr(root2.element, "aria-labelledby", `filepond--drop-label-${props.id}`);
  setAcceptedFileTypes({ root: root2, action: { value: root2.query("GET_ACCEPTED_FILE_TYPES") } });
  toggleAllowMultiple({ root: root2, action: { value: root2.query("GET_ALLOW_MULTIPLE") } });
  toggleDirectoryFilter({ root: root2, action: { value: root2.query("GET_ALLOW_DIRECTORIES_ONLY") } });
  toggleDisabled({ root: root2 });
  toggleRequired({ root: root2, action: { value: root2.query("GET_REQUIRED") } });
  setCaptureMethod({ root: root2, action: { value: root2.query("GET_CAPTURE_METHOD") } });
  root2.ref.handleChange = (e2) => {
    if (!root2.element.value) {
      return;
    }
    const files = Array.from(root2.element.files).map((file2) => {
      file2._relativePath = file2.webkitRelativePath;
      return file2;
    });
    setTimeout(() => {
      props.onload(files);
      resetFileInput(root2.element);
    }, 250);
  };
  root2.element.addEventListener("change", root2.ref.handleChange);
};
const setAcceptedFileTypes = ({ root: root2, action }) => {
  if (!root2.query("GET_ALLOW_SYNC_ACCEPT_ATTRIBUTE"))
    return;
  attrToggle(root2.element, "accept", !!action.value, action.value ? action.value.join(",") : "");
};
const toggleAllowMultiple = ({ root: root2, action }) => {
  attrToggle(root2.element, "multiple", action.value);
};
const toggleDirectoryFilter = ({ root: root2, action }) => {
  attrToggle(root2.element, "webkitdirectory", action.value);
};
const toggleDisabled = ({ root: root2 }) => {
  const isDisabled2 = root2.query("GET_DISABLED");
  const doesAllowBrowse = root2.query("GET_ALLOW_BROWSE");
  const disableField = isDisabled2 || !doesAllowBrowse;
  attrToggle(root2.element, "disabled", disableField);
};
const toggleRequired = ({ root: root2, action }) => {
  if (!action.value) {
    attrToggle(root2.element, "required", false);
  } else if (root2.query("GET_TOTAL_ITEMS") === 0) {
    attrToggle(root2.element, "required", true);
  }
};
const setCaptureMethod = ({ root: root2, action }) => {
  attrToggle(root2.element, "capture", !!action.value, action.value === true ? "" : action.value);
};
const updateRequiredStatus = ({ root: root2 }) => {
  const { element } = root2;
  if (root2.query("GET_TOTAL_ITEMS") > 0) {
    attrToggle(element, "required", false);
    attrToggle(element, "name", false);
    const activeItems = root2.query("GET_ACTIVE_ITEMS");
    let hasInvalidField = false;
    for (let i = 0; i < activeItems.length; i++) {
      if (activeItems[i].status === ItemStatus.LOAD_ERROR) {
        hasInvalidField = true;
      }
    }
    root2.element.setCustomValidity(
      hasInvalidField ? root2.query("GET_LABEL_INVALID_FIELD") : ""
    );
  } else {
    attrToggle(element, "name", true, root2.query("GET_NAME"));
    const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
    if (shouldCheckValidity) {
      element.setCustomValidity("");
    }
    if (root2.query("GET_REQUIRED")) {
      attrToggle(element, "required", true);
    }
  }
};
const updateFieldValidityStatus = ({ root: root2 }) => {
  const shouldCheckValidity = root2.query("GET_CHECK_VALIDITY");
  if (!shouldCheckValidity)
    return;
  root2.element.setCustomValidity(root2.query("GET_LABEL_INVALID_FIELD"));
};
const browser = createView({
  tag: "input",
  name: "browser",
  ignoreRect: true,
  ignoreRectUpdate: true,
  attributes: {
    type: "file"
  },
  create: create$a,
  destroy: ({ root: root2 }) => {
    root2.element.removeEventListener("change", root2.ref.handleChange);
  },
  write: createRoute({
    DID_LOAD_ITEM: updateRequiredStatus,
    DID_REMOVE_ITEM: updateRequiredStatus,
    DID_THROW_ITEM_INVALID: updateFieldValidityStatus,
    DID_SET_DISABLED: toggleDisabled,
    DID_SET_ALLOW_BROWSE: toggleDisabled,
    DID_SET_ALLOW_DIRECTORIES_ONLY: toggleDirectoryFilter,
    DID_SET_ALLOW_MULTIPLE: toggleAllowMultiple,
    DID_SET_ACCEPTED_FILE_TYPES: setAcceptedFileTypes,
    DID_SET_CAPTURE_METHOD: setCaptureMethod,
    DID_SET_REQUIRED: toggleRequired
  })
});
const Key = {
  ENTER: 13,
  SPACE: 32
};
const create$b = ({ root: root2, props }) => {
  const label = createElement$1("label");
  attr(label, "for", `filepond--browser-${props.id}`);
  attr(label, "id", `filepond--drop-label-${props.id}`);
  root2.ref.handleKeyDown = (e2) => {
    const isActivationKey = e2.keyCode === Key.ENTER || e2.keyCode === Key.SPACE;
    if (!isActivationKey)
      return;
    e2.preventDefault();
    root2.ref.label.click();
  };
  root2.ref.handleClick = (e2) => {
    const isLabelClick = e2.target === label || label.contains(e2.target);
    if (isLabelClick)
      return;
    root2.ref.label.click();
  };
  label.addEventListener("keydown", root2.ref.handleKeyDown);
  root2.element.addEventListener("click", root2.ref.handleClick);
  updateLabelValue(label, props.caption);
  root2.appendChild(label);
  root2.ref.label = label;
};
const updateLabelValue = (label, value) => {
  label.innerHTML = value;
  const clickable = label.querySelector(".filepond--label-action");
  if (clickable) {
    attr(clickable, "tabindex", "0");
  }
  return value;
};
const dropLabel = createView({
  name: "drop-label",
  ignoreRect: true,
  create: create$b,
  destroy: ({ root: root2 }) => {
    root2.ref.label.addEventListener("keydown", root2.ref.handleKeyDown);
    root2.element.removeEventListener("click", root2.ref.handleClick);
  },
  write: createRoute({
    DID_SET_LABEL_IDLE: ({ root: root2, action }) => {
      updateLabelValue(root2.ref.label, action.value);
    }
  }),
  mixins: {
    styles: ["opacity", "translateX", "translateY"],
    animations: {
      opacity: { type: "tween", duration: 150 },
      translateX: "spring",
      translateY: "spring"
    }
  }
});
const blob = createView({
  name: "drip-blob",
  ignoreRect: true,
  mixins: {
    styles: ["translateX", "translateY", "scaleX", "scaleY", "opacity"],
    animations: {
      scaleX: "spring",
      scaleY: "spring",
      translateX: "spring",
      translateY: "spring",
      opacity: { type: "tween", duration: 250 }
    }
  }
});
const addBlob = ({ root: root2 }) => {
  const centerX = root2.rect.element.width * 0.5;
  const centerY = root2.rect.element.height * 0.5;
  root2.ref.blob = root2.appendChildView(
    root2.createChildView(blob, {
      opacity: 0,
      scaleX: 2.5,
      scaleY: 2.5,
      translateX: centerX,
      translateY: centerY
    })
  );
};
const moveBlob = ({ root: root2, action }) => {
  if (!root2.ref.blob) {
    addBlob({ root: root2 });
    return;
  }
  root2.ref.blob.translateX = action.position.scopeLeft;
  root2.ref.blob.translateY = action.position.scopeTop;
  root2.ref.blob.scaleX = 1;
  root2.ref.blob.scaleY = 1;
  root2.ref.blob.opacity = 1;
};
const hideBlob = ({ root: root2 }) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.opacity = 0;
};
const explodeBlob = ({ root: root2 }) => {
  if (!root2.ref.blob) {
    return;
  }
  root2.ref.blob.scaleX = 2.5;
  root2.ref.blob.scaleY = 2.5;
  root2.ref.blob.opacity = 0;
};
const write$7 = ({ root: root2, props, actions: actions2 }) => {
  route$4({ root: root2, props, actions: actions2 });
  const { blob: blob2 } = root2.ref;
  if (actions2.length === 0 && blob2 && blob2.opacity === 0) {
    root2.removeChildView(blob2);
    root2.ref.blob = null;
  }
};
const route$4 = createRoute({
  DID_DRAG: moveBlob,
  DID_DROP: explodeBlob,
  DID_END_DRAG: hideBlob
});
const drip = createView({
  ignoreRect: true,
  ignoreRectUpdate: true,
  name: "drip",
  write: write$7
});
const setInputFiles = (element, files) => {
  try {
    const dataTransfer = new DataTransfer();
    files.forEach((file2) => {
      if (file2 instanceof File) {
        dataTransfer.items.add(file2);
      } else {
        dataTransfer.items.add(
          new File([file2], file2.name, {
            type: file2.type
          })
        );
      }
    });
    element.files = dataTransfer.files;
  } catch (err) {
    return false;
  }
  return true;
};
const create$c = ({ root: root2 }) => {
  root2.ref.fields = {};
  const legend = document.createElement("legend");
  legend.textContent = "Files";
  root2.element.appendChild(legend);
};
const getField = (root2, id) => root2.ref.fields[id];
const syncFieldPositionsWithItems = (root2) => {
  root2.query("GET_ACTIVE_ITEMS").forEach((item2) => {
    if (!root2.ref.fields[item2.id])
      return;
    root2.element.appendChild(root2.ref.fields[item2.id]);
  });
};
const didReorderItems = ({ root: root2 }) => syncFieldPositionsWithItems(root2);
const didAddItem = ({ root: root2, action }) => {
  const fileItem = root2.query("GET_ITEM", action.id);
  const isLocalFile = fileItem.origin === FileOrigin.LOCAL;
  const shouldUseFileInput = !isLocalFile && root2.query("SHOULD_UPDATE_FILE_INPUT");
  const dataContainer = createElement$1("input");
  dataContainer.type = shouldUseFileInput ? "file" : "hidden";
  dataContainer.name = root2.query("GET_NAME");
  root2.ref.fields[action.id] = dataContainer;
  syncFieldPositionsWithItems(root2);
};
const didLoadItem$1 = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.serverFileReference !== null)
    field.value = action.serverFileReference;
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  const fileItem = root2.query("GET_ITEM", action.id);
  setInputFiles(field, [fileItem.file]);
};
const didPrepareOutput = ({ root: root2, action }) => {
  if (!root2.query("SHOULD_UPDATE_FILE_INPUT"))
    return;
  setTimeout(() => {
    const field = getField(root2, action.id);
    if (!field)
      return;
    setInputFiles(field, [action.file]);
  }, 0);
};
const didSetDisabled = ({ root: root2 }) => {
  root2.element.disabled = root2.query("GET_DISABLED");
};
const didRemoveItem = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (field.parentNode)
    field.parentNode.removeChild(field);
  delete root2.ref.fields[action.id];
};
const didDefineValue = ({ root: root2, action }) => {
  const field = getField(root2, action.id);
  if (!field)
    return;
  if (action.value === null) {
    field.removeAttribute("value");
  } else {
    if (field.type != "file") {
      field.value = action.value;
    }
  }
  syncFieldPositionsWithItems(root2);
};
const write$8 = createRoute({
  DID_SET_DISABLED: didSetDisabled,
  DID_ADD_ITEM: didAddItem,
  DID_LOAD_ITEM: didLoadItem$1,
  DID_REMOVE_ITEM: didRemoveItem,
  DID_DEFINE_VALUE: didDefineValue,
  DID_PREPARE_OUTPUT: didPrepareOutput,
  DID_REORDER_ITEMS: didReorderItems,
  DID_SORT_ITEMS: didReorderItems
});
const data = createView({
  tag: "fieldset",
  name: "data",
  create: create$c,
  write: write$8,
  ignoreRect: true
});
const getRootNode = (element) => "getRootNode" in element ? element.getRootNode() : document;
const images = ["jpg", "jpeg", "png", "gif", "bmp", "webp", "svg", "tiff"];
const text$1 = ["css", "csv", "html", "txt"];
const map = {
  zip: "zip|compressed",
  epub: "application/epub+zip"
};
const guesstimateMimeType = (extension = "") => {
  extension = extension.toLowerCase();
  if (images.includes(extension)) {
    return "image/" + (extension === "jpg" ? "jpeg" : extension === "svg" ? "svg+xml" : extension);
  }
  if (text$1.includes(extension)) {
    return "text/" + extension;
  }
  return map[extension] || "";
};
const requestDataTransferItems = (dataTransfer) => new Promise((resolve, reject) => {
  const links = getLinks(dataTransfer);
  if (links.length && !hasFiles(dataTransfer)) {
    return resolve(links);
  }
  getFiles(dataTransfer).then(resolve);
});
const hasFiles = (dataTransfer) => {
  if (dataTransfer.files)
    return dataTransfer.files.length > 0;
  return false;
};
const getFiles = (dataTransfer) => new Promise((resolve, reject) => {
  const promisedFiles = (dataTransfer.items ? Array.from(dataTransfer.items) : []).filter((item2) => isFileSystemItem(item2)).map((item2) => getFilesFromItem(item2));
  if (!promisedFiles.length) {
    resolve(dataTransfer.files ? Array.from(dataTransfer.files) : []);
    return;
  }
  Promise.all(promisedFiles).then((returnedFileGroups) => {
    const files = [];
    returnedFileGroups.forEach((group) => {
      files.push.apply(files, group);
    });
    resolve(
      files.filter((file2) => file2).map((file2) => {
        if (!file2._relativePath)
          file2._relativePath = file2.webkitRelativePath;
        return file2;
      })
    );
  }).catch(console.error);
});
const isFileSystemItem = (item2) => {
  if (isEntry(item2)) {
    const entry = getAsEntry(item2);
    if (entry) {
      return entry.isFile || entry.isDirectory;
    }
  }
  return item2.kind === "file";
};
const getFilesFromItem = (item2) => new Promise((resolve, reject) => {
  if (isDirectoryEntry(item2)) {
    getFilesInDirectory(getAsEntry(item2)).then(resolve).catch(reject);
    return;
  }
  resolve([item2.getAsFile()]);
});
const getFilesInDirectory = (entry) => new Promise((resolve, reject) => {
  const files = [];
  let dirCounter = 0;
  let fileCounter = 0;
  const resolveIfDone = () => {
    if (fileCounter === 0 && dirCounter === 0) {
      resolve(files);
    }
  };
  const readEntries = (dirEntry) => {
    dirCounter++;
    const directoryReader = dirEntry.createReader();
    const readBatch = () => {
      directoryReader.readEntries((entries) => {
        if (entries.length === 0) {
          dirCounter--;
          resolveIfDone();
          return;
        }
        entries.forEach((entry2) => {
          if (entry2.isDirectory) {
            readEntries(entry2);
          } else {
            fileCounter++;
            entry2.file((file2) => {
              const correctedFile = correctMissingFileType(file2);
              if (entry2.fullPath)
                correctedFile._relativePath = entry2.fullPath;
              files.push(correctedFile);
              fileCounter--;
              resolveIfDone();
            });
          }
        });
        readBatch();
      }, reject);
    };
    readBatch();
  };
  readEntries(entry);
});
const correctMissingFileType = (file2) => {
  if (file2.type.length)
    return file2;
  const date = file2.lastModifiedDate;
  const name2 = file2.name;
  const type = guesstimateMimeType(getExtensionFromFilename(file2.name));
  if (!type.length)
    return file2;
  file2 = file2.slice(0, file2.size, type);
  file2.name = name2;
  file2.lastModifiedDate = date;
  return file2;
};
const isDirectoryEntry = (item2) => isEntry(item2) && (getAsEntry(item2) || {}).isDirectory;
const isEntry = (item2) => "webkitGetAsEntry" in item2;
const getAsEntry = (item2) => item2.webkitGetAsEntry();
const getLinks = (dataTransfer) => {
  let links = [];
  try {
    links = getLinksFromTransferMetaData(dataTransfer);
    if (links.length) {
      return links;
    }
    links = getLinksFromTransferURLData(dataTransfer);
  } catch (e2) {
  }
  return links;
};
const getLinksFromTransferURLData = (dataTransfer) => {
  let data2 = dataTransfer.getData("url");
  if (typeof data2 === "string" && data2.length) {
    return [data2];
  }
  return [];
};
const getLinksFromTransferMetaData = (dataTransfer) => {
  let data2 = dataTransfer.getData("text/html");
  if (typeof data2 === "string" && data2.length) {
    const matches = data2.match(/src\s*=\s*"(.+?)"/);
    if (matches) {
      return [matches[1]];
    }
  }
  return [];
};
const dragNDropObservers = [];
const eventPosition = (e2) => ({
  pageLeft: e2.pageX,
  pageTop: e2.pageY,
  scopeLeft: e2.offsetX || e2.layerX,
  scopeTop: e2.offsetY || e2.layerY
});
const createDragNDropClient = (element, scopeToObserve, filterElement) => {
  const observer = getDragNDropObserver(scopeToObserve);
  const client = {
    element,
    filterElement,
    state: null,
    ondrop: () => {
    },
    onenter: () => {
    },
    ondrag: () => {
    },
    onexit: () => {
    },
    onload: () => {
    },
    allowdrop: () => {
    }
  };
  client.destroy = observer.addListener(client);
  return client;
};
const getDragNDropObserver = (element) => {
  const observer = dragNDropObservers.find((item2) => item2.element === element);
  if (observer) {
    return observer;
  }
  const newObserver = createDragNDropObserver(element);
  dragNDropObservers.push(newObserver);
  return newObserver;
};
const createDragNDropObserver = (element) => {
  const clients = [];
  const routes = {
    dragenter,
    dragover,
    dragleave,
    drop
  };
  const handlers = {};
  forin(routes, (event, createHandler) => {
    handlers[event] = createHandler(element, clients);
    element.addEventListener(event, handlers[event], false);
  });
  const observer = {
    element,
    addListener: (client) => {
      clients.push(client);
      return () => {
        clients.splice(clients.indexOf(client), 1);
        if (clients.length === 0) {
          dragNDropObservers.splice(dragNDropObservers.indexOf(observer), 1);
          forin(routes, (event) => {
            element.removeEventListener(event, handlers[event], false);
          });
        }
      };
    }
  };
  return observer;
};
const elementFromPoint = (root2, point) => {
  if (!("elementFromPoint" in root2)) {
    root2 = document;
  }
  return root2.elementFromPoint(point.x, point.y);
};
const isEventTarget = (e2, target) => {
  const root2 = getRootNode(target);
  const elementAtPosition = elementFromPoint(root2, {
    x: e2.pageX - window.pageXOffset,
    y: e2.pageY - window.pageYOffset
  });
  return elementAtPosition === target || target.contains(elementAtPosition);
};
let initialTarget = null;
const setDropEffect = (dataTransfer, effect2) => {
  try {
    dataTransfer.dropEffect = effect2;
  } catch (e2) {
  }
};
const dragenter = (root2, clients) => (e2) => {
  e2.preventDefault();
  initialTarget = e2.target;
  clients.forEach((client) => {
    const { element, onenter } = client;
    if (isEventTarget(e2, element)) {
      client.state = "enter";
      onenter(eventPosition(e2));
    }
  });
};
const dragover = (root2, clients) => (e2) => {
  e2.preventDefault();
  const dataTransfer = e2.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    let overDropTarget = false;
    clients.some((client) => {
      const { filterElement, element, onenter, onexit, ondrag, allowdrop } = client;
      setDropEffect(dataTransfer, "copy");
      const allowsTransfer = allowdrop(items);
      if (!allowsTransfer) {
        setDropEffect(dataTransfer, "none");
        return;
      }
      if (isEventTarget(e2, element)) {
        overDropTarget = true;
        if (client.state === null) {
          client.state = "enter";
          onenter(eventPosition(e2));
          return;
        }
        client.state = "over";
        if (filterElement && !allowsTransfer) {
          setDropEffect(dataTransfer, "none");
          return;
        }
        ondrag(eventPosition(e2));
      } else {
        if (filterElement && !overDropTarget) {
          setDropEffect(dataTransfer, "none");
        }
        if (client.state) {
          client.state = null;
          onexit(eventPosition(e2));
        }
      }
    });
  });
};
const drop = (root2, clients) => (e2) => {
  e2.preventDefault();
  const dataTransfer = e2.dataTransfer;
  requestDataTransferItems(dataTransfer).then((items) => {
    clients.forEach((client) => {
      const { filterElement, element, ondrop, onexit, allowdrop } = client;
      client.state = null;
      if (filterElement && !isEventTarget(e2, element))
        return;
      if (!allowdrop(items))
        return onexit(eventPosition(e2));
      ondrop(eventPosition(e2), items);
    });
  });
};
const dragleave = (root2, clients) => (e2) => {
  if (initialTarget !== e2.target) {
    return;
  }
  clients.forEach((client) => {
    const { onexit } = client;
    client.state = null;
    onexit(eventPosition(e2));
  });
};
const createHopper = (scope, validateItems, options) => {
  scope.classList.add("filepond--hopper");
  const { catchesDropsOnPage, requiresDropOnElement, filterItems = (items) => items } = options;
  const client = createDragNDropClient(
    scope,
    catchesDropsOnPage ? document.documentElement : scope,
    requiresDropOnElement
  );
  let lastState = "";
  let currentState = "";
  client.allowdrop = (items) => {
    return validateItems(filterItems(items));
  };
  client.ondrop = (position, items) => {
    const filteredItems = filterItems(items);
    if (!validateItems(filteredItems)) {
      api.ondragend(position);
      return;
    }
    currentState = "drag-drop";
    api.onload(filteredItems, position);
  };
  client.ondrag = (position) => {
    api.ondrag(position);
  };
  client.onenter = (position) => {
    currentState = "drag-over";
    api.ondragstart(position);
  };
  client.onexit = (position) => {
    currentState = "drag-exit";
    api.ondragend(position);
  };
  const api = {
    updateHopperState: () => {
      if (lastState !== currentState) {
        scope.dataset.hopperState = currentState;
        lastState = currentState;
      }
    },
    onload: () => {
    },
    ondragstart: () => {
    },
    ondrag: () => {
    },
    ondragend: () => {
    },
    destroy: () => {
      client.destroy();
    }
  };
  return api;
};
let listening = false;
const listeners$1 = [];
const handlePaste = (e2) => {
  const activeEl = document.activeElement;
  const isActiveElementEditable = activeEl && (/textarea|input/i.test(activeEl.nodeName) || activeEl.getAttribute("contenteditable") === "true");
  if (isActiveElementEditable) {
    let inScope = false;
    let element = activeEl;
    while (element !== document.body) {
      if (element.classList.contains("filepond--root")) {
        inScope = true;
        break;
      }
      element = element.parentNode;
    }
    if (!inScope)
      return;
  }
  requestDataTransferItems(e2.clipboardData).then((files) => {
    if (!files.length) {
      return;
    }
    listeners$1.forEach((listener) => listener(files));
  });
};
const listen = (cb) => {
  if (listeners$1.includes(cb)) {
    return;
  }
  listeners$1.push(cb);
  if (listening) {
    return;
  }
  listening = true;
  document.addEventListener("paste", handlePaste);
};
const unlisten = (listener) => {
  arrayRemove(listeners$1, listeners$1.indexOf(listener));
  if (listeners$1.length === 0) {
    document.removeEventListener("paste", handlePaste);
    listening = false;
  }
};
const createPaster = () => {
  const cb = (files) => {
    api.onload(files);
  };
  const api = {
    destroy: () => {
      unlisten(cb);
    },
    onload: () => {
    }
  };
  listen(cb);
  return api;
};
const create$d = ({ root: root2, props }) => {
  root2.element.id = `filepond--assistant-${props.id}`;
  attr(root2.element, "role", "alert");
  attr(root2.element, "aria-live", "polite");
  attr(root2.element, "aria-relevant", "additions");
};
let addFilesNotificationTimeout = null;
let notificationClearTimeout = null;
const filenames = [];
const assist = (root2, message) => {
  root2.element.textContent = message;
};
const clear$1 = (root2) => {
  root2.element.textContent = "";
};
const listModified = (root2, filename, label) => {
  const total = root2.query("GET_TOTAL_ITEMS");
  assist(
    root2,
    `${label} ${filename}, ${total} ${total === 1 ? root2.query("GET_LABEL_FILE_COUNT_SINGULAR") : root2.query("GET_LABEL_FILE_COUNT_PLURAL")}`
  );
  clearTimeout(notificationClearTimeout);
  notificationClearTimeout = setTimeout(() => {
    clear$1(root2);
  }, 1500);
};
const isUsingFilePond = (root2) => root2.element.parentNode.contains(document.activeElement);
const itemAdded = ({ root: root2, action }) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  root2.element.textContent = "";
  const item2 = root2.query("GET_ITEM", action.id);
  filenames.push(item2.filename);
  clearTimeout(addFilesNotificationTimeout);
  addFilesNotificationTimeout = setTimeout(() => {
    listModified(root2, filenames.join(", "), root2.query("GET_LABEL_FILE_ADDED"));
    filenames.length = 0;
  }, 750);
};
const itemRemoved = ({ root: root2, action }) => {
  if (!isUsingFilePond(root2)) {
    return;
  }
  const item2 = action.item;
  listModified(root2, item2.filename, root2.query("GET_LABEL_FILE_REMOVED"));
};
const itemProcessed = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_COMPLETE");
  assist(root2, `${filename} ${label}`);
};
const itemProcessedUndo = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  const label = root2.query("GET_LABEL_FILE_PROCESSING_ABORTED");
  assist(root2, `${filename} ${label}`);
};
const itemError = ({ root: root2, action }) => {
  const item2 = root2.query("GET_ITEM", action.id);
  const filename = item2.filename;
  assist(root2, `${action.status.main} ${filename} ${action.status.sub}`);
};
const assistant = createView({
  create: create$d,
  ignoreRect: true,
  ignoreRectUpdate: true,
  write: createRoute({
    DID_LOAD_ITEM: itemAdded,
    DID_REMOVE_ITEM: itemRemoved,
    DID_COMPLETE_ITEM_PROCESSING: itemProcessed,
    DID_ABORT_ITEM_PROCESSING: itemProcessedUndo,
    DID_REVERT_ITEM_PROCESSING: itemProcessedUndo,
    DID_THROW_ITEM_REMOVE_ERROR: itemError,
    DID_THROW_ITEM_LOAD_ERROR: itemError,
    DID_THROW_ITEM_INVALID: itemError,
    DID_THROW_ITEM_PROCESSING_ERROR: itemError
  }),
  tag: "span",
  name: "assistant"
});
const toCamels = (string, separator = "-") => string.replace(new RegExp(`${separator}.`, "g"), (sub) => sub.charAt(1).toUpperCase());
const debounce$1 = (func, interval = 16, immidiateOnly = true) => {
  let last = Date.now();
  let timeout2 = null;
  return (...args) => {
    clearTimeout(timeout2);
    const dist = Date.now() - last;
    const fn3 = () => {
      last = Date.now();
      func(...args);
    };
    if (dist < interval) {
      if (!immidiateOnly) {
        timeout2 = setTimeout(fn3, interval - dist);
      }
    } else {
      fn3();
    }
  };
};
const MAX_FILES_LIMIT = 1e6;
const prevent = (e2) => e2.preventDefault();
const create$e = ({ root: root2, props }) => {
  const id = root2.query("GET_ID");
  if (id) {
    root2.element.id = id;
  }
  const className = root2.query("GET_CLASS_NAME");
  if (className) {
    className.split(" ").filter((name2) => name2.length).forEach((name2) => {
      root2.element.classList.add(name2);
    });
  }
  root2.ref.label = root2.appendChildView(
    root2.createChildView(dropLabel, {
      ...props,
      translateY: null,
      caption: root2.query("GET_LABEL_IDLE")
    })
  );
  root2.ref.list = root2.appendChildView(root2.createChildView(listScroller, { translateY: null }));
  root2.ref.panel = root2.appendChildView(root2.createChildView(panel, { name: "panel-root" }));
  root2.ref.assistant = root2.appendChildView(root2.createChildView(assistant, { ...props }));
  root2.ref.data = root2.appendChildView(root2.createChildView(data, { ...props }));
  root2.ref.measure = createElement$1("div");
  root2.ref.measure.style.height = "100%";
  root2.element.appendChild(root2.ref.measure);
  root2.ref.bounds = null;
  root2.query("GET_STYLES").filter((style) => !isEmpty(style.value)).map(({ name: name2, value }) => {
    root2.element.dataset[name2] = value;
  });
  root2.ref.widthPrevious = null;
  root2.ref.widthUpdated = debounce$1(() => {
    root2.ref.updateHistory = [];
    root2.dispatch("DID_RESIZE_ROOT");
  }, 250);
  root2.ref.previousAspectRatio = null;
  root2.ref.updateHistory = [];
  const canHover = window.matchMedia("(pointer: fine) and (hover: hover)").matches;
  const hasPointerEvents = "PointerEvent" in window;
  if (root2.query("GET_ALLOW_REORDER") && hasPointerEvents && !canHover) {
    root2.element.addEventListener("touchmove", prevent, { passive: false });
    root2.element.addEventListener("gesturestart", prevent);
  }
  const credits = root2.query("GET_CREDITS");
  const hasCredits = credits.length === 2;
  if (hasCredits) {
    const frag = document.createElement("a");
    frag.className = "filepond--credits";
    frag.href = credits[0];
    frag.tabIndex = -1;
    frag.target = "_blank";
    frag.rel = "noopener noreferrer nofollow";
    frag.textContent = credits[1];
    root2.element.appendChild(frag);
    root2.ref.credits = frag;
  }
};
const write$9 = ({ root: root2, props, actions: actions2 }) => {
  route$5({ root: root2, props, actions: actions2 });
  actions2.filter((action) => /^DID_SET_STYLE_/.test(action.type)).filter((action) => !isEmpty(action.data.value)).map(({ type, data: data2 }) => {
    const name2 = toCamels(type.substring(8).toLowerCase(), "_");
    root2.element.dataset[name2] = data2.value;
    root2.invalidateLayout();
  });
  if (root2.rect.element.hidden)
    return;
  if (root2.rect.element.width !== root2.ref.widthPrevious) {
    root2.ref.widthPrevious = root2.rect.element.width;
    root2.ref.widthUpdated();
  }
  let bounds = root2.ref.bounds;
  if (!bounds) {
    bounds = root2.ref.bounds = calculateRootBoundingBoxHeight(root2);
    root2.element.removeChild(root2.ref.measure);
    root2.ref.measure = null;
  }
  const { hopper, label, list: list2, panel: panel2 } = root2.ref;
  if (hopper) {
    hopper.updateHopperState();
  }
  const aspectRatio = root2.query("GET_PANEL_ASPECT_RATIO");
  const isMultiItem = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  const maxItems = isMultiItem ? root2.query("GET_MAX_FILES") || MAX_FILES_LIMIT : 1;
  const atMaxCapacity = totalItems === maxItems;
  const addAction = actions2.find((action) => action.type === "DID_ADD_ITEM");
  if (atMaxCapacity && addAction) {
    const interactionMethod = addAction.data.interactionMethod;
    label.opacity = 0;
    if (isMultiItem) {
      label.translateY = -40;
    } else {
      if (interactionMethod === InteractionMethod.API) {
        label.translateX = 40;
      } else if (interactionMethod === InteractionMethod.BROWSE) {
        label.translateY = 40;
      } else {
        label.translateY = 30;
      }
    }
  } else if (!atMaxCapacity) {
    label.opacity = 1;
    label.translateX = 0;
    label.translateY = 0;
  }
  const listItemMargin = calculateListItemMargin(root2);
  const listHeight = calculateListHeight(root2);
  const labelHeight = label.rect.element.height;
  const currentLabelHeight = !isMultiItem || atMaxCapacity ? 0 : labelHeight;
  const listMarginTop = atMaxCapacity ? list2.rect.element.marginTop : 0;
  const listMarginBottom = totalItems === 0 ? 0 : list2.rect.element.marginBottom;
  const visualHeight = currentLabelHeight + listMarginTop + listHeight.visual + listMarginBottom;
  const boundsHeight = currentLabelHeight + listMarginTop + listHeight.bounds + listMarginBottom;
  list2.translateY = Math.max(0, currentLabelHeight - list2.rect.element.marginTop) - listItemMargin.top;
  if (aspectRatio) {
    const width = root2.rect.element.width;
    const height = width * aspectRatio;
    if (aspectRatio !== root2.ref.previousAspectRatio) {
      root2.ref.previousAspectRatio = aspectRatio;
      root2.ref.updateHistory = [];
    }
    const history = root2.ref.updateHistory;
    history.push(width);
    const MAX_BOUNCES = 2;
    if (history.length > MAX_BOUNCES * 2) {
      const l2 = history.length;
      const bottom2 = l2 - 10;
      let bounces = 0;
      for (let i = l2; i >= bottom2; i--) {
        if (history[i] === history[i - 2]) {
          bounces++;
        }
        if (bounces >= MAX_BOUNCES) {
          return;
        }
      }
    }
    panel2.scalable = false;
    panel2.height = height;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      height - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = height;
  } else if (bounds.fixedHeight) {
    panel2.scalable = false;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      bounds.fixedHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
  } else if (bounds.cappedHeight) {
    const isCappedHeight = visualHeight >= bounds.cappedHeight;
    const panelHeight = Math.min(bounds.cappedHeight, visualHeight);
    panel2.scalable = true;
    panel2.height = isCappedHeight ? panelHeight : panelHeight - listItemMargin.top - listItemMargin.bottom;
    const listAvailableHeight = (
      // the height of the panel minus the label height
      panelHeight - currentLabelHeight - // the room we leave open between the end of the list and the panel bottom
      (listMarginBottom - listItemMargin.bottom) - // if we're full we need to leave some room between the top of the panel and the list
      (atMaxCapacity ? listMarginTop : 0)
    );
    if (visualHeight > bounds.cappedHeight && listHeight.visual > listAvailableHeight) {
      list2.overflow = listAvailableHeight;
    } else {
      list2.overflow = null;
    }
    root2.height = Math.min(
      bounds.cappedHeight,
      boundsHeight - listItemMargin.top - listItemMargin.bottom
    );
  } else {
    const itemMargin = totalItems > 0 ? listItemMargin.top + listItemMargin.bottom : 0;
    panel2.scalable = true;
    panel2.height = Math.max(labelHeight, visualHeight - itemMargin);
    root2.height = Math.max(labelHeight, boundsHeight - itemMargin);
  }
  if (root2.ref.credits && panel2.heightCurrent)
    root2.ref.credits.style.transform = `translateY(${panel2.heightCurrent}px)`;
};
const calculateListItemMargin = (root2) => {
  const item2 = root2.ref.list.childViews[0].childViews[0];
  return item2 ? {
    top: item2.rect.element.marginTop,
    bottom: item2.rect.element.marginBottom
  } : {
    top: 0,
    bottom: 0
  };
};
const calculateListHeight = (root2) => {
  let visual = 0;
  let bounds = 0;
  const scrollList = root2.ref.list;
  const itemList = scrollList.childViews[0];
  const visibleChildren = itemList.childViews.filter((child) => child.rect.element.height);
  const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
  if (children.length === 0)
    return { visual, bounds };
  const horizontalSpace = itemList.rect.element.width;
  const dragIndex = getItemIndexByPosition(itemList, children, scrollList.dragCoordinates);
  const childRect = children[0].rect.element;
  const itemVerticalMargin = childRect.marginTop + childRect.marginBottom;
  const itemHorizontalMargin = childRect.marginLeft + childRect.marginRight;
  const itemWidth = childRect.width + itemHorizontalMargin;
  const itemHeight = childRect.height + itemVerticalMargin;
  const newItem = typeof dragIndex !== "undefined" && dragIndex >= 0 ? 1 : 0;
  const removedItem = children.find((child) => child.markedForRemoval && child.opacity < 0.45) ? -1 : 0;
  const verticalItemCount = children.length + newItem + removedItem;
  const itemsPerRow = getItemsPerRow(horizontalSpace, itemWidth);
  if (itemsPerRow === 1) {
    children.forEach((item2) => {
      const height = item2.rect.element.height + itemVerticalMargin;
      bounds += height;
      visual += height * item2.opacity;
    });
  } else {
    bounds = Math.ceil(verticalItemCount / itemsPerRow) * itemHeight;
    visual = bounds;
  }
  return { visual, bounds };
};
const calculateRootBoundingBoxHeight = (root2) => {
  const height = root2.ref.measureHeight || null;
  const cappedHeight = parseInt(root2.style.maxHeight, 10) || null;
  const fixedHeight = height === 0 ? null : height;
  return {
    cappedHeight,
    fixedHeight
  };
};
const exceedsMaxFiles = (root2, items) => {
  const allowReplace = root2.query("GET_ALLOW_REPLACE");
  const allowMultiple = root2.query("GET_ALLOW_MULTIPLE");
  const totalItems = root2.query("GET_TOTAL_ITEMS");
  let maxItems = root2.query("GET_MAX_FILES");
  const totalBrowseItems = items.length;
  if (!allowMultiple && totalBrowseItems > 1) {
    root2.dispatch("DID_THROW_MAX_FILES", {
      source: items,
      error: createResponse("warning", 0, "Max files")
    });
    return true;
  }
  maxItems = allowMultiple ? maxItems : 1;
  if (!allowMultiple && allowReplace) {
    return false;
  }
  const hasMaxItems = isInt(maxItems);
  if (hasMaxItems && totalItems + totalBrowseItems > maxItems) {
    root2.dispatch("DID_THROW_MAX_FILES", {
      source: items,
      error: createResponse("warning", 0, "Max files")
    });
    return true;
  }
  return false;
};
const getDragIndex = (list2, children, position) => {
  const itemList = list2.childViews[0];
  return getItemIndexByPosition(itemList, children, {
    left: position.scopeLeft - itemList.rect.element.left,
    top: position.scopeTop - (list2.rect.outer.top + list2.rect.element.marginTop + list2.rect.element.scrollTop)
  });
};
const toggleDrop = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_DROP");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.hopper) {
    const hopper = createHopper(
      root2.element,
      (items) => {
        const beforeDropFile = root2.query("GET_BEFORE_DROP_FILE") || (() => true);
        const dropValidation = root2.query("GET_DROP_VALIDATION");
        return dropValidation ? items.every(
          (item2) => applyFilters("ALLOW_HOPPER_ITEM", item2, {
            query: root2.query
          }).every((result) => result === true) && beforeDropFile(item2)
        ) : true;
      },
      {
        filterItems: (items) => {
          const ignoredFiles = root2.query("GET_IGNORED_FILES");
          return items.filter((item2) => {
            if (isFile$1(item2)) {
              return !ignoredFiles.includes(item2.name.toLowerCase());
            }
            return true;
          });
        },
        catchesDropsOnPage: root2.query("GET_DROP_ON_PAGE"),
        requiresDropOnElement: root2.query("GET_DROP_ON_ELEMENT")
      }
    );
    hopper.onload = (items, position) => {
      const list2 = root2.ref.list.childViews[0];
      const visibleChildren = list2.childViews.filter((child) => child.rect.element.height);
      const children = root2.query("GET_ACTIVE_ITEMS").map((item2) => visibleChildren.find((child) => child.id === item2.id)).filter((item2) => item2);
      applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: getDragIndex(root2.ref.list, children, position),
          interactionMethod: InteractionMethod.DROP
        });
      });
      root2.dispatch("DID_DROP", { position });
      root2.dispatch("DID_END_DRAG", { position });
    };
    hopper.ondragstart = (position) => {
      root2.dispatch("DID_START_DRAG", { position });
    };
    hopper.ondrag = debounce$1((position) => {
      root2.dispatch("DID_DRAG", { position });
    });
    hopper.ondragend = (position) => {
      root2.dispatch("DID_END_DRAG", { position });
    };
    root2.ref.hopper = hopper;
    root2.ref.drip = root2.appendChildView(root2.createChildView(drip));
  } else if (!enabled && root2.ref.hopper) {
    root2.ref.hopper.destroy();
    root2.ref.hopper = null;
    root2.removeChildView(root2.ref.drip);
  }
};
const toggleBrowse = (root2, props) => {
  const isAllowed = root2.query("GET_ALLOW_BROWSE");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.browser) {
    root2.ref.browser = root2.appendChildView(
      root2.createChildView(browser, {
        ...props,
        onload: (items) => {
          applyFilterChain("ADD_ITEMS", items, {
            dispatch: root2.dispatch
          }).then((queue) => {
            if (exceedsMaxFiles(root2, queue))
              return false;
            root2.dispatch("ADD_ITEMS", {
              items: queue,
              index: -1,
              interactionMethod: InteractionMethod.BROWSE
            });
          });
        }
      }),
      0
    );
  } else if (!enabled && root2.ref.browser) {
    root2.removeChildView(root2.ref.browser);
    root2.ref.browser = null;
  }
};
const togglePaste = (root2) => {
  const isAllowed = root2.query("GET_ALLOW_PASTE");
  const isDisabled2 = root2.query("GET_DISABLED");
  const enabled = isAllowed && !isDisabled2;
  if (enabled && !root2.ref.paster) {
    root2.ref.paster = createPaster();
    root2.ref.paster.onload = (items) => {
      applyFilterChain("ADD_ITEMS", items, { dispatch: root2.dispatch }).then((queue) => {
        if (exceedsMaxFiles(root2, queue))
          return false;
        root2.dispatch("ADD_ITEMS", {
          items: queue,
          index: -1,
          interactionMethod: InteractionMethod.PASTE
        });
      });
    };
  } else if (!enabled && root2.ref.paster) {
    root2.ref.paster.destroy();
    root2.ref.paster = null;
  }
};
const route$5 = createRoute({
  DID_SET_ALLOW_BROWSE: ({ root: root2, props }) => {
    toggleBrowse(root2, props);
  },
  DID_SET_ALLOW_DROP: ({ root: root2 }) => {
    toggleDrop(root2);
  },
  DID_SET_ALLOW_PASTE: ({ root: root2 }) => {
    togglePaste(root2);
  },
  DID_SET_DISABLED: ({ root: root2, props }) => {
    toggleDrop(root2);
    togglePaste(root2);
    toggleBrowse(root2, props);
    const isDisabled2 = root2.query("GET_DISABLED");
    if (isDisabled2) {
      root2.element.dataset.disabled = "disabled";
    } else {
      root2.element.removeAttribute("data-disabled");
    }
  }
});
const root = createView({
  name: "root",
  read: ({ root: root2 }) => {
    if (root2.ref.measure) {
      root2.ref.measureHeight = root2.ref.measure.offsetHeight;
    }
  },
  create: create$e,
  write: write$9,
  destroy: ({ root: root2 }) => {
    if (root2.ref.paster) {
      root2.ref.paster.destroy();
    }
    if (root2.ref.hopper) {
      root2.ref.hopper.destroy();
    }
    root2.element.removeEventListener("touchmove", prevent);
    root2.element.removeEventListener("gesturestart", prevent);
  },
  mixins: {
    styles: ["height"]
  }
});
const createApp = (initialOptions = {}) => {
  let originalElement = null;
  const defaultOptions2 = getOptions();
  const store = createStore(
    // initial state (should be serializable)
    createInitialState(defaultOptions2),
    // queries
    [queries, createOptionQueries(defaultOptions2)],
    // action handlers
    [actions, createOptionActions(defaultOptions2)]
  );
  store.dispatch("SET_OPTIONS", { options: initialOptions });
  const visibilityHandler = () => {
    if (document.hidden)
      return;
    store.dispatch("KICK");
  };
  document.addEventListener("visibilitychange", visibilityHandler);
  let resizeDoneTimer = null;
  let isResizing = false;
  let isResizingHorizontally = false;
  let initialWindowWidth = null;
  let currentWindowWidth = null;
  const resizeHandler = () => {
    if (!isResizing) {
      isResizing = true;
    }
    clearTimeout(resizeDoneTimer);
    resizeDoneTimer = setTimeout(() => {
      isResizing = false;
      initialWindowWidth = null;
      currentWindowWidth = null;
      if (isResizingHorizontally) {
        isResizingHorizontally = false;
        store.dispatch("DID_STOP_RESIZE");
      }
    }, 500);
  };
  window.addEventListener("resize", resizeHandler);
  const view = root(store, { id: getUniqueId() });
  let isResting = false;
  let isHidden = false;
  const readWriteApi = {
    // necessary for update loop
    /**
     * Reads from dom (never call manually)
     * @private
     */
    _read: () => {
      if (isResizing) {
        currentWindowWidth = window.innerWidth;
        if (!initialWindowWidth) {
          initialWindowWidth = currentWindowWidth;
        }
        if (!isResizingHorizontally && currentWindowWidth !== initialWindowWidth) {
          store.dispatch("DID_START_RESIZE");
          isResizingHorizontally = true;
        }
      }
      if (isHidden && isResting) {
        isResting = view.element.offsetParent === null;
      }
      if (isResting)
        return;
      view._read();
      isHidden = view.rect.element.hidden;
    },
    /**
     * Writes to dom (never call manually)
     * @private
     */
    _write: (ts2) => {
      const actions2 = store.processActionQueue().filter((action) => !/^SET_/.test(action.type));
      if (isResting && !actions2.length)
        return;
      routeActionsToEvents(actions2);
      isResting = view._write(ts2, actions2, isResizingHorizontally);
      removeReleasedItems(store.query("GET_ITEMS"));
      if (isResting) {
        store.processDispatchQueue();
      }
    }
  };
  const createEvent = (name2) => (data2) => {
    const event = {
      type: name2
    };
    if (!data2) {
      return event;
    }
    if (data2.hasOwnProperty("error")) {
      event.error = data2.error ? { ...data2.error } : null;
    }
    if (data2.status) {
      event.status = { ...data2.status };
    }
    if (data2.file) {
      event.output = data2.file;
    }
    if (data2.source) {
      event.file = data2.source;
    } else if (data2.item || data2.id) {
      const item2 = data2.item ? data2.item : store.query("GET_ITEM", data2.id);
      event.file = item2 ? createItemAPI(item2) : null;
    }
    if (data2.items) {
      event.items = data2.items.map(createItemAPI);
    }
    if (/progress/.test(name2)) {
      event.progress = data2.progress;
    }
    if (data2.hasOwnProperty("origin") && data2.hasOwnProperty("target")) {
      event.origin = data2.origin;
      event.target = data2.target;
    }
    return event;
  };
  const eventRoutes = {
    DID_DESTROY: createEvent("destroy"),
    DID_INIT: createEvent("init"),
    DID_THROW_MAX_FILES: createEvent("warning"),
    DID_INIT_ITEM: createEvent("initfile"),
    DID_START_ITEM_LOAD: createEvent("addfilestart"),
    DID_UPDATE_ITEM_LOAD_PROGRESS: createEvent("addfileprogress"),
    DID_LOAD_ITEM: createEvent("addfile"),
    DID_THROW_ITEM_INVALID: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_LOAD_ERROR: [createEvent("error"), createEvent("addfile")],
    DID_THROW_ITEM_REMOVE_ERROR: [createEvent("error"), createEvent("removefile")],
    DID_PREPARE_OUTPUT: createEvent("preparefile"),
    DID_START_ITEM_PROCESSING: createEvent("processfilestart"),
    DID_UPDATE_ITEM_PROCESS_PROGRESS: createEvent("processfileprogress"),
    DID_ABORT_ITEM_PROCESSING: createEvent("processfileabort"),
    DID_COMPLETE_ITEM_PROCESSING: createEvent("processfile"),
    DID_COMPLETE_ITEM_PROCESSING_ALL: createEvent("processfiles"),
    DID_REVERT_ITEM_PROCESSING: createEvent("processfilerevert"),
    DID_THROW_ITEM_PROCESSING_ERROR: [createEvent("error"), createEvent("processfile")],
    DID_REMOVE_ITEM: createEvent("removefile"),
    DID_UPDATE_ITEMS: createEvent("updatefiles"),
    DID_ACTIVATE_ITEM: createEvent("activatefile"),
    DID_REORDER_ITEMS: createEvent("reorderfiles")
  };
  const exposeEvent = (event) => {
    const detail = { pond: exports, ...event };
    delete detail.type;
    view.element.dispatchEvent(
      new CustomEvent(`FilePond:${event.type}`, {
        // event info
        detail,
        // event behaviour
        bubbles: true,
        cancelable: true,
        composed: true
        // triggers listeners outside of shadow root
      })
    );
    const params = [];
    if (event.hasOwnProperty("error")) {
      params.push(event.error);
    }
    if (event.hasOwnProperty("file")) {
      params.push(event.file);
    }
    const filtered = ["type", "error", "file"];
    Object.keys(event).filter((key) => !filtered.includes(key)).forEach((key) => params.push(event[key]));
    exports.fire(event.type, ...params);
    const handler = store.query(`GET_ON${event.type.toUpperCase()}`);
    if (handler) {
      handler(...params);
    }
  };
  const routeActionsToEvents = (actions2) => {
    if (!actions2.length)
      return;
    actions2.filter((action) => eventRoutes[action.type]).forEach((action) => {
      const routes = eventRoutes[action.type];
      (Array.isArray(routes) ? routes : [routes]).forEach((route2) => {
        if (action.type === "DID_INIT_ITEM") {
          exposeEvent(route2(action.data));
        } else {
          setTimeout(() => {
            exposeEvent(route2(action.data));
          }, 0);
        }
      });
    });
  };
  const setOptions2 = (options) => store.dispatch("SET_OPTIONS", { options });
  const getFile = (query) => store.query("GET_ACTIVE_ITEM", query);
  const prepareFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PREPARE", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const addFile = (source, options = {}) => new Promise((resolve, reject) => {
    addFiles([{ source, options }], { index: options.index }).then((items) => resolve(items && items[0])).catch(reject);
  });
  const isFilePondFile = (obj) => obj.file && obj.id;
  const removeFile = (query, options) => {
    if (typeof query === "object" && !isFilePondFile(query) && !options) {
      options = query;
      query = void 0;
    }
    store.dispatch("REMOVE_ITEM", { ...options, query });
    return store.query("GET_ACTIVE_ITEM", query) === null;
  };
  const addFiles = (...args) => new Promise((resolve, reject) => {
    const sources = [];
    const options = {};
    if (isArray$1(args[0])) {
      sources.push.apply(sources, args[0]);
      Object.assign(options, args[1] || {});
    } else {
      const lastArgument = args[args.length - 1];
      if (typeof lastArgument === "object" && !(lastArgument instanceof Blob)) {
        Object.assign(options, args.pop());
      }
      sources.push(...args);
    }
    store.dispatch("ADD_ITEMS", {
      items: sources,
      index: options.index,
      interactionMethod: InteractionMethod.API,
      success: resolve,
      failure: reject
    });
  });
  const getFiles2 = () => store.query("GET_ACTIVE_ITEMS");
  const processFile = (query) => new Promise((resolve, reject) => {
    store.dispatch("REQUEST_ITEM_PROCESSING", {
      query,
      success: (item2) => {
        resolve(item2);
      },
      failure: (error2) => {
        reject(error2);
      }
    });
  });
  const prepareFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    const items = queries2.length ? queries2 : getFiles2();
    return Promise.all(items.map(prepareFile));
  };
  const processFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    if (!queries2.length) {
      const files = getFiles2().filter(
        (item2) => !(item2.status === ItemStatus.IDLE && item2.origin === FileOrigin.LOCAL) && item2.status !== ItemStatus.PROCESSING && item2.status !== ItemStatus.PROCESSING_COMPLETE && item2.status !== ItemStatus.PROCESSING_REVERT_ERROR
      );
      return Promise.all(files.map(processFile));
    }
    return Promise.all(queries2.map(processFile));
  };
  const removeFiles = (...args) => {
    const queries2 = Array.isArray(args[0]) ? args[0] : args;
    let options;
    if (typeof queries2[queries2.length - 1] === "object") {
      options = queries2.pop();
    } else if (Array.isArray(args[0])) {
      options = args[1];
    }
    const files = getFiles2();
    if (!queries2.length)
      return Promise.all(files.map((file2) => removeFile(file2, options)));
    const mappedQueries = queries2.map((query) => isNumber$1(query) ? files[query] ? files[query].id : null : query).filter((query) => query);
    return mappedQueries.map((q2) => removeFile(q2, options));
  };
  const exports = {
    // supports events
    ...on(),
    // inject private api methods
    ...readWriteApi,
    // inject all getters and setters
    ...createOptionAPI(store, defaultOptions2),
    /**
     * Override options defined in options object
     * @param options
     */
    setOptions: setOptions2,
    /**
     * Load the given file
     * @param source - the source of the file (either a File, base64 data uri or url)
     * @param options - object, { index: 0 }
     */
    addFile,
    /**
     * Load the given files
     * @param sources - the sources of the files to load
     * @param options - object, { index: 0 }
     */
    addFiles,
    /**
     * Returns the file objects matching the given query
     * @param query { string, number, null }
     */
    getFile,
    /**
     * Upload file with given name
     * @param query { string, number, null  }
     */
    processFile,
    /**
     * Request prepare output for file with given name
     * @param query { string, number, null  }
     */
    prepareFile,
    /**
     * Removes a file by its name
     * @param query { string, number, null  }
     */
    removeFile,
    /**
     * Moves a file to a new location in the files list
     */
    moveFile: (query, index) => store.dispatch("MOVE_ITEM", { query, index }),
    /**
     * Returns all files (wrapped in public api)
     */
    getFiles: getFiles2,
    /**
     * Starts uploading all files
     */
    processFiles,
    /**
     * Clears all files from the files list
     */
    removeFiles,
    /**
     * Starts preparing output of all files
     */
    prepareFiles,
    /**
     * Sort list of files
     */
    sort: (compare) => store.dispatch("SORT", { compare }),
    /**
     * Browse the file system for a file
     */
    browse: () => {
      var input = view.element.querySelector("input[type=file]");
      if (input) {
        input.click();
      }
    },
    /**
     * Destroys the app
     */
    destroy: () => {
      exports.fire("destroy", view.element);
      store.dispatch("ABORT_ALL");
      view._destroy();
      window.removeEventListener("resize", resizeHandler);
      document.removeEventListener("visibilitychange", visibilityHandler);
      store.dispatch("DID_DESTROY");
    },
    /**
     * Inserts the plugin before the target element
     */
    insertBefore: (element) => insertBefore$1(view.element, element),
    /**
     * Inserts the plugin after the target element
     */
    insertAfter: (element) => insertAfter$1(view.element, element),
    /**
     * Appends the plugin to the target element
     */
    appendTo: (element) => element.appendChild(view.element),
    /**
     * Replaces an element with the app
     */
    replaceElement: (element) => {
      insertBefore$1(view.element, element);
      element.parentNode.removeChild(element);
      originalElement = element;
    },
    /**
     * Restores the original element
     */
    restoreElement: () => {
      if (!originalElement) {
        return;
      }
      insertAfter$1(originalElement, view.element);
      view.element.parentNode.removeChild(view.element);
      originalElement = null;
    },
    /**
     * Returns true if the app root is attached to given element
     * @param element
     */
    isAttachedTo: (element) => view.element === element || originalElement === element,
    /**
     * Returns the root element
     */
    element: {
      get: () => view.element
    },
    /**
     * Returns the current pond status
     */
    status: {
      get: () => store.query("GET_STATUS")
    }
  };
  store.dispatch("DID_INIT");
  return createObject(exports);
};
const createAppObject = (customOptions = {}) => {
  const defaultOptions2 = {};
  forin(getOptions(), (key, value) => {
    defaultOptions2[key] = value[0];
  });
  const app = createApp({
    // default options
    ...defaultOptions2,
    // custom options
    ...customOptions
  });
  return app;
};
const lowerCaseFirstLetter = (string) => string.charAt(0).toLowerCase() + string.slice(1);
const attributeNameToPropertyName = (attributeName) => toCamels(attributeName.replace(/^data-/, ""));
const mapObject = (object, propertyMap) => {
  forin(propertyMap, (selector, mapping) => {
    forin(object, (property, value) => {
      const selectorRegExp = new RegExp(selector);
      const matches = selectorRegExp.test(property);
      if (!matches) {
        return;
      }
      delete object[property];
      if (mapping === false) {
        return;
      }
      if (isString$1(mapping)) {
        object[mapping] = value;
        return;
      }
      const group = mapping.group;
      if (isObject$1(mapping) && !object[group]) {
        object[group] = {};
      }
      object[group][lowerCaseFirstLetter(property.replace(selectorRegExp, ""))] = value;
    });
    if (mapping.mapping) {
      mapObject(object[mapping.group], mapping.mapping);
    }
  });
};
const getAttributesAsObject = (node, attributeMapping = {}) => {
  const attributes = [];
  forin(node.attributes, (index) => {
    attributes.push(node.attributes[index]);
  });
  const output = attributes.filter((attribute) => attribute.name).reduce((obj, attribute) => {
    const value = attr(node, attribute.name);
    obj[attributeNameToPropertyName(attribute.name)] = value === attribute.name ? true : value;
    return obj;
  }, {});
  mapObject(output, attributeMapping);
  return output;
};
const createAppAtElement = (element, options = {}) => {
  const attributeMapping = {
    // translate to other name
    "^class$": "className",
    "^multiple$": "allowMultiple",
    "^capture$": "captureMethod",
    "^webkitdirectory$": "allowDirectoriesOnly",
    // group under single property
    "^server": {
      group: "server",
      mapping: {
        "^process": {
          group: "process"
        },
        "^revert": {
          group: "revert"
        },
        "^fetch": {
          group: "fetch"
        },
        "^restore": {
          group: "restore"
        },
        "^load": {
          group: "load"
        }
      }
    },
    // don't include in object
    "^type$": false,
    "^files$": false
  };
  applyFilters("SET_ATTRIBUTE_TO_OPTION_MAP", attributeMapping);
  const mergedOptions = {
    ...options
  };
  const attributeOptions = getAttributesAsObject(
    element.nodeName === "FIELDSET" ? element.querySelector("input[type=file]") : element,
    attributeMapping
  );
  Object.keys(attributeOptions).forEach((key) => {
    if (isObject$1(attributeOptions[key])) {
      if (!isObject$1(mergedOptions[key])) {
        mergedOptions[key] = {};
      }
      Object.assign(mergedOptions[key], attributeOptions[key]);
    } else {
      mergedOptions[key] = attributeOptions[key];
    }
  });
  mergedOptions.files = (options.files || []).concat(
    Array.from(element.querySelectorAll("input:not([type=file])")).map((input) => ({
      source: input.value,
      options: {
        type: input.dataset.type
      }
    }))
  );
  const app = createAppObject(mergedOptions);
  if (element.files) {
    Array.from(element.files).forEach((file2) => {
      app.addFile(file2);
    });
  }
  app.replaceElement(element);
  return app;
};
const createApp$1 = (...args) => isNode(args[0]) ? createAppAtElement(...args) : createAppObject(...args);
const PRIVATE_METHODS = ["fire", "_read", "_write"];
const createAppAPI = (app) => {
  const api = {};
  copyObjectPropertiesToObject(app, api, PRIVATE_METHODS);
  return api;
};
const replaceInString = (string, replacements) => string.replace(/(?:{([a-zA-Z]+)})/g, (match, group) => replacements[group]);
const createWorker = (fn3) => {
  const workerBlob = new Blob(["(", fn3.toString(), ")()"], {
    type: "application/javascript"
  });
  const workerURL = URL.createObjectURL(workerBlob);
  const worker = new Worker(workerURL);
  return {
    transfer: (message, cb) => {
    },
    post: (message, cb, transferList) => {
      const id = getUniqueId();
      worker.onmessage = (e2) => {
        if (e2.data.id === id) {
          cb(e2.data.message);
        }
      };
      worker.postMessage(
        {
          id,
          message
        },
        transferList
      );
    },
    terminate: () => {
      worker.terminate();
      URL.revokeObjectURL(workerURL);
    }
  };
};
const loadImage = (url) => new Promise((resolve, reject) => {
  const img = new Image();
  img.onload = () => {
    resolve(img);
  };
  img.onerror = (e2) => {
    reject(e2);
  };
  img.src = url;
});
const renameFile = (file2, name2) => {
  const renamedFile = file2.slice(0, file2.size, file2.type);
  renamedFile.lastModifiedDate = file2.lastModifiedDate;
  renamedFile.name = name2;
  return renamedFile;
};
const copyFile = (file2) => renameFile(file2, file2.name);
const registeredPlugins = [];
const createAppPlugin = (plugin2) => {
  if (registeredPlugins.includes(plugin2)) {
    return;
  }
  registeredPlugins.push(plugin2);
  const pluginOutline = plugin2({
    addFilter,
    utils: {
      Type,
      forin,
      isString: isString$1,
      isFile: isFile$1,
      toNaturalFileSize,
      replaceInString,
      getExtensionFromFilename,
      getFilenameWithoutExtension,
      guesstimateMimeType,
      getFileFromBlob,
      getFilenameFromURL,
      createRoute,
      createWorker,
      createView,
      createItemAPI,
      loadImage,
      copyFile,
      renameFile,
      createBlob,
      applyFilterChain,
      text,
      getNumericAspectRatioFromString
    },
    views: {
      fileActionButton
    }
  });
  extendDefaultOptions(pluginOutline.options);
};
const isOperaMini = () => Object.prototype.toString.call(window.operamini) === "[object OperaMini]";
const hasPromises = () => "Promise" in window;
const hasBlobSlice = () => "slice" in Blob.prototype;
const hasCreateObjectURL = () => "URL" in window && "createObjectURL" in window.URL;
const hasVisibility = () => "visibilityState" in document;
const hasTiming = () => "performance" in window;
const hasCSSSupports = () => "supports" in (window.CSS || {});
const isIE11 = () => /MSIE|Trident/.test(window.navigator.userAgent);
const supported = (() => {
  const isSupported = (
    // Has to be a browser
    isBrowser() && // Can't run on Opera Mini due to lack of everything
    !isOperaMini() && // Require these APIs to feature detect a modern browser
    hasVisibility() && hasPromises() && hasBlobSlice() && hasCreateObjectURL() && hasTiming() && // doesn't need CSSSupports but is a good way to detect Safari 9+ (we do want to support IE11 though)
    (hasCSSSupports() || isIE11())
  );
  return () => isSupported;
})();
const state = {
  // active app instances, used to redraw the apps and to find the later
  apps: []
};
const name = "filepond";
const fn = () => {
};
let OptionTypes = {};
let create$f = fn;
let destroy = fn;
let parse = fn;
let find = fn;
let registerPlugin = fn;
let getOptions$1 = fn;
let setOptions$1 = fn;
if (supported()) {
  createPainter(
    () => {
      state.apps.forEach((app) => app._read());
    },
    (ts2) => {
      state.apps.forEach((app) => app._write(ts2));
    }
  );
  const dispatch = () => {
    document.dispatchEvent(
      new CustomEvent("FilePond:loaded", {
        detail: {
          supported,
          create: create$f,
          destroy,
          parse,
          find,
          registerPlugin,
          setOptions: setOptions$1
        }
      })
    );
    document.removeEventListener("DOMContentLoaded", dispatch);
  };
  if (document.readyState !== "loading") {
    setTimeout(() => dispatch(), 0);
  } else {
    document.addEventListener("DOMContentLoaded", dispatch);
  }
  const updateOptionTypes = () => forin(getOptions(), (key, value) => {
    OptionTypes[key] = value[1];
  });
  OptionTypes = {};
  updateOptionTypes();
  create$f = (...args) => {
    const app = createApp$1(...args);
    app.on("destroy", destroy);
    state.apps.push(app);
    return createAppAPI(app);
  };
  destroy = (hook) => {
    const indexToRemove = state.apps.findIndex((app) => app.isAttachedTo(hook));
    if (indexToRemove >= 0) {
      const app = state.apps.splice(indexToRemove, 1)[0];
      app.restoreElement();
      return true;
    }
    return false;
  };
  parse = (context) => {
    const matchedHooks = Array.from(context.querySelectorAll(`.${name}`));
    const newHooks = matchedHooks.filter(
      (newHook) => !state.apps.find((app) => app.isAttachedTo(newHook))
    );
    return newHooks.map((hook) => create$f(hook));
  };
  find = (hook) => {
    const app = state.apps.find((app2) => app2.isAttachedTo(hook));
    if (!app) {
      return null;
    }
    return createAppAPI(app);
  };
  registerPlugin = (...plugins2) => {
    plugins2.forEach(createAppPlugin);
    updateOptionTypes();
  };
  getOptions$1 = () => {
    const opts = {};
    forin(getOptions(), (key, value) => {
      opts[key] = value[0];
    });
    return opts;
  };
  setOptions$1 = (opts) => {
    if (isObject$1(opts)) {
      state.apps.forEach((app) => {
        app.setOptions(opts);
      });
      setOptions(opts);
    }
    return getOptions$1();
  };
}
function CitadelFileUpload(el) {
  init$1(el);
}
function init$1($el) {
  const server = $el.data("server") || {};
  const config2 = $el.data("config") || {};
  create$f($el[0], {
    name: $el.attr("name"),
    allowMultiple: config2.multiple,
    server: {
      process: (fieldName, file2, metadata, load, error2, progress, abort, transfer, options) => {
        const formData = new FormData();
        formData.append("file", file2, file2.name);
        const request = new XMLHttpRequest();
        request.open("POST", server.process);
        request.upload.onprogress = (e2) => {
          progress(e2.lengthComputable, e2.loaded, e2.total);
        };
        request.onload = function() {
          if (request.status >= 200 && request.status < 300) {
            load(request.responseText);
          } else {
            error2("oh no");
          }
        };
        request.send(formData);
        return {
          abort: () => {
            request.abort();
            abort();
          }
        };
      },
      load: server.load
    },
    files: $el.data("files")
  });
}
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$1(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name2) {
    var style = state2.styles[name2] || {};
    var attributes = state2.attributes[name2] || {};
    var element = state2.elements[name2];
    if (!isHTMLElement(element) || !getNodeName(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name3) {
      var value = attributes[name3];
      if (value === false) {
        element.removeAttribute(name3);
      } else {
        element.setAttribute(name3, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name2) {
      var element = state2.elements[name2];
      var attributes = state2.attributes[name2] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name2) ? state2.styles[name2] : initialStyles[name2]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
var max = Math.max;
var min = Math.min;
var round = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item2) {
      return item2.brand + "/" + item2.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$1(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x2 = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: y2 + height,
    left: x2,
    x: x2,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect = getBoundingClientRect(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function isTableElement(element) {
  return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
}
function getDocumentElement(element) {
  return ((isElement$1(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode(element) {
  if (getNodeName(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement(element)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element)) {
    var elementCss = getComputedStyle$1(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle$1(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  var window2 = getWindow(element);
  var offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle$1(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name2 = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name2] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x2 = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x2 * dpr) / dpr || 0,
    y: round(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x2 = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x: x2,
    y: y2
  }) : {
    x: x2,
    y: y2
  };
  x2 = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle$1(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x2 -= offsetX - popperRect.width;
      x2 *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x: x2,
    y: y2
  }, getWindow(popper2)) : {
    x: x2,
    y: y2
  };
  x2 = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x2 + "px, " + y2 + "px)" : "translate3d(" + x2 + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x2 + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn2() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x2 = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2 + getWindowScrollBarX(element),
    y: y2
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x2 = -winScroll.scrollLeft + getWindowScrollBarX(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x2 += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}
function listScrollParents(element, list2) {
  var _element$ownerDocumen;
  if (list2 === void 0) {
    list2 = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list2.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode(target)))
  );
}
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect(element, strategy) {
  var rect = getBoundingClientRect(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement$1(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$1(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement$1(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$1(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement$1(element) ? element : element.contextElement || getDocumentElement(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a2, b2) {
    return overflows[a2] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  if (state2.modifiersData[name2]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i3) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i3).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i2 = numberOfChecks; _i2 > 0; _i2--) {
      var _ret = _loop(_i2);
      if (_ret === "break")
        break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name2]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state2.modifiersData[name2] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$1 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name2 = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data2 = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data2[state2.placement], x2 = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x2;
    state2.modifiersData.popperOffsets.y += y2;
  }
  state2.modifiersData[name2] = data2;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name2 = _ref.name;
  state2.modifiersData[name2] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    strategy: "absolute",
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name2 = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data2 = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min$1 = offset2 + overflow[mainSide];
    var max$1 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);
    popperOffsets2[mainAxis] = preventedOffset;
    data2[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data2[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name2] = data2;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round(rect.width) / element.offsetWidth || 1;
  var scaleY = round(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce(fn3) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn3());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions2 = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions2;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions2),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions2(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions2, state2.options, options2);
        state2.scrollParents = {
          reference: isElement$1(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index = 0; index < state2.orderedModifiers.length; index++) {
          if (state2.reset === true) {
            state2.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index], fn3 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name2 = _state$orderedModifie.name;
          if (typeof fn3 === "function") {
            state2 = fn3({
              state: state2,
              options: _options,
              name: name2,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy2() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state3) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state3);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name2 = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect2 = _ref.effect;
        if (typeof effect2 === "function") {
          var cleanupFn = effect2({
            state: state2,
            name: name2,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn3) {
        return fn3();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var createPopper$2 = /* @__PURE__ */ popperGenerator();
var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];
var createPopper$1 = /* @__PURE__ */ popperGenerator({
  defaultModifiers: defaultModifiers$1
});
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
const Popper = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  afterMain,
  afterRead,
  afterWrite,
  applyStyles: applyStyles$1,
  arrow: arrow$1,
  auto,
  basePlacements,
  beforeMain,
  beforeRead,
  beforeWrite,
  bottom,
  clippingParents,
  computeStyles: computeStyles$1,
  createPopper,
  createPopperBase: createPopper$2,
  createPopperLite: createPopper$1,
  detectOverflow,
  end,
  eventListeners,
  flip: flip$1,
  hide: hide$1,
  left,
  main,
  modifierPhases,
  offset: offset$1,
  placements,
  popper,
  popperGenerator,
  popperOffsets: popperOffsets$1,
  preventOverflow: preventOverflow$1,
  read,
  reference,
  right,
  start,
  top,
  variationPlacements,
  viewport,
  write
}, Symbol.toStringTag, { value: "Module" }));
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const elementMap = /* @__PURE__ */ new Map();
const Data = {
  set(element, key, instance) {
    if (!elementMap.has(element)) {
      elementMap.set(element, /* @__PURE__ */ new Map());
    }
    const instanceMap = elementMap.get(element);
    if (!instanceMap.has(key) && instanceMap.size !== 0) {
      console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);
      return;
    }
    instanceMap.set(key, instance);
  },
  get(element, key) {
    if (elementMap.has(element)) {
      return elementMap.get(element).get(key) || null;
    }
    return null;
  },
  remove(element, key) {
    if (!elementMap.has(element)) {
      return;
    }
    const instanceMap = elementMap.get(element);
    instanceMap.delete(key);
    if (instanceMap.size === 0) {
      elementMap.delete(element);
    }
  }
};
const MAX_UID = 1e6;
const MILLISECONDS_MULTIPLIER = 1e3;
const TRANSITION_END = "transitionend";
const parseSelector = (selector) => {
  if (selector && window.CSS && window.CSS.escape) {
    selector = selector.replace(/#([^\s"#']+)/g, (match, id) => `#${CSS.escape(id)}`);
  }
  return selector;
};
const toType = (object) => {
  if (object === null || object === void 0) {
    return `${object}`;
  }
  return Object.prototype.toString.call(object).match(/\s([a-z]+)/i)[1].toLowerCase();
};
const getUID = (prefix) => {
  do {
    prefix += Math.floor(Math.random() * MAX_UID);
  } while (document.getElementById(prefix));
  return prefix;
};
const getTransitionDurationFromElement = (element) => {
  if (!element) {
    return 0;
  }
  let {
    transitionDuration,
    transitionDelay
  } = window.getComputedStyle(element);
  const floatTransitionDuration = Number.parseFloat(transitionDuration);
  const floatTransitionDelay = Number.parseFloat(transitionDelay);
  if (!floatTransitionDuration && !floatTransitionDelay) {
    return 0;
  }
  transitionDuration = transitionDuration.split(",")[0];
  transitionDelay = transitionDelay.split(",")[0];
  return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
};
const triggerTransitionEnd = (element) => {
  element.dispatchEvent(new Event(TRANSITION_END));
};
const isElement = (object) => {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (typeof object.jquery !== "undefined") {
    object = object[0];
  }
  return typeof object.nodeType !== "undefined";
};
const getElement = (object) => {
  if (isElement(object)) {
    return object.jquery ? object[0] : object;
  }
  if (typeof object === "string" && object.length > 0) {
    return document.querySelector(parseSelector(object));
  }
  return null;
};
const isVisible = (element) => {
  if (!isElement(element) || element.getClientRects().length === 0) {
    return false;
  }
  const elementIsVisible = getComputedStyle(element).getPropertyValue("visibility") === "visible";
  const closedDetails = element.closest("details:not([open])");
  if (!closedDetails) {
    return elementIsVisible;
  }
  if (closedDetails !== element) {
    const summary = element.closest("summary");
    if (summary && summary.parentNode !== closedDetails) {
      return false;
    }
    if (summary === null) {
      return false;
    }
  }
  return elementIsVisible;
};
const isDisabled = (element) => {
  if (!element || element.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }
  if (element.classList.contains("disabled")) {
    return true;
  }
  if (typeof element.disabled !== "undefined") {
    return element.disabled;
  }
  return element.hasAttribute("disabled") && element.getAttribute("disabled") !== "false";
};
const findShadowRoot = (element) => {
  if (!document.documentElement.attachShadow) {
    return null;
  }
  if (typeof element.getRootNode === "function") {
    const root2 = element.getRootNode();
    return root2 instanceof ShadowRoot ? root2 : null;
  }
  if (element instanceof ShadowRoot) {
    return element;
  }
  if (!element.parentNode) {
    return null;
  }
  return findShadowRoot(element.parentNode);
};
const noop$1 = () => {
};
const reflow = (element) => {
  element.offsetHeight;
};
const getjQuery = () => {
  if (window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")) {
    return window.jQuery;
  }
  return null;
};
const DOMContentLoadedCallbacks = [];
const onDOMContentLoaded = (callback) => {
  if (document.readyState === "loading") {
    if (!DOMContentLoadedCallbacks.length) {
      document.addEventListener("DOMContentLoaded", () => {
        for (const callback2 of DOMContentLoadedCallbacks) {
          callback2();
        }
      });
    }
    DOMContentLoadedCallbacks.push(callback);
  } else {
    callback();
  }
};
const isRTL = () => document.documentElement.dir === "rtl";
const defineJQueryPlugin = (plugin2) => {
  onDOMContentLoaded(() => {
    const $2 = getjQuery();
    if ($2) {
      const name2 = plugin2.NAME;
      const JQUERY_NO_CONFLICT = $2.fn[name2];
      $2.fn[name2] = plugin2.jQueryInterface;
      $2.fn[name2].Constructor = plugin2;
      $2.fn[name2].noConflict = () => {
        $2.fn[name2] = JQUERY_NO_CONFLICT;
        return plugin2.jQueryInterface;
      };
    }
  });
};
const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {
  return typeof possibleCallback === "function" ? possibleCallback(...args) : defaultValue;
};
const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {
  if (!waitForTransition) {
    execute(callback);
    return;
  }
  const durationPadding = 5;
  const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;
  let called = false;
  const handler = ({
    target
  }) => {
    if (target !== transitionElement) {
      return;
    }
    called = true;
    transitionElement.removeEventListener(TRANSITION_END, handler);
    execute(callback);
  };
  transitionElement.addEventListener(TRANSITION_END, handler);
  setTimeout(() => {
    if (!called) {
      triggerTransitionEnd(transitionElement);
    }
  }, emulatedDuration);
};
const getNextActiveElement = (list2, activeElement, shouldGetNext, isCycleAllowed) => {
  const listLength = list2.length;
  let index = list2.indexOf(activeElement);
  if (index === -1) {
    return !shouldGetNext && isCycleAllowed ? list2[listLength - 1] : list2[0];
  }
  index += shouldGetNext ? 1 : -1;
  if (isCycleAllowed) {
    index = (index + listLength) % listLength;
  }
  return list2[Math.max(0, Math.min(index, listLength - 1))];
};
const namespaceRegex = /[^.]*(?=\..*)\.|.*/;
const stripNameRegex = /\..*/;
const stripUidRegex = /::\d+$/;
const eventRegistry = {};
let uidEvent = 1;
const customEvents = {
  mouseenter: "mouseover",
  mouseleave: "mouseout"
};
const nativeEvents = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
function makeEventUid(element, uid) {
  return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;
}
function getElementEvents(element) {
  const uid = makeEventUid(element);
  element.uidEvent = uid;
  eventRegistry[uid] = eventRegistry[uid] || {};
  return eventRegistry[uid];
}
function bootstrapHandler(element, fn3) {
  return function handler(event) {
    hydrateObj(event, {
      delegateTarget: element
    });
    if (handler.oneOff) {
      EventHandler.off(element, event.type, fn3);
    }
    return fn3.apply(element, [event]);
  };
}
function bootstrapDelegationHandler(element, selector, fn3) {
  return function handler(event) {
    const domElements = element.querySelectorAll(selector);
    for (let {
      target
    } = event; target && target !== this; target = target.parentNode) {
      for (const domElement of domElements) {
        if (domElement !== target) {
          continue;
        }
        hydrateObj(event, {
          delegateTarget: target
        });
        if (handler.oneOff) {
          EventHandler.off(element, event.type, selector, fn3);
        }
        return fn3.apply(target, [event]);
      }
    }
  };
}
function findHandler(events, callable, delegationSelector = null) {
  return Object.values(events).find((event) => event.callable === callable && event.delegationSelector === delegationSelector);
}
function normalizeParameters(originalTypeEvent, handler, delegationFunction) {
  const isDelegated = typeof handler === "string";
  const callable = isDelegated ? delegationFunction : handler || delegationFunction;
  let typeEvent = getTypeEvent(originalTypeEvent);
  if (!nativeEvents.has(typeEvent)) {
    typeEvent = originalTypeEvent;
  }
  return [isDelegated, callable, typeEvent];
}
function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {
  if (typeof originalTypeEvent !== "string" || !element) {
    return;
  }
  let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
  if (originalTypeEvent in customEvents) {
    const wrapFunction = (fn4) => {
      return function(event) {
        if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {
          return fn4.call(this, event);
        }
      };
    };
    callable = wrapFunction(callable);
  }
  const events = getElementEvents(element);
  const handlers = events[typeEvent] || (events[typeEvent] = {});
  const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);
  if (previousFunction) {
    previousFunction.oneOff = previousFunction.oneOff && oneOff;
    return;
  }
  const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ""));
  const fn3 = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);
  fn3.delegationSelector = isDelegated ? handler : null;
  fn3.callable = callable;
  fn3.oneOff = oneOff;
  fn3.uidEvent = uid;
  handlers[uid] = fn3;
  element.addEventListener(typeEvent, fn3, isDelegated);
}
function removeHandler(element, events, typeEvent, handler, delegationSelector) {
  const fn3 = findHandler(events[typeEvent], handler, delegationSelector);
  if (!fn3) {
    return;
  }
  element.removeEventListener(typeEvent, fn3, Boolean(delegationSelector));
  delete events[typeEvent][fn3.uidEvent];
}
function removeNamespacedHandlers(element, events, typeEvent, namespace) {
  const storeElementEvent = events[typeEvent] || {};
  for (const [handlerKey, event] of Object.entries(storeElementEvent)) {
    if (handlerKey.includes(namespace)) {
      removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
    }
  }
}
function getTypeEvent(event) {
  event = event.replace(stripNameRegex, "");
  return customEvents[event] || event;
}
const EventHandler = {
  on(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, false);
  },
  one(element, event, handler, delegationFunction) {
    addHandler(element, event, handler, delegationFunction, true);
  },
  off(element, originalTypeEvent, handler, delegationFunction) {
    if (typeof originalTypeEvent !== "string" || !element) {
      return;
    }
    const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);
    const inNamespace = typeEvent !== originalTypeEvent;
    const events = getElementEvents(element);
    const storeElementEvent = events[typeEvent] || {};
    const isNamespace = originalTypeEvent.startsWith(".");
    if (typeof callable !== "undefined") {
      if (!Object.keys(storeElementEvent).length) {
        return;
      }
      removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);
      return;
    }
    if (isNamespace) {
      for (const elementEvent of Object.keys(events)) {
        removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));
      }
    }
    for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {
      const handlerKey = keyHandlers.replace(stripUidRegex, "");
      if (!inNamespace || originalTypeEvent.includes(handlerKey)) {
        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);
      }
    }
  },
  trigger(element, event, args) {
    if (typeof event !== "string" || !element) {
      return null;
    }
    const $2 = getjQuery();
    const typeEvent = getTypeEvent(event);
    const inNamespace = event !== typeEvent;
    let jQueryEvent = null;
    let bubbles = true;
    let nativeDispatch = true;
    let defaultPrevented = false;
    if (inNamespace && $2) {
      jQueryEvent = $2.Event(event, args);
      $2(element).trigger(jQueryEvent);
      bubbles = !jQueryEvent.isPropagationStopped();
      nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();
      defaultPrevented = jQueryEvent.isDefaultPrevented();
    }
    const evt = hydrateObj(new Event(event, {
      bubbles,
      cancelable: true
    }), args);
    if (defaultPrevented) {
      evt.preventDefault();
    }
    if (nativeDispatch) {
      element.dispatchEvent(evt);
    }
    if (evt.defaultPrevented && jQueryEvent) {
      jQueryEvent.preventDefault();
    }
    return evt;
  }
};
function hydrateObj(obj, meta = {}) {
  for (const [key, value] of Object.entries(meta)) {
    try {
      obj[key] = value;
    } catch (_unused) {
      Object.defineProperty(obj, key, {
        configurable: true,
        get() {
          return value;
        }
      });
    }
  }
  return obj;
}
function normalizeData(value) {
  if (value === "true") {
    return true;
  }
  if (value === "false") {
    return false;
  }
  if (value === Number(value).toString()) {
    return Number(value);
  }
  if (value === "" || value === "null") {
    return null;
  }
  if (typeof value !== "string") {
    return value;
  }
  try {
    return JSON.parse(decodeURIComponent(value));
  } catch (_unused) {
    return value;
  }
}
function normalizeDataKey(key) {
  return key.replace(/[A-Z]/g, (chr) => `-${chr.toLowerCase()}`);
}
const Manipulator = {
  setDataAttribute(element, key, value) {
    element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);
  },
  removeDataAttribute(element, key) {
    element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);
  },
  getDataAttributes(element) {
    if (!element) {
      return {};
    }
    const attributes = {};
    const bsKeys = Object.keys(element.dataset).filter((key) => key.startsWith("bs") && !key.startsWith("bsConfig"));
    for (const key of bsKeys) {
      let pureKey = key.replace(/^bs/, "");
      pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);
      attributes[pureKey] = normalizeData(element.dataset[key]);
    }
    return attributes;
  },
  getDataAttribute(element, key) {
    return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));
  }
};
class Config {
  // Getters
  static get Default() {
    return {};
  }
  static get DefaultType() {
    return {};
  }
  static get NAME() {
    throw new Error('You have to implement the static method "NAME", for each component!');
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    return config2;
  }
  _mergeConfigObj(config2, element) {
    const jsonConfig = isElement(element) ? Manipulator.getDataAttribute(element, "config") : {};
    return {
      ...this.constructor.Default,
      ...typeof jsonConfig === "object" ? jsonConfig : {},
      ...isElement(element) ? Manipulator.getDataAttributes(element) : {},
      ...typeof config2 === "object" ? config2 : {}
    };
  }
  _typeCheckConfig(config2, configTypes = this.constructor.DefaultType) {
    for (const [property, expectedTypes] of Object.entries(configTypes)) {
      const value = config2[property];
      const valueType = isElement(value) ? "element" : toType(value);
      if (!new RegExp(expectedTypes).test(valueType)) {
        throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
      }
    }
  }
}
const VERSION$1 = "5.3.3";
class BaseComponent extends Config {
  constructor(element, config2) {
    super();
    element = getElement(element);
    if (!element) {
      return;
    }
    this._element = element;
    this._config = this._getConfig(config2);
    Data.set(this._element, this.constructor.DATA_KEY, this);
  }
  // Public
  dispose() {
    Data.remove(this._element, this.constructor.DATA_KEY);
    EventHandler.off(this._element, this.constructor.EVENT_KEY);
    for (const propertyName of Object.getOwnPropertyNames(this)) {
      this[propertyName] = null;
    }
  }
  _queueCallback(callback, element, isAnimated = true) {
    executeAfterTransition(callback, element, isAnimated);
  }
  _getConfig(config2) {
    config2 = this._mergeConfigObj(config2, this._element);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  // Static
  static getInstance(element) {
    return Data.get(getElement(element), this.DATA_KEY);
  }
  static getOrCreateInstance(element, config2 = {}) {
    return this.getInstance(element) || new this(element, typeof config2 === "object" ? config2 : null);
  }
  static get VERSION() {
    return VERSION$1;
  }
  static get DATA_KEY() {
    return `bs.${this.NAME}`;
  }
  static get EVENT_KEY() {
    return `.${this.DATA_KEY}`;
  }
  static eventName(name2) {
    return `${name2}${this.EVENT_KEY}`;
  }
}
const getSelector = (element) => {
  let selector = element.getAttribute("data-bs-target");
  if (!selector || selector === "#") {
    let hrefAttribute = element.getAttribute("href");
    if (!hrefAttribute || !hrefAttribute.includes("#") && !hrefAttribute.startsWith(".")) {
      return null;
    }
    if (hrefAttribute.includes("#") && !hrefAttribute.startsWith("#")) {
      hrefAttribute = `#${hrefAttribute.split("#")[1]}`;
    }
    selector = hrefAttribute && hrefAttribute !== "#" ? hrefAttribute.trim() : null;
  }
  return selector ? selector.split(",").map((sel) => parseSelector(sel)).join(",") : null;
};
const SelectorEngine = {
  find(selector, element = document.documentElement) {
    return [].concat(...Element.prototype.querySelectorAll.call(element, selector));
  },
  findOne(selector, element = document.documentElement) {
    return Element.prototype.querySelector.call(element, selector);
  },
  children(element, selector) {
    return [].concat(...element.children).filter((child) => child.matches(selector));
  },
  parents(element, selector) {
    const parents = [];
    let ancestor = element.parentNode.closest(selector);
    while (ancestor) {
      parents.push(ancestor);
      ancestor = ancestor.parentNode.closest(selector);
    }
    return parents;
  },
  prev(element, selector) {
    let previous = element.previousElementSibling;
    while (previous) {
      if (previous.matches(selector)) {
        return [previous];
      }
      previous = previous.previousElementSibling;
    }
    return [];
  },
  // TODO: this is now unused; remove later along with prev()
  next(element, selector) {
    let next = element.nextElementSibling;
    while (next) {
      if (next.matches(selector)) {
        return [next];
      }
      next = next.nextElementSibling;
    }
    return [];
  },
  focusableChildren(element) {
    const focusables = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((selector) => `${selector}:not([tabindex^="-"])`).join(",");
    return this.find(focusables, element).filter((el) => !isDisabled(el) && isVisible(el));
  },
  getSelectorFromElement(element) {
    const selector = getSelector(element);
    if (selector) {
      return SelectorEngine.findOne(selector) ? selector : null;
    }
    return null;
  },
  getElementFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.findOne(selector) : null;
  },
  getMultipleElementsFromSelector(element) {
    const selector = getSelector(element);
    return selector ? SelectorEngine.find(selector) : [];
  }
};
const enableDismissTrigger = (component, method = "hide") => {
  const clickEvent = `click.dismiss${component.EVENT_KEY}`;
  const name2 = component.NAME;
  EventHandler.on(document, clickEvent, `[data-bs-dismiss="${name2}"]`, function(event) {
    if (["A", "AREA"].includes(this.tagName)) {
      event.preventDefault();
    }
    if (isDisabled(this)) {
      return;
    }
    const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name2}`);
    const instance = component.getOrCreateInstance(target);
    instance[method]();
  });
};
const NAME$f = "alert";
const DATA_KEY$a = "bs.alert";
const EVENT_KEY$b = `.${DATA_KEY$a}`;
const EVENT_CLOSE = `close${EVENT_KEY$b}`;
const EVENT_CLOSED = `closed${EVENT_KEY$b}`;
const CLASS_NAME_FADE$5 = "fade";
const CLASS_NAME_SHOW$8 = "show";
class Alert extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$f;
  }
  // Public
  close() {
    const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);
    if (closeEvent.defaultPrevented) {
      return;
    }
    this._element.classList.remove(CLASS_NAME_SHOW$8);
    const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);
    this._queueCallback(() => this._destroyElement(), this._element, isAnimated);
  }
  // Private
  _destroyElement() {
    this._element.remove();
    EventHandler.trigger(this._element, EVENT_CLOSED);
    this.dispose();
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Alert.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data2[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2](this);
    });
  }
}
enableDismissTrigger(Alert, "close");
defineJQueryPlugin(Alert);
const NAME$e = "button";
const DATA_KEY$9 = "bs.button";
const EVENT_KEY$a = `.${DATA_KEY$9}`;
const DATA_API_KEY$6 = ".data-api";
const CLASS_NAME_ACTIVE$3 = "active";
const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle="button"]';
const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;
class Button extends BaseComponent {
  // Getters
  static get NAME() {
    return NAME$e;
  }
  // Public
  toggle() {
    this._element.setAttribute("aria-pressed", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Button.getOrCreateInstance(this);
      if (config2 === "toggle") {
        data2[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event) => {
  event.preventDefault();
  const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);
  const data2 = Button.getOrCreateInstance(button);
  data2.toggle();
});
defineJQueryPlugin(Button);
const NAME$d = "swipe";
const EVENT_KEY$9 = ".bs.swipe";
const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;
const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;
const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;
const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;
const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;
const POINTER_TYPE_TOUCH = "touch";
const POINTER_TYPE_PEN = "pen";
const CLASS_NAME_POINTER_EVENT = "pointer-event";
const SWIPE_THRESHOLD = 40;
const Default$c = {
  endCallback: null,
  leftCallback: null,
  rightCallback: null
};
const DefaultType$c = {
  endCallback: "(function|null)",
  leftCallback: "(function|null)",
  rightCallback: "(function|null)"
};
class Swipe extends Config {
  constructor(element, config2) {
    super();
    this._element = element;
    if (!element || !Swipe.isSupported()) {
      return;
    }
    this._config = this._getConfig(config2);
    this._deltaX = 0;
    this._supportPointerEvents = Boolean(window.PointerEvent);
    this._initEvents();
  }
  // Getters
  static get Default() {
    return Default$c;
  }
  static get DefaultType() {
    return DefaultType$c;
  }
  static get NAME() {
    return NAME$d;
  }
  // Public
  dispose() {
    EventHandler.off(this._element, EVENT_KEY$9);
  }
  // Private
  _start(event) {
    if (!this._supportPointerEvents) {
      this._deltaX = event.touches[0].clientX;
      return;
    }
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX;
    }
  }
  _end(event) {
    if (this._eventIsPointerPenTouch(event)) {
      this._deltaX = event.clientX - this._deltaX;
    }
    this._handleSwipe();
    execute(this._config.endCallback);
  }
  _move(event) {
    this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;
  }
  _handleSwipe() {
    const absDeltaX = Math.abs(this._deltaX);
    if (absDeltaX <= SWIPE_THRESHOLD) {
      return;
    }
    const direction = absDeltaX / this._deltaX;
    this._deltaX = 0;
    if (!direction) {
      return;
    }
    execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);
  }
  _initEvents() {
    if (this._supportPointerEvents) {
      EventHandler.on(this._element, EVENT_POINTERDOWN, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_POINTERUP, (event) => this._end(event));
      this._element.classList.add(CLASS_NAME_POINTER_EVENT);
    } else {
      EventHandler.on(this._element, EVENT_TOUCHSTART, (event) => this._start(event));
      EventHandler.on(this._element, EVENT_TOUCHMOVE, (event) => this._move(event));
      EventHandler.on(this._element, EVENT_TOUCHEND, (event) => this._end(event));
    }
  }
  _eventIsPointerPenTouch(event) {
    return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);
  }
  // Static
  static isSupported() {
    return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
  }
}
const NAME$c = "carousel";
const DATA_KEY$8 = "bs.carousel";
const EVENT_KEY$8 = `.${DATA_KEY$8}`;
const DATA_API_KEY$5 = ".data-api";
const ARROW_LEFT_KEY$1 = "ArrowLeft";
const ARROW_RIGHT_KEY$1 = "ArrowRight";
const TOUCHEVENT_COMPAT_WAIT = 500;
const ORDER_NEXT = "next";
const ORDER_PREV = "prev";
const DIRECTION_LEFT = "left";
const DIRECTION_RIGHT = "right";
const EVENT_SLIDE = `slide${EVENT_KEY$8}`;
const EVENT_SLID = `slid${EVENT_KEY$8}`;
const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;
const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;
const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;
const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;
const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;
const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;
const CLASS_NAME_CAROUSEL = "carousel";
const CLASS_NAME_ACTIVE$2 = "active";
const CLASS_NAME_SLIDE = "slide";
const CLASS_NAME_END = "carousel-item-end";
const CLASS_NAME_START = "carousel-item-start";
const CLASS_NAME_NEXT = "carousel-item-next";
const CLASS_NAME_PREV = "carousel-item-prev";
const SELECTOR_ACTIVE = ".active";
const SELECTOR_ITEM = ".carousel-item";
const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;
const SELECTOR_ITEM_IMG = ".carousel-item img";
const SELECTOR_INDICATORS = ".carousel-indicators";
const SELECTOR_DATA_SLIDE = "[data-bs-slide], [data-bs-slide-to]";
const SELECTOR_DATA_RIDE = '[data-bs-ride="carousel"]';
const KEY_TO_DIRECTION = {
  [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,
  [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT
};
const Default$b = {
  interval: 5e3,
  keyboard: true,
  pause: "hover",
  ride: false,
  touch: true,
  wrap: true
};
const DefaultType$b = {
  interval: "(number|boolean)",
  // TODO:v6 remove boolean support
  keyboard: "boolean",
  pause: "(string|boolean)",
  ride: "(boolean|string)",
  touch: "boolean",
  wrap: "boolean"
};
class Carousel extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._interval = null;
    this._activeElement = null;
    this._isSliding = false;
    this.touchTimeout = null;
    this._swipeHelper = null;
    this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);
    this._addEventListeners();
    if (this._config.ride === CLASS_NAME_CAROUSEL) {
      this.cycle();
    }
  }
  // Getters
  static get Default() {
    return Default$b;
  }
  static get DefaultType() {
    return DefaultType$b;
  }
  static get NAME() {
    return NAME$c;
  }
  // Public
  next() {
    this._slide(ORDER_NEXT);
  }
  nextWhenVisible() {
    if (!document.hidden && isVisible(this._element)) {
      this.next();
    }
  }
  prev() {
    this._slide(ORDER_PREV);
  }
  pause() {
    if (this._isSliding) {
      triggerTransitionEnd(this._element);
    }
    this._clearInterval();
  }
  cycle() {
    this._clearInterval();
    this._updateInterval();
    this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
  }
  _maybeEnableCycle() {
    if (!this._config.ride) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.cycle());
      return;
    }
    this.cycle();
  }
  to(index) {
    const items = this._getItems();
    if (index > items.length - 1 || index < 0) {
      return;
    }
    if (this._isSliding) {
      EventHandler.one(this._element, EVENT_SLID, () => this.to(index));
      return;
    }
    const activeIndex = this._getItemIndex(this._getActive());
    if (activeIndex === index) {
      return;
    }
    const order2 = index > activeIndex ? ORDER_NEXT : ORDER_PREV;
    this._slide(order2, items[index]);
  }
  dispose() {
    if (this._swipeHelper) {
      this._swipeHelper.dispose();
    }
    super.dispose();
  }
  // Private
  _configAfterMerge(config2) {
    config2.defaultInterval = config2.interval;
    return config2;
  }
  _addEventListeners() {
    if (this._config.keyboard) {
      EventHandler.on(this._element, EVENT_KEYDOWN$1, (event) => this._keydown(event));
    }
    if (this._config.pause === "hover") {
      EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());
      EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());
    }
    if (this._config.touch && Swipe.isSupported()) {
      this._addTouchEventListeners();
    }
  }
  _addTouchEventListeners() {
    for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {
      EventHandler.on(img, EVENT_DRAG_START, (event) => event.preventDefault());
    }
    const endCallBack = () => {
      if (this._config.pause !== "hover") {
        return;
      }
      this.pause();
      if (this.touchTimeout) {
        clearTimeout(this.touchTimeout);
      }
      this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);
    };
    const swipeConfig = {
      leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),
      rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),
      endCallback: endCallBack
    };
    this._swipeHelper = new Swipe(this._element, swipeConfig);
  }
  _keydown(event) {
    if (/input|textarea/i.test(event.target.tagName)) {
      return;
    }
    const direction = KEY_TO_DIRECTION[event.key];
    if (direction) {
      event.preventDefault();
      this._slide(this._directionToOrder(direction));
    }
  }
  _getItemIndex(element) {
    return this._getItems().indexOf(element);
  }
  _setActiveIndicatorElement(index) {
    if (!this._indicatorsElement) {
      return;
    }
    const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);
    activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);
    activeIndicator.removeAttribute("aria-current");
    const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to="${index}"]`, this._indicatorsElement);
    if (newActiveIndicator) {
      newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);
      newActiveIndicator.setAttribute("aria-current", "true");
    }
  }
  _updateInterval() {
    const element = this._activeElement || this._getActive();
    if (!element) {
      return;
    }
    const elementInterval = Number.parseInt(element.getAttribute("data-bs-interval"), 10);
    this._config.interval = elementInterval || this._config.defaultInterval;
  }
  _slide(order2, element = null) {
    if (this._isSliding) {
      return;
    }
    const activeElement = this._getActive();
    const isNext = order2 === ORDER_NEXT;
    const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);
    if (nextElement === activeElement) {
      return;
    }
    const nextElementIndex = this._getItemIndex(nextElement);
    const triggerEvent2 = (eventName) => {
      return EventHandler.trigger(this._element, eventName, {
        relatedTarget: nextElement,
        direction: this._orderToDirection(order2),
        from: this._getItemIndex(activeElement),
        to: nextElementIndex
      });
    };
    const slideEvent = triggerEvent2(EVENT_SLIDE);
    if (slideEvent.defaultPrevented) {
      return;
    }
    if (!activeElement || !nextElement) {
      return;
    }
    const isCycling = Boolean(this._interval);
    this.pause();
    this._isSliding = true;
    this._setActiveIndicatorElement(nextElementIndex);
    this._activeElement = nextElement;
    const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;
    const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;
    nextElement.classList.add(orderClassName);
    reflow(nextElement);
    activeElement.classList.add(directionalClassName);
    nextElement.classList.add(directionalClassName);
    const completeCallBack = () => {
      nextElement.classList.remove(directionalClassName, orderClassName);
      nextElement.classList.add(CLASS_NAME_ACTIVE$2);
      activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);
      this._isSliding = false;
      triggerEvent2(EVENT_SLID);
    };
    this._queueCallback(completeCallBack, activeElement, this._isAnimated());
    if (isCycling) {
      this.cycle();
    }
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_SLIDE);
  }
  _getActive() {
    return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);
  }
  _getItems() {
    return SelectorEngine.find(SELECTOR_ITEM, this._element);
  }
  _clearInterval() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }
  _directionToOrder(direction) {
    if (isRTL()) {
      return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;
    }
    return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;
  }
  _orderToDirection(order2) {
    if (isRTL()) {
      return order2 === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;
    }
    return order2 === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Carousel.getOrCreateInstance(this, config2);
      if (typeof config2 === "number") {
        data2.to(config2);
        return;
      }
      if (typeof config2 === "string") {
        if (data2[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data2[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {
    return;
  }
  event.preventDefault();
  const carousel = Carousel.getOrCreateInstance(target);
  const slideIndex = this.getAttribute("data-bs-slide-to");
  if (slideIndex) {
    carousel.to(slideIndex);
    carousel._maybeEnableCycle();
    return;
  }
  if (Manipulator.getDataAttribute(this, "slide") === "next") {
    carousel.next();
    carousel._maybeEnableCycle();
    return;
  }
  carousel.prev();
  carousel._maybeEnableCycle();
});
EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {
  const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);
  for (const carousel of carousels) {
    Carousel.getOrCreateInstance(carousel);
  }
});
defineJQueryPlugin(Carousel);
const NAME$b = "collapse";
const DATA_KEY$7 = "bs.collapse";
const EVENT_KEY$7 = `.${DATA_KEY$7}`;
const DATA_API_KEY$4 = ".data-api";
const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;
const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;
const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;
const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;
const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;
const CLASS_NAME_SHOW$7 = "show";
const CLASS_NAME_COLLAPSE = "collapse";
const CLASS_NAME_COLLAPSING = "collapsing";
const CLASS_NAME_COLLAPSED = "collapsed";
const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;
const CLASS_NAME_HORIZONTAL = "collapse-horizontal";
const WIDTH = "width";
const HEIGHT = "height";
const SELECTOR_ACTIVES = ".collapse.show, .collapse.collapsing";
const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle="collapse"]';
const Default$a = {
  parent: null,
  toggle: true
};
const DefaultType$a = {
  parent: "(null|element)",
  toggle: "boolean"
};
class Collapse extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isTransitioning = false;
    this._triggerArray = [];
    const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);
    for (const elem of toggleList) {
      const selector = SelectorEngine.getSelectorFromElement(elem);
      const filterElement = SelectorEngine.find(selector).filter((foundElement) => foundElement === this._element);
      if (selector !== null && filterElement.length) {
        this._triggerArray.push(elem);
      }
    }
    this._initializeChildren();
    if (!this._config.parent) {
      this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());
    }
    if (this._config.toggle) {
      this.toggle();
    }
  }
  // Getters
  static get Default() {
    return Default$a;
  }
  static get DefaultType() {
    return DefaultType$a;
  }
  static get NAME() {
    return NAME$b;
  }
  // Public
  toggle() {
    if (this._isShown()) {
      this.hide();
    } else {
      this.show();
    }
  }
  show() {
    if (this._isTransitioning || this._isShown()) {
      return;
    }
    let activeChildren = [];
    if (this._config.parent) {
      activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element) => element !== this._element).map((element) => Collapse.getOrCreateInstance(element, {
        toggle: false
      }));
    }
    if (activeChildren.length && activeChildren[0]._isTransitioning) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    for (const activeInstance of activeChildren) {
      activeInstance.hide();
    }
    const dimension = this._getDimension();
    this._element.classList.remove(CLASS_NAME_COLLAPSE);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.style[dimension] = 0;
    this._addAriaAndCollapsedClass(this._triggerArray, true);
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
      this._element.style[dimension] = "";
      EventHandler.trigger(this._element, EVENT_SHOWN$6);
    };
    const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);
    const scrollSize = `scroll${capitalizedDimension}`;
    this._queueCallback(complete, this._element, true);
    this._element.style[dimension] = `${this._element[scrollSize]}px`;
  }
  hide() {
    if (this._isTransitioning || !this._isShown()) {
      return;
    }
    const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);
    if (startEvent.defaultPrevented) {
      return;
    }
    const dimension = this._getDimension();
    this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_COLLAPSING);
    this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);
    for (const trigger of this._triggerArray) {
      const element = SelectorEngine.getElementFromSelector(trigger);
      if (element && !this._isShown(element)) {
        this._addAriaAndCollapsedClass([trigger], false);
      }
    }
    this._isTransitioning = true;
    const complete = () => {
      this._isTransitioning = false;
      this._element.classList.remove(CLASS_NAME_COLLAPSING);
      this._element.classList.add(CLASS_NAME_COLLAPSE);
      EventHandler.trigger(this._element, EVENT_HIDDEN$6);
    };
    this._element.style[dimension] = "";
    this._queueCallback(complete, this._element, true);
  }
  _isShown(element = this._element) {
    return element.classList.contains(CLASS_NAME_SHOW$7);
  }
  // Private
  _configAfterMerge(config2) {
    config2.toggle = Boolean(config2.toggle);
    config2.parent = getElement(config2.parent);
    return config2;
  }
  _getDimension() {
    return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;
  }
  _initializeChildren() {
    if (!this._config.parent) {
      return;
    }
    const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);
    for (const element of children) {
      const selected = SelectorEngine.getElementFromSelector(element);
      if (selected) {
        this._addAriaAndCollapsedClass([element], this._isShown(selected));
      }
    }
  }
  _getFirstLevelChildren(selector) {
    const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);
    return SelectorEngine.find(selector, this._config.parent).filter((element) => !children.includes(element));
  }
  _addAriaAndCollapsedClass(triggerArray, isOpen) {
    if (!triggerArray.length) {
      return;
    }
    for (const element of triggerArray) {
      element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);
      element.setAttribute("aria-expanded", isOpen);
    }
  }
  // Static
  static jQueryInterface(config2) {
    const _config = {};
    if (typeof config2 === "string" && /show|hide/.test(config2)) {
      _config.toggle = false;
    }
    return this.each(function() {
      const data2 = Collapse.getOrCreateInstance(this, _config);
      if (typeof config2 === "string") {
        if (typeof data2[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data2[config2]();
      }
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {
  if (event.target.tagName === "A" || event.delegateTarget && event.delegateTarget.tagName === "A") {
    event.preventDefault();
  }
  for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {
    Collapse.getOrCreateInstance(element, {
      toggle: false
    }).toggle();
  }
});
defineJQueryPlugin(Collapse);
const NAME$a = "dropdown";
const DATA_KEY$6 = "bs.dropdown";
const EVENT_KEY$6 = `.${DATA_KEY$6}`;
const DATA_API_KEY$3 = ".data-api";
const ESCAPE_KEY$2 = "Escape";
const TAB_KEY$1 = "Tab";
const ARROW_UP_KEY$1 = "ArrowUp";
const ARROW_DOWN_KEY$1 = "ArrowDown";
const RIGHT_MOUSE_BUTTON = 2;
const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;
const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;
const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;
const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;
const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;
const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;
const CLASS_NAME_SHOW$6 = "show";
const CLASS_NAME_DROPUP = "dropup";
const CLASS_NAME_DROPEND = "dropend";
const CLASS_NAME_DROPSTART = "dropstart";
const CLASS_NAME_DROPUP_CENTER = "dropup-center";
const CLASS_NAME_DROPDOWN_CENTER = "dropdown-center";
const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)';
const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;
const SELECTOR_MENU = ".dropdown-menu";
const SELECTOR_NAVBAR = ".navbar";
const SELECTOR_NAVBAR_NAV = ".navbar-nav";
const SELECTOR_VISIBLE_ITEMS = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)";
const PLACEMENT_TOP = isRTL() ? "top-end" : "top-start";
const PLACEMENT_TOPEND = isRTL() ? "top-start" : "top-end";
const PLACEMENT_BOTTOM = isRTL() ? "bottom-end" : "bottom-start";
const PLACEMENT_BOTTOMEND = isRTL() ? "bottom-start" : "bottom-end";
const PLACEMENT_RIGHT = isRTL() ? "left-start" : "right-start";
const PLACEMENT_LEFT = isRTL() ? "right-start" : "left-start";
const PLACEMENT_TOPCENTER = "top";
const PLACEMENT_BOTTOMCENTER = "bottom";
const Default$9 = {
  autoClose: true,
  boundary: "clippingParents",
  display: "dynamic",
  offset: [0, 2],
  popperConfig: null,
  reference: "toggle"
};
const DefaultType$9 = {
  autoClose: "(boolean|string)",
  boundary: "(string|element)",
  display: "string",
  offset: "(array|string|function)",
  popperConfig: "(null|object|function)",
  reference: "(string|element|object)"
};
class Dropdown extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._popper = null;
    this._parent = this._element.parentNode;
    this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);
    this._inNavbar = this._detectNavbar();
  }
  // Getters
  static get Default() {
    return Default$9;
  }
  static get DefaultType() {
    return DefaultType$9;
  }
  static get NAME() {
    return NAME$a;
  }
  // Public
  toggle() {
    return this._isShown() ? this.hide() : this.show();
  }
  show() {
    if (isDisabled(this._element) || this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._createPopper();
    if ("ontouchstart" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop$1);
      }
    }
    this._element.focus();
    this._element.setAttribute("aria-expanded", true);
    this._menu.classList.add(CLASS_NAME_SHOW$6);
    this._element.classList.add(CLASS_NAME_SHOW$6);
    EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);
  }
  hide() {
    if (isDisabled(this._element) || !this._isShown()) {
      return;
    }
    const relatedTarget = {
      relatedTarget: this._element
    };
    this._completeHide(relatedTarget);
  }
  dispose() {
    if (this._popper) {
      this._popper.destroy();
    }
    super.dispose();
  }
  update() {
    this._inNavbar = this._detectNavbar();
    if (this._popper) {
      this._popper.update();
    }
  }
  // Private
  _completeHide(relatedTarget) {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);
    if (hideEvent.defaultPrevented) {
      return;
    }
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop$1);
      }
    }
    if (this._popper) {
      this._popper.destroy();
    }
    this._menu.classList.remove(CLASS_NAME_SHOW$6);
    this._element.classList.remove(CLASS_NAME_SHOW$6);
    this._element.setAttribute("aria-expanded", "false");
    Manipulator.removeDataAttribute(this._menu, "popper");
    EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);
  }
  _getConfig(config2) {
    config2 = super._getConfig(config2);
    if (typeof config2.reference === "object" && !isElement(config2.reference) && typeof config2.reference.getBoundingClientRect !== "function") {
      throw new TypeError(`${NAME$a.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
    }
    return config2;
  }
  _createPopper() {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
    }
    let referenceElement = this._element;
    if (this._config.reference === "parent") {
      referenceElement = this._parent;
    } else if (isElement(this._config.reference)) {
      referenceElement = getElement(this._config.reference);
    } else if (typeof this._config.reference === "object") {
      referenceElement = this._config.reference;
    }
    const popperConfig = this._getPopperConfig();
    this._popper = createPopper(referenceElement, this._menu, popperConfig);
  }
  _isShown() {
    return this._menu.classList.contains(CLASS_NAME_SHOW$6);
  }
  _getPlacement() {
    const parentDropdown = this._parent;
    if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {
      return PLACEMENT_RIGHT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {
      return PLACEMENT_LEFT;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {
      return PLACEMENT_TOPCENTER;
    }
    if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {
      return PLACEMENT_BOTTOMCENTER;
    }
    const isEnd = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
    if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {
      return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;
    }
    return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;
  }
  _detectNavbar() {
    return this._element.closest(SELECTOR_NAVBAR) !== null;
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _getPopperConfig() {
    const defaultBsPopperConfig = {
      placement: this._getPlacement(),
      modifiers: [{
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }]
    };
    if (this._inNavbar || this._config.display === "static") {
      Manipulator.setDataAttribute(this._menu, "popper", "static");
      defaultBsPopperConfig.modifiers = [{
        name: "applyStyles",
        enabled: false
      }];
    }
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _selectMenuItem({
    key,
    target
  }) {
    const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element) => isVisible(element));
    if (!items.length) {
      return;
    }
    getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Dropdown.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data2[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2]();
    });
  }
  static clearMenus(event) {
    if (event.button === RIGHT_MOUSE_BUTTON || event.type === "keyup" && event.key !== TAB_KEY$1) {
      return;
    }
    const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);
    for (const toggle2 of openToggles) {
      const context = Dropdown.getInstance(toggle2);
      if (!context || context._config.autoClose === false) {
        continue;
      }
      const composedPath = event.composedPath();
      const isMenuTarget = composedPath.includes(context._menu);
      if (composedPath.includes(context._element) || context._config.autoClose === "inside" && !isMenuTarget || context._config.autoClose === "outside" && isMenuTarget) {
        continue;
      }
      if (context._menu.contains(event.target) && (event.type === "keyup" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {
        continue;
      }
      const relatedTarget = {
        relatedTarget: context._element
      };
      if (event.type === "click") {
        relatedTarget.clickEvent = event;
      }
      context._completeHide(relatedTarget);
    }
  }
  static dataApiKeydownHandler(event) {
    const isInput = /input|textarea/i.test(event.target.tagName);
    const isEscapeEvent = event.key === ESCAPE_KEY$2;
    const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);
    if (!isUpOrDownEvent && !isEscapeEvent) {
      return;
    }
    if (isInput && !isEscapeEvent) {
      return;
    }
    event.preventDefault();
    const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);
    const instance = Dropdown.getOrCreateInstance(getToggleButton);
    if (isUpOrDownEvent) {
      event.stopPropagation();
      instance.show();
      instance._selectMenuItem(event);
      return;
    }
    if (instance._isShown()) {
      event.stopPropagation();
      instance.hide();
      getToggleButton.focus();
    }
  }
}
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);
EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);
EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {
  event.preventDefault();
  Dropdown.getOrCreateInstance(this).toggle();
});
defineJQueryPlugin(Dropdown);
const NAME$9 = "backdrop";
const CLASS_NAME_FADE$4 = "fade";
const CLASS_NAME_SHOW$5 = "show";
const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;
const Default$8 = {
  className: "modal-backdrop",
  clickCallback: null,
  isAnimated: false,
  isVisible: true,
  // if false, we use the backdrop helper without adding any element to the dom
  rootElement: "body"
  // give the choice to place backdrop under different elements
};
const DefaultType$8 = {
  className: "string",
  clickCallback: "(function|null)",
  isAnimated: "boolean",
  isVisible: "boolean",
  rootElement: "(element|string)"
};
class Backdrop extends Config {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isAppended = false;
    this._element = null;
  }
  // Getters
  static get Default() {
    return Default$8;
  }
  static get DefaultType() {
    return DefaultType$8;
  }
  static get NAME() {
    return NAME$9;
  }
  // Public
  show(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._append();
    const element = this._getElement();
    if (this._config.isAnimated) {
      reflow(element);
    }
    element.classList.add(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      execute(callback);
    });
  }
  hide(callback) {
    if (!this._config.isVisible) {
      execute(callback);
      return;
    }
    this._getElement().classList.remove(CLASS_NAME_SHOW$5);
    this._emulateAnimation(() => {
      this.dispose();
      execute(callback);
    });
  }
  dispose() {
    if (!this._isAppended) {
      return;
    }
    EventHandler.off(this._element, EVENT_MOUSEDOWN);
    this._element.remove();
    this._isAppended = false;
  }
  // Private
  _getElement() {
    if (!this._element) {
      const backdrop = document.createElement("div");
      backdrop.className = this._config.className;
      if (this._config.isAnimated) {
        backdrop.classList.add(CLASS_NAME_FADE$4);
      }
      this._element = backdrop;
    }
    return this._element;
  }
  _configAfterMerge(config2) {
    config2.rootElement = getElement(config2.rootElement);
    return config2;
  }
  _append() {
    if (this._isAppended) {
      return;
    }
    const element = this._getElement();
    this._config.rootElement.append(element);
    EventHandler.on(element, EVENT_MOUSEDOWN, () => {
      execute(this._config.clickCallback);
    });
    this._isAppended = true;
  }
  _emulateAnimation(callback) {
    executeAfterTransition(callback, this._getElement(), this._config.isAnimated);
  }
}
const NAME$8 = "focustrap";
const DATA_KEY$5 = "bs.focustrap";
const EVENT_KEY$5 = `.${DATA_KEY$5}`;
const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;
const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;
const TAB_KEY = "Tab";
const TAB_NAV_FORWARD = "forward";
const TAB_NAV_BACKWARD = "backward";
const Default$7 = {
  autofocus: true,
  trapElement: null
  // The element to trap focus inside of
};
const DefaultType$7 = {
  autofocus: "boolean",
  trapElement: "element"
};
class FocusTrap extends Config {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
    this._isActive = false;
    this._lastTabNavDirection = null;
  }
  // Getters
  static get Default() {
    return Default$7;
  }
  static get DefaultType() {
    return DefaultType$7;
  }
  static get NAME() {
    return NAME$8;
  }
  // Public
  activate() {
    if (this._isActive) {
      return;
    }
    if (this._config.autofocus) {
      this._config.trapElement.focus();
    }
    EventHandler.off(document, EVENT_KEY$5);
    EventHandler.on(document, EVENT_FOCUSIN$2, (event) => this._handleFocusin(event));
    EventHandler.on(document, EVENT_KEYDOWN_TAB, (event) => this._handleKeydown(event));
    this._isActive = true;
  }
  deactivate() {
    if (!this._isActive) {
      return;
    }
    this._isActive = false;
    EventHandler.off(document, EVENT_KEY$5);
  }
  // Private
  _handleFocusin(event) {
    const {
      trapElement
    } = this._config;
    if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {
      return;
    }
    const elements = SelectorEngine.focusableChildren(trapElement);
    if (elements.length === 0) {
      trapElement.focus();
    } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {
      elements[elements.length - 1].focus();
    } else {
      elements[0].focus();
    }
  }
  _handleKeydown(event) {
    if (event.key !== TAB_KEY) {
      return;
    }
    this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;
  }
}
const SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
const SELECTOR_STICKY_CONTENT = ".sticky-top";
const PROPERTY_PADDING = "padding-right";
const PROPERTY_MARGIN = "margin-right";
class ScrollBarHelper {
  constructor() {
    this._element = document.body;
  }
  // Public
  getWidth() {
    const documentWidth = document.documentElement.clientWidth;
    return Math.abs(window.innerWidth - documentWidth);
  }
  hide() {
    const width = this.getWidth();
    this._disableOverFlow();
    this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue) => calculatedValue + width);
    this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue) => calculatedValue - width);
  }
  reset() {
    this._resetElementAttributes(this._element, "overflow");
    this._resetElementAttributes(this._element, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);
    this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);
  }
  isOverflowing() {
    return this.getWidth() > 0;
  }
  // Private
  _disableOverFlow() {
    this._saveInitialAttribute(this._element, "overflow");
    this._element.style.overflow = "hidden";
  }
  _setElementAttributes(selector, styleProperty, callback) {
    const scrollbarWidth = this.getWidth();
    const manipulationCallBack = (element) => {
      if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {
        return;
      }
      this._saveInitialAttribute(element, styleProperty);
      const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);
      element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _saveInitialAttribute(element, styleProperty) {
    const actualValue = element.style.getPropertyValue(styleProperty);
    if (actualValue) {
      Manipulator.setDataAttribute(element, styleProperty, actualValue);
    }
  }
  _resetElementAttributes(selector, styleProperty) {
    const manipulationCallBack = (element) => {
      const value = Manipulator.getDataAttribute(element, styleProperty);
      if (value === null) {
        element.style.removeProperty(styleProperty);
        return;
      }
      Manipulator.removeDataAttribute(element, styleProperty);
      element.style.setProperty(styleProperty, value);
    };
    this._applyManipulationCallback(selector, manipulationCallBack);
  }
  _applyManipulationCallback(selector, callBack) {
    if (isElement(selector)) {
      callBack(selector);
      return;
    }
    for (const sel of SelectorEngine.find(selector, this._element)) {
      callBack(sel);
    }
  }
}
const NAME$7 = "modal";
const DATA_KEY$4 = "bs.modal";
const EVENT_KEY$4 = `.${DATA_KEY$4}`;
const DATA_API_KEY$2 = ".data-api";
const ESCAPE_KEY$1 = "Escape";
const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;
const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;
const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;
const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;
const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;
const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;
const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;
const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;
const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;
const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;
const CLASS_NAME_OPEN = "modal-open";
const CLASS_NAME_FADE$3 = "fade";
const CLASS_NAME_SHOW$4 = "show";
const CLASS_NAME_STATIC = "modal-static";
const OPEN_SELECTOR$1 = ".modal.show";
const SELECTOR_DIALOG = ".modal-dialog";
const SELECTOR_MODAL_BODY = ".modal-body";
const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle="modal"]';
const Default$6 = {
  backdrop: true,
  focus: true,
  keyboard: true
};
const DefaultType$6 = {
  backdrop: "(boolean|string)",
  focus: "boolean",
  keyboard: "boolean"
};
class Modal extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._isShown = false;
    this._isTransitioning = false;
    this._scrollBar = new ScrollBarHelper();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$6;
  }
  static get DefaultType() {
    return DefaultType$6;
  }
  static get NAME() {
    return NAME$7;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._isTransitioning = true;
    this._scrollBar.hide();
    document.body.classList.add(CLASS_NAME_OPEN);
    this._adjustDialog();
    this._backdrop.show(() => this._showElement(relatedTarget));
  }
  hide() {
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._isShown = false;
    this._isTransitioning = true;
    this._focustrap.deactivate();
    this._element.classList.remove(CLASS_NAME_SHOW$4);
    this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());
  }
  dispose() {
    EventHandler.off(window, EVENT_KEY$4);
    EventHandler.off(this._dialog, EVENT_KEY$4);
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  handleUpdate() {
    this._adjustDialog();
  }
  // Private
  _initializeBackDrop() {
    return new Backdrop({
      isVisible: Boolean(this._config.backdrop),
      // 'static' option will be translated to true, and booleans will keep their value,
      isAnimated: this._isAnimated()
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _showElement(relatedTarget) {
    if (!document.body.contains(this._element)) {
      document.body.append(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.scrollTop = 0;
    const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);
    if (modalBody) {
      modalBody.scrollTop = 0;
    }
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW$4);
    const transitionComplete = () => {
      if (this._config.focus) {
        this._focustrap.activate();
      }
      this._isTransitioning = false;
      EventHandler.trigger(this._element, EVENT_SHOWN$4, {
        relatedTarget
      });
    };
    this._queueCallback(transitionComplete, this._dialog, this._isAnimated());
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event) => {
      if (event.key !== ESCAPE_KEY$1) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      this._triggerBackdropTransition();
    });
    EventHandler.on(window, EVENT_RESIZE$1, () => {
      if (this._isShown && !this._isTransitioning) {
        this._adjustDialog();
      }
    });
    EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event) => {
      EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2) => {
        if (this._element !== event.target || this._element !== event2.target) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
          return;
        }
        if (this._config.backdrop) {
          this.hide();
        }
      });
    });
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._backdrop.hide(() => {
      document.body.classList.remove(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._scrollBar.reset();
      EventHandler.trigger(this._element, EVENT_HIDDEN$4);
    });
  }
  _isAnimated() {
    return this._element.classList.contains(CLASS_NAME_FADE$3);
  }
  _triggerBackdropTransition() {
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const initialOverflowY = this._element.style.overflowY;
    if (initialOverflowY === "hidden" || this._element.classList.contains(CLASS_NAME_STATIC)) {
      return;
    }
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    this._queueCallback(() => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      this._queueCallback(() => {
        this._element.style.overflowY = initialOverflowY;
      }, this._dialog);
    }, this._dialog);
    this._element.focus();
  }
  /**
   * The following methods are used to handle overflowing modals
   */
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    const scrollbarWidth = this._scrollBar.getWidth();
    const isBodyOverflowing = scrollbarWidth > 0;
    if (isBodyOverflowing && !isModalOverflowing) {
      const property = isRTL() ? "paddingLeft" : "paddingRight";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
    if (!isBodyOverflowing && isModalOverflowing) {
      const property = isRTL() ? "paddingRight" : "paddingLeft";
      this._element.style[property] = `${scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  // Static
  static jQueryInterface(config2, relatedTarget) {
    return this.each(function() {
      const data2 = Modal.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data2[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2](relatedTarget);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  EventHandler.one(target, EVENT_SHOW$4, (showEvent) => {
    if (showEvent.defaultPrevented) {
      return;
    }
    EventHandler.one(target, EVENT_HIDDEN$4, () => {
      if (isVisible(this)) {
        this.focus();
      }
    });
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);
  if (alreadyOpen) {
    Modal.getInstance(alreadyOpen).hide();
  }
  const data2 = Modal.getOrCreateInstance(target);
  data2.toggle(this);
});
enableDismissTrigger(Modal);
defineJQueryPlugin(Modal);
const NAME$6 = "offcanvas";
const DATA_KEY$3 = "bs.offcanvas";
const EVENT_KEY$3 = `.${DATA_KEY$3}`;
const DATA_API_KEY$1 = ".data-api";
const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;
const ESCAPE_KEY = "Escape";
const CLASS_NAME_SHOW$3 = "show";
const CLASS_NAME_SHOWING$1 = "showing";
const CLASS_NAME_HIDING = "hiding";
const CLASS_NAME_BACKDROP = "offcanvas-backdrop";
const OPEN_SELECTOR = ".offcanvas.show";
const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;
const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;
const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;
const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;
const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;
const EVENT_RESIZE = `resize${EVENT_KEY$3}`;
const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;
const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;
const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle="offcanvas"]';
const Default$5 = {
  backdrop: true,
  keyboard: true,
  scroll: false
};
const DefaultType$5 = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  scroll: "boolean"
};
class Offcanvas extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._isShown = false;
    this._backdrop = this._initializeBackDrop();
    this._focustrap = this._initializeFocusTrap();
    this._addEventListeners();
  }
  // Getters
  static get Default() {
    return Default$5;
  }
  static get DefaultType() {
    return DefaultType$5;
  }
  static get NAME() {
    return NAME$6;
  }
  // Public
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {
      relatedTarget
    });
    if (showEvent.defaultPrevented) {
      return;
    }
    this._isShown = true;
    this._backdrop.show();
    if (!this._config.scroll) {
      new ScrollBarHelper().hide();
    }
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    this._element.classList.add(CLASS_NAME_SHOWING$1);
    const completeCallBack = () => {
      if (!this._config.scroll || this._config.backdrop) {
        this._focustrap.activate();
      }
      this._element.classList.add(CLASS_NAME_SHOW$3);
      this._element.classList.remove(CLASS_NAME_SHOWING$1);
      EventHandler.trigger(this._element, EVENT_SHOWN$3, {
        relatedTarget
      });
    };
    this._queueCallback(completeCallBack, this._element, true);
  }
  hide() {
    if (!this._isShown) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);
    if (hideEvent.defaultPrevented) {
      return;
    }
    this._focustrap.deactivate();
    this._element.blur();
    this._isShown = false;
    this._element.classList.add(CLASS_NAME_HIDING);
    this._backdrop.hide();
    const completeCallback = () => {
      this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);
      this._element.removeAttribute("aria-modal");
      this._element.removeAttribute("role");
      if (!this._config.scroll) {
        new ScrollBarHelper().reset();
      }
      EventHandler.trigger(this._element, EVENT_HIDDEN$3);
    };
    this._queueCallback(completeCallback, this._element, true);
  }
  dispose() {
    this._backdrop.dispose();
    this._focustrap.deactivate();
    super.dispose();
  }
  // Private
  _initializeBackDrop() {
    const clickCallback = () => {
      if (this._config.backdrop === "static") {
        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
        return;
      }
      this.hide();
    };
    const isVisible2 = Boolean(this._config.backdrop);
    return new Backdrop({
      className: CLASS_NAME_BACKDROP,
      isVisible: isVisible2,
      isAnimated: true,
      rootElement: this._element.parentNode,
      clickCallback: isVisible2 ? clickCallback : null
    });
  }
  _initializeFocusTrap() {
    return new FocusTrap({
      trapElement: this._element
    });
  }
  _addEventListeners() {
    EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event) => {
      if (event.key !== ESCAPE_KEY) {
        return;
      }
      if (this._config.keyboard) {
        this.hide();
        return;
      }
      EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);
    });
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Offcanvas.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data2[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2](this);
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {
  const target = SelectorEngine.getElementFromSelector(this);
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  EventHandler.one(target, EVENT_HIDDEN$3, () => {
    if (isVisible(this)) {
      this.focus();
    }
  });
  const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);
  if (alreadyOpen && alreadyOpen !== target) {
    Offcanvas.getInstance(alreadyOpen).hide();
  }
  const data2 = Offcanvas.getOrCreateInstance(target);
  data2.toggle(this);
});
EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {
  for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {
    Offcanvas.getOrCreateInstance(selector).show();
  }
});
EventHandler.on(window, EVENT_RESIZE, () => {
  for (const element of SelectorEngine.find("[aria-modal][class*=show][class*=offcanvas-]")) {
    if (getComputedStyle(element).position !== "fixed") {
      Offcanvas.getOrCreateInstance(element).hide();
    }
  }
});
enableDismissTrigger(Offcanvas);
defineJQueryPlugin(Offcanvas);
const ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
const DefaultAllowlist = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", ARIA_ATTRIBUTE_PATTERN],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  dd: [],
  div: [],
  dl: [],
  dt: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};
const uriAttributes = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]);
const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;
const allowedAttribute = (attribute, allowedAttributeList) => {
  const attributeName = attribute.nodeName.toLowerCase();
  if (allowedAttributeList.includes(attributeName)) {
    if (uriAttributes.has(attributeName)) {
      return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));
    }
    return true;
  }
  return allowedAttributeList.filter((attributeRegex) => attributeRegex instanceof RegExp).some((regex) => regex.test(attributeName));
};
function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {
  if (!unsafeHtml.length) {
    return unsafeHtml;
  }
  if (sanitizeFunction && typeof sanitizeFunction === "function") {
    return sanitizeFunction(unsafeHtml);
  }
  const domParser = new window.DOMParser();
  const createdDocument = domParser.parseFromString(unsafeHtml, "text/html");
  const elements = [].concat(...createdDocument.body.querySelectorAll("*"));
  for (const element of elements) {
    const elementName = element.nodeName.toLowerCase();
    if (!Object.keys(allowList).includes(elementName)) {
      element.remove();
      continue;
    }
    const attributeList = [].concat(...element.attributes);
    const allowedAttributes = [].concat(allowList["*"] || [], allowList[elementName] || []);
    for (const attribute of attributeList) {
      if (!allowedAttribute(attribute, allowedAttributes)) {
        element.removeAttribute(attribute.nodeName);
      }
    }
  }
  return createdDocument.body.innerHTML;
}
const NAME$5 = "TemplateFactory";
const Default$4 = {
  allowList: DefaultAllowlist,
  content: {},
  // { selector : text ,  selector2 : text2 , }
  extraClass: "",
  html: false,
  sanitize: true,
  sanitizeFn: null,
  template: "<div></div>"
};
const DefaultType$4 = {
  allowList: "object",
  content: "object",
  extraClass: "(string|function)",
  html: "boolean",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  template: "string"
};
const DefaultContentType = {
  entry: "(string|element|function|null)",
  selector: "(string|element)"
};
class TemplateFactory extends Config {
  constructor(config2) {
    super();
    this._config = this._getConfig(config2);
  }
  // Getters
  static get Default() {
    return Default$4;
  }
  static get DefaultType() {
    return DefaultType$4;
  }
  static get NAME() {
    return NAME$5;
  }
  // Public
  getContent() {
    return Object.values(this._config.content).map((config2) => this._resolvePossibleFunction(config2)).filter(Boolean);
  }
  hasContent() {
    return this.getContent().length > 0;
  }
  changeContent(content) {
    this._checkContent(content);
    this._config.content = {
      ...this._config.content,
      ...content
    };
    return this;
  }
  toHtml() {
    const templateWrapper = document.createElement("div");
    templateWrapper.innerHTML = this._maybeSanitize(this._config.template);
    for (const [selector, text2] of Object.entries(this._config.content)) {
      this._setContent(templateWrapper, text2, selector);
    }
    const template = templateWrapper.children[0];
    const extraClass = this._resolvePossibleFunction(this._config.extraClass);
    if (extraClass) {
      template.classList.add(...extraClass.split(" "));
    }
    return template;
  }
  // Private
  _typeCheckConfig(config2) {
    super._typeCheckConfig(config2);
    this._checkContent(config2.content);
  }
  _checkContent(arg) {
    for (const [selector, content] of Object.entries(arg)) {
      super._typeCheckConfig({
        selector,
        entry: content
      }, DefaultContentType);
    }
  }
  _setContent(template, content, selector) {
    const templateElement = SelectorEngine.findOne(selector, template);
    if (!templateElement) {
      return;
    }
    content = this._resolvePossibleFunction(content);
    if (!content) {
      templateElement.remove();
      return;
    }
    if (isElement(content)) {
      this._putElementInTemplate(getElement(content), templateElement);
      return;
    }
    if (this._config.html) {
      templateElement.innerHTML = this._maybeSanitize(content);
      return;
    }
    templateElement.textContent = content;
  }
  _maybeSanitize(arg) {
    return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this]);
  }
  _putElementInTemplate(element, templateElement) {
    if (this._config.html) {
      templateElement.innerHTML = "";
      templateElement.append(element);
      return;
    }
    templateElement.textContent = element.textContent;
  }
}
const NAME$4 = "tooltip";
const DISALLOWED_ATTRIBUTES = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]);
const CLASS_NAME_FADE$2 = "fade";
const CLASS_NAME_MODAL = "modal";
const CLASS_NAME_SHOW$2 = "show";
const SELECTOR_TOOLTIP_INNER = ".tooltip-inner";
const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;
const EVENT_MODAL_HIDE = "hide.bs.modal";
const TRIGGER_HOVER = "hover";
const TRIGGER_FOCUS = "focus";
const TRIGGER_CLICK = "click";
const TRIGGER_MANUAL = "manual";
const EVENT_HIDE$2 = "hide";
const EVENT_HIDDEN$2 = "hidden";
const EVENT_SHOW$2 = "show";
const EVENT_SHOWN$2 = "shown";
const EVENT_INSERTED = "inserted";
const EVENT_CLICK$1 = "click";
const EVENT_FOCUSIN$1 = "focusin";
const EVENT_FOCUSOUT$1 = "focusout";
const EVENT_MOUSEENTER = "mouseenter";
const EVENT_MOUSELEAVE = "mouseleave";
const AttachmentMap = {
  AUTO: "auto",
  TOP: "top",
  RIGHT: isRTL() ? "left" : "right",
  BOTTOM: "bottom",
  LEFT: isRTL() ? "right" : "left"
};
const Default$3 = {
  allowList: DefaultAllowlist,
  animation: true,
  boundary: "clippingParents",
  container: false,
  customClass: "",
  delay: 0,
  fallbackPlacements: ["top", "right", "bottom", "left"],
  html: false,
  offset: [0, 6],
  placement: "top",
  popperConfig: null,
  sanitize: true,
  sanitizeFn: null,
  selector: false,
  template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
  title: "",
  trigger: "hover focus"
};
const DefaultType$3 = {
  allowList: "object",
  animation: "boolean",
  boundary: "(string|element)",
  container: "(string|element|boolean)",
  customClass: "(string|function)",
  delay: "(number|object)",
  fallbackPlacements: "array",
  html: "boolean",
  offset: "(array|string|function)",
  placement: "(string|function)",
  popperConfig: "(null|object|function)",
  sanitize: "boolean",
  sanitizeFn: "(null|function)",
  selector: "(string|boolean)",
  template: "string",
  title: "(string|element|function)",
  trigger: "string"
};
class Tooltip extends BaseComponent {
  constructor(element, config2) {
    if (typeof Popper === "undefined") {
      throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
    }
    super(element, config2);
    this._isEnabled = true;
    this._timeout = 0;
    this._isHovered = null;
    this._activeTrigger = {};
    this._popper = null;
    this._templateFactory = null;
    this._newContent = null;
    this.tip = null;
    this._setListeners();
    if (!this._config.selector) {
      this._fixTitle();
    }
  }
  // Getters
  static get Default() {
    return Default$3;
  }
  static get DefaultType() {
    return DefaultType$3;
  }
  static get NAME() {
    return NAME$4;
  }
  // Public
  enable() {
    this._isEnabled = true;
  }
  disable() {
    this._isEnabled = false;
  }
  toggleEnabled() {
    this._isEnabled = !this._isEnabled;
  }
  toggle() {
    if (!this._isEnabled) {
      return;
    }
    this._activeTrigger.click = !this._activeTrigger.click;
    if (this._isShown()) {
      this._leave();
      return;
    }
    this._enter();
  }
  dispose() {
    clearTimeout(this._timeout);
    EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
    if (this._element.getAttribute("data-bs-original-title")) {
      this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title"));
    }
    this._disposePopper();
    super.dispose();
  }
  show() {
    if (this._element.style.display === "none") {
      throw new Error("Please use show on visible elements");
    }
    if (!(this._isWithContent() && this._isEnabled)) {
      return;
    }
    const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));
    const shadowRoot = findShadowRoot(this._element);
    const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);
    if (showEvent.defaultPrevented || !isInTheDom) {
      return;
    }
    this._disposePopper();
    const tip = this._getTipElement();
    this._element.setAttribute("aria-describedby", tip.getAttribute("id"));
    const {
      container
    } = this._config;
    if (!this._element.ownerDocument.documentElement.contains(this.tip)) {
      container.append(tip);
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));
    }
    this._popper = this._createPopper(tip);
    tip.classList.add(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.on(element, "mouseover", noop$1);
      }
    }
    const complete = () => {
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));
      if (this._isHovered === false) {
        this._leave();
      }
      this._isHovered = false;
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  hide() {
    if (!this._isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));
    if (hideEvent.defaultPrevented) {
      return;
    }
    const tip = this._getTipElement();
    tip.classList.remove(CLASS_NAME_SHOW$2);
    if ("ontouchstart" in document.documentElement) {
      for (const element of [].concat(...document.body.children)) {
        EventHandler.off(element, "mouseover", noop$1);
      }
    }
    this._activeTrigger[TRIGGER_CLICK] = false;
    this._activeTrigger[TRIGGER_FOCUS] = false;
    this._activeTrigger[TRIGGER_HOVER] = false;
    this._isHovered = null;
    const complete = () => {
      if (this._isWithActiveTrigger()) {
        return;
      }
      if (!this._isHovered) {
        this._disposePopper();
      }
      this._element.removeAttribute("aria-describedby");
      EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));
    };
    this._queueCallback(complete, this.tip, this._isAnimated());
  }
  update() {
    if (this._popper) {
      this._popper.update();
    }
  }
  // Protected
  _isWithContent() {
    return Boolean(this._getTitle());
  }
  _getTipElement() {
    if (!this.tip) {
      this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());
    }
    return this.tip;
  }
  _createTipElement(content) {
    const tip = this._getTemplateFactory(content).toHtml();
    if (!tip) {
      return null;
    }
    tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);
    tip.classList.add(`bs-${this.constructor.NAME}-auto`);
    const tipId = getUID(this.constructor.NAME).toString();
    tip.setAttribute("id", tipId);
    if (this._isAnimated()) {
      tip.classList.add(CLASS_NAME_FADE$2);
    }
    return tip;
  }
  setContent(content) {
    this._newContent = content;
    if (this._isShown()) {
      this._disposePopper();
      this.show();
    }
  }
  _getTemplateFactory(content) {
    if (this._templateFactory) {
      this._templateFactory.changeContent(content);
    } else {
      this._templateFactory = new TemplateFactory({
        ...this._config,
        // the `content` var has to be after `this._config`
        // to override config.content in case of popover
        content,
        extraClass: this._resolvePossibleFunction(this._config.customClass)
      });
    }
    return this._templateFactory;
  }
  _getContentForTemplate() {
    return {
      [SELECTOR_TOOLTIP_INNER]: this._getTitle()
    };
  }
  _getTitle() {
    return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
  }
  // Private
  _initializeOnDelegatedTarget(event) {
    return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());
  }
  _isAnimated() {
    return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);
  }
  _isShown() {
    return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);
  }
  _createPopper(tip) {
    const placement = execute(this._config.placement, [this, tip, this._element]);
    const attachment = AttachmentMap[placement.toUpperCase()];
    return createPopper(this._element, tip, this._getPopperConfig(attachment));
  }
  _getOffset() {
    const {
      offset: offset2
    } = this._config;
    if (typeof offset2 === "string") {
      return offset2.split(",").map((value) => Number.parseInt(value, 10));
    }
    if (typeof offset2 === "function") {
      return (popperData) => offset2(popperData, this._element);
    }
    return offset2;
  }
  _resolvePossibleFunction(arg) {
    return execute(arg, [this._element]);
  }
  _getPopperConfig(attachment) {
    const defaultBsPopperConfig = {
      placement: attachment,
      modifiers: [{
        name: "flip",
        options: {
          fallbackPlacements: this._config.fallbackPlacements
        }
      }, {
        name: "offset",
        options: {
          offset: this._getOffset()
        }
      }, {
        name: "preventOverflow",
        options: {
          boundary: this._config.boundary
        }
      }, {
        name: "arrow",
        options: {
          element: `.${this.constructor.NAME}-arrow`
        }
      }, {
        name: "preSetPlacement",
        enabled: true,
        phase: "beforeMain",
        fn: (data2) => {
          this._getTipElement().setAttribute("data-popper-placement", data2.state.placement);
        }
      }]
    };
    return {
      ...defaultBsPopperConfig,
      ...execute(this._config.popperConfig, [defaultBsPopperConfig])
    };
  }
  _setListeners() {
    const triggers = this._config.trigger.split(" ");
    for (const trigger of triggers) {
      if (trigger === "click") {
        EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context.toggle();
        });
      } else if (trigger !== TRIGGER_MANUAL) {
        const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);
        const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);
        EventHandler.on(this._element, eventIn, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusin" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;
          context._enter();
        });
        EventHandler.on(this._element, eventOut, this._config.selector, (event) => {
          const context = this._initializeOnDelegatedTarget(event);
          context._activeTrigger[event.type === "focusout" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);
          context._leave();
        });
      }
    }
    this._hideModalHandler = () => {
      if (this._element) {
        this.hide();
      }
    };
    EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);
  }
  _fixTitle() {
    const title = this._element.getAttribute("title");
    if (!title) {
      return;
    }
    if (!this._element.getAttribute("aria-label") && !this._element.textContent.trim()) {
      this._element.setAttribute("aria-label", title);
    }
    this._element.setAttribute("data-bs-original-title", title);
    this._element.removeAttribute("title");
  }
  _enter() {
    if (this._isShown() || this._isHovered) {
      this._isHovered = true;
      return;
    }
    this._isHovered = true;
    this._setTimeout(() => {
      if (this._isHovered) {
        this.show();
      }
    }, this._config.delay.show);
  }
  _leave() {
    if (this._isWithActiveTrigger()) {
      return;
    }
    this._isHovered = false;
    this._setTimeout(() => {
      if (!this._isHovered) {
        this.hide();
      }
    }, this._config.delay.hide);
  }
  _setTimeout(handler, timeout2) {
    clearTimeout(this._timeout);
    this._timeout = setTimeout(handler, timeout2);
  }
  _isWithActiveTrigger() {
    return Object.values(this._activeTrigger).includes(true);
  }
  _getConfig(config2) {
    const dataAttributes = Manipulator.getDataAttributes(this._element);
    for (const dataAttribute of Object.keys(dataAttributes)) {
      if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {
        delete dataAttributes[dataAttribute];
      }
    }
    config2 = {
      ...dataAttributes,
      ...typeof config2 === "object" && config2 ? config2 : {}
    };
    config2 = this._mergeConfigObj(config2);
    config2 = this._configAfterMerge(config2);
    this._typeCheckConfig(config2);
    return config2;
  }
  _configAfterMerge(config2) {
    config2.container = config2.container === false ? document.body : getElement(config2.container);
    if (typeof config2.delay === "number") {
      config2.delay = {
        show: config2.delay,
        hide: config2.delay
      };
    }
    if (typeof config2.title === "number") {
      config2.title = config2.title.toString();
    }
    if (typeof config2.content === "number") {
      config2.content = config2.content.toString();
    }
    return config2;
  }
  _getDelegateConfig() {
    const config2 = {};
    for (const [key, value] of Object.entries(this._config)) {
      if (this.constructor.Default[key] !== value) {
        config2[key] = value;
      }
    }
    config2.selector = false;
    config2.trigger = "manual";
    return config2;
  }
  _disposePopper() {
    if (this._popper) {
      this._popper.destroy();
      this._popper = null;
    }
    if (this.tip) {
      this.tip.remove();
      this.tip = null;
    }
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Tooltip.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data2[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2]();
    });
  }
}
defineJQueryPlugin(Tooltip);
const NAME$3 = "popover";
const SELECTOR_TITLE = ".popover-header";
const SELECTOR_CONTENT = ".popover-body";
const Default$2 = {
  ...Tooltip.Default,
  content: "",
  offset: [0, 8],
  placement: "right",
  template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
  trigger: "click"
};
const DefaultType$2 = {
  ...Tooltip.DefaultType,
  content: "(null|string|element|function)"
};
class Popover extends Tooltip {
  // Getters
  static get Default() {
    return Default$2;
  }
  static get DefaultType() {
    return DefaultType$2;
  }
  static get NAME() {
    return NAME$3;
  }
  // Overrides
  _isWithContent() {
    return this._getTitle() || this._getContent();
  }
  // Private
  _getContentForTemplate() {
    return {
      [SELECTOR_TITLE]: this._getTitle(),
      [SELECTOR_CONTENT]: this._getContent()
    };
  }
  _getContent() {
    return this._resolvePossibleFunction(this._config.content);
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Popover.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (typeof data2[config2] === "undefined") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2]();
    });
  }
}
defineJQueryPlugin(Popover);
const NAME$2 = "scrollspy";
const DATA_KEY$2 = "bs.scrollspy";
const EVENT_KEY$2 = `.${DATA_KEY$2}`;
const DATA_API_KEY = ".data-api";
const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;
const EVENT_CLICK = `click${EVENT_KEY$2}`;
const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;
const CLASS_NAME_DROPDOWN_ITEM = "dropdown-item";
const CLASS_NAME_ACTIVE$1 = "active";
const SELECTOR_DATA_SPY = '[data-bs-spy="scroll"]';
const SELECTOR_TARGET_LINKS = "[href]";
const SELECTOR_NAV_LIST_GROUP = ".nav, .list-group";
const SELECTOR_NAV_LINKS = ".nav-link";
const SELECTOR_NAV_ITEMS = ".nav-item";
const SELECTOR_LIST_ITEMS = ".list-group-item";
const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;
const SELECTOR_DROPDOWN = ".dropdown";
const SELECTOR_DROPDOWN_TOGGLE$1 = ".dropdown-toggle";
const Default$1 = {
  offset: null,
  // TODO: v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "0px 0px -25%",
  smoothScroll: false,
  target: null,
  threshold: [0.1, 0.5, 1]
};
const DefaultType$1 = {
  offset: "(number|null)",
  // TODO v6 @deprecated, keep it for backwards compatibility reasons
  rootMargin: "string",
  smoothScroll: "boolean",
  target: "element",
  threshold: "array"
};
class ScrollSpy extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element;
    this._activeTarget = null;
    this._observer = null;
    this._previousScrollData = {
      visibleEntryTop: 0,
      parentScrollTop: 0
    };
    this.refresh();
  }
  // Getters
  static get Default() {
    return Default$1;
  }
  static get DefaultType() {
    return DefaultType$1;
  }
  static get NAME() {
    return NAME$2;
  }
  // Public
  refresh() {
    this._initializeTargetsAndObservables();
    this._maybeEnableSmoothScroll();
    if (this._observer) {
      this._observer.disconnect();
    } else {
      this._observer = this._getNewObserver();
    }
    for (const section of this._observableSections.values()) {
      this._observer.observe(section);
    }
  }
  dispose() {
    this._observer.disconnect();
    super.dispose();
  }
  // Private
  _configAfterMerge(config2) {
    config2.target = getElement(config2.target) || document.body;
    config2.rootMargin = config2.offset ? `${config2.offset}px 0px -30%` : config2.rootMargin;
    if (typeof config2.threshold === "string") {
      config2.threshold = config2.threshold.split(",").map((value) => Number.parseFloat(value));
    }
    return config2;
  }
  _maybeEnableSmoothScroll() {
    if (!this._config.smoothScroll) {
      return;
    }
    EventHandler.off(this._config.target, EVENT_CLICK);
    EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event) => {
      const observableSection = this._observableSections.get(event.target.hash);
      if (observableSection) {
        event.preventDefault();
        const root2 = this._rootElement || window;
        const height = observableSection.offsetTop - this._element.offsetTop;
        if (root2.scrollTo) {
          root2.scrollTo({
            top: height,
            behavior: "smooth"
          });
          return;
        }
        root2.scrollTop = height;
      }
    });
  }
  _getNewObserver() {
    const options = {
      root: this._rootElement,
      threshold: this._config.threshold,
      rootMargin: this._config.rootMargin
    };
    return new IntersectionObserver((entries) => this._observerCallback(entries), options);
  }
  // The logic of selection
  _observerCallback(entries) {
    const targetElement = (entry) => this._targetLinks.get(`#${entry.target.id}`);
    const activate = (entry) => {
      this._previousScrollData.visibleEntryTop = entry.target.offsetTop;
      this._process(targetElement(entry));
    };
    const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;
    const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;
    this._previousScrollData.parentScrollTop = parentScrollTop;
    for (const entry of entries) {
      if (!entry.isIntersecting) {
        this._activeTarget = null;
        this._clearActiveClass(targetElement(entry));
        continue;
      }
      const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;
      if (userScrollsDown && entryIsLowerThanPrevious) {
        activate(entry);
        if (!parentScrollTop) {
          return;
        }
        continue;
      }
      if (!userScrollsDown && !entryIsLowerThanPrevious) {
        activate(entry);
      }
    }
  }
  _initializeTargetsAndObservables() {
    this._targetLinks = /* @__PURE__ */ new Map();
    this._observableSections = /* @__PURE__ */ new Map();
    const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);
    for (const anchor of targetLinks) {
      if (!anchor.hash || isDisabled(anchor)) {
        continue;
      }
      const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);
      if (isVisible(observableSection)) {
        this._targetLinks.set(decodeURI(anchor.hash), anchor);
        this._observableSections.set(anchor.hash, observableSection);
      }
    }
  }
  _process(target) {
    if (this._activeTarget === target) {
      return;
    }
    this._clearActiveClass(this._config.target);
    this._activeTarget = target;
    target.classList.add(CLASS_NAME_ACTIVE$1);
    this._activateParents(target);
    EventHandler.trigger(this._element, EVENT_ACTIVATE, {
      relatedTarget: target
    });
  }
  _activateParents(target) {
    if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {
      SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);
      return;
    }
    for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {
      for (const item2 of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {
        item2.classList.add(CLASS_NAME_ACTIVE$1);
      }
    }
  }
  _clearActiveClass(parent) {
    parent.classList.remove(CLASS_NAME_ACTIVE$1);
    const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);
    for (const node of activeNodes) {
      node.classList.remove(CLASS_NAME_ACTIVE$1);
    }
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = ScrollSpy.getOrCreateInstance(this, config2);
      if (typeof config2 !== "string") {
        return;
      }
      if (data2[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2]();
    });
  }
}
EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {
  for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {
    ScrollSpy.getOrCreateInstance(spy);
  }
});
defineJQueryPlugin(ScrollSpy);
const NAME$1 = "tab";
const DATA_KEY$1 = "bs.tab";
const EVENT_KEY$1 = `.${DATA_KEY$1}`;
const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;
const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;
const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;
const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;
const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;
const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;
const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;
const ARROW_LEFT_KEY = "ArrowLeft";
const ARROW_RIGHT_KEY = "ArrowRight";
const ARROW_UP_KEY = "ArrowUp";
const ARROW_DOWN_KEY = "ArrowDown";
const HOME_KEY = "Home";
const END_KEY = "End";
const CLASS_NAME_ACTIVE = "active";
const CLASS_NAME_FADE$1 = "fade";
const CLASS_NAME_SHOW$1 = "show";
const CLASS_DROPDOWN = "dropdown";
const SELECTOR_DROPDOWN_TOGGLE = ".dropdown-toggle";
const SELECTOR_DROPDOWN_MENU = ".dropdown-menu";
const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;
const SELECTOR_TAB_PANEL = '.list-group, .nav, [role="tablist"]';
const SELECTOR_OUTER = ".nav-item, .list-group-item";
const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role="tab"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;
const SELECTOR_DATA_TOGGLE = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]';
const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;
const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle="tab"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="pill"], .${CLASS_NAME_ACTIVE}[data-bs-toggle="list"]`;
class Tab extends BaseComponent {
  constructor(element) {
    super(element);
    this._parent = this._element.closest(SELECTOR_TAB_PANEL);
    if (!this._parent) {
      return;
    }
    this._setInitialAttributes(this._parent, this._getChildren());
    EventHandler.on(this._element, EVENT_KEYDOWN, (event) => this._keydown(event));
  }
  // Getters
  static get NAME() {
    return NAME$1;
  }
  // Public
  show() {
    const innerElem = this._element;
    if (this._elemIsActive(innerElem)) {
      return;
    }
    const active = this._getActiveElem();
    const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {
      relatedTarget: innerElem
    }) : null;
    const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {
      relatedTarget: active
    });
    if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {
      return;
    }
    this._deactivate(active, innerElem);
    this._activate(innerElem, active);
  }
  // Private
  _activate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.add(CLASS_NAME_ACTIVE);
    this._activate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.add(CLASS_NAME_SHOW$1);
        return;
      }
      element.removeAttribute("tabindex");
      element.setAttribute("aria-selected", true);
      this._toggleDropDown(element, true);
      EventHandler.trigger(element, EVENT_SHOWN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _deactivate(element, relatedElem) {
    if (!element) {
      return;
    }
    element.classList.remove(CLASS_NAME_ACTIVE);
    element.blur();
    this._deactivate(SelectorEngine.getElementFromSelector(element));
    const complete = () => {
      if (element.getAttribute("role") !== "tab") {
        element.classList.remove(CLASS_NAME_SHOW$1);
        return;
      }
      element.setAttribute("aria-selected", false);
      element.setAttribute("tabindex", "-1");
      this._toggleDropDown(element, false);
      EventHandler.trigger(element, EVENT_HIDDEN$1, {
        relatedTarget: relatedElem
      });
    };
    this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));
  }
  _keydown(event) {
    if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {
      return;
    }
    event.stopPropagation();
    event.preventDefault();
    const children = this._getChildren().filter((element) => !isDisabled(element));
    let nextActiveElement;
    if ([HOME_KEY, END_KEY].includes(event.key)) {
      nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];
    } else {
      const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);
      nextActiveElement = getNextActiveElement(children, event.target, isNext, true);
    }
    if (nextActiveElement) {
      nextActiveElement.focus({
        preventScroll: true
      });
      Tab.getOrCreateInstance(nextActiveElement).show();
    }
  }
  _getChildren() {
    return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);
  }
  _getActiveElem() {
    return this._getChildren().find((child) => this._elemIsActive(child)) || null;
  }
  _setInitialAttributes(parent, children) {
    this._setAttributeIfNotExists(parent, "role", "tablist");
    for (const child of children) {
      this._setInitialAttributesOnChild(child);
    }
  }
  _setInitialAttributesOnChild(child) {
    child = this._getInnerElement(child);
    const isActive = this._elemIsActive(child);
    const outerElem = this._getOuterElement(child);
    child.setAttribute("aria-selected", isActive);
    if (outerElem !== child) {
      this._setAttributeIfNotExists(outerElem, "role", "presentation");
    }
    if (!isActive) {
      child.setAttribute("tabindex", "-1");
    }
    this._setAttributeIfNotExists(child, "role", "tab");
    this._setInitialAttributesOnTargetPanel(child);
  }
  _setInitialAttributesOnTargetPanel(child) {
    const target = SelectorEngine.getElementFromSelector(child);
    if (!target) {
      return;
    }
    this._setAttributeIfNotExists(target, "role", "tabpanel");
    if (child.id) {
      this._setAttributeIfNotExists(target, "aria-labelledby", `${child.id}`);
    }
  }
  _toggleDropDown(element, open) {
    const outerElem = this._getOuterElement(element);
    if (!outerElem.classList.contains(CLASS_DROPDOWN)) {
      return;
    }
    const toggle2 = (selector, className) => {
      const element2 = SelectorEngine.findOne(selector, outerElem);
      if (element2) {
        element2.classList.toggle(className, open);
      }
    };
    toggle2(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);
    toggle2(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);
    outerElem.setAttribute("aria-expanded", open);
  }
  _setAttributeIfNotExists(element, attribute, value) {
    if (!element.hasAttribute(attribute)) {
      element.setAttribute(attribute, value);
    }
  }
  _elemIsActive(elem) {
    return elem.classList.contains(CLASS_NAME_ACTIVE);
  }
  // Try to get the inner element (usually the .nav-link)
  _getInnerElement(elem) {
    return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);
  }
  // Try to get the outer element (usually the .nav-item)
  _getOuterElement(elem) {
    return elem.closest(SELECTOR_OUTER) || elem;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Tab.getOrCreateInstance(this);
      if (typeof config2 !== "string") {
        return;
      }
      if (data2[config2] === void 0 || config2.startsWith("_") || config2 === "constructor") {
        throw new TypeError(`No method named "${config2}"`);
      }
      data2[config2]();
    });
  }
}
EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  if (["A", "AREA"].includes(this.tagName)) {
    event.preventDefault();
  }
  if (isDisabled(this)) {
    return;
  }
  Tab.getOrCreateInstance(this).show();
});
EventHandler.on(window, EVENT_LOAD_DATA_API, () => {
  for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {
    Tab.getOrCreateInstance(element);
  }
});
defineJQueryPlugin(Tab);
const NAME = "toast";
const DATA_KEY = "bs.toast";
const EVENT_KEY = `.${DATA_KEY}`;
const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;
const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;
const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;
const EVENT_HIDE = `hide${EVENT_KEY}`;
const EVENT_HIDDEN = `hidden${EVENT_KEY}`;
const EVENT_SHOW = `show${EVENT_KEY}`;
const EVENT_SHOWN = `shown${EVENT_KEY}`;
const CLASS_NAME_FADE = "fade";
const CLASS_NAME_HIDE = "hide";
const CLASS_NAME_SHOW = "show";
const CLASS_NAME_SHOWING = "showing";
const DefaultType = {
  animation: "boolean",
  autohide: "boolean",
  delay: "number"
};
const Default = {
  animation: true,
  autohide: true,
  delay: 5e3
};
class Toast extends BaseComponent {
  constructor(element, config2) {
    super(element, config2);
    this._timeout = null;
    this._hasMouseInteraction = false;
    this._hasKeyboardInteraction = false;
    this._setListeners();
  }
  // Getters
  static get Default() {
    return Default;
  }
  static get DefaultType() {
    return DefaultType;
  }
  static get NAME() {
    return NAME;
  }
  // Public
  show() {
    const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);
    if (showEvent.defaultPrevented) {
      return;
    }
    this._clearTimeout();
    if (this._config.animation) {
      this._element.classList.add(CLASS_NAME_FADE);
    }
    const complete = () => {
      this._element.classList.remove(CLASS_NAME_SHOWING);
      EventHandler.trigger(this._element, EVENT_SHOWN);
      this._maybeScheduleHide();
    };
    this._element.classList.remove(CLASS_NAME_HIDE);
    reflow(this._element);
    this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  hide() {
    if (!this.isShown()) {
      return;
    }
    const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);
    if (hideEvent.defaultPrevented) {
      return;
    }
    const complete = () => {
      this._element.classList.add(CLASS_NAME_HIDE);
      this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);
      EventHandler.trigger(this._element, EVENT_HIDDEN);
    };
    this._element.classList.add(CLASS_NAME_SHOWING);
    this._queueCallback(complete, this._element, this._config.animation);
  }
  dispose() {
    this._clearTimeout();
    if (this.isShown()) {
      this._element.classList.remove(CLASS_NAME_SHOW);
    }
    super.dispose();
  }
  isShown() {
    return this._element.classList.contains(CLASS_NAME_SHOW);
  }
  // Private
  _maybeScheduleHide() {
    if (!this._config.autohide) {
      return;
    }
    if (this._hasMouseInteraction || this._hasKeyboardInteraction) {
      return;
    }
    this._timeout = setTimeout(() => {
      this.hide();
    }, this._config.delay);
  }
  _onInteraction(event, isInteracting) {
    switch (event.type) {
      case "mouseover":
      case "mouseout": {
        this._hasMouseInteraction = isInteracting;
        break;
      }
      case "focusin":
      case "focusout": {
        this._hasKeyboardInteraction = isInteracting;
        break;
      }
    }
    if (isInteracting) {
      this._clearTimeout();
      return;
    }
    const nextElement = event.relatedTarget;
    if (this._element === nextElement || this._element.contains(nextElement)) {
      return;
    }
    this._maybeScheduleHide();
  }
  _setListeners() {
    EventHandler.on(this._element, EVENT_MOUSEOVER, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_MOUSEOUT, (event) => this._onInteraction(event, false));
    EventHandler.on(this._element, EVENT_FOCUSIN, (event) => this._onInteraction(event, true));
    EventHandler.on(this._element, EVENT_FOCUSOUT, (event) => this._onInteraction(event, false));
  }
  _clearTimeout() {
    clearTimeout(this._timeout);
    this._timeout = null;
  }
  // Static
  static jQueryInterface(config2) {
    return this.each(function() {
      const data2 = Toast.getOrCreateInstance(this, config2);
      if (typeof config2 === "string") {
        if (typeof data2[config2] === "undefined") {
          throw new TypeError(`No method named "${config2}"`);
        }
        data2[config2](this);
      }
    });
  }
}
enableDismissTrigger(Toast);
defineJQueryPlugin(Toast);
function CitadelModal(element) {
  const $el = $(element);
  if (!element.data("modal")) {
    return old$3(element);
  }
  const def = JSON.stringify($el.attr("config"));
  const $body = $el.find(".offcanvas-body");
  const obj = new Modal(element);
  if ((def == null ? void 0 : def.source) == "page") {
    $el.on("show.bs.modal", async function(el) {
      const args = $(el.relatedTarget).data("flyout");
      $body.html("<div class='m-2'>Fetching Page...<div>");
      const page = await fetchPage((args == null ? void 0 : args.target) || def.target);
      $body.html("");
      $body.append(page);
    });
  }
  return obj;
}
function old$3(element) {
  const $el = $(element);
  const def = $el.data("modal");
  const $body = $el.find(".modal-body");
  console.log("MODAL ", $el, def, $body);
  const obj = new Modal(element);
  if ((def == null ? void 0 : def.source) == "page") {
    $el.on("show.bs.modal", async function(el) {
      console.log(el.relatedTarget);
      const args = $(el.relatedTarget).data("modal");
      $body.html("<div class='m-2'>Fetching Page...<div>");
      console.log("Fetching Page..");
      const page = await fetchPage((args == null ? void 0 : args.target) || def.target);
      $body.html("");
      $body.append(page);
      reinstance();
    });
  }
  return obj;
}
function CitadelFlyout(element) {
  const $el = $(element);
  if (!element.is(".flyout")) {
    return old$2(element);
  }
  const def = JSON.stringify($el.attr("config"));
  const $body = $el.find(".offcanvas-body");
  if ((def == null ? void 0 : def.source) == "page") {
    $el.on("show.bs.offcanvas", async function(el) {
      const args = $(el.relatedTarget).data("flyout");
      $body.html("<div class='m-2'>Fetching Page...<div>");
      const page = await fetchPage((args == null ? void 0 : args.target) || def.target);
      $body.html("");
      $body.append(page);
    });
  }
}
function old$2(element) {
  const $el = $(element);
  const def = $el.data("flyout");
  const $body = $el.find(".offcanvas-body");
  if ((def == null ? void 0 : def.source) == "page") {
    $el.on("show.bs.offcanvas", async function(el) {
      const args = $(el.relatedTarget).data("flyout");
      $body.html("<div class='m-2'>Fetching Page...<div>");
      const page = await fetchPage((args == null ? void 0 : args.target) || def.target);
      $body.html("");
      $body.append(page);
    });
  }
}
function CitadelWizard($wizard) {
  const config2 = $wizard.attr("wizard-config") ? JSON.parse($wizard.attr("wizard-config")) : {};
  const inputs = $wizard.find("input,select,textarea");
  const rules = {};
  const $form = $wizard.parents("form");
  inputs.each(function(_2, input) {
    input = $(input);
    const name2 = input.attr("name");
    const isFacade = input.attr("facade") != void 0;
    const rule = input.attr("citadel-rule") ? JSON.parse(input.attr("citadel-rule")) : {};
    if (!isEmpty$1(rule) && name2 && !isFacade) {
      rules[name2] = rule;
    }
  });
  if (!isEmpty$1(rules)) {
    $form.validate({
      errorPlacement: function errorPlacement(error2, element) {
        element.parents(".form-group").children(".text-danger").append(error2);
      },
      rules: rules ?? void 0,
      ignore: ":disabled"
    });
  }
  $wizard.steps({
    headerTag: ".step-label",
    bodyTag: "section.step-content",
    transitionEffect: "fade",
    stepsOrientation: "horizontal",
    enableCancelButton: false,
    enableFinishButton: false,
    titleTemplate: '<div step="#index#">#title#</div>',
    ...config2,
    onStepChanging: function(event, currentIndex, newIndex) {
      if (currentIndex > newIndex) {
        return true;
      }
      const isValid = $form.valid();
      return isValid;
    },
    onStepChanged: function(event, currentIndex, priorIndex) {
    },
    onFinishing: function(event, currentIndex, priorIndex) {
    },
    onInit: function(event, currentIndex) {
    }
  });
}
function CitadelDatepicker(element) {
  const $picker = $(element);
  const config2 = $picker.attr("citadel-datepicker") ? JSON.parse($picker.attr("citadel-datepicker")) : {};
  $picker.datepicker({
    ...config2
  });
}
function bind(fn3, thisArg) {
  return function wrap() {
    return fn3.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str2 = toString.call(thing);
  return cache[str2] || (cache[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn3, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l2 = obj.length; i < l2; i++) {
      fn3.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn3.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l2 = arguments.length; i < l2; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i = thing.length;
  if (!isNumber(i))
    return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn3) => {
  const generator2 = obj && obj[Symbol.iterator];
  const iterator = generator2.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn3.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str2) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str2)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str2) => {
  return str2.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code, config2, request, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  if (response2) {
    this.response = response2;
    this.status = response2.status ? response2.status : null;
  }
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code, config2, request, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error2, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code, config2, request, response2);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option2, source) {
    return !utils$1.isUndefined(source[option2]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn3) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn3(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name2 = path[index++];
    if (name2 === "__proto__")
      return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index >= path.length;
    name2 = !name2 && utils$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index);
    if (result && utils$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data2);
    if (isObjectPayload && utils$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1.isArrayBuffer(data2) || utils$1.isBuffer(data2) || utils$1.isStream(data2) || utils$1.isFile(data2) || utils$1.isBlob(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (utils$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1.isResponse(data2) || utils$1.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults$1.headers[method] = {};
});
const defaults$2 = defaults$1;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str2)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils$1.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils$1.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response2) {
  const config2 = this || defaults$2;
  const context = response2 || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data2 = context.data;
  utils$1.forEach(fns, function transform(fn3) {
    data2 = fn3.call(config2, data2, headers.normalize(), response2 ? response2.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve(response2);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response2.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn3, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn3.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data2);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn3) => (...args) => utils$1.asap(() => fn3(...args));
const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value, expires, path, domain, secure) {
      const cookie = [name2 + "=" + encodeURIComponent(value)];
      utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$1.isString(path) && cookie.push("path=" + path);
      utils$1.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name2) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const resolveConfig = (config2) => {
  const newConfig = mergeConfig({}, config2);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config2.params, config2.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$1.isFormData(data2)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config2);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response2 = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response2);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout2) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout2 || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout2 && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout2} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout2);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end2;
  while (pos < len) {
    end2 = pos + chunkSize;
    yield chunk.slice(pos, end2);
    pos = end2;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
const test = (fn3, ...args) => {
  try {
    return !!fn3(...args);
  } catch (e2) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res2) => res2.body)
};
isFetchSupported && ((res2) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res2[type]) ? (res3) => res3[type]() : (_2, config2) => {
      throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config2);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config2) => {
  let {
    url,
    method,
    data: data2,
    signal,
    cancelToken,
    timeout: timeout2,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config2);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data2,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response2 = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response2[prop];
      });
      const responseContentLength = utils$1.toFiniteNumber(response2.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response2 = new Response(
        trackStream(response2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response2, config2);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response2.headers),
        status: response2.status,
        statusText: response2.statusText,
        config: config2,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config2, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (fn3, value) => {
  if (fn3) {
    try {
      Object.defineProperty(fn3, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn3, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$2.adapter);
  return adapter(config2).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config2);
    response2.data = transformData.call(
      config2,
      config2.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$1.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const VERSION = "1.8.4";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config2) {
    try {
      return await this._request(configOrUrl, config2);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config2.allowAbsoluteUrls !== void 0)
      ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config2.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config2.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config2, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config2);
      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url, config2.allowAbsoluteUrls);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config2, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config2, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig2) {
  const context = new Axios$1(defaultConfig2);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig2, instanceConfig));
  };
  return instance;
}
const axios$1 = createInstance(defaults$2);
axios$1.Axios = Axios$1;
axios$1.CanceledError = CanceledError;
axios$1.CancelToken = CancelToken$1;
axios$1.isCancel = isCancel;
axios$1.VERSION = VERSION;
axios$1.toFormData = toFormData;
axios$1.AxiosError = AxiosError;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function all(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$1.mergeConfig = mergeConfig;
axios$1.AxiosHeaders = AxiosHeaders$1;
axios$1.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios$1.getAdapter = adapters.getAdapter;
axios$1.HttpStatusCode = HttpStatusCode$1;
axios$1.default = axios$1;
const axios$2 = axios$1;
async function CitadelWidget$1(el) {
  if (el.is("[citadel-widget]")) {
    return await old$1(el);
  }
  init(el);
}
async function init(el) {
  const config2 = JSON.parse(el.attr("config"));
  const name2 = el.attr("id");
  if (config2.reactive) {
    handleReactive(el, name2);
  }
}
async function handleReactive(el, name2) {
  $(el).loadingOverlay();
  axios$2.get(addQueryParams(location.href, {
    f: "reactive",
    c: name2
  })).then((response2) => {
    el.find(".content").html(response2.data);
  }).catch((errors) => {
    console.log(errors);
  }).finally(() => {
    $(el).loadingOverlay("remove");
  });
}
async function old$1(el) {
  const { source } = el.attr("citadel-widget");
  const $content = el.find(".card-content");
  $content.LoadingOverlay("show");
  const response2 = await $.get(source, function(response3) {
    return response3;
  }).fail(function() {
    toastr["error"](`Failed fetching widget from ${source}`);
    return "<Error/>";
  });
  $content.LoadingOverlay("hide");
  el.find("#description").html(response2);
}
function CitadelChart(el) {
  const name2 = el.attr("name");
  axios.get(addQueryParams(location.href, {
    f: "reactive",
    c: name2
  })).then((response2) => {
    const config2 = response2.data;
    const chart = new us(el[0], config2);
    chart.render();
  }).catch((errors) => {
    el.html = JSON.stringify(errors);
  });
}
function CitadelToast(response2) {
  showToastsFromResponse(response2);
}
function showToastsFromResponse(response2) {
  const toastContainer = document.getElementById("toast-container") || createToastContainer();
  (response2.toast || []).forEach((toastData) => {
    const { text: text2, body, options = {} } = toastData;
    const toastEl = document.createElement("div");
    toastEl.className = "toast align-items-center text-bg-" + (mapType(options.type) || "primary");
    toastEl.setAttribute("role", "alert");
    toastEl.setAttribute("aria-live", "assertive");
    toastEl.setAttribute("aria-atomic", "true");
    toastEl.innerHTML = `
            <div class="d-flex">
                <div class="toast-body">
                    <strong>${text2}</strong><br>
                    ${body}
                </div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        `;
    toastContainer.appendChild(toastEl);
    const toast = new bootstrap.Toast(toastEl, {
      autohide: true,
      delay: (options.autohide || options.autoclose || 5) * 1e3
      // fallback default 5 detik
    });
    toast.show();
  });
}
function mapType(type) {
  switch (type) {
    case "success":
      return "success";
    case "error":
      return "danger";
    case "info":
      return "info";
    case "warning":
      return "warning";
    default:
      return "primary";
  }
}
function createToastContainer() {
  const container = document.createElement("div");
  container.id = "toast-container";
  container.className = "toast-container position-fixed top-0 end-0 p-3";
  document.body.appendChild(container);
  return container;
}
function CitadelForm(el) {
  $(el).on("submit", function(e2) {
    e2.preventDefault();
  });
  $(el).on("CForm:submit", function(e2) {
    e2.target;
  });
}
function CitadelFormWatchEvent() {
  window.addEventListener(
    "CForm:submit",
    async (e2) => {
      const form_target = e2.detail.form_name;
      const srcElement = e2.detail.srcElement;
      const $form = $(`form#${form_target}.citadel-form`);
      const data2 = {
        ...serializeFormData($form.serializeArray()),
        raw: window.main_form_data
      };
      let url = e2.detail.url;
      let icon = srcElement.find("i[class^=ft-]");
      const iconClass = "ft-loader " + icon.attr("class");
      Pace.track(function() {
        icon.toggleClass(iconClass);
        srcElement.prop("disabled", true);
        srcElement.toggleClass("unclickable");
        $("body .main-content").toggleClass("unclickable");
        $form.toggleClass("citadel-onsubmit");
        $form.find('input, button[type="submit"]').prop("disabled", true);
        formSubmit({ url, method: "POST", data: data2 }).catch((e3) => {
          console.log(e3);
        }).finally((r2) => {
          $form.find('input, button[type="submit"]').prop("disabled", false);
          $form.toggleClass("citadel-onsubmit");
          srcElement.prop("disabled", false);
          srcElement.toggleClass("unclickable");
          icon.toggleClass(iconClass);
          $("body .main-content").toggleClass("unclickable");
        });
      });
    }
  );
}
const CitadelObject = {
  redirect(args) {
  },
  toast(args) {
    CitadelToast(args);
  }
};
const response = {
  validation(json) {
    Swal$1.fire({
      title: "Validation Error",
      html: json.message,
      icon: "error",
      confirmButtonText: "Close"
    });
    Object.keys(json.errors).forEach((key) => {
      json.errors[key].forEach((m2) => {
        toastr.error(m2);
        $(`#${key}_error`).html(m2);
      });
    });
  },
  bad_request(json) {
    if (json.citadel) {
      this.init_citadel_object(json.citadel);
    }
  },
  success(json) {
    console.log(json);
    if (json.citadel) {
      this.init_citadel_object(json.citadel);
    }
    if (json.swal) {
      Swal$1.fire({ ...json.swal, icon: "success" }).then((x2) => {
        window.location.href = json.swal.redirectUrl;
      });
    }
  },
  handle_swal(config2) {
    Swal$1.fire(config2);
  },
  init_citadel_object(c2) {
    if (c2.constructor === Array) {
      c2.forEach(function(v2, i) {
        CitadelObject[i](v2);
      });
    }
    if (c2.constructor === Object) {
      if (c2.args) {
        const sw = c2.args;
        Swal$1.fire(sw.config).then((r2) => {
          console.log(r2);
          this.handle_after_confirm(sw);
        }).catch((error2) => {
          console.log(error2);
        });
      } else {
        Object.keys(c2).forEach(function(key) {
          CitadelObject[key](c2[key]);
        });
      }
    }
  },
  handle_after_confirm({ after_confirm, after_confirm_args, redirectUrl }) {
    if (redirectUrl) {
      window.location.href = redirectUrl;
    }
    if (after_confirm == "none")
      return;
    if (after_confirm == "reload") {
      window.location.reload();
    }
  }
};
function ajaxResponseHandler({ responseJSON: json, status, statusText }) {
  if (json == void 0) {
    Swal$1.fire({
      title: "No Response!",
      html: "Server doesnt give any response.<br> Try contact your administrator"
    });
    return;
  }
  if (status == 422) {
    return response.validation(json);
  }
  if (status == 400) {
    return response.bad_request(json);
  }
  if (status == 200) {
    return response.success(json);
  }
  if (status == 500) {
    if (json.message) {
      Swal$1.fire({
        title: "Internal Server Error",
        html: json.message
      });
    }
    return response.bad_request(json);
  }
  Swal$1.fire({
    title: statusText,
    html: JSON.stringify(json)
  });
  return;
}
async function formSubmit({
  url,
  method,
  data: data2
}) {
  let headers = {
    "X-CSRF-TOKEN": $('meta[name="csrf-token"]').attr(
      "content"
    ),
    "Content-Type": "application/json",
    "x-request-via": "citadel-form-wrapped"
  };
  $("body").loadingOverlay();
  return await $.ajax({
    url,
    headers,
    type: method ?? "POST",
    data: JSON.stringify(data2),
    success: function(data3, textStatus, res2) {
      console.log(res2);
      ajaxResponseHandler(res2);
    },
    error: function(res2) {
      ajaxResponseHandler(res2);
    },
    complete: function() {
      $("body").loadingOverlay("remove");
    }
  });
}
var selectize = { exports: {} };
(function(module) {
  (function(root2, factory) {
    {
      module.exports = factory(requireJquery());
    }
  })(commonjsGlobal, function($2) {
    var highlight2 = function($element, pattern) {
      if (typeof pattern === "string" && !pattern.length)
        return;
      var regex = typeof pattern === "string" ? new RegExp(pattern, "i") : pattern;
      var highlight3 = function(node) {
        var skip = 0;
        if (node.nodeType === 3) {
          var pos = node.data.search(regex);
          if (pos >= 0 && node.data.length > 0) {
            var match = node.data.match(regex);
            var spannode = document.createElement("span");
            spannode.className = "highlight";
            var middlebit = node.splitText(pos);
            middlebit.splitText(match[0].length);
            var middleclone = middlebit.cloneNode(true);
            spannode.appendChild(middleclone);
            middlebit.parentNode.replaceChild(spannode, middlebit);
            skip = 1;
          }
        } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
          for (var i = 0; i < node.childNodes.length; ++i) {
            i += highlight3(node.childNodes[i]);
          }
        }
        return skip;
      };
      return $element.each(function() {
        highlight3(this);
      });
    };
    $2.fn.removeHighlight = function() {
      return this.find("span.highlight").each(function() {
        this.parentNode.firstChild.nodeName;
        var parent = this.parentNode;
        parent.replaceChild(this.firstChild, this);
        parent.normalize();
      }).end();
    };
    var MicroEvent2 = function() {
    };
    MicroEvent2.prototype = {
      on: function(event, fct) {
        this._events = this._events || {};
        this._events[event] = this._events[event] || [];
        this._events[event].push(fct);
      },
      off: function(event, fct) {
        var n2 = arguments.length;
        if (n2 === 0)
          return delete this._events;
        if (n2 === 1)
          return delete this._events[event];
        this._events = this._events || {};
        if (event in this._events === false)
          return;
        this._events[event].splice(this._events[event].indexOf(fct), 1);
      },
      trigger: function(event) {
        const events = this._events = this._events || {};
        if (event in events === false)
          return;
        for (var i = 0; i < events[event].length; i++) {
          events[event][i].apply(this, Array.prototype.slice.call(arguments, 1));
        }
      }
    };
    MicroEvent2.mixin = function(destObject) {
      var props = ["on", "off", "trigger"];
      for (var i = 0; i < props.length; i++) {
        destObject.prototype[props[i]] = MicroEvent2.prototype[props[i]];
      }
    };
    var MicroPlugin2 = {};
    MicroPlugin2.mixin = function(Interface) {
      Interface.plugins = {};
      Interface.prototype.initializePlugins = function(plugins2) {
        var i, n2, key;
        var self2 = this;
        var queue = [];
        self2.plugins = {
          names: [],
          settings: {},
          requested: {},
          loaded: {}
        };
        if (utils2.isArray(plugins2)) {
          for (i = 0, n2 = plugins2.length; i < n2; i++) {
            if (typeof plugins2[i] === "string") {
              queue.push(plugins2[i]);
            } else {
              self2.plugins.settings[plugins2[i].name] = plugins2[i].options;
              queue.push(plugins2[i].name);
            }
          }
        } else if (plugins2) {
          for (key in plugins2) {
            if (plugins2.hasOwnProperty(key)) {
              self2.plugins.settings[key] = plugins2[key];
              queue.push(key);
            }
          }
        }
        while (queue.length) {
          self2.require(queue.shift());
        }
      };
      Interface.prototype.loadPlugin = function(name2) {
        var self2 = this;
        var plugins2 = self2.plugins;
        var plugin2 = Interface.plugins[name2];
        if (!Interface.plugins.hasOwnProperty(name2)) {
          throw new Error('Unable to find "' + name2 + '" plugin');
        }
        plugins2.requested[name2] = true;
        plugins2.loaded[name2] = plugin2.fn.apply(self2, [self2.plugins.settings[name2] || {}]);
        plugins2.names.push(name2);
      };
      Interface.prototype.require = function(name2) {
        var self2 = this;
        var plugins2 = self2.plugins;
        if (!self2.plugins.loaded.hasOwnProperty(name2)) {
          if (plugins2.requested[name2]) {
            throw new Error('Plugin has circular dependency ("' + name2 + '")');
          }
          self2.loadPlugin(name2);
        }
        return plugins2.loaded[name2];
      };
      Interface.define = function(name2, fn3) {
        Interface.plugins[name2] = {
          "name": name2,
          "fn": fn3
        };
      };
    };
    var utils2 = {
      isArray: Array.isArray || function(vArg) {
        return Object.prototype.toString.call(vArg) === "[object Array]";
      }
    };
    var Sifter2 = function(items, settings) {
      this.items = items;
      this.settings = settings || { diacritics: true };
    };
    Sifter2.prototype.tokenize = function(query, respect_word_boundaries) {
      query = trim2(String(query || "").toLowerCase());
      if (!query || !query.length)
        return [];
      var i, n2, regex, letter;
      var tokens = [];
      var words = query.split(/ +/);
      for (i = 0, n2 = words.length; i < n2; i++) {
        regex = escape_regex2(words[i]);
        if (this.settings.diacritics) {
          for (letter in DIACRITICS) {
            if (DIACRITICS.hasOwnProperty(letter)) {
              regex = regex.replace(new RegExp(letter, "g"), DIACRITICS[letter]);
            }
          }
        }
        if (respect_word_boundaries)
          regex = "\\b" + regex;
        tokens.push({
          string: words[i],
          regex: new RegExp(regex, "i")
        });
      }
      return tokens;
    };
    Sifter2.prototype.iterator = function(object, callback) {
      var iterator;
      if (is_array(object)) {
        iterator = Array.prototype.forEach || function(callback2) {
          for (var i = 0, n2 = this.length; i < n2; i++) {
            callback2(this[i], i, this);
          }
        };
      } else {
        iterator = function(callback2) {
          for (var key in this) {
            if (this.hasOwnProperty(key)) {
              callback2(this[key], key, this);
            }
          }
        };
      }
      iterator.apply(object, [callback]);
    };
    Sifter2.prototype.getScoreFunction = function(search, options) {
      var self2, fields, tokens, token_count, nesting;
      self2 = this;
      search = self2.prepareSearch(search, options);
      tokens = search.tokens;
      fields = search.options.fields;
      token_count = tokens.length;
      nesting = search.options.nesting;
      var scoreValue2 = function(value, token) {
        var score, pos;
        if (!value)
          return 0;
        value = String(value || "");
        pos = value.search(token.regex);
        if (pos === -1)
          return 0;
        score = token.string.length / value.length;
        if (pos === 0)
          score += 0.5;
        return score;
      };
      var scoreObject = function() {
        var field_count = fields.length;
        if (!field_count) {
          return function() {
            return 0;
          };
        }
        if (field_count === 1) {
          return function(token, data2) {
            return scoreValue2(getattr(data2, fields[0], nesting), token);
          };
        }
        return function(token, data2) {
          for (var i = 0, sum = 0; i < field_count; i++) {
            sum += scoreValue2(getattr(data2, fields[i], nesting), token);
          }
          return sum / field_count;
        };
      }();
      if (!token_count) {
        return function() {
          return 0;
        };
      }
      if (token_count === 1) {
        return function(data2) {
          return scoreObject(tokens[0], data2);
        };
      }
      if (search.options.conjunction === "and") {
        return function(data2) {
          var score;
          for (var i = 0, sum = 0; i < token_count; i++) {
            score = scoreObject(tokens[i], data2);
            if (score <= 0)
              return 0;
            sum += score;
          }
          return sum / token_count;
        };
      } else {
        return function(data2) {
          for (var i = 0, sum = 0; i < token_count; i++) {
            sum += scoreObject(tokens[i], data2);
          }
          return sum / token_count;
        };
      }
    };
    Sifter2.prototype.getSortFunction = function(search, options) {
      var i, n2, self2, field, fields, fields_count, multiplier, multipliers, get_field, implicit_score, sort;
      self2 = this;
      search = self2.prepareSearch(search, options);
      sort = !search.query && options.sort_empty || options.sort;
      get_field = function(name2, result) {
        if (name2 === "$score")
          return result.score;
        return getattr(self2.items[result.id], name2, options.nesting);
      };
      fields = [];
      if (sort) {
        for (i = 0, n2 = sort.length; i < n2; i++) {
          if (search.query || sort[i].field !== "$score") {
            fields.push(sort[i]);
          }
        }
      }
      if (search.query) {
        implicit_score = true;
        for (i = 0, n2 = fields.length; i < n2; i++) {
          if (fields[i].field === "$score") {
            implicit_score = false;
            break;
          }
        }
        if (implicit_score) {
          fields.unshift({ field: "$score", direction: "desc" });
        }
      } else {
        for (i = 0, n2 = fields.length; i < n2; i++) {
          if (fields[i].field === "$score") {
            fields.splice(i, 1);
            break;
          }
        }
      }
      multipliers = [];
      for (i = 0, n2 = fields.length; i < n2; i++) {
        multipliers.push(fields[i].direction === "desc" ? -1 : 1);
      }
      fields_count = fields.length;
      if (!fields_count) {
        return null;
      } else if (fields_count === 1) {
        field = fields[0].field;
        multiplier = multipliers[0];
        return function(a2, b2) {
          return multiplier * cmp2(
            get_field(field, a2),
            get_field(field, b2)
          );
        };
      } else {
        return function(a2, b2) {
          var i2, result, field2;
          for (i2 = 0; i2 < fields_count; i2++) {
            field2 = fields[i2].field;
            result = multipliers[i2] * cmp2(
              get_field(field2, a2),
              get_field(field2, b2)
            );
            if (result)
              return result;
          }
          return 0;
        };
      }
    };
    Sifter2.prototype.prepareSearch = function(query, options) {
      if (typeof query === "object")
        return query;
      options = extend2({}, options);
      var option_fields = options.fields;
      var option_sort = options.sort;
      var option_sort_empty = options.sort_empty;
      if (option_fields && !is_array(option_fields))
        options.fields = [option_fields];
      if (option_sort && !is_array(option_sort))
        options.sort = [option_sort];
      if (option_sort_empty && !is_array(option_sort_empty))
        options.sort_empty = [option_sort_empty];
      return {
        options,
        query: String(query || "").toLowerCase(),
        tokens: this.tokenize(query, options.respect_word_boundaries),
        total: 0,
        items: []
      };
    };
    Sifter2.prototype.search = function(query, options) {
      var self2 = this, score, search;
      var fn_sort;
      var fn_score;
      search = this.prepareSearch(query, options);
      options = search.options;
      query = search.query;
      fn_score = options.score || self2.getScoreFunction(search);
      if (query.length) {
        self2.iterator(self2.items, function(item2, id) {
          score = fn_score(item2);
          if (options.filter === false || score > 0) {
            search.items.push({ "score": score, "id": id });
          }
        });
      } else {
        self2.iterator(self2.items, function(item2, id) {
          search.items.push({ "score": 1, "id": id });
        });
      }
      fn_sort = self2.getSortFunction(search, options);
      if (fn_sort)
        search.items.sort(fn_sort);
      search.total = search.items.length;
      if (typeof options.limit === "number") {
        search.items = search.items.slice(0, options.limit);
      }
      return search;
    };
    var cmp2 = function(a2, b2) {
      if (typeof a2 === "number" && typeof b2 === "number") {
        return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
      }
      a2 = asciifold2(String(a2 || ""));
      b2 = asciifold2(String(b2 || ""));
      if (a2 > b2)
        return 1;
      if (b2 > a2)
        return -1;
      return 0;
    };
    var extend2 = function(a2, b2) {
      var i, n2, k2, object;
      for (i = 1, n2 = arguments.length; i < n2; i++) {
        object = arguments[i];
        if (!object)
          continue;
        for (k2 in object) {
          if (object.hasOwnProperty(k2)) {
            a2[k2] = object[k2];
          }
        }
      }
      return a2;
    };
    var getattr = function(obj, name2, nesting) {
      if (!obj || !name2)
        return;
      if (!nesting)
        return obj[name2];
      var names = name2.split(".");
      while (names.length && (obj = obj[names.shift()]))
        ;
      return obj;
    };
    var trim2 = function(str2) {
      return (str2 + "").replace(/^\s+|\s+$|/g, "");
    };
    var escape_regex2 = function(str2) {
      return (str2 + "").replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    };
    var is_array = Array.isArray || typeof $2 !== "undefined" && $2.isArray || function(object) {
      return Object.prototype.toString.call(object) === "[object Array]";
    };
    var DIACRITICS = {
      "a": "[aḀḁĂăÂâǍǎȺⱥȦȧẠạÄäÀàÁáĀāÃãÅåąĄÃąĄ]",
      "b": "[b␢βΒB฿𐌁ᛒ]",
      "c": "[cĆćĈĉČčĊċC̄c̄ÇçḈḉȻȼƇƈɕᴄＣｃ]",
      "d": "[dĎďḊḋḐḑḌḍḒḓḎḏĐđD̦d̦ƉɖƊɗƋƌᵭᶁᶑȡᴅＤｄð]",
      "e": "[eÉéÈèÊêḘḙĚěĔĕẼẽḚḛẺẻĖėËëĒēȨȩĘęᶒɆɇȄȅẾếỀềỄễỂểḜḝḖḗḔḕȆȇẸẹỆệⱸᴇＥｅɘǝƏƐε]",
      "f": "[fƑƒḞḟ]",
      "g": "[gɢ₲ǤǥĜĝĞğĢģƓɠĠġ]",
      "h": "[hĤĥĦħḨḩẖẖḤḥḢḣɦʰǶƕ]",
      "i": "[iÍíÌìĬĭÎîǏǐÏïḮḯĨĩĮįĪīỈỉȈȉȊȋỊịḬḭƗɨɨ̆ᵻᶖİiIıɪＩｉ]",
      "j": "[jȷĴĵɈɉʝɟʲ]",
      "k": "[kƘƙꝀꝁḰḱǨǩḲḳḴḵκϰ₭]",
      "l": "[lŁłĽľĻļĹĺḶḷḸḹḼḽḺḻĿŀȽƚⱠⱡⱢɫɬᶅɭȴʟＬｌ]",
      "n": "[nŃńǸǹŇňÑñṄṅŅņṆṇṊṋṈṉN̈n̈ƝɲȠƞᵰᶇɳȵɴＮｎŊŋ]",
      "o": "[oØøÖöÓóÒòÔôǑǒŐőŎŏȮȯỌọƟɵƠơỎỏŌōÕõǪǫȌȍՕօ]",
      "p": "[pṔṕṖṗⱣᵽƤƥᵱ]",
      "q": "[qꝖꝗʠɊɋꝘꝙq̃]",
      "r": "[rŔŕɌɍŘřŖŗṘṙȐȑȒȓṚṛⱤɽ]",
      "s": "[sŚśṠṡṢṣꞨꞩŜŝŠšŞşȘșS̈s̈]",
      "t": "[tŤťṪṫŢţṬṭƮʈȚțṰṱṮṯƬƭ]",
      "u": "[uŬŭɄʉỤụÜüÚúÙùÛûǓǔŰűŬŭƯưỦủŪūŨũŲųȔȕ∪]",
      "v": "[vṼṽṾṿƲʋꝞꝟⱱʋ]",
      "w": "[wẂẃẀẁŴŵẄẅẆẇẈẉ]",
      "x": "[xẌẍẊẋχ]",
      "y": "[yÝýỲỳŶŷŸÿỸỹẎẏỴỵɎɏƳƴ]",
      "z": "[zŹźẐẑŽžŻżẒẓẔẕƵƶ]"
    };
    var asciifold2 = function() {
      var i, n2, k2, chunk;
      var foreignletters = "";
      var lookup = {};
      for (k2 in DIACRITICS) {
        if (DIACRITICS.hasOwnProperty(k2)) {
          chunk = DIACRITICS[k2].substring(2, DIACRITICS[k2].length - 1);
          foreignletters += chunk;
          for (i = 0, n2 = chunk.length; i < n2; i++) {
            lookup[chunk.charAt(i)] = k2;
          }
        }
      }
      var regexp = new RegExp("[" + foreignletters + "]", "g");
      return function(str2) {
        return str2.replace(regexp, function(foreignletter) {
          return lookup[foreignletter];
        }).toLowerCase();
      };
    }();
    function uaDetect(platform2, re2) {
      if (navigator.userAgentData) {
        return platform2 === navigator.userAgentData.platform;
      }
      return re2.test(navigator.userAgent);
    }
    var IS_MAC2 = uaDetect("macOS", /Mac/);
    var KEY_A2 = 65;
    var KEY_RETURN2 = 13;
    var KEY_ESC2 = 27;
    var KEY_LEFT2 = 37;
    var KEY_UP2 = 38;
    var KEY_P = 80;
    var KEY_RIGHT2 = 39;
    var KEY_DOWN2 = 40;
    var KEY_N = 78;
    var KEY_BACKSPACE2 = 8;
    var KEY_DELETE2 = 46;
    var KEY_SHIFT = 16;
    var KEY_CMD = IS_MAC2 ? 91 : 17;
    var KEY_CTRL = IS_MAC2 ? 18 : 17;
    var KEY_TAB2 = 9;
    var TAG_SELECT = 1;
    var TAG_INPUT = 2;
    var SUPPORTS_VALIDITY_API = !uaDetect("Android", /android/i) && !!document.createElement("input").validity;
    var isset = function(object) {
      return typeof object !== "undefined";
    };
    var hash_key2 = function(value) {
      if (typeof value === "undefined" || value === null)
        return null;
      if (typeof value === "boolean")
        return value ? "1" : "0";
      return value + "";
    };
    var escape_html2 = function(str2) {
      return (str2 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
    };
    var hook = {};
    hook.before = function(self2, method, fn3) {
      var original = self2[method];
      self2[method] = function() {
        fn3.apply(self2, arguments);
        return original.apply(self2, arguments);
      };
    };
    hook.after = function(self2, method, fn3) {
      var original = self2[method];
      self2[method] = function() {
        var result = original.apply(self2, arguments);
        fn3.apply(self2, arguments);
        return result;
      };
    };
    var once2 = function(fn3) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        fn3.apply(this, arguments);
      };
    };
    var debounce2 = function(fn3, delay) {
      var timeout2;
      return function() {
        var self2 = this;
        var args = arguments;
        window.clearTimeout(timeout2);
        timeout2 = window.setTimeout(function() {
          fn3.apply(self2, args);
        }, delay);
      };
    };
    var debounce_events2 = function(self2, types, fn3) {
      var type;
      var trigger = self2.trigger;
      var event_args = {};
      self2.trigger = function() {
        var type2 = arguments[0];
        if (types.indexOf(type2) !== -1) {
          event_args[type2] = arguments;
        } else {
          return trigger.apply(self2, arguments);
        }
      };
      fn3.apply(self2, []);
      self2.trigger = trigger;
      for (type in event_args) {
        if (event_args.hasOwnProperty(type)) {
          trigger.apply(self2, event_args[type]);
        }
      }
    };
    var watchChildEvent = function($parent, event, selector, fn3) {
      $parent.on(event, selector, function(e2) {
        var child = e2.target;
        while (child && child.parentNode !== $parent[0]) {
          child = child.parentNode;
        }
        e2.currentTarget = child;
        return fn3.apply(this, [e2]);
      });
    };
    var getInputSelection = function(input) {
      var result = {};
      if (input === void 0) {
        console.warn("WARN getInputSelection cannot locate input control");
        return result;
      }
      if ("selectionStart" in input) {
        result.start = input.selectionStart;
        result.length = input.selectionEnd - result.start;
      } else if (document.selection) {
        input.focus();
        var sel = document.selection.createRange();
        var selLen = document.selection.createRange().text.length;
        sel.moveStart("character", -input.value.length);
        result.start = sel.text.length - selLen;
        result.length = selLen;
      }
      return result;
    };
    var transferStyles = function($from, $to, properties) {
      var i, n2, styles2 = {};
      if (properties) {
        for (i = 0, n2 = properties.length; i < n2; i++) {
          styles2[properties[i]] = $from.css(properties[i]);
        }
      } else {
        styles2 = $from.css();
      }
      $to.css(styles2);
    };
    var measureString = function(str2, $parent) {
      if (!str2) {
        return 0;
      }
      if (!Selectize.$testInput) {
        Selectize.$testInput = $2("<span />").css({
          position: "absolute",
          width: "auto",
          padding: 0,
          whiteSpace: "pre"
        });
        $2("<div />").css({
          position: "absolute",
          width: 0,
          height: 0,
          overflow: "hidden"
        }).append(Selectize.$testInput).appendTo("body");
      }
      Selectize.$testInput.text(str2);
      transferStyles($parent, Selectize.$testInput, [
        "letterSpacing",
        "fontSize",
        "fontFamily",
        "fontWeight",
        "textTransform"
      ]);
      return Selectize.$testInput.width();
    };
    var autoGrow = function($input) {
      var currentWidth = null;
      var update2 = function(e2, options) {
        var value, keyCode, printable, width;
        var placeholder, placeholderWidth;
        var shift, character, selection;
        e2 = e2 || window.event || {};
        options = options || {};
        if (e2.metaKey || e2.altKey)
          return;
        if (!options.force && $input.data("grow") === false)
          return;
        value = $input.val();
        if (e2.type && e2.type.toLowerCase() === "keydown") {
          keyCode = e2.keyCode;
          printable = keyCode >= 48 && keyCode <= 57 || // 0-9
          keyCode >= 65 && keyCode <= 90 || // a-z
          keyCode >= 96 && keyCode <= 111 || // numpad 0-9, numeric operators
          keyCode >= 186 && keyCode <= 222 || // semicolon, equal, comma, dash, etc.
          keyCode === 32;
          if (keyCode === KEY_DELETE2 || keyCode === KEY_BACKSPACE2) {
            selection = getInputSelection($input[0]);
            if (selection.length) {
              value = value.substring(0, selection.start) + value.substring(selection.start + selection.length);
            } else if (keyCode === KEY_BACKSPACE2 && selection.start) {
              value = value.substring(0, selection.start - 1) + value.substring(selection.start + 1);
            } else if (keyCode === KEY_DELETE2 && typeof selection.start !== "undefined") {
              value = value.substring(0, selection.start) + value.substring(selection.start + 1);
            }
          } else if (printable) {
            shift = e2.shiftKey;
            character = String.fromCharCode(e2.keyCode);
            if (shift)
              character = character.toUpperCase();
            else
              character = character.toLowerCase();
            value += character;
          }
        }
        placeholder = $input.attr("placeholder");
        if (placeholder) {
          placeholderWidth = measureString(placeholder, $input) + 4;
        } else {
          placeholderWidth = 0;
        }
        width = Math.max(measureString(value, $input), placeholderWidth) + 4;
        if (width !== currentWidth) {
          currentWidth = width;
          $input.width(width);
          $input.triggerHandler("resize");
        }
      };
      $input.on("keydown keyup update blur", update2);
      update2();
    };
    var domToString = function(d2) {
      var tmp = document.createElement("div");
      tmp.appendChild(d2.cloneNode(true));
      return tmp.innerHTML;
    };
    var isJSON = function(data2) {
      try {
        JSON.parse(str);
      } catch (e2) {
        return false;
      }
      return true;
    };
    var Selectize = function($input, settings) {
      var i, n2, dir, input, self2 = this;
      input = $input[0];
      input.selectize = self2;
      var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
      dir = computedStyle ? computedStyle.getPropertyValue("direction") : input.currentStyle && input.currentStyle.direction;
      dir = dir || $input.parents("[dir]:first").attr("dir") || "";
      $2.extend(self2, {
        order: 0,
        settings,
        $input,
        tabIndex: $input.attr("tabindex") || "",
        tagType: input.tagName.toLowerCase() === "select" ? TAG_SELECT : TAG_INPUT,
        rtl: /rtl/i.test(dir),
        eventNS: ".selectize" + ++Selectize.count,
        highlightedValue: null,
        isBlurring: false,
        isOpen: false,
        isDisabled: false,
        isRequired: $input.is("[required]"),
        isInvalid: false,
        isLocked: false,
        isFocused: false,
        isInputHidden: false,
        isSetup: false,
        isShiftDown: false,
        isCmdDown: false,
        isCtrlDown: false,
        ignoreFocus: false,
        ignoreBlur: false,
        ignoreHover: false,
        hasOptions: false,
        currentResults: null,
        lastValue: "",
        lastValidValue: "",
        lastOpenTarget: false,
        caretPos: 0,
        loading: 0,
        loadedSearches: {},
        isDropdownClosing: false,
        $activeOption: null,
        $activeItems: [],
        optgroups: {},
        options: {},
        userOptions: {},
        items: [],
        renderCache: {},
        onSearchChange: settings.loadThrottle === null ? self2.onSearchChange : debounce2(self2.onSearchChange, settings.loadThrottle)
      });
      self2.sifter = new Sifter2(this.options, { diacritics: settings.diacritics });
      if (self2.settings.options) {
        for (i = 0, n2 = self2.settings.options.length; i < n2; i++) {
          self2.registerOption(self2.settings.options[i]);
        }
        delete self2.settings.options;
      }
      if (self2.settings.optgroups) {
        for (i = 0, n2 = self2.settings.optgroups.length; i < n2; i++) {
          self2.registerOptionGroup(self2.settings.optgroups[i]);
        }
        delete self2.settings.optgroups;
      }
      self2.settings.mode = self2.settings.mode || (self2.settings.maxItems === 1 ? "single" : "multi");
      if (typeof self2.settings.hideSelected !== "boolean") {
        self2.settings.hideSelected = self2.settings.mode === "multi";
      }
      self2.initializePlugins(self2.settings.plugins);
      self2.setupCallbacks();
      self2.setupTemplates();
      self2.setup();
    };
    MicroEvent2.mixin(Selectize);
    MicroPlugin2.mixin(Selectize);
    $2.extend(Selectize.prototype, {
      /**
       * Creates all elements and sets up event bindings.
       */
      setup: function() {
        var self2 = this;
        var settings = self2.settings;
        var eventNS = self2.eventNS;
        var $window = $2(window);
        var $document = $2(document);
        var $input = self2.$input;
        var $wrapper;
        var $control;
        var $control_input;
        var $dropdown;
        var $dropdown_content;
        var $dropdown_parent;
        var inputMode;
        var classes;
        var classes_plugins;
        var inputId;
        inputMode = self2.settings.mode;
        classes = $input.attr("class") || "";
        $wrapper = $2("<div>").addClass(settings.wrapperClass).addClass(classes + " selectize-control").addClass(inputMode);
        $control = $2("<div>").addClass(settings.inputClass + " selectize-input items").appendTo($wrapper);
        $control_input = $2('<input type="select-one" autocomplete="new-password" autofill="no" />').appendTo($control).attr("tabindex", $input.is(":disabled") ? "-1" : self2.tabIndex);
        $dropdown_parent = $2(settings.dropdownParent || $wrapper);
        $dropdown = $2("<div>").addClass(settings.dropdownClass).addClass(inputMode + " selectize-dropdown").hide().appendTo($dropdown_parent);
        $dropdown_content = $2("<div>").addClass(settings.dropdownContentClass + " selectize-dropdown-content").attr("tabindex", "-1").appendTo($dropdown);
        if (inputId = $input.attr("id")) {
          $control_input.attr("id", inputId + "-selectized");
          $2("label[for='" + inputId + "']").attr("for", inputId + "-selectized");
        }
        if (self2.settings.copyClassesToDropdown) {
          $dropdown.addClass(classes);
        }
        $wrapper.css({
          width: $input[0].style.width
        });
        if (self2.plugins.names.length) {
          classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
          $wrapper.addClass(classes_plugins);
          $dropdown.addClass(classes_plugins);
        }
        if ((settings.maxItems === null || settings.maxItems > 1) && self2.tagType === TAG_SELECT) {
          $input.attr("multiple", "multiple");
        }
        if (self2.settings.placeholder) {
          $control_input.attr("placeholder", settings.placeholder);
        }
        if (!self2.settings.search) {
          $control_input.attr("readonly", true);
          $control_input.attr("inputmode", "none");
          $control.css("cursor", "pointer");
        }
        if (!self2.settings.splitOn && self2.settings.delimiter) {
          var delimiterEscaped = self2.settings.delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
          self2.settings.splitOn = new RegExp("\\s*" + delimiterEscaped + "+\\s*");
        }
        if ($input.attr("autocorrect")) {
          $control_input.attr("autocorrect", $input.attr("autocorrect"));
        }
        if ($input.attr("autocapitalize")) {
          $control_input.attr("autocapitalize", $input.attr("autocapitalize"));
        }
        if ($input.is("input")) {
          $control_input[0].type = $input[0].type;
        }
        self2.$wrapper = $wrapper;
        self2.$control = $control;
        self2.$control_input = $control_input;
        self2.$dropdown = $dropdown;
        self2.$dropdown_content = $dropdown_content;
        $dropdown.on("mouseenter mousedown mouseup click", "[data-disabled]>[data-selectable]", function(e2) {
          e2.stopImmediatePropagation();
        });
        $dropdown.on("mouseenter", "[data-selectable]", function() {
          return self2.onOptionHover.apply(self2, arguments);
        });
        $dropdown.on("mouseup click", "[data-selectable]", function() {
          return self2.onOptionSelect.apply(self2, arguments);
        });
        watchChildEvent($control, "mouseup", "*:not(input)", function() {
          return self2.onItemSelect.apply(self2, arguments);
        });
        autoGrow($control_input);
        $control.on({
          mousedown: function() {
            return self2.onMouseDown.apply(self2, arguments);
          },
          click: function() {
            return self2.onClick.apply(self2, arguments);
          }
        });
        $control_input.on({
          mousedown: function(e2) {
            if (self2.$control_input.val() !== "" || self2.settings.openOnFocus) {
              e2.stopPropagation();
            }
          },
          keydown: function() {
            return self2.onKeyDown.apply(self2, arguments);
          },
          keypress: function() {
            return self2.onKeyPress.apply(self2, arguments);
          },
          input: function() {
            return self2.onInput.apply(self2, arguments);
          },
          resize: function() {
            self2.positionDropdown.apply(self2, []);
          },
          // blur      : function() { return self.onBlur.apply(self, arguments); },
          focus: function() {
            self2.ignoreBlur = false;
            return self2.onFocus.apply(self2, arguments);
          },
          paste: function() {
            return self2.onPaste.apply(self2, arguments);
          }
        });
        $document.on("keydown" + eventNS, function(e2) {
          self2.isCmdDown = e2[IS_MAC2 ? "metaKey" : "ctrlKey"];
          self2.isCtrlDown = e2[IS_MAC2 ? "altKey" : "ctrlKey"];
          self2.isShiftDown = e2.shiftKey;
        });
        $document.on("keyup" + eventNS, function(e2) {
          if (e2.keyCode === KEY_CTRL)
            self2.isCtrlDown = false;
          if (e2.keyCode === KEY_SHIFT)
            self2.isShiftDown = false;
          if (e2.keyCode === KEY_CMD)
            self2.isCmdDown = false;
        });
        $document.on("mousedown" + eventNS, function(e2) {
          if (self2.isFocused) {
            if (e2.target === self2.$dropdown[0] || e2.target.parentNode === self2.$dropdown[0]) {
              return false;
            }
            if (!self2.$dropdown.has(e2.target).length && e2.target !== self2.$control[0]) {
              self2.blur(e2.target);
            }
          }
        });
        $window.on(["scroll" + eventNS, "resize" + eventNS].join(" "), function() {
          if (self2.isOpen) {
            self2.positionDropdown.apply(self2, arguments);
          }
        });
        $window.on("mousemove" + eventNS, function() {
          self2.ignoreHover = self2.settings.ignoreHover;
        });
        var inputPlaceholder = $2("<div></div>");
        var inputChildren = $input.children().detach();
        $input.replaceWith(inputPlaceholder);
        inputPlaceholder.replaceWith($input);
        this.revertSettings = {
          $children: inputChildren,
          tabindex: $input.attr("tabindex")
        };
        $input.attr("tabindex", -1).hide().after(self2.$wrapper);
        if (Array.isArray(settings.items)) {
          self2.lastValidValue = settings.items;
          self2.setValue(settings.items);
          delete settings.items;
        }
        if (SUPPORTS_VALIDITY_API) {
          $input.on("invalid" + eventNS, function(e2) {
            e2.preventDefault();
            self2.isInvalid = true;
            self2.refreshState();
          });
        }
        self2.updateOriginalInput();
        self2.refreshItems();
        self2.refreshState();
        self2.updatePlaceholder();
        self2.isSetup = true;
        if ($input.is(":disabled")) {
          self2.disable();
        }
        self2.on("change", this.onChange);
        $input.data("selectize", self2);
        $input.addClass("selectized");
        self2.trigger("initialize");
        if (settings.preload === true) {
          self2.onSearchChange("");
        }
      },
      /**
       * Sets up default rendering functions.
       */
      setupTemplates: function() {
        var self2 = this;
        var field_label = self2.settings.labelField;
        var field_value = self2.settings.valueField;
        var field_optgroup = self2.settings.optgroupLabelField;
        var templates = {
          "optgroup": function(data2) {
            return '<div class="optgroup">' + data2.html + "</div>";
          },
          "optgroup_header": function(data2, escape) {
            return '<div class="optgroup-header">' + escape(data2[field_optgroup]) + "</div>";
          },
          "option": function(data2, escape) {
            var classes = data2.classes ? " " + data2.classes : "";
            classes += data2[field_value] === "" ? " selectize-dropdown-emptyoptionlabel" : "";
            var styles2 = data2.styles ? ' style="' + data2.styles + '"' : "";
            return "<div" + styles2 + ' class="option' + classes + '">' + escape(data2[field_label]) + "</div>";
          },
          "item": function(data2, escape) {
            return '<div class="item">' + escape(data2[field_label]) + "</div>";
          },
          "option_create": function(data2, escape) {
            return '<div class="create">Add <strong>' + escape(data2.input) + "</strong>&#x2026;</div>";
          }
        };
        self2.settings.render = $2.extend({}, templates, self2.settings.render);
      },
      /**
       * Maps fired events to callbacks provided
       * in the settings used when creating the control.
       */
      setupCallbacks: function() {
        var key, fn3, callbacks = {
          "initialize": "onInitialize",
          "change": "onChange",
          "item_add": "onItemAdd",
          "item_remove": "onItemRemove",
          "clear": "onClear",
          "option_add": "onOptionAdd",
          "option_remove": "onOptionRemove",
          "option_clear": "onOptionClear",
          "optgroup_add": "onOptionGroupAdd",
          "optgroup_remove": "onOptionGroupRemove",
          "optgroup_clear": "onOptionGroupClear",
          "dropdown_open": "onDropdownOpen",
          "dropdown_close": "onDropdownClose",
          "type": "onType",
          "load": "onLoad",
          "focus": "onFocus",
          "blur": "onBlur",
          "dropdown_item_activate": "onDropdownItemActivate",
          "dropdown_item_deactivate": "onDropdownItemDeactivate"
        };
        for (key in callbacks) {
          if (callbacks.hasOwnProperty(key)) {
            fn3 = this.settings[callbacks[key]];
            if (fn3)
              this.on(key, fn3);
          }
        }
      },
      /**
       * Triggered when the main control element
       * has a click event.
       *
       * @param {PointerEvent} e
       * @return {boolean}
       */
      onClick: function(e2) {
        var self2 = this;
        if (self2.isDropdownClosing) {
          return;
        }
        if (!self2.isFocused || !self2.isOpen) {
          self2.focus();
          e2.preventDefault();
        }
      },
      /**
       * Triggered when the main control element
       * has a mouse down event.
       *
       * @param {object} e
       * @return {boolean}
       */
      onMouseDown: function(e2) {
        var self2 = this;
        var defaultPrevented = e2.isDefaultPrevented();
        $2(e2.target);
        if (!self2.isFocused) {
          if (!defaultPrevented) {
            window.setTimeout(function() {
              self2.focus();
            }, 0);
          }
        }
        if (e2.target !== self2.$control_input[0] || self2.$control_input.val() === "") {
          if (self2.settings.mode === "single") {
            self2.isOpen ? self2.close() : self2.open();
          } else {
            if (!defaultPrevented) {
              self2.setActiveItem(null);
            }
            if (!self2.settings.openOnFocus) {
              if (self2.isOpen && e2.target === self2.lastOpenTarget) {
                self2.close();
                self2.lastOpenTarget = false;
              } else if (!self2.isOpen) {
                self2.refreshOptions();
                self2.open();
                self2.lastOpenTarget = e2.target;
              } else {
                self2.lastOpenTarget = e2.target;
              }
            }
          }
          return false;
        }
      },
      /**
       * Triggered when the value of the control has been changed.
       * This should propagate the event to the original DOM
       * input / select element.
       */
      onChange: function() {
        var self2 = this;
        if (self2.getValue() !== "") {
          self2.lastValidValue = self2.getValue();
        }
        this.$input.trigger("input");
        this.$input.trigger("change");
      },
      /**
       * Triggered on <input> paste.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onPaste: function(e2) {
        var self2 = this;
        if (self2.isFull() || self2.isInputHidden || self2.isLocked) {
          e2.preventDefault();
          return;
        }
        if (self2.settings.splitOn) {
          setTimeout(function() {
            var pastedText = self2.$control_input.val();
            if (!pastedText.match(self2.settings.splitOn)) {
              return;
            }
            var splitInput = pastedText.trim().split(self2.settings.splitOn);
            for (var i = 0, n2 = splitInput.length; i < n2; i++) {
              self2.createItem(splitInput[i]);
            }
          }, 0);
        }
      },
      /**
       * Triggered on <input> keypress.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onKeyPress: function(e2) {
        if (this.isLocked)
          return e2 && e2.preventDefault();
        var character = String.fromCharCode(e2.keyCode || e2.which);
        if (this.settings.create && this.settings.mode === "multi" && character === this.settings.delimiter) {
          this.createItem();
          e2.preventDefault();
          return false;
        }
      },
      /**
       * Triggered on <input> keydown.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onKeyDown: function(e2) {
        e2.target === this.$control_input[0];
        var self2 = this;
        if (self2.isLocked) {
          if (e2.keyCode !== KEY_TAB2) {
            e2.preventDefault();
          }
          return;
        }
        switch (e2.keyCode) {
          case KEY_A2:
            if (self2.isCmdDown) {
              self2.selectAll();
              return;
            }
            break;
          case KEY_ESC2:
            if (self2.isOpen) {
              e2.preventDefault();
              e2.stopPropagation();
              self2.close();
            }
            return;
          case KEY_N:
            if (!e2.ctrlKey || e2.altKey)
              break;
          case KEY_DOWN2:
            if (!self2.isOpen && self2.hasOptions) {
              self2.open();
            } else if (self2.$activeOption) {
              self2.ignoreHover = true;
              var $next = self2.getAdjacentOption(self2.$activeOption, 1);
              if ($next.length)
                self2.setActiveOption($next, true, true);
            }
            e2.preventDefault();
            return;
          case KEY_P:
            if (!e2.ctrlKey || e2.altKey)
              break;
          case KEY_UP2:
            if (self2.$activeOption) {
              self2.ignoreHover = true;
              var $prev = self2.getAdjacentOption(self2.$activeOption, -1);
              if ($prev.length)
                self2.setActiveOption($prev, true, true);
            }
            e2.preventDefault();
            return;
          case KEY_RETURN2:
            if (self2.isOpen && self2.$activeOption) {
              self2.onOptionSelect({ currentTarget: self2.$activeOption });
              e2.preventDefault();
            }
            return;
          case KEY_LEFT2:
            self2.advanceSelection(-1, e2);
            return;
          case KEY_RIGHT2:
            self2.advanceSelection(1, e2);
            return;
          case KEY_TAB2:
            if (self2.settings.selectOnTab && self2.isOpen && self2.$activeOption) {
              self2.onOptionSelect({ currentTarget: self2.$activeOption });
              if (!self2.isFull()) {
                e2.preventDefault();
              }
            }
            if (self2.settings.create && self2.createItem() && self2.settings.showAddOptionOnCreate) {
              e2.preventDefault();
            }
            return;
          case KEY_BACKSPACE2:
          case KEY_DELETE2:
            self2.deleteSelection(e2);
            return;
        }
        if ((self2.isFull() || self2.isInputHidden) && !(IS_MAC2 ? e2.metaKey : e2.ctrlKey)) {
          e2.preventDefault();
          return;
        }
      },
      /**
       * Triggered on <input> input.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onInput: function(e2) {
        var self2 = this;
        var value = self2.$control_input.val() || "";
        if (self2.lastValue !== value) {
          self2.lastValue = value;
          self2.onSearchChange(value);
          self2.refreshOptions();
          self2.trigger("type", value);
        }
      },
      /**
       * Invokes the user-provide option provider / loader.
       *
       * Note: this function is debounced in the Selectize
       * constructor (by `settings.loadThrottle` milliseconds)
       *
       * @param {string} value
       */
      onSearchChange: function(value) {
        var self2 = this;
        var fn3 = self2.settings.load;
        if (!fn3)
          return;
        if (self2.loadedSearches.hasOwnProperty(value))
          return;
        self2.loadedSearches[value] = true;
        self2.load(function(callback) {
          fn3.apply(self2, [value, callback]);
        });
      },
      /**
       * Triggered on <input> focus.
       *
       * @param {FocusEvent} e (optional)
       * @returns {boolean}
       */
      onFocus: function(e2) {
        var self2 = this;
        var wasFocused = self2.isFocused;
        if (self2.isDisabled) {
          self2.blur();
          e2 && e2.preventDefault();
          return false;
        }
        if (self2.ignoreFocus)
          return;
        self2.isFocused = true;
        if (self2.settings.preload === "focus")
          self2.onSearchChange("");
        if (!wasFocused)
          self2.trigger("focus");
        if (!self2.$activeItems.length) {
          self2.showInput();
          self2.setActiveItem(null);
          self2.refreshOptions(!!self2.settings.openOnFocus);
        }
        self2.refreshState();
      },
      /**
       * Triggered on <input> blur.
       *
       * @param {object} e
       * @param {Element} dest
       */
      onBlur: function(e2, dest) {
        var self2 = this;
        if (!self2.isFocused)
          return;
        self2.isFocused = false;
        if (self2.ignoreFocus) {
          return;
        }
        var deactivate = function() {
          self2.close();
          self2.setTextboxValue("");
          self2.setActiveItem(null);
          self2.setActiveOption(null);
          self2.setCaret(self2.items.length);
          self2.refreshState();
          dest && dest.focus && dest.focus();
          self2.isBlurring = false;
          self2.ignoreFocus = false;
          self2.trigger("blur");
        };
        self2.isBlurring = true;
        self2.ignoreFocus = true;
        if (self2.settings.create && self2.settings.createOnBlur) {
          self2.createItem(null, false, deactivate);
        } else {
          deactivate();
        }
      },
      /**
       * Triggered when the user rolls over
       * an option in the autocomplete dropdown menu.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onOptionHover: function(e2) {
        if (this.ignoreHover)
          return;
        this.setActiveOption(e2.currentTarget, false);
      },
      /**
       * Triggered when the user clicks on an option
       * in the autocomplete dropdown menu.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onOptionSelect: function(e2) {
        var value, $target, self2 = this;
        if (e2.preventDefault) {
          e2.preventDefault();
          e2.stopPropagation();
        }
        $target = $2(e2.currentTarget);
        if ($target.hasClass("create")) {
          self2.createItem(null, function() {
            if (self2.settings.closeAfterSelect) {
              self2.close();
            }
          });
        } else {
          value = $target.attr("data-value");
          if (typeof value !== "undefined") {
            self2.lastQuery = null;
            self2.setTextboxValue("");
            self2.addItem(value);
            if (self2.settings.closeAfterSelect) {
              self2.close();
            } else if (!self2.settings.hideSelected && e2.type && /mouse/.test(e2.type)) {
              self2.setActiveOption(self2.getOption(value));
            }
          }
        }
      },
      /**
       * Triggered when the user clicks on an item
       * that has been selected.
       *
       * @param {object} e
       * @returns {boolean}
       */
      onItemSelect: function(e2) {
        var self2 = this;
        if (self2.isLocked)
          return;
        if (self2.settings.mode === "multi") {
          e2.preventDefault();
          self2.setActiveItem(e2.currentTarget, e2);
        }
      },
      /**
       * Invokes the provided method that provides
       * results to a callback---which are then added
       * as options to the control.
       *
       * @param {function} fn
       */
      load: function(fn3) {
        var self2 = this;
        var $wrapper = self2.$wrapper.addClass(self2.settings.loadingClass);
        self2.loading++;
        fn3.apply(self2, [function(results) {
          self2.loading = Math.max(self2.loading - 1, 0);
          if (results && results.length) {
            self2.addOption(results);
            self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
          }
          if (!self2.loading) {
            $wrapper.removeClass(self2.settings.loadingClass);
          }
          self2.trigger("load", results);
        }]);
      },
      /**
       * Gets the value of input field of the control.
       *
       * @returns {string} value
       */
      getTextboxValue: function() {
        var $input = this.$control_input;
        return $input.val();
      },
      /**
       * Sets the input field of the control to the specified value.
       *
       * @param {string} value
       */
      setTextboxValue: function(value) {
        var $input = this.$control_input;
        var changed = $input.val() !== value;
        if (changed) {
          $input.val(value).triggerHandler("update");
          this.lastValue = value;
        }
      },
      /**
       * Returns the value of the control. If multiple items
       * can be selected (e.g. <select multiple>), this returns
       * an array. If only one item can be selected, this
       * returns a string.
       *
       * @returns {mixed}
       */
      getValue: function() {
        if (this.tagType === TAG_SELECT && this.$input.attr("multiple")) {
          return this.items;
        } else {
          return this.items.join(this.settings.delimiter);
        }
      },
      /**
       * Resets the selected items to the given value.
       *
       * @param {Array<String|Number>} value
       */
      setValue: function(value, silent) {
        const items = Array.isArray(value) ? value : [value];
        if (items.join("") === this.items.join("")) {
          return;
        }
        var events = silent ? [] : ["change"];
        debounce_events2(this, events, function() {
          this.clear(silent);
          this.addItems(value, silent);
        });
      },
      /**
       * Resets the number of max items to the given value
       *
       * @param {number} value
       */
      setMaxItems: function(value) {
        if (value === 0)
          value = null;
        this.settings.maxItems = value;
        this.settings.mode = this.settings.mode || (this.settings.maxItems === 1 ? "single" : "multi");
        this.refreshState();
      },
      /**
       * Sets the selected item.
       *
       * @param {object} $item
       * @param {object} e (optional)
       */
      setActiveItem: function($item, e2) {
        var self2 = this;
        var eventName;
        var i, idx, begin, end2, item2, swap;
        var $last;
        if (self2.settings.mode === "single")
          return;
        $item = $2($item);
        if (!$item.length) {
          $2(self2.$activeItems).removeClass("active");
          self2.$activeItems = [];
          if (self2.isFocused) {
            self2.showInput();
          }
          return;
        }
        eventName = e2 && e2.type.toLowerCase();
        if (eventName === "mousedown" && self2.isShiftDown && self2.$activeItems.length) {
          $last = self2.$control.children(".active:last");
          begin = Array.prototype.indexOf.apply(self2.$control[0].childNodes, [$last[0]]);
          end2 = Array.prototype.indexOf.apply(self2.$control[0].childNodes, [$item[0]]);
          if (begin > end2) {
            swap = begin;
            begin = end2;
            end2 = swap;
          }
          for (i = begin; i <= end2; i++) {
            item2 = self2.$control[0].childNodes[i];
            if (self2.$activeItems.indexOf(item2) === -1) {
              $2(item2).addClass("active");
              self2.$activeItems.push(item2);
            }
          }
          e2.preventDefault();
        } else if (eventName === "mousedown" && self2.isCtrlDown || eventName === "keydown" && this.isShiftDown) {
          if ($item.hasClass("active")) {
            idx = self2.$activeItems.indexOf($item[0]);
            self2.$activeItems.splice(idx, 1);
            $item.removeClass("active");
          } else {
            self2.$activeItems.push($item.addClass("active")[0]);
          }
        } else {
          $2(self2.$activeItems).removeClass("active");
          self2.$activeItems = [$item.addClass("active")[0]];
        }
        self2.hideInput();
        if (!this.isFocused) {
          self2.focus();
        }
      },
      /**
       * Sets the selected item in the dropdown menu
       * of available options.
       *
       * @param {object} $object
       * @param {boolean} scroll
       * @param {boolean} animate
       */
      setActiveOption: function($option, scroll, animate) {
        var height_menu, height_item, y2;
        var scroll_top, scroll_bottom;
        var self2 = this;
        if (self2.$activeOption) {
          self2.$activeOption.removeClass("active");
          self2.trigger("dropdown_item_deactivate", self2.$activeOption.attr("data-value"));
        }
        self2.$activeOption = null;
        $option = $2($option);
        if (!$option.length)
          return;
        self2.$activeOption = $option.addClass("active");
        if (self2.isOpen)
          self2.trigger("dropdown_item_activate", self2.$activeOption.attr("data-value"));
        if (scroll || !isset(scroll)) {
          height_menu = self2.$dropdown_content.height();
          height_item = self2.$activeOption.outerHeight(true);
          scroll = self2.$dropdown_content.scrollTop() || 0;
          y2 = self2.$activeOption.offset().top - self2.$dropdown_content.offset().top + scroll;
          scroll_top = y2;
          scroll_bottom = y2 - height_menu + height_item;
          if (y2 + height_item > height_menu + scroll) {
            self2.$dropdown_content.stop().animate({ scrollTop: scroll_bottom }, animate ? self2.settings.scrollDuration : 0);
          } else if (y2 < scroll) {
            self2.$dropdown_content.stop().animate({ scrollTop: scroll_top }, animate ? self2.settings.scrollDuration : 0);
          }
        }
      },
      /**
       * Selects all items (CTRL + A).
       */
      selectAll: function() {
        var self2 = this;
        if (self2.settings.mode === "single")
          return;
        self2.$activeItems = Array.prototype.slice.apply(self2.$control.children(":not(input)").addClass("active"));
        if (self2.$activeItems.length) {
          self2.hideInput();
          self2.close();
        }
        self2.focus();
      },
      /**
       * Hides the input element out of view, while
       * retaining its focus.
       */
      hideInput: function() {
        var self2 = this;
        self2.setTextboxValue("");
        self2.$control_input.css({ opacity: 0, position: "absolute", left: self2.rtl ? 1e4 : 0 });
        self2.isInputHidden = true;
      },
      /**
       * Restores input visibility.
       */
      showInput: function() {
        this.$control_input.css({ opacity: 1, position: "relative", left: 0 });
        this.isInputHidden = false;
      },
      /**
       * Gives the control focus.
       */
      focus: function() {
        var self2 = this;
        if (self2.isDisabled)
          return self2;
        self2.ignoreFocus = true;
        self2.$control_input[0].focus();
        window.setTimeout(function() {
          self2.ignoreFocus = false;
          self2.onFocus();
        }, 0);
        return self2;
      },
      /**
       * Forces the control out of focus.
       *
       * @param {Element} dest
       */
      blur: function(dest) {
        this.$control_input[0].blur();
        this.onBlur(null, dest);
        return this;
      },
      /**
       * Returns a function that scores an object
       * to show how good of a match it is to the
       * provided query.
       *
       * @param {string} query
       * @param {object} options
       * @return {function}
       */
      getScoreFunction: function(query) {
        return this.sifter.getScoreFunction(query, this.getSearchOptions());
      },
      /**
       * Returns search options for sifter (the system
       * for scoring and sorting results).
       *
       * @see https://github.com/brianreavis/sifter.js
       * @return {object}
       */
      getSearchOptions: function() {
        var settings = this.settings;
        var sort = settings.sortField;
        if (typeof sort === "string") {
          sort = [{ field: sort }];
        }
        return {
          fields: settings.searchField,
          conjunction: settings.searchConjunction,
          sort,
          nesting: settings.nesting,
          filter: settings.filter,
          respect_word_boundaries: settings.respect_word_boundaries
        };
      },
      /**
       * Searches through available options and returns
       * a sorted array of matches.
       *
       * Returns an object containing:
       *
       *   - query {string}
       *   - tokens {array}
       *   - total {int}
       *   - items {array}
       *
       * @param {string} query
       * @returns {object}
       */
      search: function(query) {
        var i, result, calculateScore;
        var self2 = this;
        var settings = self2.settings;
        var options = this.getSearchOptions();
        if (settings.score) {
          calculateScore = self2.settings.score.apply(this, [query]);
          if (typeof calculateScore !== "function") {
            throw new Error('Selectize "score" setting must be a function that returns a function');
          }
        }
        if (query !== self2.lastQuery) {
          if (settings.normalize)
            query = query.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
          self2.lastQuery = query;
          result = self2.sifter.search(query, $2.extend(options, { score: calculateScore }));
          self2.currentResults = result;
        } else {
          result = $2.extend(true, {}, self2.currentResults);
        }
        if (settings.hideSelected) {
          for (i = result.items.length - 1; i >= 0; i--) {
            if (self2.items.indexOf(hash_key2(result.items[i].id)) !== -1) {
              result.items.splice(i, 1);
            }
          }
        }
        return result;
      },
      /**
       * Refreshes the list of available options shown
       * in the autocomplete dropdown menu.
       *
       * @param {boolean} triggerDropdown
       */
      refreshOptions: function(triggerDropdown) {
        var i, j2, k2, n2, groups, groups_order, option2, option_html, optgroup, optgroups, html, html_children, has_create_option;
        var $active, $active_before, $create;
        if (typeof triggerDropdown === "undefined") {
          triggerDropdown = true;
        }
        var self2 = this;
        var query = self2.$control_input.val().trim();
        var results = self2.search(query);
        var $dropdown_content = self2.$dropdown_content;
        var active_before = self2.$activeOption && hash_key2(self2.$activeOption.attr("data-value"));
        n2 = results.items.length;
        if (typeof self2.settings.maxOptions === "number") {
          n2 = Math.min(n2, self2.settings.maxOptions);
        }
        groups = {};
        groups_order = [];
        for (i = 0; i < n2; i++) {
          option2 = self2.options[results.items[i].id];
          option_html = self2.render("option", option2);
          optgroup = option2[self2.settings.optgroupField] || "";
          optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
          for (j2 = 0, k2 = optgroups && optgroups.length; j2 < k2; j2++) {
            optgroup = optgroups[j2];
            if (!self2.optgroups.hasOwnProperty(optgroup) && typeof self2.settings.optionGroupRegister === "function") {
              var regGroup;
              if (regGroup = self2.settings.optionGroupRegister.apply(self2, [optgroup])) {
                self2.registerOptionGroup(regGroup);
              }
            }
            if (!self2.optgroups.hasOwnProperty(optgroup)) {
              optgroup = "";
            }
            if (!groups.hasOwnProperty(optgroup)) {
              groups[optgroup] = document.createDocumentFragment();
              groups_order.push(optgroup);
            }
            groups[optgroup].appendChild(option_html);
          }
        }
        if (this.settings.lockOptgroupOrder) {
          groups_order.sort(function(a2, b2) {
            var a_order = self2.optgroups[a2] && self2.optgroups[a2].$order || 0;
            var b_order = self2.optgroups[b2] && self2.optgroups[b2].$order || 0;
            return a_order - b_order;
          });
        }
        html = document.createDocumentFragment();
        for (i = 0, n2 = groups_order.length; i < n2; i++) {
          optgroup = groups_order[i];
          if (self2.optgroups.hasOwnProperty(optgroup) && groups[optgroup].childNodes.length) {
            html_children = document.createDocumentFragment();
            html_children.appendChild(self2.render("optgroup_header", self2.optgroups[optgroup]));
            html_children.appendChild(groups[optgroup]);
            html.appendChild(self2.render("optgroup", $2.extend({}, self2.optgroups[optgroup], {
              html: domToString(html_children),
              dom: html_children
            })));
          } else {
            html.appendChild(groups[optgroup]);
          }
        }
        $dropdown_content.html(html);
        if (self2.settings.highlight) {
          $dropdown_content.removeHighlight();
          if (results.query.length && results.tokens.length) {
            for (i = 0, n2 = results.tokens.length; i < n2; i++) {
              highlight2($dropdown_content, results.tokens[i].regex);
            }
          }
        }
        if (!self2.settings.hideSelected) {
          self2.$dropdown.find(".selected").removeClass("selected");
          for (i = 0, n2 = self2.items.length; i < n2; i++) {
            self2.getOption(self2.items[i]).addClass("selected");
          }
        }
        if (self2.settings.dropdownSize.sizeType !== "auto" && self2.isOpen) {
          self2.setupDropdownHeight();
        }
        has_create_option = self2.canCreate(query);
        if (has_create_option) {
          if (self2.settings.showAddOptionOnCreate) {
            $dropdown_content.prepend(self2.render("option_create", { input: query }));
            $create = $2($dropdown_content[0].childNodes[0]);
          }
        }
        self2.hasOptions = results.items.length > 0 || has_create_option && self2.settings.showAddOptionOnCreate || self2.settings.setFirstOptionActive;
        if (self2.hasOptions) {
          if (results.items.length > 0) {
            $active_before = active_before && self2.getOption(active_before);
            if (results.query !== "" && self2.settings.setFirstOptionActive) {
              $active = $dropdown_content.find("[data-selectable]:first");
            } else if (results.query !== "" && $active_before && $active_before.length) {
              $active = $active_before;
            } else if (self2.settings.mode === "single" && self2.items.length) {
              $active = self2.getOption(self2.items[0]);
            }
            if (!$active || !$active.length) {
              if ($create && !self2.settings.addPrecedence) {
                $active = self2.getAdjacentOption($create, 1);
              } else {
                $active = $dropdown_content.find("[data-selectable]:first");
              }
            }
          } else {
            $active = $create;
          }
          self2.setActiveOption($active);
          if (triggerDropdown && !self2.isOpen) {
            self2.open();
          }
        } else {
          self2.setActiveOption(null);
          if (triggerDropdown && self2.isOpen) {
            self2.close();
          }
        }
      },
      /**
       * Adds an available option. If it already exists,
       * nothing will happen. Note: this does not refresh
       * the options list dropdown (use `refreshOptions`
       * for that).
       *
       * Usage:
       *
       *   this.addOption(data)
       *
       * @param {object|array} data
       */
      addOption: function(data2) {
        var i, n2, value, self2 = this;
        if (Array.isArray(data2)) {
          for (i = 0, n2 = data2.length; i < n2; i++) {
            self2.addOption(data2[i]);
          }
          return;
        }
        if (value = self2.registerOption(data2)) {
          self2.userOptions[value] = true;
          self2.lastQuery = null;
          self2.trigger("option_add", value, data2);
        }
      },
      /**
       * Registers an option to the pool of options.
       *
       * @param {object} data
       * @return {boolean|string}
       */
      registerOption: function(data2) {
        var key = hash_key2(data2[this.settings.valueField]);
        if (typeof key === "undefined" || key === null || this.options.hasOwnProperty(key))
          return false;
        data2.$order = data2.$order || ++this.order;
        this.options[key] = data2;
        return key;
      },
      /**
       * Registers an option group to the pool of option groups.
       *
       * @param {object} data
       * @return {boolean|string}
       */
      registerOptionGroup: function(data2) {
        var key = hash_key2(data2[this.settings.optgroupValueField]);
        if (!key)
          return false;
        data2.$order = data2.$order || ++this.order;
        this.optgroups[key] = data2;
        return key;
      },
      /**
       * Registers a new optgroup for options
       * to be bucketed into.
       *
       * @param {string} id
       * @param {object} data
       */
      addOptionGroup: function(id, data2) {
        data2[this.settings.optgroupValueField] = id;
        if (id = this.registerOptionGroup(data2)) {
          this.trigger("optgroup_add", id, data2);
        }
      },
      /**
       * Removes an existing option group.
       *
       * @param {string} id
       */
      removeOptionGroup: function(id) {
        if (this.optgroups.hasOwnProperty(id)) {
          delete this.optgroups[id];
          this.renderCache = {};
          this.trigger("optgroup_remove", id);
        }
      },
      /**
       * Clears all existing option groups.
       */
      clearOptionGroups: function() {
        this.optgroups = {};
        this.renderCache = {};
        this.trigger("optgroup_clear");
      },
      /**
       * Updates an option available for selection. If
       * it is visible in the selected items or options
       * dropdown, it will be re-rendered automatically.
       *
       * @param {string} value
       * @param {object} data
       */
      updateOption: function(value, data2) {
        var self2 = this;
        var $item, $item_new;
        var value_new, index_item, cache_items, cache_options, order_old;
        value = hash_key2(value);
        value_new = hash_key2(data2[self2.settings.valueField]);
        if (value === null)
          return;
        if (!self2.options.hasOwnProperty(value))
          return;
        if (typeof value_new !== "string")
          throw new Error("Value must be set in option data");
        order_old = self2.options[value].$order;
        if (value_new !== value) {
          delete self2.options[value];
          index_item = self2.items.indexOf(value);
          if (index_item !== -1) {
            self2.items.splice(index_item, 1, value_new);
          }
        }
        data2.$order = data2.$order || order_old;
        self2.options[value_new] = data2;
        cache_items = self2.renderCache["item"];
        cache_options = self2.renderCache["option"];
        if (cache_items) {
          delete cache_items[value];
          delete cache_items[value_new];
        }
        if (cache_options) {
          delete cache_options[value];
          delete cache_options[value_new];
        }
        if (self2.items.indexOf(value_new) !== -1) {
          $item = self2.getItem(value);
          $item_new = $2(self2.render("item", data2));
          if ($item.hasClass("active"))
            $item_new.addClass("active");
          $item.replaceWith($item_new);
        }
        self2.lastQuery = null;
        if (self2.isOpen) {
          self2.refreshOptions(false);
        }
      },
      /**
       * Removes a single option.
       *
       * @param {string} value
       * @param {boolean} silent
       */
      removeOption: function(value, silent) {
        var self2 = this;
        value = hash_key2(value);
        var cache_items = self2.renderCache["item"];
        var cache_options = self2.renderCache["option"];
        if (cache_items)
          delete cache_items[value];
        if (cache_options)
          delete cache_options[value];
        delete self2.userOptions[value];
        delete self2.options[value];
        self2.lastQuery = null;
        self2.trigger("option_remove", value);
        self2.removeItem(value, silent);
      },
      /**
       * Clears all options, including all selected items
       *
       * @param {boolean} silent
       */
      clearOptions: function(silent) {
        var self2 = this;
        self2.loadedSearches = {};
        self2.userOptions = {};
        self2.renderCache = {};
        var options = self2.options;
        $2.each(self2.options, function(key, value) {
          if (self2.items.indexOf(key) == -1) {
            delete options[key];
          }
        });
        self2.options = self2.sifter.items = options;
        self2.lastQuery = null;
        self2.trigger("option_clear");
        self2.clear(silent);
      },
      /**
       * Returns the jQuery element of the option
       * matching the given value.
       *
       * @param {string} value
       * @returns {object}
       */
      getOption: function(value) {
        return this.getElementWithValue(value, this.$dropdown_content.find("[data-selectable]"));
      },
      /**
       * Returns the jQuery element of the first
       * selectable option.
       *
       * @return {object}
       */
      getFirstOption: function() {
        var $options = this.$dropdown.find("[data-selectable]");
        return $options.length > 0 ? $options.eq(0) : $2();
      },
      /**
       * Returns the jQuery element of the next or
       * previous selectable option.
       *
       * @param {object} $option
       * @param {int} direction  can be 1 for next or -1 for previous
       * @return {object}
       */
      getAdjacentOption: function($option, direction) {
        var $options = this.$dropdown.find("[data-selectable]");
        var index = $options.index($option) + direction;
        return index >= 0 && index < $options.length ? $options.eq(index) : $2();
      },
      /**
       * Finds the first element with a "data-value" attribute
       * that matches the given value.
       *
       * @param {mixed} value
       * @param {object} $els
       * @return {object}
       */
      getElementWithValue: function(value, $els) {
        value = hash_key2(value);
        if (typeof value !== "undefined" && value !== null) {
          for (var i = 0, n2 = $els.length; i < n2; i++) {
            if ($els[i].getAttribute("data-value") === value) {
              return $2($els[i]);
            }
          }
        }
        return $2();
      },
      /**
       * Finds the first element with a "textContent" property
       * that matches the given textContent value.
       *
       * @param {mixed} textContent
       * @param {boolean} ignoreCase
       * @param {object} $els
       * @return {object}
       */
      getElementWithTextContent: function(textContent, ignoreCase, $els) {
        textContent = hash_key2(textContent);
        if (typeof textContent !== "undefined" && textContent !== null) {
          for (var i = 0, n2 = $els.length; i < n2; i++) {
            var eleTextContent = $els[i].textContent;
            if (ignoreCase == true) {
              eleTextContent = eleTextContent !== null ? eleTextContent.toLowerCase() : null;
              textContent = textContent.toLowerCase();
            }
            if (eleTextContent === textContent) {
              return $2($els[i]);
            }
          }
        }
        return $2();
      },
      /**
       * Returns the jQuery element of the item
       * matching the given value.
       *
       * @param {string} value
       * @returns {object}
       */
      getItem: function(value) {
        return this.getElementWithValue(value, this.$control.children());
      },
      /**
       * Returns the jQuery element of the item
       * matching the given textContent.
       *
       * @param {string} value
       * @param {boolean} ignoreCase
       * @returns {object}
       */
      getFirstItemMatchedByTextContent: function(textContent, ignoreCase) {
        ignoreCase = ignoreCase !== null && ignoreCase === true ? true : false;
        return this.getElementWithTextContent(textContent, ignoreCase, this.$dropdown_content.find("[data-selectable]"));
      },
      /**
       * "Selects" multiple items at once. Adds them to the list
       * at the current caret position.
       *
       * @param {string} values
       * @param {boolean} silent
       */
      addItems: function(values, silent) {
        this.buffer = document.createDocumentFragment();
        var childNodes = this.$control[0].childNodes;
        for (var i = 0; i < childNodes.length; i++) {
          this.buffer.appendChild(childNodes[i]);
        }
        var items = Array.isArray(values) ? values : [values];
        for (var i = 0, n2 = items.length; i < n2; i++) {
          this.isPending = i < n2 - 1;
          this.addItem(items[i], silent);
        }
        var control = this.$control[0];
        control.insertBefore(this.buffer, control.firstChild);
        this.buffer = null;
      },
      /**
       * "Selects" an item. Adds it to the list
       * at the current caret position.
       *
       * @param {string} value
       * @param {boolean} silent
       */
      addItem: function(value, silent) {
        var events = silent ? [] : ["change"];
        debounce_events2(this, events, function() {
          var $item, $option, $options;
          var self2 = this;
          var inputMode = self2.settings.mode;
          var value_next, wasFull;
          value = hash_key2(value);
          if (self2.items.indexOf(value) !== -1) {
            if (inputMode === "single")
              self2.close();
            return;
          }
          if (!self2.options.hasOwnProperty(value))
            return;
          if (inputMode === "single")
            self2.clear(silent);
          if (inputMode === "multi" && self2.isFull())
            return;
          $item = $2(self2.render("item", self2.options[value]));
          wasFull = self2.isFull();
          self2.items.splice(self2.caretPos, 0, value);
          self2.insertAtCaret($item);
          if (!self2.isPending || !wasFull && self2.isFull()) {
            self2.refreshState();
          }
          if (self2.isSetup) {
            $options = self2.$dropdown_content.find("[data-selectable]");
            if (!self2.isPending) {
              $option = self2.getOption(value);
              value_next = self2.getAdjacentOption($option, 1).attr("data-value");
              self2.refreshOptions(self2.isFocused && inputMode !== "single");
              if (value_next) {
                self2.setActiveOption(self2.getOption(value_next));
              }
            }
            if (!$options.length || self2.isFull()) {
              self2.close();
            } else if (!self2.isPending) {
              self2.positionDropdown();
            }
            self2.updatePlaceholder();
            self2.trigger("item_add", value, $item);
            if (!self2.isPending) {
              self2.updateOriginalInput({ silent });
            }
          }
        });
      },
      /**
       * Removes the selected item matching
       * the provided value.
       *
       * @param {string} value
       */
      removeItem: function(value, silent) {
        var self2 = this;
        var $item, i, idx;
        $item = value instanceof $2 ? value : self2.getItem(value);
        value = hash_key2($item.attr("data-value"));
        i = self2.items.indexOf(value);
        if (i !== -1) {
          self2.trigger("item_before_remove", value, $item);
          $item.remove();
          if ($item.hasClass("active")) {
            $item.removeClass("active");
            idx = self2.$activeItems.indexOf($item[0]);
            self2.$activeItems.splice(idx, 1);
            $item.removeClass("active");
          }
          self2.items.splice(i, 1);
          self2.lastQuery = null;
          if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
            self2.removeOption(value, silent);
          }
          if (i < self2.caretPos) {
            self2.setCaret(self2.caretPos - 1);
          }
          self2.refreshState();
          self2.updatePlaceholder();
          self2.updateOriginalInput({ silent });
          self2.positionDropdown();
          self2.trigger("item_remove", value, $item);
        }
      },
      /**
       * Invokes the `create` method provided in the
       * selectize options that should provide the data
       * for the new item, given the user input.
       *
       * Once this completes, it will be added
       * to the item list.
       *
       * @param {string} value
       * @param {boolean} [triggerDropdown]
       * @param {function} [callback]
       * @return {boolean}
       */
      createItem: function(input, triggerDropdown) {
        var self2 = this;
        var caret = self2.caretPos;
        input = input || (self2.$control_input.val() || "").trim();
        var callback = arguments[arguments.length - 1];
        if (typeof callback !== "function")
          callback = function() {
          };
        if (typeof triggerDropdown !== "boolean") {
          triggerDropdown = true;
        }
        if (!self2.canCreate(input)) {
          callback();
          return false;
        }
        self2.lock();
        var setup = typeof self2.settings.create === "function" ? this.settings.create : function(input2) {
          var data2 = {};
          data2[self2.settings.labelField] = input2;
          var key = input2;
          if (self2.settings.formatValueToKey && typeof self2.settings.formatValueToKey === "function") {
            key = self2.settings.formatValueToKey.apply(this, [key]);
            if (key === null || typeof key === "undefined" || typeof key === "object" || typeof key === "function") {
              throw new Error('Selectize "formatValueToKey" setting must be a function that returns a value other than object or function.');
            }
          }
          data2[self2.settings.valueField] = key;
          return data2;
        };
        var create2 = once2(function(data2) {
          self2.unlock();
          if (!data2 || typeof data2 !== "object")
            return callback();
          var value = hash_key2(data2[self2.settings.valueField]);
          if (typeof value !== "string")
            return callback();
          self2.setTextboxValue("");
          self2.addOption(data2);
          self2.setCaret(caret);
          self2.addItem(value);
          self2.refreshOptions(triggerDropdown && self2.settings.mode !== "single");
          callback(data2);
        });
        var output = setup.apply(this, [input, create2]);
        if (typeof output !== "undefined") {
          create2(output);
        }
        return true;
      },
      /**
       * Re-renders the selected item lists.
       */
      refreshItems: function(silent) {
        this.lastQuery = null;
        if (this.isSetup) {
          this.addItem(this.items, silent);
        }
        this.refreshState();
        this.updateOriginalInput({ silent });
      },
      /**
       * Updates all state-dependent attributes
       * and CSS classes.
       */
      refreshState: function() {
        this.refreshValidityState();
        this.refreshClasses();
      },
      /**
       * Update the `required` attribute of both input and control input.
       *
       * The `required` property needs to be activated on the control input
       * for the error to be displayed at the right place. `required` also
       * needs to be temporarily deactivated on the input since the input is
       * hidden and can't show errors.
       */
      refreshValidityState: function() {
        if (!this.isRequired)
          return false;
        var invalid = !this.items.length;
        this.isInvalid = invalid;
        this.$control_input.prop("required", invalid);
        this.$input.prop("required", !invalid);
      },
      /**
       * Updates all state-dependent CSS classes.
       */
      refreshClasses: function() {
        var self2 = this;
        var isFull = self2.isFull();
        var isLocked = self2.isLocked;
        self2.$wrapper.toggleClass("rtl", self2.rtl);
        self2.$control.toggleClass("focus", self2.isFocused).toggleClass("disabled", self2.isDisabled).toggleClass("required", self2.isRequired).toggleClass("invalid", self2.isInvalid).toggleClass("locked", isLocked).toggleClass("full", isFull).toggleClass("not-full", !isFull).toggleClass("input-active", self2.isFocused && !self2.isInputHidden).toggleClass("dropdown-active", self2.isOpen).toggleClass("has-options", !$2.isEmptyObject(self2.options)).toggleClass("has-items", self2.items.length > 0);
        self2.$control_input.data("grow", !isFull && !isLocked);
      },
      /**
       * Determines whether or not more items can be added
       * to the control without exceeding the user-defined maximum.
       *
       * @returns {boolean}
       */
      isFull: function() {
        return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
      },
      /**
       * Refreshes the original <select> or <input>
       * element to reflect the current state.
       */
      updateOriginalInput: function(opts) {
        var existing, fresh, old2, $options, label, values, self2 = this;
        opts = opts || {};
        if (self2.tagType === TAG_SELECT) {
          $options = self2.$input.find("option");
          existing = [];
          fresh = [];
          old2 = [];
          values = [];
          $options.get().forEach(function(option2) {
            existing.push(option2.value);
          });
          self2.items.forEach(function(item2) {
            label = self2.options[item2][self2.settings.labelField] || "";
            values.push(item2);
            if (existing.indexOf(item2) != -1) {
              return;
            }
            fresh.push('<option value="' + escape_html2(item2) + '" selected="selected">' + escape_html2(label) + "</option>");
          });
          old2 = existing.filter(function(value) {
            return values.indexOf(value) < 0;
          }).map(function(value) {
            return 'option[value="' + value + '"]';
          });
          if (existing.length - old2.length + fresh.length === 0 && !self2.$input.attr("multiple")) {
            fresh.push('<option value="" selected="selected"></option>');
          }
          self2.$input.find(old2.join(", ")).remove();
          self2.$input.append(fresh.join(""));
        } else {
          self2.$input.val(self2.getValue());
          self2.$input.attr("value", self2.$input.val());
        }
        if (self2.isSetup) {
          if (!opts.silent) {
            self2.trigger("change", self2.$input.val());
          }
        }
      },
      /**
       * Shows/hide the input placeholder depending
       * on if there items in the list already.
       */
      updatePlaceholder: function() {
        if (!this.settings.placeholder)
          return;
        var $input = this.$control_input;
        if (this.items.length) {
          $input.removeAttr("placeholder");
        } else {
          $input.attr("placeholder", this.settings.placeholder);
        }
        $input.triggerHandler("update", { force: true });
      },
      /**
       * Shows the autocomplete dropdown containing
       * the available options.
       */
      open: function() {
        var self2 = this;
        if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
          return;
        self2.focus();
        self2.isOpen = true;
        self2.refreshState();
        self2.$dropdown.css({ visibility: "hidden", display: "block" });
        self2.setupDropdownHeight();
        self2.positionDropdown();
        self2.$dropdown.css({ visibility: "visible" });
        self2.trigger("dropdown_open", self2.$dropdown);
      },
      /**
       * Closes the autocomplete dropdown menu.
       */
      close: function() {
        var self2 = this;
        var trigger = self2.isOpen;
        if (self2.settings.mode === "single" && self2.items.length) {
          self2.hideInput();
          if (self2.isBlurring) {
            self2.$control_input[0].blur();
          }
        }
        self2.isOpen = false;
        self2.$dropdown.hide();
        self2.setActiveOption(null);
        self2.refreshState();
        if (trigger)
          self2.trigger("dropdown_close", self2.$dropdown);
      },
      /**
       * Calculates and applies the appropriate
       * position of the dropdown.
       */
      positionDropdown: function() {
        var $control = this.$control;
        var offset2 = this.settings.dropdownParent === "body" ? $control.offset() : $control.position();
        offset2.top += $control.outerHeight(true);
        var w2 = $control[0].getBoundingClientRect().width;
        if (this.settings.minWidth && this.settings.minWidth > w2) {
          w2 = this.settings.minWidth;
        }
        this.$dropdown.css({
          width: w2,
          top: offset2.top,
          left: offset2.left
        });
      },
      setupDropdownHeight: function() {
        if (typeof this.settings.dropdownSize === "object" && this.settings.dropdownSize.sizeType !== "auto") {
          var height = this.settings.dropdownSize.sizeValue;
          if (this.settings.dropdownSize.sizeType === "numberItems") {
            var $items = this.$dropdown_content.find("*").not(".optgroup, .highlight").not(this.settings.ignoreOnDropwdownHeight);
            var totalHeight = 0;
            var marginTop = 0;
            var marginBottom = 0;
            var separatorHeight = 0;
            for (var i = 0; i < height; i++) {
              var $item = $2($items[i]);
              if ($item.length === 0) {
                break;
              }
              totalHeight += $item.outerHeight(true);
              if (typeof $item.data("selectable") == "undefined") {
                if ($item.hasClass("optgroup-header")) {
                  var styles2 = window.getComputedStyle($item.parent()[0], ":before");
                  if (styles2) {
                    marginTop = styles2.marginTop ? Number(styles2.marginTop.replace(/\W*(\w)\w*/g, "$1")) : 0;
                    marginBottom = styles2.marginBottom ? Number(styles2.marginBottom.replace(/\W*(\w)\w*/g, "$1")) : 0;
                    separatorHeight = styles2.borderTopWidth ? Number(styles2.borderTopWidth.replace(/\W*(\w)\w*/g, "$1")) : 0;
                  }
                }
                height++;
              }
            }
            var paddingTop = this.$dropdown_content.css("padding-top") ? Number(this.$dropdown_content.css("padding-top").replace(/\W*(\w)\w*/g, "$1")) : 0;
            var paddingBottom = this.$dropdown_content.css("padding-bottom") ? Number(this.$dropdown_content.css("padding-bottom").replace(/\W*(\w)\w*/g, "$1")) : 0;
            height = totalHeight + paddingTop + paddingBottom + marginTop + marginBottom + separatorHeight + "px";
          } else if (this.settings.dropdownSize.sizeType !== "fixedHeight") {
            console.warn('Selectize.js - Value of "sizeType" must be "fixedHeight" or "numberItems');
            return;
          }
          this.$dropdown_content.css({ height, maxHeight: "none" });
        }
      },
      /**
       * Resets / clears all selected items
       * from the control.
       *
       * @param {boolean} silent
       */
      clear: function(silent) {
        var self2 = this;
        if (!self2.items.length)
          return;
        self2.$control.children(":not(input)").remove();
        self2.items = [];
        self2.lastQuery = null;
        self2.setCaret(0);
        self2.setActiveItem(null);
        self2.updatePlaceholder();
        self2.updateOriginalInput({ silent });
        self2.refreshState();
        self2.showInput();
        self2.trigger("clear");
      },
      /**
       * A helper method for inserting an element
       * at the current caret position.
       *
       * @param {object} $el
       */
      insertAtCaret: function($el) {
        var caret = Math.min(this.caretPos, this.items.length);
        var el = $el[0];
        var target = this.buffer || this.$control[0];
        if (caret === 0) {
          target.insertBefore(el, target.firstChild);
        } else {
          target.insertBefore(el, target.childNodes[caret]);
        }
        this.setCaret(caret + 1);
      },
      /**
       * Removes the current selected item(s).
       *
       * @param {object} e (optional)
       * @returns {boolean}
       */
      deleteSelection: function(e2) {
        var i, n2, direction, selection, values, caret, option_select, $option_select, $tail;
        var self2 = this;
        direction = e2 && e2.keyCode === KEY_BACKSPACE2 ? -1 : 1;
        selection = getInputSelection(self2.$control_input[0]);
        if (self2.$activeOption && !self2.settings.hideSelected) {
          if (typeof self2.settings.deselectBehavior === "string" && self2.settings.deselectBehavior === "top") {
            option_select = self2.getFirstOption().attr("data-value");
          } else {
            option_select = self2.getAdjacentOption(self2.$activeOption, -1).attr("data-value");
          }
        }
        values = [];
        if (self2.$activeItems.length) {
          $tail = self2.$control.children(".active:" + (direction > 0 ? "last" : "first"));
          caret = self2.$control.children(":not(input)").index($tail);
          if (direction > 0) {
            caret++;
          }
          for (i = 0, n2 = self2.$activeItems.length; i < n2; i++) {
            values.push($2(self2.$activeItems[i]).attr("data-value"));
          }
          if (e2) {
            e2.preventDefault();
            e2.stopPropagation();
          }
        } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
          if (direction < 0 && selection.start === 0 && selection.length === 0) {
            values.push(self2.items[self2.caretPos - 1]);
          } else if (direction > 0 && selection.start === self2.$control_input.val().length) {
            values.push(self2.items[self2.caretPos]);
          }
        }
        if (!values.length || typeof self2.settings.onDelete === "function" && self2.settings.onDelete.apply(self2, [values]) === false) {
          return false;
        }
        if (typeof caret !== "undefined") {
          self2.setCaret(caret);
        }
        while (values.length) {
          self2.removeItem(values.pop());
        }
        self2.showInput();
        self2.positionDropdown();
        self2.refreshOptions(true);
        if (option_select) {
          $option_select = self2.getOption(option_select);
          if ($option_select.length) {
            self2.setActiveOption($option_select);
          }
        }
        return true;
      },
      /**
       * Selects the previous / next item (depending
       * on the `direction` argument).
       *
       * > 0 - right
       * < 0 - left
       *
       * @param {int} direction
       * @param {object} e (optional)
       */
      advanceSelection: function(direction, e2) {
        var tail, selection, idx, valueLength, cursorAtEdge, $tail;
        var self2 = this;
        if (direction === 0)
          return;
        if (self2.rtl)
          direction *= -1;
        tail = direction > 0 ? "last" : "first";
        selection = getInputSelection(self2.$control_input[0]);
        if (self2.isFocused && !self2.isInputHidden) {
          valueLength = self2.$control_input.val().length;
          cursorAtEdge = direction < 0 ? selection.start === 0 && selection.length === 0 : selection.start === valueLength;
          if (cursorAtEdge && !valueLength) {
            self2.advanceCaret(direction, e2);
          }
        } else {
          $tail = self2.$control.children(".active:" + tail);
          if ($tail.length) {
            idx = self2.$control.children(":not(input)").index($tail);
            self2.setActiveItem(null);
            self2.setCaret(direction > 0 ? idx + 1 : idx);
          }
        }
      },
      /**
       * Moves the caret left / right.
       *
       * @param {int} direction
       * @param {object} e (optional)
       */
      advanceCaret: function(direction, e2) {
        var self2 = this, fn3, $adj;
        if (direction === 0)
          return;
        fn3 = direction > 0 ? "next" : "prev";
        if (self2.isShiftDown) {
          $adj = self2.$control_input[fn3]();
          if ($adj.length) {
            self2.hideInput();
            self2.setActiveItem($adj);
            e2 && e2.preventDefault();
          }
        } else {
          self2.setCaret(self2.caretPos + direction);
        }
      },
      /**
       * Moves the caret to the specified index.
       *
       * @param {int} i
       */
      setCaret: function(i) {
        var self2 = this;
        if (self2.settings.mode === "single") {
          i = self2.items.length;
        } else {
          i = Math.max(0, Math.min(self2.items.length, i));
        }
        if (!self2.isPending) {
          var j2, n2, $children, $child;
          $children = self2.$control.children(":not(input)");
          for (j2 = 0, n2 = $children.length; j2 < n2; j2++) {
            $child = $2($children[j2]).detach();
            if (j2 < i) {
              self2.$control_input.before($child);
            } else {
              self2.$control.append($child);
            }
          }
        }
        self2.caretPos = i;
      },
      /**
       * Disables user input on the control. Used while
       * items are being asynchronously created.
       */
      lock: function() {
        this.close();
        this.isLocked = true;
        this.refreshState();
      },
      /**
       * Re-enables user input on the control.
       */
      unlock: function() {
        this.isLocked = false;
        this.refreshState();
      },
      /**
       * Disables user input on the control completely.
       * While disabled, it cannot receive focus.
       */
      disable: function() {
        var self2 = this;
        self2.$input.prop("disabled", true);
        self2.$control_input.prop("disabled", true).prop("tabindex", -1);
        self2.isDisabled = true;
        self2.lock();
      },
      /**
       * Enables the control so that it can respond
       * to focus and user input.
       */
      enable: function() {
        var self2 = this;
        self2.$input.prop("disabled", false);
        self2.$control_input.prop("disabled", false).prop("tabindex", self2.tabIndex);
        self2.isDisabled = false;
        self2.unlock();
      },
      /**
       * Completely destroys the control and
       * unbinds all event listeners so that it can
       * be garbage collected.
       */
      destroy: function() {
        var self2 = this;
        var eventNS = self2.eventNS;
        var revertSettings = self2.revertSettings;
        self2.trigger("destroy");
        self2.off();
        self2.$wrapper.remove();
        self2.$dropdown.remove();
        self2.$input.html("").append(revertSettings.$children).removeAttr("tabindex").removeClass("selectized").attr({ tabindex: revertSettings.tabindex }).show();
        self2.$control_input.removeData("grow");
        self2.$input.removeData("selectize");
        if (--Selectize.count == 0 && Selectize.$testInput) {
          Selectize.$testInput.remove();
          Selectize.$testInput = void 0;
        }
        $2(window).off(eventNS);
        $2(document).off(eventNS);
        $2(document.body).off(eventNS);
        delete self2.$input[0].selectize;
      },
      /**
       * A helper method for rendering "item" and
       * "option" templates, given the data.
       *
       * @param {string} templateName
       * @param {object} data
       * @returns {string}
       */
      render: function(templateName, data2) {
        var value, id;
        var html = "";
        var cache = false;
        var self2 = this;
        if (templateName === "option" || templateName === "item") {
          value = hash_key2(data2[self2.settings.valueField]);
          cache = !!value;
        }
        if (cache) {
          if (!isset(self2.renderCache[templateName])) {
            self2.renderCache[templateName] = {};
          }
          if (self2.renderCache[templateName].hasOwnProperty(value)) {
            return self2.renderCache[templateName][value];
          }
        }
        html = $2(self2.settings.render[templateName].apply(this, [data2, escape_html2]));
        if (templateName === "option" || templateName === "option_create") {
          if (!data2[self2.settings.disabledField]) {
            html.attr("data-selectable", "");
          }
        } else if (templateName === "optgroup") {
          id = data2[self2.settings.optgroupValueField] || "";
          html.attr("data-group", id);
          if (data2[self2.settings.disabledField]) {
            html.attr("data-disabled", "");
          }
        }
        if (templateName === "option" || templateName === "item") {
          html.attr("data-value", value || "");
        }
        if (cache) {
          self2.renderCache[templateName][value] = html[0];
        }
        return html[0];
      },
      /**
       * Clears the render cache for a template. If
       * no template is given, clears all render
       * caches.
       *
       * @param {string} templateName
       */
      clearCache: function(templateName) {
        var self2 = this;
        if (typeof templateName === "undefined") {
          self2.renderCache = {};
        } else {
          delete self2.renderCache[templateName];
        }
      },
      /**
       * Determines whether or not to display the
       * create item prompt, given a user input.
       *
       * @param {string} input
       * @return {boolean}
       */
      canCreate: function(input) {
        var self2 = this;
        if (!self2.settings.create)
          return false;
        var filter2 = self2.settings.createFilter;
        return input.length && (typeof filter2 !== "function" || filter2.apply(self2, [input])) && (typeof filter2 !== "string" || new RegExp(filter2).test(input)) && (!(filter2 instanceof RegExp) || filter2.test(input));
      }
    });
    Selectize.count = 0;
    Selectize.defaults = {
      options: [],
      optgroups: [],
      plugins: [],
      delimiter: ",",
      splitOn: null,
      // regexp or string for splitting up values from a paste command
      persist: true,
      diacritics: true,
      create: false,
      showAddOptionOnCreate: true,
      createOnBlur: false,
      createFilter: null,
      highlight: true,
      openOnFocus: true,
      maxOptions: 1e3,
      maxItems: null,
      hideSelected: null,
      addPrecedence: false,
      selectOnTab: true,
      preload: false,
      allowEmptyOption: false,
      showEmptyOptionInDropdown: false,
      emptyOptionLabel: "--",
      setFirstOptionActive: false,
      closeAfterSelect: false,
      closeDropdownThreshold: 250,
      // number of ms to prevent reopening of dropdown after mousedown
      scrollDuration: 60,
      deselectBehavior: "previous",
      //top, previous
      loadThrottle: 300,
      loadingClass: "loading",
      dataAttr: "data-data",
      optgroupField: "optgroup",
      valueField: "value",
      labelField: "text",
      disabledField: "disabled",
      optgroupLabelField: "label",
      optgroupValueField: "value",
      lockOptgroupOrder: false,
      sortField: "$order",
      searchField: ["text"],
      searchConjunction: "and",
      respect_word_boundaries: true,
      mode: null,
      wrapperClass: "",
      inputClass: "",
      dropdownClass: "",
      dropdownContentClass: "",
      dropdownParent: null,
      copyClassesToDropdown: true,
      dropdownSize: {
        sizeType: "auto",
        // 'numberItems' or 'fixedHeight'
        sizeValue: "auto"
        // number of items or height value (px is default) or CSS height (px, rem, em, vh)
      },
      normalize: false,
      ignoreOnDropwdownHeight: "img, i",
      search: true,
      /*
      load                 : null, // function(query, callback) { ... }
      score                : null, // function(search) { ... }
      formatValueToKey     : null, // function(key) { ... }
      optionGroupRegister  : null, // function(optgroup) to register dynamically created option groups
      onInitialize         : null, // function() { ... }
      onChange             : null, // function(value) { ... }
      onItemAdd            : null, // function(value, $item) { ... }
      onItemRemove         : null, // function(value, $item) { ... }
      onClear              : null, // function() { ... }
      onOptionAdd          : null, // function(value, data) { ... }
      onOptionRemove       : null, // function(value) { ... }
      onOptionClear        : null, // function() { ... }
      onOptionGroupAdd     : null, // function(id, data) { ... }
      onOptionGroupRemove  : null, // function(id) { ... }
      onOptionGroupClear   : null, // function() { ... }
      onDropdownOpen       : null, // function($dropdown) { ... }
      onDropdownClose      : null, // function($dropdown) { ... }
      onType               : null, // function(str) { ... }
      onDelete             : null, // function(values) { ... }
      */
      render: {
        /*
        item: null,
        optgroup: null,
        optgroup_header: null,
        option: null,
        option_create: null
        */
      }
    };
    $2.fn.selectize = function(settings_user) {
      var defaults2 = $2.fn.selectize.defaults;
      var settings = $2.extend({}, defaults2, settings_user);
      var attr_data = settings.dataAttr;
      var field_label = settings.labelField;
      var field_value = settings.valueField;
      var field_disabled = settings.disabledField;
      var field_optgroup = settings.optgroupField;
      var field_optgroup_label = settings.optgroupLabelField;
      var field_optgroup_value = settings.optgroupValueField;
      var init_textbox = function($input, settings_element) {
        var i, n2, values, option2;
        var data_raw = $input.attr(attr_data);
        if (!data_raw) {
          var value = ($input.val() || "").trim();
          if (!settings.allowEmptyOption && !value.length)
            return;
          values = value.split(settings.delimiter);
          for (i = 0, n2 = values.length; i < n2; i++) {
            option2 = {};
            option2[field_label] = values[i];
            option2[field_value] = values[i];
            settings_element.options.push(option2);
          }
          settings_element.items = values;
        } else {
          settings_element.options = JSON.parse(data_raw);
          for (i = 0, n2 = settings_element.options.length; i < n2; i++) {
            settings_element.items.push(settings_element.options[i][field_value]);
          }
        }
      };
      var init_select = function($input, settings_element) {
        var i, n2, tagName, $children;
        var options = settings_element.options;
        var optionsMap = {};
        var readData = function($el) {
          var data2 = attr_data && $el.attr(attr_data);
          var allData = $el.data();
          var obj = {};
          if (typeof data2 === "string" && data2.length) {
            if (isJSON()) {
              Object.assign(obj, JSON.parse(data2));
            } else {
              obj[data2] = data2;
            }
          }
          Object.assign(obj, allData);
          return obj || null;
        };
        var addOption = function($option, group) {
          $option = $2($option);
          var value = hash_key2($option.val());
          if (!value && !settings.allowEmptyOption)
            return;
          if (optionsMap.hasOwnProperty(value)) {
            if (group) {
              var arr = optionsMap[value][field_optgroup];
              if (!arr) {
                optionsMap[value][field_optgroup] = group;
              } else if (!Array.isArray(arr)) {
                optionsMap[value][field_optgroup] = [arr, group];
              } else {
                arr.push(group);
              }
            }
            return;
          }
          var option2 = readData($option) || {};
          option2[field_label] = option2[field_label] || $option.text();
          option2[field_value] = option2[field_value] || value;
          option2[field_disabled] = option2[field_disabled] || $option.prop("disabled");
          option2[field_optgroup] = option2[field_optgroup] || group;
          option2.styles = $option.attr("style") || "";
          option2.classes = $option.attr("class") || "";
          optionsMap[value] = option2;
          options.push(option2);
          if ($option.is(":selected")) {
            settings_element.items.push(value);
          }
        };
        var addGroup = function($optgroup) {
          var i2, n3, id, optgroup, $options;
          $optgroup = $2($optgroup);
          id = $optgroup.attr("label");
          if (id) {
            optgroup = readData($optgroup) || {};
            optgroup[field_optgroup_label] = id;
            optgroup[field_optgroup_value] = id;
            optgroup[field_disabled] = $optgroup.prop("disabled");
            settings_element.optgroups.push(optgroup);
          }
          $options = $2("option", $optgroup);
          for (i2 = 0, n3 = $options.length; i2 < n3; i2++) {
            addOption($options[i2], id);
          }
        };
        settings_element.maxItems = $input.attr("multiple") ? null : 1;
        $children = $input.children();
        for (i = 0, n2 = $children.length; i < n2; i++) {
          tagName = $children[i].tagName.toLowerCase();
          if (tagName === "optgroup") {
            addGroup($children[i]);
          } else if (tagName === "option") {
            addOption($children[i]);
          }
        }
      };
      return this.each(function() {
        if (this.selectize)
          return;
        var instance;
        var $input = $2(this);
        var tag_name = this.tagName.toLowerCase();
        var placeholder = $input.attr("placeholder") || $input.attr("data-placeholder");
        if (!placeholder && !settings.allowEmptyOption) {
          placeholder = $input.children('option[value=""]').text();
        }
        if (settings.allowEmptyOption && settings.showEmptyOptionInDropdown && !$input.children('option[value=""]').length) {
          var input_html = $input.html();
          var label = escape_html2(settings.emptyOptionLabel || "--");
          $input.html('<option value="">' + label + "</option>" + input_html);
        }
        var settings_element = {
          "placeholder": placeholder,
          "options": [],
          "optgroups": [],
          "items": []
        };
        if (tag_name === "select") {
          init_select($input, settings_element);
        } else {
          init_textbox($input, settings_element);
        }
        instance = new Selectize($input, $2.extend(true, {}, defaults2, settings_element, settings_user));
        instance.settings_user = settings_user;
      });
    };
    $2.fn.selectize.defaults = Selectize.defaults;
    $2.fn.selectize.support = {
      validity: SUPPORTS_VALIDITY_API
    };
    Selectize.define("auto_position", function() {
      var self2 = this;
      const POSITION = {
        top: "top",
        bottom: "bottom"
      };
      self2.positionDropdown = function() {
        return function() {
          const $control = this.$control;
          const offset2 = this.settings.dropdownParent === "body" ? $control.offset() : $control.position();
          offset2.top += $control.outerHeight(true);
          const dropdownHeight = this.$dropdown.prop("scrollHeight") + 5;
          const controlPosTop = this.$control.get(0).getBoundingClientRect().top;
          const wrapperHeight = this.$wrapper.height();
          const position = controlPosTop + dropdownHeight + wrapperHeight > window.innerHeight ? POSITION.top : POSITION.bottom;
          const styles2 = {
            width: $control.outerWidth(),
            left: offset2.left
          };
          if (position === POSITION.top) {
            const styleToAdd = { bottom: offset2.top, top: "unset" };
            if (this.settings.dropdownParent === "body") {
              styleToAdd.top = offset2.top - this.$dropdown.outerHeight(true) - $control.outerHeight(true);
              styleToAdd.bottom = "unset";
            }
            Object.assign(styles2, styleToAdd);
            this.$dropdown.addClass("selectize-position-top");
            this.$control.addClass("selectize-position-top");
          } else {
            Object.assign(styles2, { top: offset2.top, bottom: "unset" });
            this.$dropdown.removeClass("selectize-position-top");
            this.$control.removeClass("selectize-position-top");
          }
          this.$dropdown.css(styles2);
        };
      }();
    });
    Selectize.define("auto_select_on_type", function(options) {
      var self2 = this;
      self2.onBlur = function() {
        var originalBlur = self2.onBlur;
        return function(e2) {
          var $matchedItem = self2.getFirstItemMatchedByTextContent(self2.lastValue, true);
          if (typeof $matchedItem.attr("data-value") !== "undefined" && self2.getValue() !== $matchedItem.attr("data-value")) {
            self2.setValue($matchedItem.attr("data-value"));
          }
          return originalBlur.apply(this, arguments);
        };
      }();
    });
    Selectize.define("autofill_disable", function(options) {
      var self2 = this;
      self2.setup = function() {
        var original = self2.setup;
        return function() {
          original.apply(self2, arguments);
          self2.$control_input.attr({ autocomplete: "new-password", autofill: "no" });
        };
      }();
    });
    Selectize.define("clear_button", function(options) {
      var self2 = this;
      options = $2.extend(
        {
          title: "Clear",
          className: "clear",
          label: "×",
          html: function(data2) {
            return '<a class="' + data2.className + '" title="' + data2.title + '"> ' + data2.label + "</a>";
          }
        },
        options
      );
      self2.setup = function() {
        var original = self2.setup;
        return function() {
          original.apply(self2, arguments);
          self2.$button_clear = $2(options.html(options));
          if (self2.settings.mode === "single")
            self2.$wrapper.addClass("single");
          self2.$wrapper.append(self2.$button_clear);
          if (self2.getValue() === "" || self2.getValue().length === 0) {
            self2.$wrapper.find("." + options.className).css("display", "none");
          }
          self2.on("change", function() {
            if (self2.getValue() === "" || self2.getValue().length === 0) {
              self2.$wrapper.find("." + options.className).css("display", "none");
            } else {
              self2.$wrapper.find("." + options.className).css("display", "");
            }
          });
          self2.$wrapper.on("click", "." + options.className, function(e2) {
            e2.preventDefault();
            e2.stopImmediatePropagation();
            e2.stopPropagation();
            if (self2.isLocked)
              return;
            self2.clear();
            self2.$wrapper.find("." + options.className).css("display", "none");
          });
        };
      }();
    });
    Selectize.define("drag_drop", function(options) {
      if (!$2.fn.sortable)
        throw new Error('The "drag_drop" plugin requires jQuery UI "sortable".');
      if (this.settings.mode !== "multi")
        return;
      var self2 = this;
      self2.lock = function() {
        var original = self2.lock;
        return function() {
          var sortable = self2.$control.data("sortable");
          if (sortable)
            sortable.disable();
          return original.apply(self2, arguments);
        };
      }();
      self2.unlock = function() {
        var original = self2.unlock;
        return function() {
          var sortable = self2.$control.data("sortable");
          if (sortable)
            sortable.enable();
          return original.apply(self2, arguments);
        };
      }();
      self2.setup = function() {
        var original = self2.setup;
        return function() {
          original.apply(this, arguments);
          var $control = self2.$control.sortable({
            items: "[data-value]",
            forcePlaceholderSize: true,
            disabled: self2.isLocked,
            start: function(e2, ui2) {
              ui2.placeholder.css("width", ui2.helper.css("width"));
              $control.addClass("dragging");
            },
            stop: function() {
              $control.removeClass("dragging");
              var active = self2.$activeItems ? self2.$activeItems.slice() : null;
              var values = [];
              $control.children("[data-value]").each(function() {
                values.push($2(this).attr("data-value"));
              });
              self2.isFocused = false;
              self2.setValue(values);
              self2.isFocused = true;
              self2.setActiveItem(active);
              self2.positionDropdown();
            }
          });
        };
      }();
    });
    Selectize.define("dropdown_header", function(options) {
      var self2 = this;
      options = $2.extend({
        title: "Untitled",
        headerClass: "selectize-dropdown-header",
        titleRowClass: "selectize-dropdown-header-title",
        labelClass: "selectize-dropdown-header-label",
        closeClass: "selectize-dropdown-header-close",
        html: function(data2) {
          return '<div class="' + data2.headerClass + '"><div class="' + data2.titleRowClass + '"><span class="' + data2.labelClass + '">' + data2.title + '</span><a href="javascript:void(0)" class="' + data2.closeClass + '">&#xd7;</a></div></div>';
        }
      }, options);
      self2.setup = function() {
        var original = self2.setup;
        return function() {
          original.apply(self2, arguments);
          self2.$dropdown_header = $2(options.html(options));
          self2.$dropdown.prepend(self2.$dropdown_header);
          self2.$dropdown_header.find("." + options.closeClass).on("click", function() {
            self2.close();
          });
        };
      }();
    });
    Selectize.define("optgroup_columns", function(options) {
      var self2 = this;
      options = $2.extend({
        equalizeWidth: true,
        equalizeHeight: true
      }, options);
      this.getAdjacentOption = function($option, direction) {
        var $options = $option.closest("[data-group]").find("[data-selectable]");
        var index = $options.index($option) + direction;
        return index >= 0 && index < $options.length ? $options.eq(index) : $2();
      };
      this.onKeyDown = function() {
        var original = self2.onKeyDown;
        return function(e2) {
          var index, $option, $options, $optgroup;
          if (this.isOpen && (e2.keyCode === KEY_LEFT2 || e2.keyCode === KEY_RIGHT2)) {
            self2.ignoreHover = true;
            $optgroup = this.$activeOption.closest("[data-group]");
            index = $optgroup.find("[data-selectable]").index(this.$activeOption);
            if (e2.keyCode === KEY_LEFT2) {
              $optgroup = $optgroup.prev("[data-group]");
            } else {
              $optgroup = $optgroup.next("[data-group]");
            }
            $options = $optgroup.find("[data-selectable]");
            $option = $options.eq(Math.min($options.length - 1, index));
            if ($option.length) {
              this.setActiveOption($option);
            }
            return;
          }
          return original.apply(this, arguments);
        };
      }();
      var getScrollbarWidth = function() {
        var div;
        var width = getScrollbarWidth.width;
        var doc = document;
        if (typeof width === "undefined") {
          div = doc.createElement("div");
          div.innerHTML = '<div style="width:50px;height:50px;position:absolute;left:-50px;top:-50px;overflow:auto;"><div style="width:1px;height:100px;"></div></div>';
          div = div.firstChild;
          doc.body.appendChild(div);
          width = getScrollbarWidth.width = div.offsetWidth - div.clientWidth;
          doc.body.removeChild(div);
        }
        return width;
      };
      var equalizeSizes = function() {
        var i, n2, height_max, width, width_last, width_parent, $optgroups;
        $optgroups = $2("[data-group]", self2.$dropdown_content);
        n2 = $optgroups.length;
        if (!n2 || !self2.$dropdown_content.width())
          return;
        if (options.equalizeHeight) {
          height_max = 0;
          for (i = 0; i < n2; i++) {
            height_max = Math.max(height_max, $optgroups.eq(i).height());
          }
          $optgroups.css({ height: height_max });
        }
        if (options.equalizeWidth) {
          width_parent = self2.$dropdown_content.innerWidth() - getScrollbarWidth();
          width = Math.round(width_parent / n2);
          $optgroups.css({ width });
          if (n2 > 1) {
            width_last = width_parent - width * (n2 - 1);
            $optgroups.eq(n2 - 1).css({ width: width_last });
          }
        }
      };
      if (options.equalizeHeight || options.equalizeWidth) {
        hook.after(this, "positionDropdown", equalizeSizes);
        hook.after(this, "refreshOptions", equalizeSizes);
      }
    });
    Selectize.define("remove_button", function(options) {
      if (this.settings.mode === "single")
        return;
      options = $2.extend({
        label: "&#xd7;",
        title: "Remove",
        className: "remove",
        append: true
      }, options);
      var multiClose = function(thisRef, options2) {
        var self2 = thisRef;
        var html = '<a href="javascript:void(0)" class="' + options2.className + '" tabindex="-1" title="' + escape_html2(options2.title) + '">' + options2.label + "</a>";
        var append3 = function(html_container, html_element) {
          var pos = html_container.search(/(<\/[^>]+>\s*)$/);
          return html_container.substring(0, pos) + html_element + html_container.substring(pos);
        };
        thisRef.setup = function() {
          var original = self2.setup;
          return function() {
            if (options2.append) {
              var render_item = self2.settings.render.item;
              self2.settings.render.item = function(data2) {
                return append3(render_item.apply(thisRef, arguments), html);
              };
            }
            original.apply(thisRef, arguments);
            thisRef.$control.on("click", "." + options2.className, function(e2) {
              e2.preventDefault();
              if (self2.isLocked)
                return;
              var $item = $2(e2.currentTarget).parent();
              self2.setActiveItem($item);
              if (self2.deleteSelection()) {
                self2.setCaret(self2.items.length);
              }
              return false;
            });
          };
        }();
      };
      multiClose(this, options);
    });
    Selectize.define("restore_on_backspace", function(options) {
      var self2 = this;
      options.text = options.text || function(option2) {
        return option2[this.settings.labelField];
      };
      this.onKeyDown = function() {
        var original = self2.onKeyDown;
        return function(e2) {
          var index, option2;
          if (e2.keyCode === KEY_BACKSPACE2 && this.$control_input.val() === "" && !this.$activeItems.length) {
            index = this.caretPos - 1;
            if (index >= 0 && index < this.items.length) {
              option2 = this.options[this.items[index]];
              if (this.deleteSelection(e2)) {
                this.setTextboxValue(options.text.apply(this, [option2]));
                this.refreshOptions(true);
              }
              e2.preventDefault();
              return;
            }
          }
          return original.apply(this, arguments);
        };
      }();
    });
    Selectize.define("select_on_focus", function(options) {
      var self2 = this;
      self2.on("focus", function() {
        var originalFocus = self2.onFocus;
        return function(e2) {
          var value = self2.getItem(self2.getValue()).text();
          self2.clear();
          self2.setTextboxValue(value);
          self2.$control_input.select();
          setTimeout(function() {
            if (self2.settings.selectOnTab) {
              self2.setActiveOption(self2.getFirstItemMatchedByTextContent(value));
            }
            self2.settings.score = null;
          }, 0);
          return originalFocus.apply(this, arguments);
        };
      }());
      self2.onBlur = function() {
        var originalBlur = self2.onBlur;
        return function(e2) {
          if (self2.getValue() === "" && self2.lastValidValue !== self2.getValue()) {
            self2.setValue(self2.lastValidValue);
          }
          setTimeout(function() {
            self2.settings.score = function() {
              return function() {
                return 1;
              };
            };
          }, 0);
          return originalBlur.apply(this, arguments);
        };
      }();
      self2.settings.score = function() {
        return function() {
          return 1;
        };
      };
    });
    Selectize.define("tag_limit", function(options) {
      const self2 = this;
      options.tagLimit = options.tagLimit;
      this.onBlur = function(e2) {
        const original = self2.onBlur;
        return function(e3) {
          original.apply(this, e3);
          if (!e3)
            return;
          const $control = this.$control;
          const $items = $control.find(".item");
          const limit2 = options.tagLimit;
          if (limit2 === void 0 || $items.length <= limit2)
            return;
          $items.toArray().forEach(function(item2, index) {
            if (index < limit2)
              return;
            $2(item2).hide();
          });
          $control.append("<span><b>" + ($items.length - limit2) + "</b></span>");
        };
      }();
      this.onFocus = function(e2) {
        const original = self2.onFocus;
        return function(e3) {
          original.apply(this, e3);
          if (!e3)
            return;
          const $control = this.$control;
          const $items = $control.find(".item");
          $items.show();
          $control.find("span").remove();
        };
      }();
    });
    return Selectize;
  });
})(selectize);
function forEvents(events, callback) {
  events.split(/\s+/).forEach((event) => {
    callback(event);
  });
}
class MicroEvent {
  constructor() {
    this._events = {};
  }
  on(events, fct) {
    forEvents(events, (event) => {
      const event_array = this._events[event] || [];
      event_array.push(fct);
      this._events[event] = event_array;
    });
  }
  off(events, fct) {
    var n2 = arguments.length;
    if (n2 === 0) {
      this._events = {};
      return;
    }
    forEvents(events, (event) => {
      if (n2 === 1) {
        delete this._events[event];
        return;
      }
      const event_array = this._events[event];
      if (event_array === void 0)
        return;
      event_array.splice(event_array.indexOf(fct), 1);
      this._events[event] = event_array;
    });
  }
  trigger(events, ...args) {
    var self2 = this;
    forEvents(events, (event) => {
      const event_array = self2._events[event];
      if (event_array === void 0)
        return;
      event_array.forEach((fct) => {
        fct.apply(self2, args);
      });
    });
  }
}
function MicroPlugin(Interface) {
  Interface.plugins = {};
  return class extends Interface {
    constructor() {
      super(...arguments);
      this.plugins = {
        names: [],
        settings: {},
        requested: {},
        loaded: {}
      };
    }
    /**
     * Registers a plugin.
     *
     * @param {function} fn
     */
    static define(name2, fn3) {
      Interface.plugins[name2] = {
        "name": name2,
        "fn": fn3
      };
    }
    /**
     * Initializes the listed plugins (with options).
     * Acceptable formats:
     *
     * List (without options):
     *   ['a', 'b', 'c']
     *
     * List (with options):
     *   [{'name': 'a', options: {}}, {'name': 'b', options: {}}]
     *
     * Hash (with options):
     *   {'a': { ... }, 'b': { ... }, 'c': { ... }}
     *
     * @param {array|object} plugins
     */
    initializePlugins(plugins2) {
      var key, name2;
      const self2 = this;
      const queue = [];
      if (Array.isArray(plugins2)) {
        plugins2.forEach((plugin2) => {
          if (typeof plugin2 === "string") {
            queue.push(plugin2);
          } else {
            self2.plugins.settings[plugin2.name] = plugin2.options;
            queue.push(plugin2.name);
          }
        });
      } else if (plugins2) {
        for (key in plugins2) {
          if (plugins2.hasOwnProperty(key)) {
            self2.plugins.settings[key] = plugins2[key];
            queue.push(key);
          }
        }
      }
      while (name2 = queue.shift()) {
        self2.require(name2);
      }
    }
    loadPlugin(name2) {
      var self2 = this;
      var plugins2 = self2.plugins;
      var plugin2 = Interface.plugins[name2];
      if (!Interface.plugins.hasOwnProperty(name2)) {
        throw new Error('Unable to find "' + name2 + '" plugin');
      }
      plugins2.requested[name2] = true;
      plugins2.loaded[name2] = plugin2.fn.apply(self2, [self2.plugins.settings[name2] || {}]);
      plugins2.names.push(name2);
    }
    /**
     * Initializes a plugin.
     *
     */
    require(name2) {
      var self2 = this;
      var plugins2 = self2.plugins;
      if (!self2.plugins.loaded.hasOwnProperty(name2)) {
        if (plugins2.requested[name2]) {
          throw new Error('Plugin has circular dependency ("' + name2 + '")');
        }
        self2.loadPlugin(name2);
      }
      return plugins2.loaded[name2];
    }
  };
}
const arrayToPattern = (chars) => {
  chars = chars.filter(Boolean);
  if (chars.length < 2) {
    return chars[0] || "";
  }
  return maxValueLength(chars) == 1 ? "[" + chars.join("") + "]" : "(?:" + chars.join("|") + ")";
};
const sequencePattern = (array) => {
  if (!hasDuplicates(array)) {
    return array.join("");
  }
  let pattern = "";
  let prev_char_count = 0;
  const prev_pattern = () => {
    if (prev_char_count > 1) {
      pattern += "{" + prev_char_count + "}";
    }
  };
  array.forEach((char, i) => {
    if (char === array[i - 1]) {
      prev_char_count++;
      return;
    }
    prev_pattern();
    pattern += char;
    prev_char_count = 1;
  });
  prev_pattern();
  return pattern;
};
const setToPattern = (chars) => {
  let array = Array.from(chars);
  return arrayToPattern(array);
};
const hasDuplicates = (array) => {
  return new Set(array).size !== array.length;
};
const escape_regex = (str2) => {
  return (str2 + "").replace(/([\$\(\)\*\+\.\?\[\]\^\{\|\}\\])/gu, "\\$1");
};
const maxValueLength = (array) => {
  return array.reduce((longest, value) => Math.max(longest, unicodeLength(value)), 0);
};
const unicodeLength = (str2) => {
  return Array.from(str2).length;
};
const allSubstrings = (input) => {
  if (input.length === 1)
    return [[input]];
  let result = [];
  const start2 = input.substring(1);
  const suba = allSubstrings(start2);
  suba.forEach(function(subresult) {
    let tmp = subresult.slice(0);
    tmp[0] = input.charAt(0) + tmp[0];
    result.push(tmp);
    tmp = subresult.slice(0);
    tmp.unshift(input.charAt(0));
    result.push(tmp);
  });
  return result;
};
const code_points = [[0, 65535]];
const accent_pat = "[̀-ͯ·ʾʼ]";
let unicode_map;
let multi_char_reg;
const max_char_length = 3;
const latin_convert = {};
const latin_condensed = {
  "/": "⁄∕",
  "0": "߀",
  "a": "ⱥɐɑ",
  "aa": "ꜳ",
  "ae": "æǽǣ",
  "ao": "ꜵ",
  "au": "ꜷ",
  "av": "ꜹꜻ",
  "ay": "ꜽ",
  "b": "ƀɓƃ",
  "c": "ꜿƈȼↄ",
  "d": "đɗɖᴅƌꮷԁɦ",
  "e": "ɛǝᴇɇ",
  "f": "ꝼƒ",
  "g": "ǥɠꞡᵹꝿɢ",
  "h": "ħⱨⱶɥ",
  "i": "ɨı",
  "j": "ɉȷ",
  "k": "ƙⱪꝁꝃꝅꞣ",
  "l": "łƚɫⱡꝉꝇꞁɭ",
  "m": "ɱɯϻ",
  "n": "ꞥƞɲꞑᴎлԉ",
  "o": "øǿɔɵꝋꝍᴑ",
  "oe": "œ",
  "oi": "ƣ",
  "oo": "ꝏ",
  "ou": "ȣ",
  "p": "ƥᵽꝑꝓꝕρ",
  "q": "ꝗꝙɋ",
  "r": "ɍɽꝛꞧꞃ",
  "s": "ßȿꞩꞅʂ",
  "t": "ŧƭʈⱦꞇ",
  "th": "þ",
  "tz": "ꜩ",
  "u": "ʉ",
  "v": "ʋꝟʌ",
  "vy": "ꝡ",
  "w": "ⱳ",
  "y": "ƴɏỿ",
  "z": "ƶȥɀⱬꝣ",
  "hv": "ƕ"
};
for (let latin in latin_condensed) {
  let unicode = latin_condensed[latin] || "";
  for (let i = 0; i < unicode.length; i++) {
    let char = unicode.substring(i, i + 1);
    latin_convert[char] = latin;
  }
}
const convert_pat = new RegExp(Object.keys(latin_convert).join("|") + "|" + accent_pat, "gu");
const initialize = (_code_points) => {
  if (unicode_map !== void 0)
    return;
  unicode_map = generateMap(_code_points || code_points);
};
const normalize = (str2, form = "NFKD") => str2.normalize(form);
const asciifold = (str2) => {
  return Array.from(str2).reduce(
    /**
     * @param {string} result
     * @param {string} char
     */
    (result, char) => {
      return result + _asciifold(char);
    },
    ""
  );
};
const _asciifold = (str2) => {
  str2 = normalize(str2).toLowerCase().replace(convert_pat, (char) => {
    return latin_convert[char] || "";
  });
  return normalize(str2, "NFC");
};
function* generator(code_points2) {
  for (const [code_point_min, code_point_max] of code_points2) {
    for (let i = code_point_min; i <= code_point_max; i++) {
      let composed = String.fromCharCode(i);
      let folded = asciifold(composed);
      if (folded == composed.toLowerCase()) {
        continue;
      }
      if (folded.length > max_char_length) {
        continue;
      }
      if (folded.length == 0) {
        continue;
      }
      yield { folded, composed, code_point: i };
    }
  }
}
const generateSets = (code_points2) => {
  const unicode_sets = {};
  const addMatching = (folded, to_add) => {
    const folded_set = unicode_sets[folded] || /* @__PURE__ */ new Set();
    const patt = new RegExp("^" + setToPattern(folded_set) + "$", "iu");
    if (to_add.match(patt)) {
      return;
    }
    folded_set.add(escape_regex(to_add));
    unicode_sets[folded] = folded_set;
  };
  for (let value of generator(code_points2)) {
    addMatching(value.folded, value.folded);
    addMatching(value.folded, value.composed);
  }
  return unicode_sets;
};
const generateMap = (code_points2) => {
  const unicode_sets = generateSets(code_points2);
  const unicode_map2 = {};
  let multi_char = [];
  for (let folded in unicode_sets) {
    let set = unicode_sets[folded];
    if (set) {
      unicode_map2[folded] = setToPattern(set);
    }
    if (folded.length > 1) {
      multi_char.push(escape_regex(folded));
    }
  }
  multi_char.sort((a2, b2) => b2.length - a2.length);
  const multi_char_patt = arrayToPattern(multi_char);
  multi_char_reg = new RegExp("^" + multi_char_patt, "u");
  return unicode_map2;
};
const mapSequence = (strings, min_replacement = 1) => {
  let chars_replaced = 0;
  strings = strings.map((str2) => {
    if (unicode_map[str2]) {
      chars_replaced += str2.length;
    }
    return unicode_map[str2] || str2;
  });
  if (chars_replaced >= min_replacement) {
    return sequencePattern(strings);
  }
  return "";
};
const substringsToPattern = (str2, min_replacement = 1) => {
  min_replacement = Math.max(min_replacement, str2.length - 1);
  return arrayToPattern(allSubstrings(str2).map((sub_pat) => {
    return mapSequence(sub_pat, min_replacement);
  }));
};
const sequencesToPattern = (sequences, all2 = true) => {
  let min_replacement = sequences.length > 1 ? 1 : 0;
  return arrayToPattern(sequences.map((sequence) => {
    let seq = [];
    const len = all2 ? sequence.length() : sequence.length() - 1;
    for (let j2 = 0; j2 < len; j2++) {
      seq.push(substringsToPattern(sequence.substrs[j2] || "", min_replacement));
    }
    return sequencePattern(seq);
  }));
};
const inSequences = (needle_seq, sequences) => {
  for (const seq of sequences) {
    if (seq.start != needle_seq.start || seq.end != needle_seq.end) {
      continue;
    }
    if (seq.substrs.join("") !== needle_seq.substrs.join("")) {
      continue;
    }
    let needle_parts = needle_seq.parts;
    const filter2 = (part) => {
      for (const needle_part of needle_parts) {
        if (needle_part.start === part.start && needle_part.substr === part.substr) {
          return false;
        }
        if (part.length == 1 || needle_part.length == 1) {
          continue;
        }
        if (part.start < needle_part.start && part.end > needle_part.start) {
          return true;
        }
        if (needle_part.start < part.start && needle_part.end > part.start) {
          return true;
        }
      }
      return false;
    };
    let filtered = seq.parts.filter(filter2);
    if (filtered.length > 0) {
      continue;
    }
    return true;
  }
  return false;
};
class Sequence {
  constructor() {
    __publicField(this, "parts");
    __publicField(this, "substrs");
    __publicField(this, "start");
    __publicField(this, "end");
    this.parts = [];
    this.substrs = [];
    this.start = 0;
    this.end = 0;
  }
  add(part) {
    if (part) {
      this.parts.push(part);
      this.substrs.push(part.substr);
      this.start = Math.min(part.start, this.start);
      this.end = Math.max(part.end, this.end);
    }
  }
  last() {
    return this.parts[this.parts.length - 1];
  }
  length() {
    return this.parts.length;
  }
  clone(position, last_piece) {
    let clone = new Sequence();
    let parts = JSON.parse(JSON.stringify(this.parts));
    let last_part = parts.pop();
    for (const part of parts) {
      clone.add(part);
    }
    let last_substr = last_piece.substr.substring(0, position - last_part.start);
    let clone_last_len = last_substr.length;
    clone.add({ start: last_part.start, end: last_part.start + clone_last_len, length: clone_last_len, substr: last_substr });
    return clone;
  }
}
const getPattern = (str2) => {
  initialize();
  str2 = asciifold(str2);
  let pattern = "";
  let sequences = [new Sequence()];
  for (let i = 0; i < str2.length; i++) {
    let substr = str2.substring(i);
    let match = substr.match(multi_char_reg);
    const char = str2.substring(i, i + 1);
    const match_str = match ? match[0] : null;
    let overlapping = [];
    let added_types = /* @__PURE__ */ new Set();
    for (const sequence of sequences) {
      const last_piece = sequence.last();
      if (!last_piece || last_piece.length == 1 || last_piece.end <= i) {
        if (match_str) {
          const len = match_str.length;
          sequence.add({ start: i, end: i + len, length: len, substr: match_str });
          added_types.add("1");
        } else {
          sequence.add({ start: i, end: i + 1, length: 1, substr: char });
          added_types.add("2");
        }
      } else if (match_str) {
        let clone = sequence.clone(i, last_piece);
        const len = match_str.length;
        clone.add({ start: i, end: i + len, length: len, substr: match_str });
        overlapping.push(clone);
      } else {
        added_types.add("3");
      }
    }
    if (overlapping.length > 0) {
      overlapping = overlapping.sort((a2, b2) => {
        return a2.length() - b2.length();
      });
      for (let clone of overlapping) {
        if (inSequences(clone, sequences)) {
          continue;
        }
        sequences.push(clone);
      }
      continue;
    }
    if (i > 0 && added_types.size == 1 && !added_types.has("3")) {
      pattern += sequencesToPattern(sequences, false);
      let new_seq = new Sequence();
      const old_seq = sequences[0];
      if (old_seq) {
        new_seq.add(old_seq.last());
      }
      sequences = [new_seq];
    }
  }
  pattern += sequencesToPattern(sequences, true);
  return pattern;
};
const getAttr = (obj, name2) => {
  if (!obj)
    return;
  return obj[name2];
};
const getAttrNesting = (obj, name2) => {
  if (!obj)
    return;
  var part, names = name2.split(".");
  while ((part = names.shift()) && (obj = obj[part]))
    ;
  return obj;
};
const scoreValue = (value, token, weight) => {
  var score, pos;
  if (!value)
    return 0;
  value = value + "";
  if (token.regex == null)
    return 0;
  pos = value.search(token.regex);
  if (pos === -1)
    return 0;
  score = token.string.length / value.length;
  if (pos === 0)
    score += 0.5;
  return score * weight;
};
const propToArray = (obj, key) => {
  var value = obj[key];
  if (typeof value == "function")
    return value;
  if (value && !Array.isArray(value)) {
    obj[key] = [value];
  }
};
const iterate$5 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const cmp = (a2, b2) => {
  if (typeof a2 === "number" && typeof b2 === "number") {
    return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
  }
  a2 = asciifold(a2 + "").toLowerCase();
  b2 = asciifold(b2 + "").toLowerCase();
  if (a2 > b2)
    return 1;
  if (b2 > a2)
    return -1;
  return 0;
};
class Sifter {
  /**
   * Textually searches arrays and hashes of objects
   * by property (or multiple properties). Designed
   * specifically for autocomplete.
   *
   */
  constructor(items, settings) {
    __publicField(this, "items");
    // []|{};
    __publicField(this, "settings");
    this.items = items;
    this.settings = settings || { diacritics: true };
  }
  /**
   * Splits a search string into an array of individual
   * regexps to be used to match results.
   *
   */
  tokenize(query, respect_word_boundaries, weights) {
    if (!query || !query.length)
      return [];
    const tokens = [];
    const words = query.split(/\s+/);
    var field_regex;
    if (weights) {
      field_regex = new RegExp("^(" + Object.keys(weights).map(escape_regex).join("|") + "):(.*)$");
    }
    words.forEach((word) => {
      let field_match;
      let field = null;
      let regex = null;
      if (field_regex && (field_match = word.match(field_regex))) {
        field = field_match[1];
        word = field_match[2];
      }
      if (word.length > 0) {
        if (this.settings.diacritics) {
          regex = getPattern(word) || null;
        } else {
          regex = escape_regex(word);
        }
        if (regex && respect_word_boundaries)
          regex = "\\b" + regex;
      }
      tokens.push({
        string: word,
        regex: regex ? new RegExp(regex, "iu") : null,
        field
      });
    });
    return tokens;
  }
  /**
   * Returns a function to be used to score individual results.
   *
   * Good matches will have a higher score than poor matches.
   * If an item is not a match, 0 will be returned by the function.
   *
   * @returns {T.ScoreFn}
   */
  getScoreFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getScoreFunction(search);
  }
  /**
   * @returns {T.ScoreFn}
   *
   */
  _getScoreFunction(search) {
    const tokens = search.tokens, token_count = tokens.length;
    if (!token_count) {
      return function() {
        return 0;
      };
    }
    const fields = search.options.fields, weights = search.weights, field_count = fields.length, getAttrFn = search.getAttrFn;
    if (!field_count) {
      return function() {
        return 1;
      };
    }
    const scoreObject = function() {
      if (field_count === 1) {
        return function(token, data2) {
          const field = fields[0].field;
          return scoreValue(getAttrFn(data2, field), token, weights[field] || 1);
        };
      }
      return function(token, data2) {
        var sum = 0;
        if (token.field) {
          const value = getAttrFn(data2, token.field);
          if (!token.regex && value) {
            sum += 1 / field_count;
          } else {
            sum += scoreValue(value, token, 1);
          }
        } else {
          iterate$5(weights, (weight, field) => {
            sum += scoreValue(getAttrFn(data2, field), token, weight);
          });
        }
        return sum / field_count;
      };
    }();
    if (token_count === 1) {
      return function(data2) {
        return scoreObject(tokens[0], data2);
      };
    }
    if (search.options.conjunction === "and") {
      return function(data2) {
        var score, sum = 0;
        for (let token of tokens) {
          score = scoreObject(token, data2);
          if (score <= 0)
            return 0;
          sum += score;
        }
        return sum / token_count;
      };
    } else {
      return function(data2) {
        var sum = 0;
        iterate$5(tokens, (token) => {
          sum += scoreObject(token, data2);
        });
        return sum / token_count;
      };
    }
  }
  /**
   * Returns a function that can be used to compare two
   * results, for sorting purposes. If no sorting should
   * be performed, `null` will be returned.
   *
   * @return function(a,b)
   */
  getSortFunction(query, options) {
    var search = this.prepareSearch(query, options);
    return this._getSortFunction(search);
  }
  _getSortFunction(search) {
    var implicit_score, sort_flds = [];
    const self2 = this, options = search.options, sort = !search.query && options.sort_empty ? options.sort_empty : options.sort;
    if (typeof sort == "function") {
      return sort.bind(this);
    }
    const get_field = function(name2, result) {
      if (name2 === "$score")
        return result.score;
      return search.getAttrFn(self2.items[result.id], name2);
    };
    if (sort) {
      for (let s2 of sort) {
        if (search.query || s2.field !== "$score") {
          sort_flds.push(s2);
        }
      }
    }
    if (search.query) {
      implicit_score = true;
      for (let fld of sort_flds) {
        if (fld.field === "$score") {
          implicit_score = false;
          break;
        }
      }
      if (implicit_score) {
        sort_flds.unshift({ field: "$score", direction: "desc" });
      }
    } else {
      sort_flds = sort_flds.filter((fld) => fld.field !== "$score");
    }
    const sort_flds_count = sort_flds.length;
    if (!sort_flds_count) {
      return null;
    }
    return function(a2, b2) {
      var result, field;
      for (let sort_fld of sort_flds) {
        field = sort_fld.field;
        let multiplier = sort_fld.direction === "desc" ? -1 : 1;
        result = multiplier * cmp(get_field(field, a2), get_field(field, b2));
        if (result)
          return result;
      }
      return 0;
    };
  }
  /**
   * Parses a search query and returns an object
   * with tokens and fields ready to be populated
   * with results.
   *
   */
  prepareSearch(query, optsUser) {
    const weights = {};
    var options = Object.assign({}, optsUser);
    propToArray(options, "sort");
    propToArray(options, "sort_empty");
    if (options.fields) {
      propToArray(options, "fields");
      const fields = [];
      options.fields.forEach((field) => {
        if (typeof field == "string") {
          field = { field, weight: 1 };
        }
        fields.push(field);
        weights[field.field] = "weight" in field ? field.weight : 1;
      });
      options.fields = fields;
    }
    return {
      options,
      query: query.toLowerCase().trim(),
      tokens: this.tokenize(query, options.respect_word_boundaries, weights),
      total: 0,
      items: [],
      weights,
      getAttrFn: options.nesting ? getAttrNesting : getAttr
    };
  }
  /**
   * Searches through all items and returns a sorted array of matches.
   *
   */
  search(query, options) {
    var self2 = this, score, search;
    search = this.prepareSearch(query, options);
    options = search.options;
    query = search.query;
    const fn_score = options.score || self2._getScoreFunction(search);
    if (query.length) {
      iterate$5(self2.items, (item2, id) => {
        score = fn_score(item2);
        if (options.filter === false || score > 0) {
          search.items.push({ "score": score, "id": id });
        }
      });
    } else {
      iterate$5(self2.items, (_2, id) => {
        search.items.push({ "score": 1, "id": id });
      });
    }
    const fn_sort = self2._getSortFunction(search);
    if (fn_sort)
      search.items.sort(fn_sort);
    search.total = search.items.length;
    if (typeof options.limit === "number") {
      search.items = search.items.slice(0, options.limit);
    }
    return search;
  }
}
const hash_key$1 = (value) => {
  if (typeof value === "undefined" || value === null)
    return null;
  return get_hash$1(value);
};
const get_hash$1 = (value) => {
  if (typeof value === "boolean")
    return value ? "1" : "0";
  return value + "";
};
const escape_html$1 = (str2) => {
  return (str2 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
const timeout = (fn3, timeout2) => {
  if (timeout2 > 0) {
    return window.setTimeout(fn3, timeout2);
  }
  fn3.call(null);
  return null;
};
const loadDebounce = (fn3, delay) => {
  var timeout2;
  return function(value, callback) {
    var self2 = this;
    if (timeout2) {
      self2.loading = Math.max(self2.loading - 1, 0);
      clearTimeout(timeout2);
    }
    timeout2 = setTimeout(function() {
      timeout2 = null;
      self2.loadedSearches[value] = true;
      fn3.call(self2, value, callback);
    }, delay);
  };
};
const debounce_events = (self2, types, fn3) => {
  var type;
  var trigger = self2.trigger;
  var event_args = {};
  self2.trigger = function() {
    var type2 = arguments[0];
    if (types.indexOf(type2) !== -1) {
      event_args[type2] = arguments;
    } else {
      return trigger.apply(self2, arguments);
    }
  };
  fn3.apply(self2, []);
  self2.trigger = trigger;
  for (type of types) {
    if (type in event_args) {
      trigger.apply(self2, event_args[type]);
    }
  }
};
const getSelection = (input) => {
  return {
    start: input.selectionStart || 0,
    length: (input.selectionEnd || 0) - (input.selectionStart || 0)
  };
};
const preventDefault$5 = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const addEvent$5 = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
const isKeyDown = (key_name, evt) => {
  if (!evt) {
    return false;
  }
  if (!evt[key_name]) {
    return false;
  }
  var count = (evt.altKey ? 1 : 0) + (evt.ctrlKey ? 1 : 0) + (evt.shiftKey ? 1 : 0) + (evt.metaKey ? 1 : 0);
  if (count === 1) {
    return true;
  }
  return false;
};
const getId = (el, id) => {
  const existing_id = el.getAttribute("id");
  if (existing_id) {
    return existing_id;
  }
  el.setAttribute("id", id);
  return id;
};
const addSlashes = (str2) => {
  return str2.replace(/[\\"']/g, "\\$&");
};
const append2 = (parent, node) => {
  if (node)
    parent.append(node);
};
const iterate$4 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const getDom$6 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$6(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$6 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
const escapeQuery = (query) => {
  return query.replace(/['"\\]/g, "\\$&");
};
const triggerEvent = (dom_el, event_name) => {
  var event = document.createEvent("HTMLEvents");
  event.initEvent(event_name, true, false);
  dom_el.dispatchEvent(event);
};
const applyCSS = (dom_el, css) => {
  Object.assign(dom_el.style, css);
};
const addClasses$2 = (elmts, ...classes) => {
  var norm_classes = classesArray$3(classes);
  elmts = castAsArray$3(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.add(cls);
    });
  });
};
const removeClasses$1 = (elmts, ...classes) => {
  var norm_classes = classesArray$3(classes);
  elmts = castAsArray$3(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.remove(cls);
    });
  });
};
const classesArray$3 = (args) => {
  var classes = [];
  iterate$4(args, (_classes) => {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};
const castAsArray$3 = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
const parentMatch$1 = (target, selector, wrapper) => {
  if (wrapper && !wrapper.contains(target)) {
    return;
  }
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};
const getTail = (list2, direction = 0) => {
  if (direction > 0) {
    return list2[list2.length - 1];
  }
  return list2[0];
};
const isEmptyObject = (obj) => {
  return Object.keys(obj).length === 0;
};
const nodeIndex$2 = (el, amongst) => {
  if (!el)
    return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};
const setAttr$1 = (el, attrs) => {
  iterate$4(attrs, (val, attr2) => {
    if (val == null) {
      el.removeAttribute(attr2);
    } else {
      el.setAttribute(attr2, "" + val);
    }
  });
};
const replaceNode = (existing, replacement) => {
  if (existing.parentNode)
    existing.parentNode.replaceChild(replacement, existing);
};
const highlight = (element, regex) => {
  if (regex === null)
    return;
  if (typeof regex === "string") {
    if (!regex.length)
      return;
    regex = new RegExp(regex, "i");
  }
  const highlightText = (node) => {
    var match = node.data.match(regex);
    if (match && node.data.length > 0) {
      var spannode = document.createElement("span");
      spannode.className = "highlight";
      var middlebit = node.splitText(match.index);
      middlebit.splitText(match[0].length);
      var middleclone = middlebit.cloneNode(true);
      spannode.appendChild(middleclone);
      replaceNode(middlebit, spannode);
      return 1;
    }
    return 0;
  };
  const highlightChildren = (node) => {
    if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName) && (node.className !== "highlight" || node.tagName !== "SPAN")) {
      Array.from(node.childNodes).forEach((element2) => {
        highlightRecursive(element2);
      });
    }
  };
  const highlightRecursive = (node) => {
    if (node.nodeType === 3) {
      return highlightText(node);
    }
    highlightChildren(node);
    return 0;
  };
  highlightRecursive(element);
};
const removeHighlight = (el) => {
  var elements = el.querySelectorAll("span.highlight");
  Array.prototype.forEach.call(elements, function(el2) {
    var parent = el2.parentNode;
    parent.replaceChild(el2.firstChild, el2);
    parent.normalize();
  });
};
const KEY_A = 65;
const KEY_RETURN = 13;
const KEY_ESC$1 = 27;
const KEY_LEFT$1 = 37;
const KEY_UP = 38;
const KEY_RIGHT$1 = 39;
const KEY_DOWN = 40;
const KEY_BACKSPACE = 8;
const KEY_DELETE = 46;
const KEY_TAB$1 = 9;
const IS_MAC = typeof navigator === "undefined" ? false : /Mac/.test(navigator.userAgent);
const KEY_SHORTCUT = IS_MAC ? "metaKey" : "ctrlKey";
const defaults = {
  options: [],
  optgroups: [],
  plugins: [],
  delimiter: ",",
  splitOn: null,
  // regexp or string for splitting up values from a paste command
  persist: true,
  diacritics: true,
  create: null,
  createOnBlur: false,
  createFilter: null,
  highlight: true,
  openOnFocus: true,
  shouldOpen: null,
  maxOptions: 50,
  maxItems: null,
  hideSelected: null,
  duplicates: false,
  addPrecedence: false,
  selectOnTab: false,
  preload: null,
  allowEmptyOption: false,
  //closeAfterSelect: false,
  refreshThrottle: 300,
  loadThrottle: 300,
  loadingClass: "loading",
  dataAttr: null,
  //'data-data',
  optgroupField: "optgroup",
  valueField: "value",
  labelField: "text",
  disabledField: "disabled",
  optgroupLabelField: "label",
  optgroupValueField: "value",
  lockOptgroupOrder: false,
  sortField: "$order",
  searchField: ["text"],
  searchConjunction: "and",
  mode: null,
  wrapperClass: "ts-wrapper",
  controlClass: "ts-control",
  dropdownClass: "ts-dropdown",
  dropdownContentClass: "ts-dropdown-content",
  itemClass: "item",
  optionClass: "option",
  dropdownParent: null,
  controlInput: '<input type="text" autocomplete="off" size="1" />',
  copyClassesToDropdown: false,
  placeholder: null,
  hidePlaceholder: null,
  shouldLoad: function(query) {
    return query.length > 0;
  },
  /*
  load                 : null, // function(query, callback) { ... }
  score                : null, // function(search) { ... }
  onInitialize         : null, // function() { ... }
  onChange             : null, // function(value) { ... }
  onItemAdd            : null, // function(value, $item) { ... }
  onItemRemove         : null, // function(value) { ... }
  onClear              : null, // function() { ... }
  onOptionAdd          : null, // function(value, data) { ... }
  onOptionRemove       : null, // function(value) { ... }
  onOptionClear        : null, // function() { ... }
  onOptionGroupAdd     : null, // function(id, data) { ... }
  onOptionGroupRemove  : null, // function(id) { ... }
  onOptionGroupClear   : null, // function() { ... }
  onDropdownOpen       : null, // function(dropdown) { ... }
  onDropdownClose      : null, // function(dropdown) { ... }
  onType               : null, // function(str) { ... }
  onDelete             : null, // function(values) { ... }
  */
  render: {
    /*
    item: null,
    optgroup: null,
    optgroup_header: null,
    option: null,
    option_create: null
    */
  }
};
function getSettings(input, settings_user) {
  var settings = Object.assign({}, defaults, settings_user);
  var attr_data = settings.dataAttr;
  var field_label = settings.labelField;
  var field_value = settings.valueField;
  var field_disabled = settings.disabledField;
  var field_optgroup = settings.optgroupField;
  var field_optgroup_label = settings.optgroupLabelField;
  var field_optgroup_value = settings.optgroupValueField;
  var tag_name = input.tagName.toLowerCase();
  var placeholder = input.getAttribute("placeholder") || input.getAttribute("data-placeholder");
  if (!placeholder && !settings.allowEmptyOption) {
    let option2 = input.querySelector('option[value=""]');
    if (option2) {
      placeholder = option2.textContent;
    }
  }
  var settings_element = {
    placeholder,
    options: [],
    optgroups: [],
    items: [],
    maxItems: null
  };
  var init_select = () => {
    var tagName;
    var options = settings_element.options;
    var optionsMap = {};
    var group_count = 1;
    let $order = 0;
    var readData = (el) => {
      var data2 = Object.assign({}, el.dataset);
      var json = attr_data && data2[attr_data];
      if (typeof json === "string" && json.length) {
        data2 = Object.assign(data2, JSON.parse(json));
      }
      return data2;
    };
    var addOption = (option2, group) => {
      var value = hash_key$1(option2.value);
      if (value == null)
        return;
      if (!value && !settings.allowEmptyOption)
        return;
      if (optionsMap.hasOwnProperty(value)) {
        if (group) {
          var arr = optionsMap[value][field_optgroup];
          if (!arr) {
            optionsMap[value][field_optgroup] = group;
          } else if (!Array.isArray(arr)) {
            optionsMap[value][field_optgroup] = [arr, group];
          } else {
            arr.push(group);
          }
        }
      } else {
        var option_data = readData(option2);
        option_data[field_label] = option_data[field_label] || option2.textContent;
        option_data[field_value] = option_data[field_value] || value;
        option_data[field_disabled] = option_data[field_disabled] || option2.disabled;
        option_data[field_optgroup] = option_data[field_optgroup] || group;
        option_data.$option = option2;
        option_data.$order = option_data.$order || ++$order;
        optionsMap[value] = option_data;
        options.push(option_data);
      }
      if (option2.selected) {
        settings_element.items.push(value);
      }
    };
    var addGroup = (optgroup) => {
      var id, optgroup_data;
      optgroup_data = readData(optgroup);
      optgroup_data[field_optgroup_label] = optgroup_data[field_optgroup_label] || optgroup.getAttribute("label") || "";
      optgroup_data[field_optgroup_value] = optgroup_data[field_optgroup_value] || group_count++;
      optgroup_data[field_disabled] = optgroup_data[field_disabled] || optgroup.disabled;
      optgroup_data.$order = optgroup_data.$order || ++$order;
      settings_element.optgroups.push(optgroup_data);
      id = optgroup_data[field_optgroup_value];
      iterate$4(optgroup.children, (option2) => {
        addOption(option2, id);
      });
    };
    settings_element.maxItems = input.hasAttribute("multiple") ? null : 1;
    iterate$4(input.children, (child) => {
      tagName = child.tagName.toLowerCase();
      if (tagName === "optgroup") {
        addGroup(child);
      } else if (tagName === "option") {
        addOption(child);
      }
    });
  };
  var init_textbox = () => {
    const data_raw = input.getAttribute(attr_data);
    if (!data_raw) {
      var value = input.value.trim() || "";
      if (!settings.allowEmptyOption && !value.length)
        return;
      const values = value.split(settings.delimiter);
      iterate$4(values, (value2) => {
        const option2 = {};
        option2[field_label] = value2;
        option2[field_value] = value2;
        settings_element.options.push(option2);
      });
      settings_element.items = values;
    } else {
      settings_element.options = JSON.parse(data_raw);
      iterate$4(settings_element.options, (opt) => {
        settings_element.items.push(opt[field_value]);
      });
    }
  };
  if (tag_name === "select") {
    init_select();
  } else {
    init_textbox();
  }
  return Object.assign({}, defaults, settings_element, settings_user);
}
var instance_i = 0;
class TomSelect extends MicroPlugin(MicroEvent) {
  constructor(input_arg, user_settings) {
    super();
    this.order = 0;
    this.isOpen = false;
    this.isDisabled = false;
    this.isReadOnly = false;
    this.isInvalid = false;
    this.isValid = true;
    this.isLocked = false;
    this.isFocused = false;
    this.isInputHidden = false;
    this.isSetup = false;
    this.ignoreFocus = false;
    this.ignoreHover = false;
    this.hasOptions = false;
    this.lastValue = "";
    this.caretPos = 0;
    this.loading = 0;
    this.loadedSearches = {};
    this.activeOption = null;
    this.activeItems = [];
    this.optgroups = {};
    this.options = {};
    this.userOptions = {};
    this.items = [];
    this.refreshTimeout = null;
    instance_i++;
    var dir;
    var input = getDom$6(input_arg);
    if (input.tomselect) {
      throw new Error("Tom Select already initialized on this element");
    }
    input.tomselect = this;
    var computedStyle = window.getComputedStyle && window.getComputedStyle(input, null);
    dir = computedStyle.getPropertyValue("direction");
    const settings = getSettings(input, user_settings);
    this.settings = settings;
    this.input = input;
    this.tabIndex = input.tabIndex || 0;
    this.is_select_tag = input.tagName.toLowerCase() === "select";
    this.rtl = /rtl/i.test(dir);
    this.inputId = getId(input, "tomselect-" + instance_i);
    this.isRequired = input.required;
    this.sifter = new Sifter(this.options, { diacritics: settings.diacritics });
    settings.mode = settings.mode || (settings.maxItems === 1 ? "single" : "multi");
    if (typeof settings.hideSelected !== "boolean") {
      settings.hideSelected = settings.mode === "multi";
    }
    if (typeof settings.hidePlaceholder !== "boolean") {
      settings.hidePlaceholder = settings.mode !== "multi";
    }
    var filter2 = settings.createFilter;
    if (typeof filter2 !== "function") {
      if (typeof filter2 === "string") {
        filter2 = new RegExp(filter2);
      }
      if (filter2 instanceof RegExp) {
        settings.createFilter = (input2) => filter2.test(input2);
      } else {
        settings.createFilter = (value) => {
          return this.settings.duplicates || !this.options[value];
        };
      }
    }
    this.initializePlugins(settings.plugins);
    this.setupCallbacks();
    this.setupTemplates();
    const wrapper = getDom$6("<div>");
    const control = getDom$6("<div>");
    const dropdown = this._render("dropdown");
    const dropdown_content = getDom$6(`<div role="listbox" tabindex="-1">`);
    const classes = this.input.getAttribute("class") || "";
    const inputMode = settings.mode;
    var control_input;
    addClasses$2(wrapper, settings.wrapperClass, classes, inputMode);
    addClasses$2(control, settings.controlClass);
    append2(wrapper, control);
    addClasses$2(dropdown, settings.dropdownClass, inputMode);
    if (settings.copyClassesToDropdown) {
      addClasses$2(dropdown, classes);
    }
    addClasses$2(dropdown_content, settings.dropdownContentClass);
    append2(dropdown, dropdown_content);
    getDom$6(settings.dropdownParent || wrapper).appendChild(dropdown);
    if (isHtmlString$6(settings.controlInput)) {
      control_input = getDom$6(settings.controlInput);
      var attrs = ["autocorrect", "autocapitalize", "autocomplete", "spellcheck"];
      iterate$4(attrs, (attr2) => {
        if (input.getAttribute(attr2)) {
          setAttr$1(control_input, { [attr2]: input.getAttribute(attr2) });
        }
      });
      control_input.tabIndex = -1;
      control.appendChild(control_input);
      this.focus_node = control_input;
    } else if (settings.controlInput) {
      control_input = getDom$6(settings.controlInput);
      this.focus_node = control_input;
    } else {
      control_input = getDom$6("<input/>");
      this.focus_node = control;
    }
    this.wrapper = wrapper;
    this.dropdown = dropdown;
    this.dropdown_content = dropdown_content;
    this.control = control;
    this.control_input = control_input;
    this.setup();
  }
  /**
   * set up event bindings.
   *
   */
  setup() {
    const self2 = this;
    const settings = self2.settings;
    const control_input = self2.control_input;
    const dropdown = self2.dropdown;
    const dropdown_content = self2.dropdown_content;
    const wrapper = self2.wrapper;
    const control = self2.control;
    const input = self2.input;
    const focus_node = self2.focus_node;
    const passive_event = { passive: true };
    const listboxId = self2.inputId + "-ts-dropdown";
    setAttr$1(dropdown_content, {
      id: listboxId
    });
    setAttr$1(focus_node, {
      role: "combobox",
      "aria-haspopup": "listbox",
      "aria-expanded": "false",
      "aria-controls": listboxId
    });
    const control_id = getId(focus_node, self2.inputId + "-ts-control");
    const query = "label[for='" + escapeQuery(self2.inputId) + "']";
    const label = document.querySelector(query);
    const label_click = self2.focus.bind(self2);
    if (label) {
      addEvent$5(label, "click", label_click);
      setAttr$1(label, { for: control_id });
      const label_id = getId(label, self2.inputId + "-ts-label");
      setAttr$1(focus_node, { "aria-labelledby": label_id });
      setAttr$1(dropdown_content, { "aria-labelledby": label_id });
    }
    wrapper.style.width = input.style.width;
    if (self2.plugins.names.length) {
      const classes_plugins = "plugin-" + self2.plugins.names.join(" plugin-");
      addClasses$2([wrapper, dropdown], classes_plugins);
    }
    if ((settings.maxItems === null || settings.maxItems > 1) && self2.is_select_tag) {
      setAttr$1(input, { multiple: "multiple" });
    }
    if (settings.placeholder) {
      setAttr$1(control_input, { placeholder: settings.placeholder });
    }
    if (!settings.splitOn && settings.delimiter) {
      settings.splitOn = new RegExp("\\s*" + escape_regex(settings.delimiter) + "+\\s*");
    }
    if (settings.load && settings.loadThrottle) {
      settings.load = loadDebounce(settings.load, settings.loadThrottle);
    }
    addEvent$5(dropdown, "mousemove", () => {
      self2.ignoreHover = false;
    });
    addEvent$5(dropdown, "mouseenter", (e2) => {
      var target_match = parentMatch$1(e2.target, "[data-selectable]", dropdown);
      if (target_match)
        self2.onOptionHover(e2, target_match);
    }, { capture: true });
    addEvent$5(dropdown, "click", (evt) => {
      const option2 = parentMatch$1(evt.target, "[data-selectable]");
      if (option2) {
        self2.onOptionSelect(evt, option2);
        preventDefault$5(evt, true);
      }
    });
    addEvent$5(control, "click", (evt) => {
      var target_match = parentMatch$1(evt.target, "[data-ts-item]", control);
      if (target_match && self2.onItemSelect(evt, target_match)) {
        preventDefault$5(evt, true);
        return;
      }
      if (control_input.value != "") {
        return;
      }
      self2.onClick();
      preventDefault$5(evt, true);
    });
    addEvent$5(focus_node, "keydown", (e2) => self2.onKeyDown(e2));
    addEvent$5(control_input, "keypress", (e2) => self2.onKeyPress(e2));
    addEvent$5(control_input, "input", (e2) => self2.onInput(e2));
    addEvent$5(focus_node, "blur", (e2) => self2.onBlur(e2));
    addEvent$5(focus_node, "focus", (e2) => self2.onFocus(e2));
    addEvent$5(control_input, "paste", (e2) => self2.onPaste(e2));
    const doc_mousedown = (evt) => {
      const target = evt.composedPath()[0];
      if (!wrapper.contains(target) && !dropdown.contains(target)) {
        if (self2.isFocused) {
          self2.blur();
        }
        self2.inputState();
        return;
      }
      if (target == control_input && self2.isOpen) {
        evt.stopPropagation();
      } else {
        preventDefault$5(evt, true);
      }
    };
    const win_scroll = () => {
      if (self2.isOpen) {
        self2.positionDropdown();
      }
    };
    addEvent$5(document, "mousedown", doc_mousedown);
    addEvent$5(window, "scroll", win_scroll, passive_event);
    addEvent$5(window, "resize", win_scroll, passive_event);
    this._destroy = () => {
      document.removeEventListener("mousedown", doc_mousedown);
      window.removeEventListener("scroll", win_scroll);
      window.removeEventListener("resize", win_scroll);
      if (label)
        label.removeEventListener("click", label_click);
    };
    this.revertSettings = {
      innerHTML: input.innerHTML,
      tabIndex: input.tabIndex
    };
    input.tabIndex = -1;
    input.insertAdjacentElement("afterend", self2.wrapper);
    self2.sync(false);
    settings.items = [];
    delete settings.optgroups;
    delete settings.options;
    addEvent$5(input, "invalid", () => {
      if (self2.isValid) {
        self2.isValid = false;
        self2.isInvalid = true;
        self2.refreshState();
      }
    });
    self2.updateOriginalInput();
    self2.refreshItems();
    self2.close(false);
    self2.inputState();
    self2.isSetup = true;
    if (input.disabled) {
      self2.disable();
    } else if (input.readOnly) {
      self2.setReadOnly(true);
    } else {
      self2.enable();
    }
    self2.on("change", this.onChange);
    addClasses$2(input, "tomselected", "ts-hidden-accessible");
    self2.trigger("initialize");
    if (settings.preload === true) {
      self2.preload();
    }
  }
  /**
   * Register options and optgroups
   *
   */
  setupOptions(options = [], optgroups = []) {
    this.addOptions(options);
    iterate$4(optgroups, (optgroup) => {
      this.registerOptionGroup(optgroup);
    });
  }
  /**
   * Sets up default rendering functions.
   */
  setupTemplates() {
    var self2 = this;
    var field_label = self2.settings.labelField;
    var field_optgroup = self2.settings.optgroupLabelField;
    var templates = {
      "optgroup": (data2) => {
        let optgroup = document.createElement("div");
        optgroup.className = "optgroup";
        optgroup.appendChild(data2.options);
        return optgroup;
      },
      "optgroup_header": (data2, escape) => {
        return '<div class="optgroup-header">' + escape(data2[field_optgroup]) + "</div>";
      },
      "option": (data2, escape) => {
        return "<div>" + escape(data2[field_label]) + "</div>";
      },
      "item": (data2, escape) => {
        return "<div>" + escape(data2[field_label]) + "</div>";
      },
      "option_create": (data2, escape) => {
        return '<div class="create">Add <strong>' + escape(data2.input) + "</strong>&hellip;</div>";
      },
      "no_results": () => {
        return '<div class="no-results">No results found</div>';
      },
      "loading": () => {
        return '<div class="spinner"></div>';
      },
      "not_loading": () => {
      },
      "dropdown": () => {
        return "<div></div>";
      }
    };
    self2.settings.render = Object.assign({}, templates, self2.settings.render);
  }
  /**
   * Maps fired events to callbacks provided
   * in the settings used when creating the control.
   */
  setupCallbacks() {
    var key, fn3;
    var callbacks = {
      "initialize": "onInitialize",
      "change": "onChange",
      "item_add": "onItemAdd",
      "item_remove": "onItemRemove",
      "item_select": "onItemSelect",
      "clear": "onClear",
      "option_add": "onOptionAdd",
      "option_remove": "onOptionRemove",
      "option_clear": "onOptionClear",
      "optgroup_add": "onOptionGroupAdd",
      "optgroup_remove": "onOptionGroupRemove",
      "optgroup_clear": "onOptionGroupClear",
      "dropdown_open": "onDropdownOpen",
      "dropdown_close": "onDropdownClose",
      "type": "onType",
      "load": "onLoad",
      "focus": "onFocus",
      "blur": "onBlur"
    };
    for (key in callbacks) {
      fn3 = this.settings[callbacks[key]];
      if (fn3)
        this.on(key, fn3);
    }
  }
  /**
   * Sync the Tom Select instance with the original input or select
   *
   */
  sync(get_settings = true) {
    const self2 = this;
    const settings = get_settings ? getSettings(self2.input, { delimiter: self2.settings.delimiter }) : self2.settings;
    self2.setupOptions(settings.options, settings.optgroups);
    self2.setValue(settings.items || [], true);
    self2.lastQuery = null;
  }
  /**
   * Triggered when the main control element
   * has a click event.
   *
   */
  onClick() {
    var self2 = this;
    if (self2.activeItems.length > 0) {
      self2.clearActiveItems();
      self2.focus();
      return;
    }
    if (self2.isFocused && self2.isOpen) {
      self2.blur();
    } else {
      self2.focus();
    }
  }
  /**
   * @deprecated v1.7
   *
   */
  onMouseDown() {
  }
  /**
   * Triggered when the value of the control has been changed.
   * This should propagate the event to the original DOM
   * input / select element.
   */
  onChange() {
    triggerEvent(this.input, "input");
    triggerEvent(this.input, "change");
  }
  /**
   * Triggered on <input> paste.
   *
   */
  onPaste(e2) {
    var self2 = this;
    if (self2.isInputHidden || self2.isLocked) {
      preventDefault$5(e2);
      return;
    }
    if (!self2.settings.splitOn) {
      return;
    }
    setTimeout(() => {
      var pastedText = self2.inputValue();
      if (!pastedText.match(self2.settings.splitOn)) {
        return;
      }
      var splitInput = pastedText.trim().split(self2.settings.splitOn);
      iterate$4(splitInput, (piece) => {
        const hash2 = hash_key$1(piece);
        if (hash2) {
          if (this.options[piece]) {
            self2.addItem(piece);
          } else {
            self2.createItem(piece);
          }
        }
      });
    }, 0);
  }
  /**
   * Triggered on <input> keypress.
   *
   */
  onKeyPress(e2) {
    var self2 = this;
    if (self2.isLocked) {
      preventDefault$5(e2);
      return;
    }
    var character = String.fromCharCode(e2.keyCode || e2.which);
    if (self2.settings.create && self2.settings.mode === "multi" && character === self2.settings.delimiter) {
      self2.createItem();
      preventDefault$5(e2);
      return;
    }
  }
  /**
   * Triggered on <input> keydown.
   *
   */
  onKeyDown(e2) {
    var self2 = this;
    self2.ignoreHover = true;
    if (self2.isLocked) {
      if (e2.keyCode !== KEY_TAB$1) {
        preventDefault$5(e2);
      }
      return;
    }
    switch (e2.keyCode) {
      case KEY_A:
        if (isKeyDown(KEY_SHORTCUT, e2)) {
          if (self2.control_input.value == "") {
            preventDefault$5(e2);
            self2.selectAll();
            return;
          }
        }
        break;
      case KEY_ESC$1:
        if (self2.isOpen) {
          preventDefault$5(e2, true);
          self2.close();
        }
        self2.clearActiveItems();
        return;
      case KEY_DOWN:
        if (!self2.isOpen && self2.hasOptions) {
          self2.open();
        } else if (self2.activeOption) {
          let next = self2.getAdjacent(self2.activeOption, 1);
          if (next)
            self2.setActiveOption(next);
        }
        preventDefault$5(e2);
        return;
      case KEY_UP:
        if (self2.activeOption) {
          let prev = self2.getAdjacent(self2.activeOption, -1);
          if (prev)
            self2.setActiveOption(prev);
        }
        preventDefault$5(e2);
        return;
      case KEY_RETURN:
        if (self2.canSelect(self2.activeOption)) {
          self2.onOptionSelect(e2, self2.activeOption);
          preventDefault$5(e2);
        } else if (self2.settings.create && self2.createItem()) {
          preventDefault$5(e2);
        } else if (document.activeElement == self2.control_input && self2.isOpen) {
          preventDefault$5(e2);
        }
        return;
      case KEY_LEFT$1:
        self2.advanceSelection(-1, e2);
        return;
      case KEY_RIGHT$1:
        self2.advanceSelection(1, e2);
        return;
      case KEY_TAB$1:
        if (self2.settings.selectOnTab) {
          if (self2.canSelect(self2.activeOption)) {
            self2.onOptionSelect(e2, self2.activeOption);
            preventDefault$5(e2);
          }
          if (self2.settings.create && self2.createItem()) {
            preventDefault$5(e2);
          }
        }
        return;
      case KEY_BACKSPACE:
      case KEY_DELETE:
        self2.deleteSelection(e2);
        return;
    }
    if (self2.isInputHidden && !isKeyDown(KEY_SHORTCUT, e2)) {
      preventDefault$5(e2);
    }
  }
  /**
   * Triggered on <input> keyup.
   *
   */
  onInput(e2) {
    if (this.isLocked) {
      return;
    }
    const value = this.inputValue();
    if (this.lastValue === value)
      return;
    this.lastValue = value;
    if (value == "") {
      this._onInput();
      return;
    }
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
    }
    this.refreshTimeout = timeout(() => {
      this.refreshTimeout = null;
      this._onInput();
    }, this.settings.refreshThrottle);
  }
  _onInput() {
    const value = this.lastValue;
    if (this.settings.shouldLoad.call(this, value)) {
      this.load(value);
    }
    this.refreshOptions();
    this.trigger("type", value);
  }
  /**
   * Triggered when the user rolls over
   * an option in the autocomplete dropdown menu.
   *
   */
  onOptionHover(evt, option2) {
    if (this.ignoreHover)
      return;
    this.setActiveOption(option2, false);
  }
  /**
   * Triggered on <input> focus.
   *
   */
  onFocus(e2) {
    var self2 = this;
    var wasFocused = self2.isFocused;
    if (self2.isDisabled || self2.isReadOnly) {
      self2.blur();
      preventDefault$5(e2);
      return;
    }
    if (self2.ignoreFocus)
      return;
    self2.isFocused = true;
    if (self2.settings.preload === "focus")
      self2.preload();
    if (!wasFocused)
      self2.trigger("focus");
    if (!self2.activeItems.length) {
      self2.inputState();
      self2.refreshOptions(!!self2.settings.openOnFocus);
    }
    self2.refreshState();
  }
  /**
   * Triggered on <input> blur.
   *
   */
  onBlur(e2) {
    if (document.hasFocus() === false)
      return;
    var self2 = this;
    if (!self2.isFocused)
      return;
    self2.isFocused = false;
    self2.ignoreFocus = false;
    var deactivate = () => {
      self2.close();
      self2.setActiveItem();
      self2.setCaret(self2.items.length);
      self2.trigger("blur");
    };
    if (self2.settings.create && self2.settings.createOnBlur) {
      self2.createItem(null, deactivate);
    } else {
      deactivate();
    }
  }
  /**
   * Triggered when the user clicks on an option
   * in the autocomplete dropdown menu.
   *
   */
  onOptionSelect(evt, option2) {
    var value, self2 = this;
    if (option2.parentElement && option2.parentElement.matches("[data-disabled]")) {
      return;
    }
    if (option2.classList.contains("create")) {
      self2.createItem(null, () => {
        if (self2.settings.closeAfterSelect) {
          self2.close();
        }
      });
    } else {
      value = option2.dataset.value;
      if (typeof value !== "undefined") {
        self2.lastQuery = null;
        self2.addItem(value);
        if (self2.settings.closeAfterSelect) {
          self2.close();
        }
        if (!self2.settings.hideSelected && evt.type && /click/.test(evt.type)) {
          self2.setActiveOption(option2);
        }
      }
    }
  }
  /**
   * Return true if the given option can be selected
   *
   */
  canSelect(option2) {
    if (this.isOpen && option2 && this.dropdown_content.contains(option2)) {
      return true;
    }
    return false;
  }
  /**
   * Triggered when the user clicks on an item
   * that has been selected.
   *
   */
  onItemSelect(evt, item2) {
    var self2 = this;
    if (!self2.isLocked && self2.settings.mode === "multi") {
      preventDefault$5(evt);
      self2.setActiveItem(item2, evt);
      return true;
    }
    return false;
  }
  /**
   * Determines whether or not to invoke
   * the user-provided option provider / loader
   *
   * Note, there is a subtle difference between
   * this.canLoad() and this.settings.shouldLoad();
   *
   *	- settings.shouldLoad() is a user-input validator.
   *	When false is returned, the not_loading template
   *	will be added to the dropdown
   *
   *	- canLoad() is lower level validator that checks
   * 	the Tom Select instance. There is no inherent user
   *	feedback when canLoad returns false
   *
   */
  canLoad(value) {
    if (!this.settings.load)
      return false;
    if (this.loadedSearches.hasOwnProperty(value))
      return false;
    return true;
  }
  /**
   * Invokes the user-provided option provider / loader.
   *
   */
  load(value) {
    const self2 = this;
    if (!self2.canLoad(value))
      return;
    addClasses$2(self2.wrapper, self2.settings.loadingClass);
    self2.loading++;
    const callback = self2.loadCallback.bind(self2);
    self2.settings.load.call(self2, value, callback);
  }
  /**
   * Invoked by the user-provided option provider
   *
   */
  loadCallback(options, optgroups) {
    const self2 = this;
    self2.loading = Math.max(self2.loading - 1, 0);
    self2.lastQuery = null;
    self2.clearActiveOption();
    self2.setupOptions(options, optgroups);
    self2.refreshOptions(self2.isFocused && !self2.isInputHidden);
    if (!self2.loading) {
      removeClasses$1(self2.wrapper, self2.settings.loadingClass);
    }
    self2.trigger("load", options, optgroups);
  }
  preload() {
    var classList = this.wrapper.classList;
    if (classList.contains("preloaded"))
      return;
    classList.add("preloaded");
    this.load("");
  }
  /**
   * Sets the input field of the control to the specified value.
   *
   */
  setTextboxValue(value = "") {
    var input = this.control_input;
    var changed = input.value !== value;
    if (changed) {
      input.value = value;
      triggerEvent(input, "update");
      this.lastValue = value;
    }
  }
  /**
   * Returns the value of the control. If multiple items
   * can be selected (e.g. <select multiple>), this returns
   * an array. If only one item can be selected, this
   * returns a string.
   *
   */
  getValue() {
    if (this.is_select_tag && this.input.hasAttribute("multiple")) {
      return this.items;
    }
    return this.items.join(this.settings.delimiter);
  }
  /**
   * Resets the selected items to the given value.
   *
   */
  setValue(value, silent) {
    var events = silent ? [] : ["change"];
    debounce_events(this, events, () => {
      this.clear(silent);
      this.addItems(value, silent);
    });
  }
  /**
   * Resets the number of max items to the given value
   *
   */
  setMaxItems(value) {
    if (value === 0)
      value = null;
    this.settings.maxItems = value;
    this.refreshState();
  }
  /**
   * Sets the selected item.
   *
   */
  setActiveItem(item2, e2) {
    var self2 = this;
    var eventName;
    var i, begin, end2, swap;
    var last;
    if (self2.settings.mode === "single")
      return;
    if (!item2) {
      self2.clearActiveItems();
      if (self2.isFocused) {
        self2.inputState();
      }
      return;
    }
    eventName = e2 && e2.type.toLowerCase();
    if (eventName === "click" && isKeyDown("shiftKey", e2) && self2.activeItems.length) {
      last = self2.getLastActive();
      begin = Array.prototype.indexOf.call(self2.control.children, last);
      end2 = Array.prototype.indexOf.call(self2.control.children, item2);
      if (begin > end2) {
        swap = begin;
        begin = end2;
        end2 = swap;
      }
      for (i = begin; i <= end2; i++) {
        item2 = self2.control.children[i];
        if (self2.activeItems.indexOf(item2) === -1) {
          self2.setActiveItemClass(item2);
        }
      }
      preventDefault$5(e2);
    } else if (eventName === "click" && isKeyDown(KEY_SHORTCUT, e2) || eventName === "keydown" && isKeyDown("shiftKey", e2)) {
      if (item2.classList.contains("active")) {
        self2.removeActiveItem(item2);
      } else {
        self2.setActiveItemClass(item2);
      }
    } else {
      self2.clearActiveItems();
      self2.setActiveItemClass(item2);
    }
    self2.inputState();
    if (!self2.isFocused) {
      self2.focus();
    }
  }
  /**
   * Set the active and last-active classes
   *
   */
  setActiveItemClass(item2) {
    const self2 = this;
    const last_active = self2.control.querySelector(".last-active");
    if (last_active)
      removeClasses$1(last_active, "last-active");
    addClasses$2(item2, "active last-active");
    self2.trigger("item_select", item2);
    if (self2.activeItems.indexOf(item2) == -1) {
      self2.activeItems.push(item2);
    }
  }
  /**
   * Remove active item
   *
   */
  removeActiveItem(item2) {
    var idx = this.activeItems.indexOf(item2);
    this.activeItems.splice(idx, 1);
    removeClasses$1(item2, "active");
  }
  /**
   * Clears all the active items
   *
   */
  clearActiveItems() {
    removeClasses$1(this.activeItems, "active");
    this.activeItems = [];
  }
  /**
   * Sets the selected item in the dropdown menu
   * of available options.
   *
   */
  setActiveOption(option2, scroll = true) {
    if (option2 === this.activeOption) {
      return;
    }
    this.clearActiveOption();
    if (!option2)
      return;
    this.activeOption = option2;
    setAttr$1(this.focus_node, { "aria-activedescendant": option2.getAttribute("id") });
    setAttr$1(option2, { "aria-selected": "true" });
    addClasses$2(option2, "active");
    if (scroll)
      this.scrollToOption(option2);
  }
  /**
   * Sets the dropdown_content scrollTop to display the option
   *
   */
  scrollToOption(option2, behavior) {
    if (!option2)
      return;
    const content = this.dropdown_content;
    const height_menu = content.clientHeight;
    const scrollTop = content.scrollTop || 0;
    const height_item = option2.offsetHeight;
    const y2 = option2.getBoundingClientRect().top - content.getBoundingClientRect().top + scrollTop;
    if (y2 + height_item > height_menu + scrollTop) {
      this.scroll(y2 - height_menu + height_item, behavior);
    } else if (y2 < scrollTop) {
      this.scroll(y2, behavior);
    }
  }
  /**
   * Scroll the dropdown to the given position
   *
   */
  scroll(scrollTop, behavior) {
    const content = this.dropdown_content;
    if (behavior) {
      content.style.scrollBehavior = behavior;
    }
    content.scrollTop = scrollTop;
    content.style.scrollBehavior = "";
  }
  /**
   * Clears the active option
   *
   */
  clearActiveOption() {
    if (this.activeOption) {
      removeClasses$1(this.activeOption, "active");
      setAttr$1(this.activeOption, { "aria-selected": null });
    }
    this.activeOption = null;
    setAttr$1(this.focus_node, { "aria-activedescendant": null });
  }
  /**
   * Selects all items (CTRL + A).
   */
  selectAll() {
    const self2 = this;
    if (self2.settings.mode === "single")
      return;
    const activeItems = self2.controlChildren();
    if (!activeItems.length)
      return;
    self2.inputState();
    self2.close();
    self2.activeItems = activeItems;
    iterate$4(activeItems, (item2) => {
      self2.setActiveItemClass(item2);
    });
  }
  /**
   * Determines if the control_input should be in a hidden or visible state
   *
   */
  inputState() {
    var self2 = this;
    if (!self2.control.contains(self2.control_input))
      return;
    setAttr$1(self2.control_input, { placeholder: self2.settings.placeholder });
    if (self2.activeItems.length > 0 || !self2.isFocused && self2.settings.hidePlaceholder && self2.items.length > 0) {
      self2.setTextboxValue();
      self2.isInputHidden = true;
    } else {
      if (self2.settings.hidePlaceholder && self2.items.length > 0) {
        setAttr$1(self2.control_input, { placeholder: "" });
      }
      self2.isInputHidden = false;
    }
    self2.wrapper.classList.toggle("input-hidden", self2.isInputHidden);
  }
  /**
   * Get the input value
   */
  inputValue() {
    return this.control_input.value.trim();
  }
  /**
   * Gives the control focus.
   */
  focus() {
    var self2 = this;
    if (self2.isDisabled || self2.isReadOnly)
      return;
    self2.ignoreFocus = true;
    if (self2.control_input.offsetWidth) {
      self2.control_input.focus();
    } else {
      self2.focus_node.focus();
    }
    setTimeout(() => {
      self2.ignoreFocus = false;
      self2.onFocus();
    }, 0);
  }
  /**
   * Forces the control out of focus.
   *
   */
  blur() {
    this.focus_node.blur();
    this.onBlur();
  }
  /**
   * Returns a function that scores an object
   * to show how good of a match it is to the
   * provided query.
   *
   * @return {function}
   */
  getScoreFunction(query) {
    return this.sifter.getScoreFunction(query, this.getSearchOptions());
  }
  /**
   * Returns search options for sifter (the system
   * for scoring and sorting results).
   *
   * @see https://github.com/orchidjs/sifter.js
   * @return {object}
   */
  getSearchOptions() {
    var settings = this.settings;
    var sort = settings.sortField;
    if (typeof settings.sortField === "string") {
      sort = [{ field: settings.sortField }];
    }
    return {
      fields: settings.searchField,
      conjunction: settings.searchConjunction,
      sort,
      nesting: settings.nesting
    };
  }
  /**
   * Searches through available options and returns
   * a sorted array of matches.
   *
   */
  search(query) {
    var result, calculateScore;
    var self2 = this;
    var options = this.getSearchOptions();
    if (self2.settings.score) {
      calculateScore = self2.settings.score.call(self2, query);
      if (typeof calculateScore !== "function") {
        throw new Error('Tom Select "score" setting must be a function that returns a function');
      }
    }
    if (query !== self2.lastQuery) {
      self2.lastQuery = query;
      result = self2.sifter.search(query, Object.assign(options, { score: calculateScore }));
      self2.currentResults = result;
    } else {
      result = Object.assign({}, self2.currentResults);
    }
    if (self2.settings.hideSelected) {
      result.items = result.items.filter((item2) => {
        let hashed = hash_key$1(item2.id);
        return !(hashed && self2.items.indexOf(hashed) !== -1);
      });
    }
    return result;
  }
  /**
   * Refreshes the list of available options shown
   * in the autocomplete dropdown menu.
   *
   */
  refreshOptions(triggerDropdown = true) {
    var i, j2, k2, n2, optgroup, optgroups, html, has_create_option, active_group;
    var create2;
    const groups = {};
    const groups_order = [];
    var self2 = this;
    var query = self2.inputValue();
    const same_query = query === self2.lastQuery || query == "" && self2.lastQuery == null;
    var results = self2.search(query);
    var active_option = null;
    var show_dropdown = self2.settings.shouldOpen || false;
    var dropdown_content = self2.dropdown_content;
    if (same_query) {
      active_option = self2.activeOption;
      if (active_option) {
        active_group = active_option.closest("[data-group]");
      }
    }
    n2 = results.items.length;
    if (typeof self2.settings.maxOptions === "number") {
      n2 = Math.min(n2, self2.settings.maxOptions);
    }
    if (n2 > 0) {
      show_dropdown = true;
    }
    const getGroupFragment = (optgroup2, order2) => {
      let group_order_i = groups[optgroup2];
      if (group_order_i !== void 0) {
        let order_group = groups_order[group_order_i];
        if (order_group !== void 0) {
          return [group_order_i, order_group.fragment];
        }
      }
      let group_fragment = document.createDocumentFragment();
      group_order_i = groups_order.length;
      groups_order.push({ fragment: group_fragment, order: order2, optgroup: optgroup2 });
      return [group_order_i, group_fragment];
    };
    for (i = 0; i < n2; i++) {
      let item2 = results.items[i];
      if (!item2)
        continue;
      let opt_value = item2.id;
      let option2 = self2.options[opt_value];
      if (option2 === void 0)
        continue;
      let opt_hash = get_hash$1(opt_value);
      let option_el = self2.getOption(opt_hash, true);
      if (!self2.settings.hideSelected) {
        option_el.classList.toggle("selected", self2.items.includes(opt_hash));
      }
      optgroup = option2[self2.settings.optgroupField] || "";
      optgroups = Array.isArray(optgroup) ? optgroup : [optgroup];
      for (j2 = 0, k2 = optgroups && optgroups.length; j2 < k2; j2++) {
        optgroup = optgroups[j2];
        let order2 = option2.$order;
        let self_optgroup = self2.optgroups[optgroup];
        if (self_optgroup === void 0) {
          optgroup = "";
        } else {
          order2 = self_optgroup.$order;
        }
        const [group_order_i, group_fragment] = getGroupFragment(optgroup, order2);
        if (j2 > 0) {
          option_el = option_el.cloneNode(true);
          setAttr$1(option_el, { id: option2.$id + "-clone-" + j2, "aria-selected": null });
          option_el.classList.add("ts-cloned");
          removeClasses$1(option_el, "active");
          if (self2.activeOption && self2.activeOption.dataset.value == opt_value) {
            if (active_group && active_group.dataset.group === optgroup.toString()) {
              active_option = option_el;
            }
          }
        }
        group_fragment.appendChild(option_el);
        if (optgroup != "") {
          groups[optgroup] = group_order_i;
        }
      }
    }
    if (self2.settings.lockOptgroupOrder) {
      groups_order.sort((a2, b2) => {
        return a2.order - b2.order;
      });
    }
    html = document.createDocumentFragment();
    iterate$4(groups_order, (group_order) => {
      let group_fragment = group_order.fragment;
      let optgroup2 = group_order.optgroup;
      if (!group_fragment || !group_fragment.children.length)
        return;
      let group_heading = self2.optgroups[optgroup2];
      if (group_heading !== void 0) {
        let group_options = document.createDocumentFragment();
        let header = self2.render("optgroup_header", group_heading);
        append2(group_options, header);
        append2(group_options, group_fragment);
        let group_html = self2.render("optgroup", { group: group_heading, options: group_options });
        append2(html, group_html);
      } else {
        append2(html, group_fragment);
      }
    });
    dropdown_content.innerHTML = "";
    append2(dropdown_content, html);
    if (self2.settings.highlight) {
      removeHighlight(dropdown_content);
      if (results.query.length && results.tokens.length) {
        iterate$4(results.tokens, (tok) => {
          highlight(dropdown_content, tok.regex);
        });
      }
    }
    var add_template = (template) => {
      let content = self2.render(template, { input: query });
      if (content) {
        show_dropdown = true;
        dropdown_content.insertBefore(content, dropdown_content.firstChild);
      }
      return content;
    };
    if (self2.loading) {
      add_template("loading");
    } else if (!self2.settings.shouldLoad.call(self2, query)) {
      add_template("not_loading");
    } else if (results.items.length === 0) {
      add_template("no_results");
    }
    has_create_option = self2.canCreate(query);
    if (has_create_option) {
      create2 = add_template("option_create");
    }
    self2.hasOptions = results.items.length > 0 || has_create_option;
    if (show_dropdown) {
      if (results.items.length > 0) {
        if (!active_option && self2.settings.mode === "single" && self2.items[0] != void 0) {
          active_option = self2.getOption(self2.items[0]);
        }
        if (!dropdown_content.contains(active_option)) {
          let active_index = 0;
          if (create2 && !self2.settings.addPrecedence) {
            active_index = 1;
          }
          active_option = self2.selectable()[active_index];
        }
      } else if (create2) {
        active_option = create2;
      }
      if (triggerDropdown && !self2.isOpen) {
        self2.open();
        self2.scrollToOption(active_option, "auto");
      }
      self2.setActiveOption(active_option);
    } else {
      self2.clearActiveOption();
      if (triggerDropdown && self2.isOpen) {
        self2.close(false);
      }
    }
  }
  /**
   * Return list of selectable options
   *
   */
  selectable() {
    return this.dropdown_content.querySelectorAll("[data-selectable]");
  }
  /**
   * Adds an available option. If it already exists,
   * nothing will happen. Note: this does not refresh
   * the options list dropdown (use `refreshOptions`
   * for that).
   *
   * Usage:
   *
   *   this.addOption(data)
   *
   */
  addOption(data2, user_created = false) {
    const self2 = this;
    if (Array.isArray(data2)) {
      self2.addOptions(data2, user_created);
      return false;
    }
    const key = hash_key$1(data2[self2.settings.valueField]);
    if (key === null || self2.options.hasOwnProperty(key)) {
      return false;
    }
    data2.$order = data2.$order || ++self2.order;
    data2.$id = self2.inputId + "-opt-" + data2.$order;
    self2.options[key] = data2;
    self2.lastQuery = null;
    if (user_created) {
      self2.userOptions[key] = user_created;
      self2.trigger("option_add", key, data2);
    }
    return key;
  }
  /**
   * Add multiple options
   *
   */
  addOptions(data2, user_created = false) {
    iterate$4(data2, (dat) => {
      this.addOption(dat, user_created);
    });
  }
  /**
   * @deprecated 1.7.7
   */
  registerOption(data2) {
    return this.addOption(data2);
  }
  /**
   * Registers an option group to the pool of option groups.
   *
   * @return {boolean|string}
   */
  registerOptionGroup(data2) {
    var key = hash_key$1(data2[this.settings.optgroupValueField]);
    if (key === null)
      return false;
    data2.$order = data2.$order || ++this.order;
    this.optgroups[key] = data2;
    return key;
  }
  /**
   * Registers a new optgroup for options
   * to be bucketed into.
   *
   */
  addOptionGroup(id, data2) {
    var hashed_id;
    data2[this.settings.optgroupValueField] = id;
    if (hashed_id = this.registerOptionGroup(data2)) {
      this.trigger("optgroup_add", hashed_id, data2);
    }
  }
  /**
   * Removes an existing option group.
   *
   */
  removeOptionGroup(id) {
    if (this.optgroups.hasOwnProperty(id)) {
      delete this.optgroups[id];
      this.clearCache();
      this.trigger("optgroup_remove", id);
    }
  }
  /**
   * Clears all existing option groups.
   */
  clearOptionGroups() {
    this.optgroups = {};
    this.clearCache();
    this.trigger("optgroup_clear");
  }
  /**
   * Updates an option available for selection. If
   * it is visible in the selected items or options
   * dropdown, it will be re-rendered automatically.
   *
   */
  updateOption(value, data2) {
    const self2 = this;
    var item_new;
    var index_item;
    const value_old = hash_key$1(value);
    const value_new = hash_key$1(data2[self2.settings.valueField]);
    if (value_old === null)
      return;
    const data_old = self2.options[value_old];
    if (data_old == void 0)
      return;
    if (typeof value_new !== "string")
      throw new Error("Value must be set in option data");
    const option2 = self2.getOption(value_old);
    const item2 = self2.getItem(value_old);
    data2.$order = data2.$order || data_old.$order;
    delete self2.options[value_old];
    self2.uncacheValue(value_new);
    self2.options[value_new] = data2;
    if (option2) {
      if (self2.dropdown_content.contains(option2)) {
        const option_new = self2._render("option", data2);
        replaceNode(option2, option_new);
        if (self2.activeOption === option2) {
          self2.setActiveOption(option_new);
        }
      }
      option2.remove();
    }
    if (item2) {
      index_item = self2.items.indexOf(value_old);
      if (index_item !== -1) {
        self2.items.splice(index_item, 1, value_new);
      }
      item_new = self2._render("item", data2);
      if (item2.classList.contains("active"))
        addClasses$2(item_new, "active");
      replaceNode(item2, item_new);
    }
    self2.lastQuery = null;
  }
  /**
   * Removes a single option.
   *
   */
  removeOption(value, silent) {
    const self2 = this;
    value = get_hash$1(value);
    self2.uncacheValue(value);
    delete self2.userOptions[value];
    delete self2.options[value];
    self2.lastQuery = null;
    self2.trigger("option_remove", value);
    self2.removeItem(value, silent);
  }
  /**
   * Clears all options.
   */
  clearOptions(filter2) {
    const boundFilter = (filter2 || this.clearFilter).bind(this);
    this.loadedSearches = {};
    this.userOptions = {};
    this.clearCache();
    const selected = {};
    iterate$4(this.options, (option2, key) => {
      if (boundFilter(option2, key)) {
        selected[key] = option2;
      }
    });
    this.options = this.sifter.items = selected;
    this.lastQuery = null;
    this.trigger("option_clear");
  }
  /**
   * Used by clearOptions() to decide whether or not an option should be removed
   * Return true to keep an option, false to remove
   *
   */
  clearFilter(option2, value) {
    if (this.items.indexOf(value) >= 0) {
      return true;
    }
    return false;
  }
  /**
   * Returns the dom element of the option
   * matching the given value.
   *
   */
  getOption(value, create2 = false) {
    const hashed = hash_key$1(value);
    if (hashed === null)
      return null;
    const option2 = this.options[hashed];
    if (option2 != void 0) {
      if (option2.$div) {
        return option2.$div;
      }
      if (create2) {
        return this._render("option", option2);
      }
    }
    return null;
  }
  /**
   * Returns the dom element of the next or previous dom element of the same type
   * Note: adjacent options may not be adjacent DOM elements (optgroups)
   *
   */
  getAdjacent(option2, direction, type = "option") {
    var self2 = this, all2;
    if (!option2) {
      return null;
    }
    if (type == "item") {
      all2 = self2.controlChildren();
    } else {
      all2 = self2.dropdown_content.querySelectorAll("[data-selectable]");
    }
    for (let i = 0; i < all2.length; i++) {
      if (all2[i] != option2) {
        continue;
      }
      if (direction > 0) {
        return all2[i + 1];
      }
      return all2[i - 1];
    }
    return null;
  }
  /**
   * Returns the dom element of the item
   * matching the given value.
   *
   */
  getItem(item2) {
    if (typeof item2 == "object") {
      return item2;
    }
    var value = hash_key$1(item2);
    return value !== null ? this.control.querySelector(`[data-value="${addSlashes(value)}"]`) : null;
  }
  /**
   * "Selects" multiple items at once. Adds them to the list
   * at the current caret position.
   *
   */
  addItems(values, silent) {
    var self2 = this;
    var items = Array.isArray(values) ? values : [values];
    items = items.filter((x2) => self2.items.indexOf(x2) === -1);
    const last_item = items[items.length - 1];
    items.forEach((item2) => {
      self2.isPending = item2 !== last_item;
      self2.addItem(item2, silent);
    });
  }
  /**
   * "Selects" an item. Adds it to the list
   * at the current caret position.
   *
   */
  addItem(value, silent) {
    var events = silent ? [] : ["change", "dropdown_close"];
    debounce_events(this, events, () => {
      var item2, wasFull;
      const self2 = this;
      const inputMode = self2.settings.mode;
      const hashed = hash_key$1(value);
      if (hashed && self2.items.indexOf(hashed) !== -1) {
        if (inputMode === "single") {
          self2.close();
        }
        if (inputMode === "single" || !self2.settings.duplicates) {
          return;
        }
      }
      if (hashed === null || !self2.options.hasOwnProperty(hashed))
        return;
      if (inputMode === "single")
        self2.clear(silent);
      if (inputMode === "multi" && self2.isFull())
        return;
      item2 = self2._render("item", self2.options[hashed]);
      if (self2.control.contains(item2)) {
        item2 = item2.cloneNode(true);
      }
      wasFull = self2.isFull();
      self2.items.splice(self2.caretPos, 0, hashed);
      self2.insertAtCaret(item2);
      if (self2.isSetup) {
        if (!self2.isPending && self2.settings.hideSelected) {
          let option2 = self2.getOption(hashed);
          let next = self2.getAdjacent(option2, 1);
          if (next) {
            self2.setActiveOption(next);
          }
        }
        if (!self2.isPending && !self2.settings.closeAfterSelect) {
          self2.refreshOptions(self2.isFocused && inputMode !== "single");
        }
        if (self2.settings.closeAfterSelect != false && self2.isFull()) {
          self2.close();
        } else if (!self2.isPending) {
          self2.positionDropdown();
        }
        self2.trigger("item_add", hashed, item2);
        if (!self2.isPending) {
          self2.updateOriginalInput({ silent });
        }
      }
      if (!self2.isPending || !wasFull && self2.isFull()) {
        self2.inputState();
        self2.refreshState();
      }
    });
  }
  /**
   * Removes the selected item matching
   * the provided value.
   *
   */
  removeItem(item2 = null, silent) {
    const self2 = this;
    item2 = self2.getItem(item2);
    if (!item2)
      return;
    var i, idx;
    const value = item2.dataset.value;
    i = nodeIndex$2(item2);
    item2.remove();
    if (item2.classList.contains("active")) {
      idx = self2.activeItems.indexOf(item2);
      self2.activeItems.splice(idx, 1);
      removeClasses$1(item2, "active");
    }
    self2.items.splice(i, 1);
    self2.lastQuery = null;
    if (!self2.settings.persist && self2.userOptions.hasOwnProperty(value)) {
      self2.removeOption(value, silent);
    }
    if (i < self2.caretPos) {
      self2.setCaret(self2.caretPos - 1);
    }
    self2.updateOriginalInput({ silent });
    self2.refreshState();
    self2.positionDropdown();
    self2.trigger("item_remove", value, item2);
  }
  /**
   * Invokes the `create` method provided in the
   * TomSelect options that should provide the data
   * for the new item, given the user input.
   *
   * Once this completes, it will be added
   * to the item list.
   *
   */
  createItem(input = null, callback = () => {
  }) {
    if (arguments.length === 3) {
      callback = arguments[2];
    }
    if (typeof callback != "function") {
      callback = () => {
      };
    }
    var self2 = this;
    var caret = self2.caretPos;
    var output;
    input = input || self2.inputValue();
    if (!self2.canCreate(input)) {
      callback();
      return false;
    }
    self2.lock();
    var created = false;
    var create2 = (data2) => {
      self2.unlock();
      if (!data2 || typeof data2 !== "object")
        return callback();
      var value = hash_key$1(data2[self2.settings.valueField]);
      if (typeof value !== "string") {
        return callback();
      }
      self2.setTextboxValue();
      self2.addOption(data2, true);
      self2.setCaret(caret);
      self2.addItem(value);
      callback(data2);
      created = true;
    };
    if (typeof self2.settings.create === "function") {
      output = self2.settings.create.call(this, input, create2);
    } else {
      output = {
        [self2.settings.labelField]: input,
        [self2.settings.valueField]: input
      };
    }
    if (!created) {
      create2(output);
    }
    return true;
  }
  /**
   * Re-renders the selected item lists.
   */
  refreshItems() {
    var self2 = this;
    self2.lastQuery = null;
    if (self2.isSetup) {
      self2.addItems(self2.items);
    }
    self2.updateOriginalInput();
    self2.refreshState();
  }
  /**
   * Updates all state-dependent attributes
   * and CSS classes.
   */
  refreshState() {
    const self2 = this;
    self2.refreshValidityState();
    const isFull = self2.isFull();
    const isLocked = self2.isLocked;
    self2.wrapper.classList.toggle("rtl", self2.rtl);
    const wrap_classList = self2.wrapper.classList;
    wrap_classList.toggle("focus", self2.isFocused);
    wrap_classList.toggle("disabled", self2.isDisabled);
    wrap_classList.toggle("readonly", self2.isReadOnly);
    wrap_classList.toggle("required", self2.isRequired);
    wrap_classList.toggle("invalid", !self2.isValid);
    wrap_classList.toggle("locked", isLocked);
    wrap_classList.toggle("full", isFull);
    wrap_classList.toggle("input-active", self2.isFocused && !self2.isInputHidden);
    wrap_classList.toggle("dropdown-active", self2.isOpen);
    wrap_classList.toggle("has-options", isEmptyObject(self2.options));
    wrap_classList.toggle("has-items", self2.items.length > 0);
  }
  /**
   * Update the `required` attribute of both input and control input.
   *
   * The `required` property needs to be activated on the control input
   * for the error to be displayed at the right place. `required` also
   * needs to be temporarily deactivated on the input since the input is
   * hidden and can't show errors.
   */
  refreshValidityState() {
    var self2 = this;
    if (!self2.input.validity) {
      return;
    }
    self2.isValid = self2.input.validity.valid;
    self2.isInvalid = !self2.isValid;
  }
  /**
   * Determines whether or not more items can be added
   * to the control without exceeding the user-defined maximum.
   *
   * @returns {boolean}
   */
  isFull() {
    return this.settings.maxItems !== null && this.items.length >= this.settings.maxItems;
  }
  /**
   * Refreshes the original <select> or <input>
   * element to reflect the current state.
   *
   */
  updateOriginalInput(opts = {}) {
    const self2 = this;
    var option2, label;
    const empty_option = self2.input.querySelector('option[value=""]');
    if (self2.is_select_tag) {
      let AddSelected2 = function(option_el, value, label2) {
        if (!option_el) {
          option_el = getDom$6('<option value="' + escape_html$1(value) + '">' + escape_html$1(label2) + "</option>");
        }
        if (option_el != empty_option) {
          self2.input.append(option_el);
        }
        selected.push(option_el);
        if (option_el != empty_option || has_selected > 0) {
          option_el.selected = true;
        }
        return option_el;
      };
      var AddSelected = AddSelected2;
      const selected = [];
      const has_selected = self2.input.querySelectorAll("option:checked").length;
      self2.input.querySelectorAll("option:checked").forEach((option_el) => {
        option_el.selected = false;
      });
      if (self2.items.length == 0 && self2.settings.mode == "single") {
        AddSelected2(empty_option, "", "");
      } else {
        self2.items.forEach((value) => {
          option2 = self2.options[value];
          label = option2[self2.settings.labelField] || "";
          if (selected.includes(option2.$option)) {
            const reuse_opt = self2.input.querySelector(`option[value="${addSlashes(value)}"]:not(:checked)`);
            AddSelected2(reuse_opt, value, label);
          } else {
            option2.$option = AddSelected2(option2.$option, value, label);
          }
        });
      }
    } else {
      self2.input.value = self2.getValue();
    }
    if (self2.isSetup) {
      if (!opts.silent) {
        self2.trigger("change", self2.getValue());
      }
    }
  }
  /**
   * Shows the autocomplete dropdown containing
   * the available options.
   */
  open() {
    var self2 = this;
    if (self2.isLocked || self2.isOpen || self2.settings.mode === "multi" && self2.isFull())
      return;
    self2.isOpen = true;
    setAttr$1(self2.focus_node, { "aria-expanded": "true" });
    self2.refreshState();
    applyCSS(self2.dropdown, { visibility: "hidden", display: "block" });
    self2.positionDropdown();
    applyCSS(self2.dropdown, { visibility: "visible", display: "block" });
    self2.focus();
    self2.trigger("dropdown_open", self2.dropdown);
  }
  /**
   * Closes the autocomplete dropdown menu.
   */
  close(setTextboxValue = true) {
    var self2 = this;
    var trigger = self2.isOpen;
    if (setTextboxValue) {
      self2.setTextboxValue();
      if (self2.settings.mode === "single" && self2.items.length) {
        self2.inputState();
      }
    }
    self2.isOpen = false;
    setAttr$1(self2.focus_node, { "aria-expanded": "false" });
    applyCSS(self2.dropdown, { display: "none" });
    if (self2.settings.hideSelected) {
      self2.clearActiveOption();
    }
    self2.refreshState();
    if (trigger)
      self2.trigger("dropdown_close", self2.dropdown);
  }
  /**
   * Calculates and applies the appropriate
   * position of the dropdown if dropdownParent = 'body'.
   * Otherwise, position is determined by css
   */
  positionDropdown() {
    if (this.settings.dropdownParent !== "body") {
      return;
    }
    var context = this.control;
    var rect = context.getBoundingClientRect();
    var top2 = context.offsetHeight + rect.top + window.scrollY;
    var left2 = rect.left + window.scrollX;
    applyCSS(this.dropdown, {
      width: rect.width + "px",
      top: top2 + "px",
      left: left2 + "px"
    });
  }
  /**
   * Resets / clears all selected items
   * from the control.
   *
   */
  clear(silent) {
    var self2 = this;
    if (!self2.items.length)
      return;
    var items = self2.controlChildren();
    iterate$4(items, (item2) => {
      self2.removeItem(item2, true);
    });
    self2.inputState();
    if (!silent)
      self2.updateOriginalInput();
    self2.trigger("clear");
  }
  /**
   * A helper method for inserting an element
   * at the current caret position.
   *
   */
  insertAtCaret(el) {
    const self2 = this;
    const caret = self2.caretPos;
    const target = self2.control;
    target.insertBefore(el, target.children[caret] || null);
    self2.setCaret(caret + 1);
  }
  /**
   * Removes the current selected item(s).
   *
   */
  deleteSelection(e2) {
    var direction, selection, caret, tail;
    var self2 = this;
    direction = e2 && e2.keyCode === KEY_BACKSPACE ? -1 : 1;
    selection = getSelection(self2.control_input);
    const rm_items = [];
    if (self2.activeItems.length) {
      tail = getTail(self2.activeItems, direction);
      caret = nodeIndex$2(tail);
      if (direction > 0) {
        caret++;
      }
      iterate$4(self2.activeItems, (item2) => rm_items.push(item2));
    } else if ((self2.isFocused || self2.settings.mode === "single") && self2.items.length) {
      const items = self2.controlChildren();
      let rm_item;
      if (direction < 0 && selection.start === 0 && selection.length === 0) {
        rm_item = items[self2.caretPos - 1];
      } else if (direction > 0 && selection.start === self2.inputValue().length) {
        rm_item = items[self2.caretPos];
      }
      if (rm_item !== void 0) {
        rm_items.push(rm_item);
      }
    }
    if (!self2.shouldDelete(rm_items, e2)) {
      return false;
    }
    preventDefault$5(e2, true);
    if (typeof caret !== "undefined") {
      self2.setCaret(caret);
    }
    while (rm_items.length) {
      self2.removeItem(rm_items.pop());
    }
    self2.inputState();
    self2.positionDropdown();
    self2.refreshOptions(false);
    return true;
  }
  /**
   * Return true if the items should be deleted
   */
  shouldDelete(items, evt) {
    const values = items.map((item2) => item2.dataset.value);
    if (!values.length || typeof this.settings.onDelete === "function" && this.settings.onDelete(values, evt) === false) {
      return false;
    }
    return true;
  }
  /**
   * Selects the previous / next item (depending on the `direction` argument).
   *
   * > 0 - right
   * < 0 - left
   *
   */
  advanceSelection(direction, e2) {
    var last_active, adjacent, self2 = this;
    if (self2.rtl)
      direction *= -1;
    if (self2.inputValue().length)
      return;
    if (isKeyDown(KEY_SHORTCUT, e2) || isKeyDown("shiftKey", e2)) {
      last_active = self2.getLastActive(direction);
      if (last_active) {
        if (!last_active.classList.contains("active")) {
          adjacent = last_active;
        } else {
          adjacent = self2.getAdjacent(last_active, direction, "item");
        }
      } else if (direction > 0) {
        adjacent = self2.control_input.nextElementSibling;
      } else {
        adjacent = self2.control_input.previousElementSibling;
      }
      if (adjacent) {
        if (adjacent.classList.contains("active")) {
          self2.removeActiveItem(last_active);
        }
        self2.setActiveItemClass(adjacent);
      }
    } else {
      self2.moveCaret(direction);
    }
  }
  moveCaret(direction) {
  }
  /**
   * Get the last active item
   *
   */
  getLastActive(direction) {
    let last_active = this.control.querySelector(".last-active");
    if (last_active) {
      return last_active;
    }
    var result = this.control.querySelectorAll(".active");
    if (result) {
      return getTail(result, direction);
    }
  }
  /**
   * Moves the caret to the specified index.
   *
   * The input must be moved by leaving it in place and moving the
   * siblings, due to the fact that focus cannot be restored once lost
   * on mobile webkit devices
   *
   */
  setCaret(new_pos) {
    this.caretPos = this.items.length;
  }
  /**
   * Return list of item dom elements
   *
   */
  controlChildren() {
    return Array.from(this.control.querySelectorAll("[data-ts-item]"));
  }
  /**
   * Disables user input on the control. Used while
   * items are being asynchronously created.
   */
  lock() {
    this.setLocked(true);
  }
  /**
   * Re-enables user input on the control.
   */
  unlock() {
    this.setLocked(false);
  }
  /**
   * Disable or enable user input on the control
   */
  setLocked(lock = this.isReadOnly || this.isDisabled) {
    this.isLocked = lock;
    this.refreshState();
  }
  /**
   * Disables user input on the control completely.
   * While disabled, it cannot receive focus.
   */
  disable() {
    this.setDisabled(true);
    this.close();
  }
  /**
   * Enables the control so that it can respond
   * to focus and user input.
   */
  enable() {
    this.setDisabled(false);
  }
  setDisabled(disabled) {
    this.focus_node.tabIndex = disabled ? -1 : this.tabIndex;
    this.isDisabled = disabled;
    this.input.disabled = disabled;
    this.control_input.disabled = disabled;
    this.setLocked();
  }
  setReadOnly(isReadOnly) {
    this.isReadOnly = isReadOnly;
    this.input.readOnly = isReadOnly;
    this.control_input.readOnly = isReadOnly;
    this.setLocked();
  }
  /**
   * Completely destroys the control and
   * unbinds all event listeners so that it can
   * be garbage collected.
   */
  destroy() {
    var self2 = this;
    var revertSettings = self2.revertSettings;
    self2.trigger("destroy");
    self2.off();
    self2.wrapper.remove();
    self2.dropdown.remove();
    self2.input.innerHTML = revertSettings.innerHTML;
    self2.input.tabIndex = revertSettings.tabIndex;
    removeClasses$1(self2.input, "tomselected", "ts-hidden-accessible");
    self2._destroy();
    delete self2.input.tomselect;
  }
  /**
   * A helper method for rendering "item" and
   * "option" templates, given the data.
   *
   */
  render(templateName, data2) {
    var id, html;
    const self2 = this;
    if (typeof this.settings.render[templateName] !== "function") {
      return null;
    }
    html = self2.settings.render[templateName].call(this, data2, escape_html$1);
    if (!html) {
      return null;
    }
    html = getDom$6(html);
    if (templateName === "option" || templateName === "option_create") {
      if (data2[self2.settings.disabledField]) {
        setAttr$1(html, { "aria-disabled": "true" });
      } else {
        setAttr$1(html, { "data-selectable": "" });
      }
    } else if (templateName === "optgroup") {
      id = data2.group[self2.settings.optgroupValueField];
      setAttr$1(html, { "data-group": id });
      if (data2.group[self2.settings.disabledField]) {
        setAttr$1(html, { "data-disabled": "" });
      }
    }
    if (templateName === "option" || templateName === "item") {
      const value = get_hash$1(data2[self2.settings.valueField]);
      setAttr$1(html, { "data-value": value });
      if (templateName === "item") {
        addClasses$2(html, self2.settings.itemClass);
        setAttr$1(html, { "data-ts-item": "" });
      } else {
        addClasses$2(html, self2.settings.optionClass);
        setAttr$1(html, {
          role: "option",
          id: data2.$id
        });
        data2.$div = html;
        self2.options[value] = data2;
      }
    }
    return html;
  }
  /**
   * Type guarded rendering
   *
   */
  _render(templateName, data2) {
    const html = this.render(templateName, data2);
    if (html == null) {
      throw "HTMLElement expected";
    }
    return html;
  }
  /**
   * Clears the render cache for a template. If
   * no template is given, clears all render
   * caches.
   *
   */
  clearCache() {
    iterate$4(this.options, (option2) => {
      if (option2.$div) {
        option2.$div.remove();
        delete option2.$div;
      }
    });
  }
  /**
   * Removes a value from item and option caches
   *
   */
  uncacheValue(value) {
    const option_el = this.getOption(value);
    if (option_el)
      option_el.remove();
  }
  /**
   * Determines whether or not to display the
   * create item prompt, given a user input.
   *
   */
  canCreate(input) {
    return this.settings.create && input.length > 0 && this.settings.createFilter.call(this, input);
  }
  /**
   * Wraps this.`method` so that `new_fn` can be invoked 'before', 'after', or 'instead' of the original method
   *
   * this.hook('instead','onKeyDown',function( arg1, arg2 ...){
   *
   * });
   */
  hook(when, method, new_fn) {
    var self2 = this;
    var orig_method = self2[method];
    self2[method] = function() {
      var result, result_new;
      if (when === "after") {
        result = orig_method.apply(self2, arguments);
      }
      result_new = new_fn.apply(self2, arguments);
      if (when === "instead") {
        return result_new;
      }
      if (when === "before") {
        result = orig_method.apply(self2, arguments);
      }
      return result;
    };
  }
}
const addEvent$4 = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
function plugin$d() {
  addEvent$4(this.input, "change", () => {
    this.sync();
  });
}
const hash_key = (value) => {
  if (typeof value === "undefined" || value === null)
    return null;
  return get_hash(value);
};
const get_hash = (value) => {
  if (typeof value === "boolean")
    return value ? "1" : "0";
  return value + "";
};
const preventDefault$4 = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const getDom$5 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$5(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$5 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
function plugin$c(userOptions) {
  var self2 = this;
  var orig_onOptionSelect = self2.onOptionSelect;
  self2.settings.hideSelected = false;
  const cbOptions = Object.assign({
    // so that the user may add different ones as well
    className: "tomselect-checkbox",
    // the following default to the historic plugin's values
    checkedClassNames: void 0,
    uncheckedClassNames: void 0
  }, userOptions);
  var UpdateChecked = function UpdateChecked2(checkbox, toCheck) {
    if (toCheck) {
      checkbox.checked = true;
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.remove(...cbOptions.uncheckedClassNames);
      }
      if (cbOptions.checkedClassNames) {
        checkbox.classList.add(...cbOptions.checkedClassNames);
      }
    } else {
      checkbox.checked = false;
      if (cbOptions.checkedClassNames) {
        checkbox.classList.remove(...cbOptions.checkedClassNames);
      }
      if (cbOptions.uncheckedClassNames) {
        checkbox.classList.add(...cbOptions.uncheckedClassNames);
      }
    }
  };
  var UpdateCheckbox = function UpdateCheckbox2(option2) {
    setTimeout(() => {
      var checkbox = option2.querySelector("input." + cbOptions.className);
      if (checkbox instanceof HTMLInputElement) {
        UpdateChecked(checkbox, option2.classList.contains("selected"));
      }
    }, 1);
  };
  self2.hook("after", "setupTemplates", () => {
    var orig_render_option = self2.settings.render.option;
    self2.settings.render.option = (data2, escape_html2) => {
      var rendered = getDom$5(orig_render_option.call(self2, data2, escape_html2));
      var checkbox = document.createElement("input");
      if (cbOptions.className) {
        checkbox.classList.add(cbOptions.className);
      }
      checkbox.addEventListener("click", function(evt) {
        preventDefault$4(evt);
      });
      checkbox.type = "checkbox";
      const hashed = hash_key(data2[self2.settings.valueField]);
      UpdateChecked(checkbox, !!(hashed && self2.items.indexOf(hashed) > -1));
      rendered.prepend(checkbox);
      return rendered;
    };
  });
  self2.on("item_remove", (value) => {
    var option2 = self2.getOption(value);
    if (option2) {
      option2.classList.remove("selected");
      UpdateCheckbox(option2);
    }
  });
  self2.on("item_add", (value) => {
    var option2 = self2.getOption(value);
    if (option2) {
      UpdateCheckbox(option2);
    }
  });
  self2.hook("instead", "onOptionSelect", (evt, option2) => {
    if (option2.classList.contains("selected")) {
      option2.classList.remove("selected");
      self2.removeItem(option2.dataset.value);
      self2.refreshOptions();
      preventDefault$4(evt, true);
      return;
    }
    orig_onOptionSelect.call(self2, evt, option2);
    UpdateCheckbox(option2);
  });
}
const getDom$4 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$4(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$4 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
function plugin$b(userOptions) {
  const self2 = this;
  const options = Object.assign({
    className: "clear-button",
    title: "Clear All",
    html: (data2) => {
      return `<div class="${data2.className}" title="${data2.title}">&#10799;</div>`;
    }
  }, userOptions);
  self2.on("initialize", () => {
    var button = getDom$4(options.html(options));
    button.addEventListener("click", (evt) => {
      if (self2.isLocked)
        return;
      self2.clear();
      if (self2.settings.mode === "single" && self2.settings.allowEmptyOption) {
        self2.addItem("");
      }
      evt.preventDefault();
      evt.stopPropagation();
    });
    self2.control.appendChild(button);
  });
}
const preventDefault$3 = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const addEvent$3 = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
const iterate$3 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const getDom$3 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$3(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$3 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
const setAttr = (el, attrs) => {
  iterate$3(attrs, (val, attr2) => {
    if (val == null) {
      el.removeAttribute(attr2);
    } else {
      el.setAttribute(attr2, "" + val);
    }
  });
};
const insertAfter = (referenceNode, newNode) => {
  var _referenceNode$parent;
  (_referenceNode$parent = referenceNode.parentNode) == null || _referenceNode$parent.insertBefore(newNode, referenceNode.nextSibling);
};
const insertBefore = (referenceNode, newNode) => {
  var _referenceNode$parent2;
  (_referenceNode$parent2 = referenceNode.parentNode) == null || _referenceNode$parent2.insertBefore(newNode, referenceNode);
};
const isBefore = (referenceNode, newNode) => {
  do {
    var _newNode;
    newNode = (_newNode = newNode) == null ? void 0 : _newNode.previousElementSibling;
    if (referenceNode == newNode) {
      return true;
    }
  } while (newNode && newNode.previousElementSibling);
  return false;
};
function plugin$a() {
  var self2 = this;
  if (self2.settings.mode !== "multi")
    return;
  var orig_lock = self2.lock;
  var orig_unlock = self2.unlock;
  let sortable = true;
  let drag_item;
  self2.hook("after", "setupTemplates", () => {
    var orig_render_item = self2.settings.render.item;
    self2.settings.render.item = (data2, escape) => {
      const item2 = getDom$3(orig_render_item.call(self2, data2, escape));
      setAttr(item2, {
        "draggable": "true"
      });
      const mousedown = (evt) => {
        if (!sortable)
          preventDefault$3(evt);
        evt.stopPropagation();
      };
      const dragStart = (evt) => {
        drag_item = item2;
        setTimeout(() => {
          item2.classList.add("ts-dragging");
        }, 0);
      };
      const dragOver = (evt) => {
        evt.preventDefault();
        item2.classList.add("ts-drag-over");
        moveitem(item2, drag_item);
      };
      const dragLeave = () => {
        item2.classList.remove("ts-drag-over");
      };
      const moveitem = (targetitem, dragitem) => {
        if (dragitem === void 0)
          return;
        if (isBefore(dragitem, item2)) {
          insertAfter(targetitem, dragitem);
        } else {
          insertBefore(targetitem, dragitem);
        }
      };
      const dragend = () => {
        var _drag_item;
        document.querySelectorAll(".ts-drag-over").forEach((el) => el.classList.remove("ts-drag-over"));
        (_drag_item = drag_item) == null || _drag_item.classList.remove("ts-dragging");
        drag_item = void 0;
        var values = [];
        self2.control.querySelectorAll(`[data-value]`).forEach((el) => {
          if (el.dataset.value) {
            let value = el.dataset.value;
            if (value) {
              values.push(value);
            }
          }
        });
        self2.setValue(values);
      };
      addEvent$3(item2, "mousedown", mousedown);
      addEvent$3(item2, "dragstart", dragStart);
      addEvent$3(item2, "dragenter", dragOver);
      addEvent$3(item2, "dragover", dragOver);
      addEvent$3(item2, "dragleave", dragLeave);
      addEvent$3(item2, "dragend", dragend);
      return item2;
    };
  });
  self2.hook("instead", "lock", () => {
    sortable = false;
    return orig_lock.call(self2);
  });
  self2.hook("instead", "unlock", () => {
    sortable = true;
    return orig_unlock.call(self2);
  });
}
const preventDefault$2 = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const getDom$2 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$2(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$2 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
function plugin$9(userOptions) {
  const self2 = this;
  const options = Object.assign({
    title: "Untitled",
    headerClass: "dropdown-header",
    titleRowClass: "dropdown-header-title",
    labelClass: "dropdown-header-label",
    closeClass: "dropdown-header-close",
    html: (data2) => {
      return '<div class="' + data2.headerClass + '"><div class="' + data2.titleRowClass + '"><span class="' + data2.labelClass + '">' + data2.title + '</span><a class="' + data2.closeClass + '">&times;</a></div></div>';
    }
  }, userOptions);
  self2.on("initialize", () => {
    var header = getDom$2(options.html(options));
    var close_link = header.querySelector("." + options.closeClass);
    if (close_link) {
      close_link.addEventListener("click", (evt) => {
        preventDefault$2(evt, true);
        self2.close();
      });
    }
    self2.dropdown.insertBefore(header, self2.dropdown.firstChild);
  });
}
const iterate$2 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const removeClasses = (elmts, ...classes) => {
  var norm_classes = classesArray$2(classes);
  elmts = castAsArray$2(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.remove(cls);
    });
  });
};
const classesArray$2 = (args) => {
  var classes = [];
  iterate$2(args, (_classes) => {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};
const castAsArray$2 = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
const nodeIndex$1 = (el, amongst) => {
  if (!el)
    return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};
function plugin$8() {
  var self2 = this;
  self2.hook("instead", "setCaret", (new_pos) => {
    if (self2.settings.mode === "single" || !self2.control.contains(self2.control_input)) {
      new_pos = self2.items.length;
    } else {
      new_pos = Math.max(0, Math.min(self2.items.length, new_pos));
      if (new_pos != self2.caretPos && !self2.isPending) {
        self2.controlChildren().forEach((child, j2) => {
          if (j2 < new_pos) {
            self2.control_input.insertAdjacentElement("beforebegin", child);
          } else {
            self2.control.appendChild(child);
          }
        });
      }
    }
    self2.caretPos = new_pos;
  });
  self2.hook("instead", "moveCaret", (direction) => {
    if (!self2.isFocused)
      return;
    const last_active = self2.getLastActive(direction);
    if (last_active) {
      const idx = nodeIndex$1(last_active);
      self2.setCaret(direction > 0 ? idx + 1 : idx);
      self2.setActiveItem();
      removeClasses(last_active, "last-active");
    } else {
      self2.setCaret(self2.caretPos + direction);
    }
  });
}
const KEY_ESC = 27;
const KEY_TAB = 9;
const preventDefault$1 = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const addEvent$2 = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
const iterate$1 = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const getDom$1 = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString$1(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString$1 = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
const addClasses$1 = (elmts, ...classes) => {
  var norm_classes = classesArray$1(classes);
  elmts = castAsArray$1(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.add(cls);
    });
  });
};
const classesArray$1 = (args) => {
  var classes = [];
  iterate$1(args, (_classes) => {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};
const castAsArray$1 = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
function plugin$7() {
  const self2 = this;
  self2.settings.shouldOpen = true;
  self2.hook("before", "setup", () => {
    self2.focus_node = self2.control;
    addClasses$1(self2.control_input, "dropdown-input");
    const div = getDom$1('<div class="dropdown-input-wrap">');
    div.append(self2.control_input);
    self2.dropdown.insertBefore(div, self2.dropdown.firstChild);
    const placeholder = getDom$1('<input class="items-placeholder" tabindex="-1" />');
    placeholder.placeholder = self2.settings.placeholder || "";
    self2.control.append(placeholder);
  });
  self2.on("initialize", () => {
    self2.control_input.addEventListener("keydown", (evt) => {
      switch (evt.keyCode) {
        case KEY_ESC:
          if (self2.isOpen) {
            preventDefault$1(evt, true);
            self2.close();
          }
          self2.clearActiveItems();
          return;
        case KEY_TAB:
          self2.focus_node.tabIndex = -1;
          break;
      }
      return self2.onKeyDown.call(self2, evt);
    });
    self2.on("blur", () => {
      self2.focus_node.tabIndex = self2.isDisabled ? -1 : self2.tabIndex;
    });
    self2.on("dropdown_open", () => {
      self2.control_input.focus();
    });
    const orig_onBlur = self2.onBlur;
    self2.hook("instead", "onBlur", (evt) => {
      if (evt && evt.relatedTarget == self2.control_input)
        return;
      return orig_onBlur.call(self2);
    });
    addEvent$2(self2.control_input, "blur", () => self2.onBlur());
    self2.hook("before", "close", () => {
      if (!self2.isOpen)
        return;
      self2.focus_node.focus({
        preventScroll: true
      });
    });
  });
}
const addEvent$1 = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
function plugin$6() {
  var self2 = this;
  self2.on("initialize", () => {
    var test_input = document.createElement("span");
    var control = self2.control_input;
    test_input.style.cssText = "position:absolute; top:-99999px; left:-99999px; width:auto; padding:0; white-space:pre; ";
    self2.wrapper.appendChild(test_input);
    var transfer_styles = ["letterSpacing", "fontSize", "fontFamily", "fontWeight", "textTransform"];
    for (const style_name of transfer_styles) {
      test_input.style[style_name] = control.style[style_name];
    }
    var resize = () => {
      test_input.textContent = control.value;
      control.style.width = test_input.clientWidth + "px";
    };
    resize();
    self2.on("update item_add item_remove", resize);
    addEvent$1(control, "input", resize);
    addEvent$1(control, "keyup", resize);
    addEvent$1(control, "blur", resize);
    addEvent$1(control, "update", resize);
  });
}
function plugin$5() {
  var self2 = this;
  var orig_deleteSelection = self2.deleteSelection;
  this.hook("instead", "deleteSelection", (evt) => {
    if (self2.activeItems.length) {
      return orig_deleteSelection.call(self2, evt);
    }
    return false;
  });
}
function plugin$4() {
  this.hook("instead", "setActiveItem", () => {
  });
  this.hook("instead", "selectAll", () => {
  });
}
const KEY_LEFT = 37;
const KEY_RIGHT = 39;
const parentMatch = (target, selector, wrapper) => {
  while (target && target.matches) {
    if (target.matches(selector)) {
      return target;
    }
    target = target.parentNode;
  }
};
const nodeIndex = (el, amongst) => {
  if (!el)
    return -1;
  amongst = amongst || el.nodeName;
  var i = 0;
  while (el = el.previousElementSibling) {
    if (el.matches(amongst)) {
      i++;
    }
  }
  return i;
};
function plugin$3() {
  var self2 = this;
  var orig_keydown = self2.onKeyDown;
  self2.hook("instead", "onKeyDown", (evt) => {
    var index, option2, options, optgroup;
    if (!self2.isOpen || !(evt.keyCode === KEY_LEFT || evt.keyCode === KEY_RIGHT)) {
      return orig_keydown.call(self2, evt);
    }
    self2.ignoreHover = true;
    optgroup = parentMatch(self2.activeOption, "[data-group]");
    index = nodeIndex(self2.activeOption, "[data-selectable]");
    if (!optgroup) {
      return;
    }
    if (evt.keyCode === KEY_LEFT) {
      optgroup = optgroup.previousSibling;
    } else {
      optgroup = optgroup.nextSibling;
    }
    if (!optgroup) {
      return;
    }
    options = optgroup.querySelectorAll("[data-selectable]");
    option2 = options[Math.min(options.length - 1, index)];
    if (option2) {
      self2.setActiveOption(option2);
    }
  });
}
const escape_html = (str2) => {
  return (str2 + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
const preventDefault = (evt, stop = false) => {
  if (evt) {
    evt.preventDefault();
    if (stop) {
      evt.stopPropagation();
    }
  }
};
const addEvent = (target, type, callback, options) => {
  target.addEventListener(type, callback, options);
};
const getDom = (query) => {
  if (query.jquery) {
    return query[0];
  }
  if (query instanceof HTMLElement) {
    return query;
  }
  if (isHtmlString(query)) {
    var tpl = document.createElement("template");
    tpl.innerHTML = query.trim();
    return tpl.content.firstChild;
  }
  return document.querySelector(query);
};
const isHtmlString = (arg) => {
  if (typeof arg === "string" && arg.indexOf("<") > -1) {
    return true;
  }
  return false;
};
function plugin$2(userOptions) {
  const options = Object.assign({
    label: "&times;",
    title: "Remove",
    className: "remove",
    append: true
  }, userOptions);
  var self2 = this;
  if (!options.append) {
    return;
  }
  var html = '<a href="javascript:void(0)" class="' + options.className + '" tabindex="-1" title="' + escape_html(options.title) + '">' + options.label + "</a>";
  self2.hook("after", "setupTemplates", () => {
    var orig_render_item = self2.settings.render.item;
    self2.settings.render.item = (data2, escape) => {
      var item2 = getDom(orig_render_item.call(self2, data2, escape));
      var close_button = getDom(html);
      item2.appendChild(close_button);
      addEvent(close_button, "mousedown", (evt) => {
        preventDefault(evt, true);
      });
      addEvent(close_button, "click", (evt) => {
        if (self2.isLocked)
          return;
        preventDefault(evt, true);
        if (self2.isLocked)
          return;
        if (!self2.shouldDelete([item2], evt))
          return;
        self2.removeItem(item2);
        self2.refreshOptions(false);
        self2.inputState();
      });
      return item2;
    };
  });
}
function plugin$1(userOptions) {
  const self2 = this;
  const options = Object.assign({
    text: (option2) => {
      return option2[self2.settings.labelField];
    }
  }, userOptions);
  self2.on("item_remove", function(value) {
    if (!self2.isFocused) {
      return;
    }
    if (self2.control_input.value.trim() === "") {
      var option2 = self2.options[value];
      if (option2) {
        self2.setTextboxValue(options.text.call(self2, option2));
      }
    }
  });
}
const iterate = (object, callback) => {
  if (Array.isArray(object)) {
    object.forEach(callback);
  } else {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        callback(object[key], key);
      }
    }
  }
};
const addClasses = (elmts, ...classes) => {
  var norm_classes = classesArray(classes);
  elmts = castAsArray(elmts);
  elmts.map((el) => {
    norm_classes.map((cls) => {
      el.classList.add(cls);
    });
  });
};
const classesArray = (args) => {
  var classes = [];
  iterate(args, (_classes) => {
    if (typeof _classes === "string") {
      _classes = _classes.trim().split(/[\t\n\f\r\s]/);
    }
    if (Array.isArray(_classes)) {
      classes = classes.concat(_classes);
    }
  });
  return classes.filter(Boolean);
};
const castAsArray = (arg) => {
  if (!Array.isArray(arg)) {
    arg = [arg];
  }
  return arg;
};
function plugin() {
  const self2 = this;
  const orig_canLoad = self2.canLoad;
  const orig_clearActiveOption = self2.clearActiveOption;
  const orig_loadCallback = self2.loadCallback;
  var pagination = {};
  var dropdown_content;
  var loading_more = false;
  var load_more_opt;
  var default_values = [];
  if (!self2.settings.shouldLoadMore) {
    self2.settings.shouldLoadMore = () => {
      const scroll_percent = dropdown_content.clientHeight / (dropdown_content.scrollHeight - dropdown_content.scrollTop);
      if (scroll_percent > 0.9) {
        return true;
      }
      if (self2.activeOption) {
        var selectable = self2.selectable();
        var index = Array.from(selectable).indexOf(self2.activeOption);
        if (index >= selectable.length - 2) {
          return true;
        }
      }
      return false;
    };
  }
  if (!self2.settings.firstUrl) {
    throw "virtual_scroll plugin requires a firstUrl() method";
  }
  self2.settings.sortField = [{
    field: "$order"
  }, {
    field: "$score"
  }];
  const canLoadMore = (query) => {
    if (typeof self2.settings.maxOptions === "number" && dropdown_content.children.length >= self2.settings.maxOptions) {
      return false;
    }
    if (query in pagination && pagination[query]) {
      return true;
    }
    return false;
  };
  const clearFilter = (option2, value) => {
    if (self2.items.indexOf(value) >= 0 || default_values.indexOf(value) >= 0) {
      return true;
    }
    return false;
  };
  self2.setNextUrl = (value, next_url) => {
    pagination[value] = next_url;
  };
  self2.getUrl = (query) => {
    if (query in pagination) {
      const next_url = pagination[query];
      pagination[query] = false;
      return next_url;
    }
    self2.clearPagination();
    return self2.settings.firstUrl.call(self2, query);
  };
  self2.clearPagination = () => {
    pagination = {};
  };
  self2.hook("instead", "clearActiveOption", () => {
    if (loading_more) {
      return;
    }
    return orig_clearActiveOption.call(self2);
  });
  self2.hook("instead", "canLoad", (query) => {
    if (!(query in pagination)) {
      return orig_canLoad.call(self2, query);
    }
    return canLoadMore(query);
  });
  self2.hook("instead", "loadCallback", (options, optgroups) => {
    if (!loading_more) {
      self2.clearOptions(clearFilter);
    } else if (load_more_opt) {
      const first_option = options[0];
      if (first_option !== void 0) {
        load_more_opt.dataset.value = first_option[self2.settings.valueField];
      }
    }
    orig_loadCallback.call(self2, options, optgroups);
    loading_more = false;
  });
  self2.hook("after", "refreshOptions", () => {
    const query = self2.lastValue;
    var option2;
    if (canLoadMore(query)) {
      option2 = self2.render("loading_more", {
        query
      });
      if (option2) {
        option2.setAttribute("data-selectable", "");
        load_more_opt = option2;
      }
    } else if (query in pagination && !dropdown_content.querySelector(".no-results")) {
      option2 = self2.render("no_more_results", {
        query
      });
    }
    if (option2) {
      addClasses(option2, self2.settings.optionClass);
      dropdown_content.append(option2);
    }
  });
  self2.on("initialize", () => {
    default_values = Object.keys(self2.options);
    dropdown_content = self2.dropdown_content;
    self2.settings.render = Object.assign({}, {
      loading_more: () => {
        return `<div class="loading-more-results">Loading more results ... </div>`;
      },
      no_more_results: () => {
        return `<div class="no-more-results">No more results</div>`;
      }
    }, self2.settings.render);
    dropdown_content.addEventListener("scroll", () => {
      if (!self2.settings.shouldLoadMore.call(self2)) {
        return;
      }
      if (!canLoadMore(self2.lastValue)) {
        return;
      }
      if (loading_more)
        return;
      loading_more = true;
      self2.load.call(self2, self2.lastValue);
    });
  });
}
TomSelect.define("change_listener", plugin$d);
TomSelect.define("checkbox_options", plugin$c);
TomSelect.define("clear_button", plugin$b);
TomSelect.define("drag_drop", plugin$a);
TomSelect.define("dropdown_header", plugin$9);
TomSelect.define("caret_position", plugin$8);
TomSelect.define("dropdown_input", plugin$7);
TomSelect.define("input_autogrow", plugin$6);
TomSelect.define("no_backspace_delete", plugin$5);
TomSelect.define("no_active_items", plugin$4);
TomSelect.define("optgroup_columns", plugin$3);
TomSelect.define("remove_button", plugin$2);
TomSelect.define("restore_on_backspace", plugin$1);
TomSelect.define("virtual_scroll", plugin);
function CitadelSelect(el, config2 = {}) {
  if (el.attr("citadel-input")) {
    return old(el);
  }
  console.log("SELECT EL", el);
  config2 = $.extend({
    // plugins: ['dropdown_input'],
  }, getConfig(el), config2);
  $(el).select2(config2);
}
const defaultConfig = {
  multiple: false,
  placeholder: "Choose an Option",
  closeOnSelect: true,
  ajax: null,
  allowClear: false,
  tags: false
};
function getConfig(el) {
  const id = el.attr("id");
  const cc = JSON.parse(el.attr("config") ?? "{}");
  cc.config = $.extend(defaultConfig, cc.config, {
    // multiple: !isEmpty($(el).attr('multiple')),
    dropdownParent: el.parent(),
    showAddOptionOnCreate: false
  });
  if (cc.reactive) {
    cc.config.ajax = {
      url: citadelFetchComponentLifeCycle(id),
      dataType: "json"
    };
  }
  return cc.config;
}
function old($select) {
  const config2 = $select.attr("citadel-input") ? JSON.parse($select.attr("citadel-input")) : {};
  const name2 = $select.attr("name");
  const depend_on2 = $select.attr("depend-on");
  const citadelUrl = $select.data("citadel-url");
  const paramNameJson = $select.data("citadel-param-name");
  console.log("CITADEL SELECT", $select);
  $select.selectize({
    plugins: ["clear_button"],
    ...config2,
    dropdownParent: "body",
    //use citadel url
    load: citadelUrl ? citadelURLHandler(paramNameJson) : null
    // If no citadel-url, don't add load function
  });
  const selectizedObj = $select[0].selectize;
  if (config2.setValue) {
    selectizedObj.setValue(config2.setValue);
    selectizedObj.trigger("change");
  }
  if (config2.lock == true) {
    selectizedObj.lock();
  }
  if (depend_on2) {
    checkValue(selectizedObj);
    $(depend_on2).on("change", function(e2) {
      checkValue(selectizedObj);
    });
  } else {
    fetchDynamicOptions(name2);
  }
}
const setOption = (selectizedObj, data2) => {
  const s2 = selectizedObj;
  s2.clearOptions();
  for (var i in data2) {
    s2.addOption(data2[i]);
  }
  console.log("SELECTIZE", s2);
  s2.refreshOptions();
  s2.enable();
};
const fetchDynamicOptions = function(name2) {
  const params = {
    citadel_component: name2,
    context: "get_dynamic_options"
  };
  console.log(params);
  const url = new URL(location.href);
  const searchParams = new URLSearchParams(params);
  url.search = searchParams.toString();
  $.get(url.toString(), function(data2) {
  }).always(function() {
  });
};
const checkValue = function(selectizedObj) {
  selectizedObj.disable();
  let allHaveValue = true;
  $(depend_on).each(function(_2, item2) {
    if (!$(item2).val()) {
      allHaveValue = false;
      return false;
    }
  });
  if (allHaveValue) {
    if (config._dynamicOptions.dynamic) {
      console.log("CONFIG SELECT 99", config);
      fetchDynamicOptions();
    } else {
      setOption(selectizedObj, config.options);
      selectizedObj.enable();
    }
  } else {
    selectizedObj.disable();
    selectizedObj.clear();
  }
};
(function(window2, document2, $2) {
  $2.fn.instances = {
    table: {}
  };
  const watchEvent = () => {
    CitadelTableWatchEvent();
    CitadelFormWatchEvent();
  };
  const through = function(callback) {
    return function(config2) {
      if (this.length < 1)
        return;
      return Array.from(this).forEach((el) => {
        callback($2(el), config2);
      });
    };
  };
  $2.fn.CButton = through(CitadelButton);
  $2.fn.CForm = through(CitadelForm);
  $2.fn.CChart = through(CitadelChart);
  $2.fn.CFlyout = through(CitadelFlyout);
  $2.fn.CModal = through(CitadelModal);
  $2.fn.CFilepond = through(CitadelFileUpload);
  $2.fn.CSelect = through(CitadelSelect);
  $2.fn.CTable = through(CitadelTable);
  $2.fn.CWizard = through(CitadelWizard);
  $2.fn.CDatepicker = through(CitadelDatepicker);
  $2.fn.CWidget = through(CitadelWidget$1);
  watchEvent();
})(window, document, jQuery);
(function(window2, document2, $2) {
  const reinstance2 = () => {
    $2(".filepond").CFilepond();
    $2(".offcanvas, .flyout").CFlyout();
    startObserver();
    initGlobalFunction(window2.$);
    initSummerNote(window2.$);
    $2(".citadel-button").CButton();
    $2(".citadel-chart").CChart();
    $2(".citadel-form").CForm();
    $2("[citadel-table], .citadel-table").CTable();
    $2("[citadel-wizard]").CWizard();
    $2("[citadel-modal]").CModal();
    $2("[citadel-datepicker]").CDatepicker();
    setAppend($2("button[citadel-append]"));
    $2("[citadel-widget], .citadel-widget").CWidget();
    $2(document2).on("submit", "form[citadel-ajax]", (event) => {
      event.preventDefault();
    });
    $2(document2).on("keydown", "#swal2-content textarea", (event) => {
      if (event.key === "Enter" && (event.metaKey || event.ctrlKey)) {
        $2(".swal2-actions .swal2-confirm").click();
      }
    });
    $2(document2).on("click", "[citadel-onclick]", function(event) {
      const $target = $2(this);
      const plugins2 = $target.attr("citadel-onclick");
      event.preventDefault();
      getPlugins(plugins2, $target).init();
    });
  };
  reinstance2();
  const fetchSidebar = () => {
    $2.get("/admin/app/sidebar", function(data2) {
      renderSidebarMenu(data2.sidebar);
    }).fail(function() {
      console.error("Error fetching sidebar data");
    });
  };
  const renderSidebarMenu = (dataMenu) => {
    if (dataMenu == void 0)
      return;
    const $navigation = $2(".navigation-main");
    $navigation.html("");
    $2(".app-sidebar").loadingOverlay();
    $navigation.append(dataMenu.map(createMenuItem));
    $2(".app-sidebar").loadingOverlay("remove");
  };
  const createMenuItem = (item2, hasParent = false) => {
    const li2 = $2('<li class="citadel-menu-item"></li>');
    const menuTitle = $2('<span class="menu-title"></span>').text(item2.label);
    const icon = $2("<i></i>").addClass(item2.icon ?? "ft-list");
    const a2 = $2('<a class="nav_link"></a>').attr("href", item2.url).attr("id", item2.id).prepend(icon).append(menuTitle);
    if (item2.url === window2.location.pathname) {
      li2.addClass("active");
    }
    if (item2.children && item2.children.length > 0) {
      const ul = $2('<ul class="menu-content"></ul>');
      item2.child_active = false;
      item2.children.map((child) => {
        const childItem = createMenuItem(child, true);
        ul.append(childItem);
        if (childItem.hasClass("active"))
          item2.child_active = true;
      });
      a2.attr("href", "javascript:void(0)");
      li2.append(a2);
      li2.append(ul);
      li2.addClass("has-sub");
    } else {
      li2.append(a2);
    }
    if (item2.child_active) {
      li2.addClass("active open");
    }
    return li2;
  };
  fetchSidebar();
  $2("#sidebarToggle").on("click", function() {
    setTimeout(() => {
      localStorage.setItem("app.menu", JSON.stringify($2.app.menu));
    }, 500);
  });
  $2.citadel = {};
  $2.citadel.append = {
    init($append) {
      const depend_on2 = $append.attr("depend-on");
      const checkValue2 = function() {
        $append.prop("disabled", true);
        let allHaveValue = true;
        $2(depend_on2).each(function(_2, item2) {
          if (!$2(item2).val()) {
            allHaveValue = false;
            return false;
          }
        });
        if (allHaveValue) {
          $append.prop("disabled", false);
        } else {
          $append.prop("disabled", true);
        }
      };
      if (depend_on2) {
        checkValue2();
        $2(depend_on2).on("change", function(e2) {
          checkValue2();
        });
      }
    }
  };
})(window, document, jQuery);
function setAppend(components2) {
  components2.each((_2, append3) => {
    const $append = $(append3);
    $.citadel.append.init($append);
  });
}
